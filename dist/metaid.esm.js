import require$$2$1 from 'buffer';
import require$$0$5 from 'crypto';
import require$$0$4 from 'assert';
import require$$0$6 from 'http';
import require$$1$1 from 'https';
import require$$2$2 from 'url';
import require$$3$1 from 'stream';
import require$$5$1 from 'tty';
import require$$1$2 from 'util';
import require$$7$1 from 'os';
import require$$8$1 from 'zlib';
import require$$9$1 from 'path';
import require$$10 from 'fs';

var NodeName;
(function (NodeName) {
    NodeName["ETHBinding"] = "EVMBinding";
    NodeName["MetaFile"] = "MetaFile";
    NodeName["NFTAvatar"] = "NFTAvatar";
    NodeName["PayComment"] = "PayComment";
    NodeName["PayLike"] = "PayLike";
    NodeName["PayFollow"] = "PayFollow";
    NodeName["SimpleMicroblog"] = "SimpleMicroblog";
    NodeName["SimpleRePost"] = "SimpleRePost";
    NodeName["SimpleGroupChat"] = "SimpleGroupChat";
    NodeName["SimpleFileGroupChat"] = "SimpleFileGroupChat";
    NodeName["SimpleCommunity"] = "SimpleCommunity";
    NodeName["SimpleCommunityJoin"] = "SimpleCommunityJoin";
    NodeName["SimpleGroupCreate"] = "SimpleGroupCreate";
    NodeName["ShowMsg"] = "ShowMsg";
    NodeName["NftIssue"] = "NftIssue";
    NodeName["NftGenesis"] = "NftGenesis";
    NodeName["NftSell"] = "NftSell";
    NodeName["NftCancel"] = "NftCancel";
    NodeName["nftBuy"] = "nftBuy";
    NodeName["FtGenesis"] = "FtGenesis";
    NodeName["FtIssue"] = "FtIssue";
    NodeName["SimpleRedEnvelope"] = "SimpleRedEnvelope";
    NodeName["OpenRedenvelope"] = "OpenRedenvelope";
    NodeName["SimplePublicShare"] = "SimplePublicShare";
    NodeName["LegalSellNft"] = "sell_nft";
    NodeName["Name"] = "name";
    NodeName["MetaNote"] = "metanote";
    NodeName["SimpleFileMsg"] = "SimpleFileMsg";
    NodeName["SimpleCreateAnnouncement"] = "SimpleCreateAnnouncement";
    NodeName["SimpleAnnouncementQuote"] = "SimpleAnnouncementQuote";
    NodeName["SimpleDAOCreate"] = "SimpleDAOCreate";
    NodeName["NftName"] = "NftName";
    NodeName["NftTransfer"] = "NftTransfer";
    NodeName["SendMoney"] = "SendMoney";
    NodeName["Phone"] = "phone";
    NodeName["Email"] = "email";
    NodeName["ShareChatMessage"] = "ShareChatMessage";
    // DAO
})(NodeName || (NodeName = {}));
var SdkPayType;
(function (SdkPayType) {
    SdkPayType["SPACE"] = "SPACE";
    SdkPayType["BTC"] = "BTC";
    SdkPayType["ETH"] = "ETH";
})(SdkPayType || (SdkPayType = {}));
var IsEncrypt;
(function (IsEncrypt) {
    IsEncrypt[IsEncrypt["Yes"] = 1] = "Yes";
    IsEncrypt[IsEncrypt["No"] = 0] = "No";
})(IsEncrypt || (IsEncrypt = {}));
var HdWalletChain;
(function (HdWalletChain) {
    HdWalletChain["MVC"] = "mvc";
})(HdWalletChain || (HdWalletChain = {}));
var Network$1;
(function (Network) {
    Network["mainnet"] = "mainnet";
    Network["testnet"] = "testnet";
})(Network$1 || (Network$1 = {}));
var WalletPath;
(function (WalletPath) {
    WalletPath[WalletPath["mainnet"] = 10001] = "mainnet";
    WalletPath[WalletPath["testnet"] = 236] = "testnet";
})(WalletPath || (WalletPath = {}));
var JobStepStatus;
(function (JobStepStatus) {
    JobStepStatus["Waiting"] = "waiting";
    JobStepStatus["Success"] = "success";
    JobStepStatus["Failed"] = "failed";
})(JobStepStatus || (JobStepStatus = {}));
var JobStatus;
(function (JobStatus) {
    JobStatus["Waiting"] = "waiting";
    JobStatus["Success"] = "success";
    JobStatus["Failed"] = "failed";
})(JobStatus || (JobStatus = {}));
var MetaIdTag;
(function (MetaIdTag) {
    MetaIdTag["mainnet"] = "metaid";
    MetaIdTag["testnet"] = "testmetaid";
})(MetaIdTag || (MetaIdTag = {}));
var MetaNameOp;
(function (MetaNameOp) {
    MetaNameOp[MetaNameOp["register"] = 1] = "register";
    MetaNameOp[MetaNameOp["renew"] = 2] = "renew";
    MetaNameOp[MetaNameOp["updataInfo"] = 3] = "updataInfo";
})(MetaNameOp || (MetaNameOp = {}));
var MetaNameReqType;
(function (MetaNameReqType) {
    MetaNameReqType["register"] = "register";
    MetaNameReqType["renew"] = "renew";
    MetaNameReqType["updataInfo"] = "updateinfo";
})(MetaNameReqType || (MetaNameReqType = {}));
var MetaNameReqCode;
(function (MetaNameReqCode) {
    MetaNameReqCode[MetaNameReqCode["register"] = 1] = "register";
    MetaNameReqCode[MetaNameReqCode["renew"] = 21] = "renew";
    MetaNameReqCode[MetaNameReqCode["updataInfo"] = 22] = "updataInfo";
})(MetaNameReqCode || (MetaNameReqCode = {}));
var Chains;
(function (Chains) {
    Chains["MVC"] = "mvc";
    Chains["ETH"] = "eth";
})(Chains || (Chains = {}));
var MetaidTag;
(function (MetaidTag) {
    MetaidTag["test"] = "testmetaid";
    MetaidTag["main"] = "metaid";
})(MetaidTag || (MetaidTag = {}));

({
    // NOT  Protocols Node
    [NodeName.LegalSellNft]: {
        brfcId: "--",
        path: "--",
        version: "1.0.0",
    },
    // Info Node
    [NodeName.ETHBinding]: {
        brfcId: "--",
        path: "info",
        version: "1.0.0",
    },
    [NodeName.Name]: {
        brfcId: "--",
        path: "info",
        version: "1.0.0",
    },
    [NodeName.Phone]: {
        brfcId: "--",
        path: "info",
        version: "1.0.0",
    },
    [NodeName.Email]: {
        brfcId: "--",
        path: "info",
        version: "1.0.0",
    },
    // Protocols Node
    [NodeName.SimpleMicroblog]: {
        brfcId: "b17e9e277bd7",
        path: "/Protocols/SimpleMicroblog",
        version: "1.0.0",
    },
    [NodeName.MetaFile]: {
        brfcId: "fcac10a5ed83",
        path: "/Protocols/MetaFile",
        version: "1.0.1",
    },
    [NodeName.SimpleGroupChat]: {
        brfcId: "96e2649ce8b6",
        path: "/Protocols/SimpleGroupChat",
        version: "1.0.2",
    },
    [NodeName.SimpleFileGroupChat]: {
        brfcId: "47cf94e87a8a",
        path: "/Protocols/SimpleFileGroupChat",
        version: "1.0.0",
    },
    [NodeName.NFTAvatar]: {
        brfcId: "b1e12b089e71",
        path: "/Protocols/NFTAvatar",
        version: "1.0.0",
    },
    [NodeName.PayComment]: {
        brfcId: "9396c994040a",
        path: "/Protocols/PayComment",
        version: "1.0.0",
    },
    [NodeName.SimpleRePost]: {
        brfcId: "157cd804478e",
        path: "/Protocols/SimpleRePost",
        version: "1.0.0",
    },
    [NodeName.PayLike]: {
        brfcId: "2ae43eeb26d9",
        path: "/Protocols/PayLike",
        version: "1.0.0",
    },
    [NodeName.SimpleCommunity]: {
        brfcId: "c12f783a883f",
        path: "/Protocols/SimpleCommunity",
        version: "1.0.3",
    },
    [NodeName.SimpleCommunityJoin]: {
        brfcId: "b736fc6b98fd",
        path: "/Protocols/SimpleCommunityJoin",
        version: "1.0.0",
    },
    [NodeName.ShowMsg]: {
        brfcId: "1bf2c5a70377",
        path: "/Protocols/ShowMsg",
        version: "1.0.1",
    },
    [NodeName.SimpleGroupCreate]: {
        brfcId: "7b2b19ddf267",
        path: "/Protocols/SimpleGroupCreate",
        version: "1.0.3",
    },
    [NodeName.PayFollow]: {
        brfcId: "203ee2c8b732",
        path: "/Protocols/PayFollow",
        version: "1.0.0",
    },
    [NodeName.NftIssue]: {
        brfcId: "5a6fa04c6612",
        path: "/Protocols/NftIssue",
        version: "1.0.0",
    },
    [NodeName.NftGenesis]: {
        brfcId: "599aa8e586e8",
        path: "/Protocols/NftGenesis",
        version: "1.0.0",
    },
    [NodeName.FtIssue]: {
        brfcId: "97b23b9f3a09",
        path: "/Protocols/FtIssue",
        version: "1.0.0",
    },
    [NodeName.FtGenesis]: {
        brfcId: "c75e9217b9bd",
        path: "/Protocols/FtGenesis",
        version: "1.0.0",
    },
    [NodeName.SimpleRedEnvelope]: {
        brfcId: "695e19ddf852",
        path: "/Protocols/SimpleRedEnvelope",
        version: "1.0.2",
    },
    [NodeName.SimplePublicShare]: {
        brfcId: "ba9478837e9a",
        path: "/Protocols/SimplePublicShare",
        version: "1.0.0",
    },
    [NodeName.OpenRedenvelope]: {
        brfcId: "bf90aa3b2d1c",
        path: "/Protocols/OpenRedenvelope",
        version: "1.0.1",
    },
    [NodeName.MetaNote]: {
        brfcId: "4934f562fc29",
        path: "/Protocols/metanote",
        version: "1.0.1",
    },
    [NodeName.NftSell]: {
        brfcId: "13104a689fd3",
        path: "/Protocols/NftSell",
        version: "1.0.1",
    },
    [NodeName.SimpleFileMsg]: {
        brfcId: "1b9ff346f190",
        path: "/Protocols/SimpleFileMsg",
        version: "1.0.1",
    },
    [NodeName.SimpleCreateAnnouncement]: {
        brfcId: "97b6023a62e8",
        path: "/Protocols/SimpleCreateAnnouncement",
        version: "1.0.4",
    },
    [NodeName.SimpleAnnouncementQuote]: {
        brfcId: "4118a343ce29",
        path: "/Protocols/SimpleAnnouncementQuote",
        version: "1.0.5",
    },
    [NodeName.SimpleDAOCreate]: {
        brfcId: "c35433ced842",
        path: "/Protocols/SimpleDAOCreate",
        version: "1.0.5",
    },
    [NodeName.NftName]: {
        brfcId: "6ed1b1d1119d",
        path: "/Protocols/NftName",
        version: "1.0.0",
    },
    [NodeName.NftTransfer]: {
        brfcId: "e13d25db6c9c",
        path: "/Protocols/NftTransfer",
        version: "1.0.2",
    },
    [NodeName.SendMoney]: {
        brfcId: "xxxxxxxxxxxx",
        path: "/Protocols/SendMoney",
        version: "1.0.0",
    },
    [NodeName.NftCancel]: {
        brfcId: "249044dac325",
        path: "/Protocols/NftCancel",
        version: "1.0.3",
    },
    [NodeName.nftBuy]: {
        brfcId: "1847e7d33857",
        path: "/Protocols/nftBuy",
        version: "1.0.2",
    },
    [NodeName.ShareChatMessage]: {
        brfcId: "11111111111",
        path: "/Protocols/ShareChatMessage",
        version: "1.0.0",
    },
});

var global$1 = (typeof global !== "undefined" ? global :
            typeof self !== "undefined" ? self :
            typeof window !== "undefined" ? window : {});

var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var inited = false;
function init$1 () {
  inited = true;
  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }

  revLookup['-'.charCodeAt(0)] = 62;
  revLookup['_'.charCodeAt(0)] = 63;
}

function toByteArray (b64) {
  if (!inited) {
    init$1();
  }
  var i, j, l, tmp, placeHolders, arr;
  var len = b64.length;

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

  // base64 is 4/3 + up to two characters of the original data
  arr = new Arr(len * 3 / 4 - placeHolders);

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len;

  var L = 0;

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];
    arr[L++] = (tmp >> 16) & 0xFF;
    arr[L++] = (tmp >> 8) & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
    arr[L++] = tmp & 0xFF;
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);
    arr[L++] = (tmp >> 8) & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
    output.push(tripletToBase64(tmp));
  }
  return output.join('')
}

function fromByteArray (uint8) {
  if (!inited) {
    init$1();
  }
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
  var output = '';
  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[(tmp << 4) & 0x3F];
    output += '==';
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
    output += lookup[tmp >> 10];
    output += lookup[(tmp >> 4) & 0x3F];
    output += lookup[(tmp << 2) & 0x3F];
    output += '=';
  }

  parts.push(output);

  return parts.join('')
}

function read (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? (nBytes - 1) : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

function write (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
  var i = isLE ? 0 : (nBytes - 1);
  var d = isLE ? 1 : -1;
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
}

var toString$2 = {}.toString;

var isArray$2 = Array.isArray || function (arr) {
  return toString$2.call(arr) == '[object Array]';
};

var INSPECT_MAX_BYTES = 50;

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined
  ? global$1.TYPED_ARRAY_SUPPORT
  : true;

/*
 * Export kMaxLength after typed array support is determined.
 */
kMaxLength();

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length);
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length);
    }
    that.length = length;
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192; // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype;
  return arr
};

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
};

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype;
  Buffer.__proto__ = Uint8Array;
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) ;
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
};

function allocUnsafe (that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
};

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);

  var actual = that.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual);
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array;
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array);
  }
  return that
}

function fromObject (that, obj) {
  if (internalIsBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len);
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray$2(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}
Buffer.isBuffer = isBuffer$2;
function internalIsBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
};

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
};

Buffer.concat = function concat (list, length) {
  if (!isArray$2(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i;
  if (length === undefined) {
    length = 0;
    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (!internalIsBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer
};

function byteLength (string, encoding) {
  if (internalIsBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string;
  }

  var len = string.length;
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer.byteLength = byteLength;

function slowToString (encoding, start, end) {
  var loweredCase = false;

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0;
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true;

function swap (b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }
  return this
};

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }
  return this
};

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }
  return this
};

Buffer.prototype.toString = function toString () {
  var length = this.length | 0;
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
};

Buffer.prototype.equals = function equals (b) {
  if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
};

Buffer.prototype.inspect = function inspect () {
  var str = '';
  var max = INSPECT_MAX_BYTES;
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }
  return '<Buffer ' + str + '>'
};

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!internalIsBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0;
  }
  if (end === undefined) {
    end = target ? target.length : 0;
  }
  if (thisStart === undefined) {
    thisStart = 0;
  }
  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;

  if (this === target) return 0

  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);

  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
};

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }
  byteOffset = +byteOffset;  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1);
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (internalIsBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
};

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
};

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
};

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed;
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0;
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0;
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0;
    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8';

  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
};

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return fromByteArray(buf)
  } else {
    return fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];

  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }
          break
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }
          break
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }
          break
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = '';
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    );
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;

  var newBuf;
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer(sliceLen, undefined);
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }

  return newBuf
};

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val
};

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val
};

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset]
};

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | (this[offset + 1] << 8)
};

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return (this[offset] << 8) | this[offset + 1]
};

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
};

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
};

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val
};

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val
};

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
};

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | (this[offset + 1] << 8);
  return (val & 0x8000) ? val | 0xFFFF0000 : val
};

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | (this[offset] << 8);
  return (val & 0x8000) ? val | 0xFFFF0000 : val
};

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
};

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
};

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return read(this, offset, true, 23, 4)
};

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return read(this, offset, false, 23, 4)
};

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return read(this, offset, true, 52, 8)
};

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return read(this, offset, false, 52, 8)
};

function checkInt (buf, value, offset, ext, max, min) {
  if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF;
  }

  return offset + byteLength
};

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF;
  }

  return offset + byteLength
};

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  this[offset] = (value & 0xff);
  return offset + 1
};

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8;
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff);
    this[offset + 1] = (value >>> 8);
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2
};

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8);
    this[offset + 1] = (value & 0xff);
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2
};

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24);
    this[offset + 2] = (value >>> 16);
    this[offset + 1] = (value >>> 8);
    this[offset] = (value & 0xff);
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4
};

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24);
    this[offset + 1] = (value >>> 16);
    this[offset + 2] = (value >>> 8);
    this[offset + 3] = (value & 0xff);
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4
};

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
  }

  return offset + byteLength
};

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
  }

  return offset + byteLength
};

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = (value & 0xff);
  return offset + 1
};

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff);
    this[offset + 1] = (value >>> 8);
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2
};

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8);
    this[offset + 1] = (value & 0xff);
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2
};

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff);
    this[offset + 1] = (value >>> 8);
    this[offset + 2] = (value >>> 16);
    this[offset + 3] = (value >>> 24);
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4
};

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24);
    this[offset + 1] = (value >>> 16);
    this[offset + 2] = (value >>> 8);
    this[offset + 3] = (value & 0xff);
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4
};

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4);
  }
  write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
};

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
};

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8);
  }
  write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
};

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start;

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;
  var i;

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    );
  }

  return len
};

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;

  if (!val) val = 0;

  var i;
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = internalIsBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString());
    var len = bytes.length;
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this
};

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '');
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '=';
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue
        }

        // valid lead
        leadSurrogate = codePoint;

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null;

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      );
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      );
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      );
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray
}


function base64ToBytes (str) {
  return toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i];
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}


// the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
function isBuffer$2(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))
}

function isFastBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var mvcLib = {exports: {}};

var name$1 = "mvc-lib";
var version$2 = "1.0.5";
var description$1 = "A pure and powerful JavaScript MetaverseChain (mvc) library.";
var author$1 = "zyoyoung <ouyangzhiying@showpay.top>";
var ide = true;
var main$1 = "index.js";
var scripts$1 = {
	lint: "standard",
	test: "standard && mocha",
	coverage: "nyc --reporter=text npm run test",
	"build-mvc": "webpack index.js --config webpack.config.js",
	"build-ecies": "webpack ecies/index.js --config webpack.subproject.config.js --output-library mvcEcies -o mvc-ecies.min.js",
	"build-message": "webpack message/index.js --config webpack.subproject.config.js --output-library mvcMessage -o mvc-message.min.js",
	"build-mnemonic": "webpack mnemonic/index.js --config webpack.subproject.config.js --output-library mvcMnemonic -o mvc-mnemonic.min.js",
	build: "yarn build-mvc && yarn build-ecies && yarn build-message && yarn build-mnemonic",
	prepublishOnly: "yarn build"
};
var unpkg = "mvc.min.js";
var keywords$1 = [
	"mvc",
	"metaversechain",
	"transaction",
	"address",
	"p5p",
	"ecies",
	"cryptocurrency",
	"blockchain",
	"payment",
	"bip21",
	"bip32",
	"bip37",
	"bip69",
	"bip70",
	"multisig"
];
var repository$1 = {
	type: "git",
	url: "https://github.com/MetaverseChain/mvc-lib-js"
};
var browser$4 = {
	request: "browser-request"
};
var dependencies$1 = {
	"aes-js": "^3.1.2",
	"bn.js": "=4.11.9",
	bs58: "=4.0.1",
	"clone-deep": "^4.0.1",
	elliptic: "6.5.4",
	"hash.js": "^1.1.7",
	inherits: "2.0.3",
	unorm: "1.4.1"
};
var devDependencies$1 = {
	brfs: "2.0.1",
	chai: "4.2.0",
	mocha: "^8.4.0",
	nyc: "^14.1.1",
	sinon: "7.2.3",
	standard: "12.0.1",
	webpack: "4.29.3",
	"webpack-cli": "^3.3.12"
};
var license$1 = "MIT";
var standard = {
	globals: [
		"afterEach",
		"beforeEach",
		"describe",
		"it"
	],
	ignore: [
		"dist/**"
	]
};
var require$$0$3 = {
	name: name$1,
	version: version$2,
	description: description$1,
	author: author$1,
	ide: ide,
	main: main$1,
	scripts: scripts$1,
	unpkg: unpkg,
	keywords: keywords$1,
	repository: repository$1,
	browser: browser$4,
	dependencies: dependencies$1,
	devDependencies: devDependencies$1,
	license: license$1,
	standard: standard
};

var bn$2 = {exports: {}};

bn$2.exports;

(function (module) {
	(function (module, exports) {

	  // Utils
	  function assert (val, msg) {
	    if (!val) throw new Error(msg || 'Assertion failed');
	  }

	  // Could use `inherits` module, but don't want to move from single file
	  // architecture yet.
	  function inherits (ctor, superCtor) {
	    ctor.super_ = superCtor;
	    var TempCtor = function () {};
	    TempCtor.prototype = superCtor.prototype;
	    ctor.prototype = new TempCtor();
	    ctor.prototype.constructor = ctor;
	  }

	  // BN

	  function BN (number, base, endian) {
	    if (BN.isBN(number)) {
	      return number;
	    }

	    this.negative = 0;
	    this.words = null;
	    this.length = 0;

	    // Reduction context
	    this.red = null;

	    if (number !== null) {
	      if (base === 'le' || base === 'be') {
	        endian = base;
	        base = 10;
	      }

	      this._init(number || 0, base || 10, endian || 'be');
	    }
	  }
	  if (typeof module === 'object') {
	    module.exports = BN;
	  } else {
	    exports.BN = BN;
	  }

	  BN.BN = BN;
	  BN.wordSize = 26;

	  var Buffer;
	  try {
	    Buffer = require('buffer').Buffer;
	  } catch (e) {
	  }

	  BN.isBN = function isBN (num) {
	    if (num instanceof BN) {
	      return true;
	    }

	    return num !== null && typeof num === 'object' &&
	      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
	  };

	  BN.max = function max (left, right) {
	    if (left.cmp(right) > 0) return left;
	    return right;
	  };

	  BN.min = function min (left, right) {
	    if (left.cmp(right) < 0) return left;
	    return right;
	  };

	  BN.prototype._init = function init (number, base, endian) {
	    if (typeof number === 'number') {
	      return this._initNumber(number, base, endian);
	    }

	    if (typeof number === 'object') {
	      return this._initArray(number, base, endian);
	    }

	    if (base === 'hex') {
	      base = 16;
	    }
	    assert(base === (base | 0) && base >= 2 && base <= 36);

	    number = number.toString().replace(/\s+/g, '');
	    var start = 0;
	    if (number[0] === '-') {
	      start++;
	    }

	    if (base === 16) {
	      this._parseHex(number, start);
	    } else {
	      this._parseBase(number, base, start);
	    }

	    if (number[0] === '-') {
	      this.negative = 1;
	    }

	    this.strip();

	    if (endian !== 'le') return;

	    this._initArray(this.toArray(), base, endian);
	  };

	  BN.prototype._initNumber = function _initNumber (number, base, endian) {
	    if (number < 0) {
	      this.negative = 1;
	      number = -number;
	    }
	    if (number < 0x4000000) {
	      this.words = [ number & 0x3ffffff ];
	      this.length = 1;
	    } else if (number < 0x10000000000000) {
	      this.words = [
	        number & 0x3ffffff,
	        (number / 0x4000000) & 0x3ffffff
	      ];
	      this.length = 2;
	    } else {
	      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
	      this.words = [
	        number & 0x3ffffff,
	        (number / 0x4000000) & 0x3ffffff,
	        1
	      ];
	      this.length = 3;
	    }

	    if (endian !== 'le') return;

	    // Reverse the bytes
	    this._initArray(this.toArray(), base, endian);
	  };

	  BN.prototype._initArray = function _initArray (number, base, endian) {
	    // Perhaps a Uint8Array
	    assert(typeof number.length === 'number');
	    if (number.length <= 0) {
	      this.words = [ 0 ];
	      this.length = 1;
	      return this;
	    }

	    this.length = Math.ceil(number.length / 3);
	    this.words = new Array(this.length);
	    for (var i = 0; i < this.length; i++) {
	      this.words[i] = 0;
	    }

	    var j, w;
	    var off = 0;
	    if (endian === 'be') {
	      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
	        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
	        this.words[j] |= (w << off) & 0x3ffffff;
	        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
	        off += 24;
	        if (off >= 26) {
	          off -= 26;
	          j++;
	        }
	      }
	    } else if (endian === 'le') {
	      for (i = 0, j = 0; i < number.length; i += 3) {
	        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
	        this.words[j] |= (w << off) & 0x3ffffff;
	        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
	        off += 24;
	        if (off >= 26) {
	          off -= 26;
	          j++;
	        }
	      }
	    }
	    return this.strip();
	  };

	  function parseHex (str, start, end) {
	    var r = 0;
	    var len = Math.min(str.length, end);
	    for (var i = start; i < len; i++) {
	      var c = str.charCodeAt(i) - 48;

	      r <<= 4;

	      // 'a' - 'f'
	      if (c >= 49 && c <= 54) {
	        r |= c - 49 + 0xa;

	      // 'A' - 'F'
	      } else if (c >= 17 && c <= 22) {
	        r |= c - 17 + 0xa;

	      // '0' - '9'
	      } else {
	        r |= c & 0xf;
	      }
	    }
	    return r;
	  }

	  BN.prototype._parseHex = function _parseHex (number, start) {
	    // Create possibly bigger array to ensure that it fits the number
	    this.length = Math.ceil((number.length - start) / 6);
	    this.words = new Array(this.length);
	    for (var i = 0; i < this.length; i++) {
	      this.words[i] = 0;
	    }

	    var j, w;
	    // Scan 24-bit chunks and add them to the number
	    var off = 0;
	    for (i = number.length - 6, j = 0; i >= start; i -= 6) {
	      w = parseHex(number, i, i + 6);
	      this.words[j] |= (w << off) & 0x3ffffff;
	      // NOTE: `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb
	      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
	      off += 24;
	      if (off >= 26) {
	        off -= 26;
	        j++;
	      }
	    }
	    if (i + 6 !== start) {
	      w = parseHex(number, start, i + 6);
	      this.words[j] |= (w << off) & 0x3ffffff;
	      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
	    }
	    this.strip();
	  };

	  function parseBase (str, start, end, mul) {
	    var r = 0;
	    var len = Math.min(str.length, end);
	    for (var i = start; i < len; i++) {
	      var c = str.charCodeAt(i) - 48;

	      r *= mul;

	      // 'a'
	      if (c >= 49) {
	        r += c - 49 + 0xa;

	      // 'A'
	      } else if (c >= 17) {
	        r += c - 17 + 0xa;

	      // '0' - '9'
	      } else {
	        r += c;
	      }
	    }
	    return r;
	  }

	  BN.prototype._parseBase = function _parseBase (number, base, start) {
	    // Initialize as zero
	    this.words = [ 0 ];
	    this.length = 1;

	    // Find length of limb in base
	    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
	      limbLen++;
	    }
	    limbLen--;
	    limbPow = (limbPow / base) | 0;

	    var total = number.length - start;
	    var mod = total % limbLen;
	    var end = Math.min(total, total - mod) + start;

	    var word = 0;
	    for (var i = start; i < end; i += limbLen) {
	      word = parseBase(number, i, i + limbLen, base);

	      this.imuln(limbPow);
	      if (this.words[0] + word < 0x4000000) {
	        this.words[0] += word;
	      } else {
	        this._iaddn(word);
	      }
	    }

	    if (mod !== 0) {
	      var pow = 1;
	      word = parseBase(number, i, number.length, base);

	      for (i = 0; i < mod; i++) {
	        pow *= base;
	      }

	      this.imuln(pow);
	      if (this.words[0] + word < 0x4000000) {
	        this.words[0] += word;
	      } else {
	        this._iaddn(word);
	      }
	    }
	  };

	  BN.prototype.copy = function copy (dest) {
	    dest.words = new Array(this.length);
	    for (var i = 0; i < this.length; i++) {
	      dest.words[i] = this.words[i];
	    }
	    dest.length = this.length;
	    dest.negative = this.negative;
	    dest.red = this.red;
	  };

	  BN.prototype.clone = function clone () {
	    var r = new BN(null);
	    this.copy(r);
	    return r;
	  };

	  BN.prototype._expand = function _expand (size) {
	    while (this.length < size) {
	      this.words[this.length++] = 0;
	    }
	    return this;
	  };

	  // Remove leading `0` from `this`
	  BN.prototype.strip = function strip () {
	    while (this.length > 1 && this.words[this.length - 1] === 0) {
	      this.length--;
	    }
	    return this._normSign();
	  };

	  BN.prototype._normSign = function _normSign () {
	    // -0 = 0
	    if (this.length === 1 && this.words[0] === 0) {
	      this.negative = 0;
	    }
	    return this;
	  };

	  BN.prototype.inspect = function inspect () {
	    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
	  };

	  /*

	  var zeros = [];
	  var groupSizes = [];
	  var groupBases = [];

	  var s = '';
	  var i = -1;
	  while (++i < BN.wordSize) {
	    zeros[i] = s;
	    s += '0';
	  }
	  groupSizes[0] = 0;
	  groupSizes[1] = 0;
	  groupBases[0] = 0;
	  groupBases[1] = 0;
	  var base = 2 - 1;
	  while (++base < 36 + 1) {
	    var groupSize = 0;
	    var groupBase = 1;
	    while (groupBase < (1 << BN.wordSize) / base) {
	      groupBase *= base;
	      groupSize += 1;
	    }
	    groupSizes[base] = groupSize;
	    groupBases[base] = groupBase;
	  }

	  */

	  var zeros = [
	    '',
	    '0',
	    '00',
	    '000',
	    '0000',
	    '00000',
	    '000000',
	    '0000000',
	    '00000000',
	    '000000000',
	    '0000000000',
	    '00000000000',
	    '000000000000',
	    '0000000000000',
	    '00000000000000',
	    '000000000000000',
	    '0000000000000000',
	    '00000000000000000',
	    '000000000000000000',
	    '0000000000000000000',
	    '00000000000000000000',
	    '000000000000000000000',
	    '0000000000000000000000',
	    '00000000000000000000000',
	    '000000000000000000000000',
	    '0000000000000000000000000'
	  ];

	  var groupSizes = [
	    0, 0,
	    25, 16, 12, 11, 10, 9, 8,
	    8, 7, 7, 7, 7, 6, 6,
	    6, 6, 6, 6, 6, 5, 5,
	    5, 5, 5, 5, 5, 5, 5,
	    5, 5, 5, 5, 5, 5, 5
	  ];

	  var groupBases = [
	    0, 0,
	    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
	    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
	    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
	    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
	    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
	  ];

	  BN.prototype.toString = function toString (base, padding) {
	    base = base || 10;
	    padding = padding | 0 || 1;

	    var out;
	    if (base === 16 || base === 'hex') {
	      out = '';
	      var off = 0;
	      var carry = 0;
	      for (var i = 0; i < this.length; i++) {
	        var w = this.words[i];
	        var word = (((w << off) | carry) & 0xffffff).toString(16);
	        carry = (w >>> (24 - off)) & 0xffffff;
	        if (carry !== 0 || i !== this.length - 1) {
	          out = zeros[6 - word.length] + word + out;
	        } else {
	          out = word + out;
	        }
	        off += 2;
	        if (off >= 26) {
	          off -= 26;
	          i--;
	        }
	      }
	      if (carry !== 0) {
	        out = carry.toString(16) + out;
	      }
	      while (out.length % padding !== 0) {
	        out = '0' + out;
	      }
	      if (this.negative !== 0) {
	        out = '-' + out;
	      }
	      return out;
	    }

	    if (base === (base | 0) && base >= 2 && base <= 36) {
	      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
	      var groupSize = groupSizes[base];
	      // var groupBase = Math.pow(base, groupSize);
	      var groupBase = groupBases[base];
	      out = '';
	      var c = this.clone();
	      c.negative = 0;
	      while (!c.isZero()) {
	        var r = c.modn(groupBase).toString(base);
	        c = c.idivn(groupBase);

	        if (!c.isZero()) {
	          out = zeros[groupSize - r.length] + r + out;
	        } else {
	          out = r + out;
	        }
	      }
	      if (this.isZero()) {
	        out = '0' + out;
	      }
	      while (out.length % padding !== 0) {
	        out = '0' + out;
	      }
	      if (this.negative !== 0) {
	        out = '-' + out;
	      }
	      return out;
	    }

	    assert(false, 'Base should be between 2 and 36');
	  };

	  BN.prototype.toNumber = function toNumber () {
	    var ret = this.words[0];
	    if (this.length === 2) {
	      ret += this.words[1] * 0x4000000;
	    } else if (this.length === 3 && this.words[2] === 0x01) {
	      // NOTE: at this stage it is known that the top bit is set
	      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
	    } else if (this.length > 2) {
	      assert(false, 'Number can only safely store up to 53 bits');
	    }
	    return (this.negative !== 0) ? -ret : ret;
	  };

	  BN.prototype.toJSON = function toJSON () {
	    return this.toString(16);
	  };

	  BN.prototype.toBuffer = function toBuffer (endian, length) {
	    assert(typeof Buffer !== 'undefined');
	    return this.toArrayLike(Buffer, endian, length);
	  };

	  BN.prototype.toArray = function toArray (endian, length) {
	    return this.toArrayLike(Array, endian, length);
	  };

	  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
	    var byteLength = this.byteLength();
	    var reqLength = length || Math.max(1, byteLength);
	    assert(byteLength <= reqLength, 'byte array longer than desired length');
	    assert(reqLength > 0, 'Requested array length <= 0');

	    this.strip();
	    var littleEndian = endian === 'le';
	    var res = new ArrayType(reqLength);

	    var b, i;
	    var q = this.clone();
	    if (!littleEndian) {
	      // Assume big-endian
	      for (i = 0; i < reqLength - byteLength; i++) {
	        res[i] = 0;
	      }

	      for (i = 0; !q.isZero(); i++) {
	        b = q.andln(0xff);
	        q.iushrn(8);

	        res[reqLength - i - 1] = b;
	      }
	    } else {
	      for (i = 0; !q.isZero(); i++) {
	        b = q.andln(0xff);
	        q.iushrn(8);

	        res[i] = b;
	      }

	      for (; i < reqLength; i++) {
	        res[i] = 0;
	      }
	    }

	    return res;
	  };

	  if (Math.clz32) {
	    BN.prototype._countBits = function _countBits (w) {
	      return 32 - Math.clz32(w);
	    };
	  } else {
	    BN.prototype._countBits = function _countBits (w) {
	      var t = w;
	      var r = 0;
	      if (t >= 0x1000) {
	        r += 13;
	        t >>>= 13;
	      }
	      if (t >= 0x40) {
	        r += 7;
	        t >>>= 7;
	      }
	      if (t >= 0x8) {
	        r += 4;
	        t >>>= 4;
	      }
	      if (t >= 0x02) {
	        r += 2;
	        t >>>= 2;
	      }
	      return r + t;
	    };
	  }

	  BN.prototype._zeroBits = function _zeroBits (w) {
	    // Short-cut
	    if (w === 0) return 26;

	    var t = w;
	    var r = 0;
	    if ((t & 0x1fff) === 0) {
	      r += 13;
	      t >>>= 13;
	    }
	    if ((t & 0x7f) === 0) {
	      r += 7;
	      t >>>= 7;
	    }
	    if ((t & 0xf) === 0) {
	      r += 4;
	      t >>>= 4;
	    }
	    if ((t & 0x3) === 0) {
	      r += 2;
	      t >>>= 2;
	    }
	    if ((t & 0x1) === 0) {
	      r++;
	    }
	    return r;
	  };

	  // Return number of used bits in a BN
	  BN.prototype.bitLength = function bitLength () {
	    var w = this.words[this.length - 1];
	    var hi = this._countBits(w);
	    return (this.length - 1) * 26 + hi;
	  };

	  function toBitArray (num) {
	    var w = new Array(num.bitLength());

	    for (var bit = 0; bit < w.length; bit++) {
	      var off = (bit / 26) | 0;
	      var wbit = bit % 26;

	      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
	    }

	    return w;
	  }

	  // Number of trailing zero bits
	  BN.prototype.zeroBits = function zeroBits () {
	    if (this.isZero()) return 0;

	    var r = 0;
	    for (var i = 0; i < this.length; i++) {
	      var b = this._zeroBits(this.words[i]);
	      r += b;
	      if (b !== 26) break;
	    }
	    return r;
	  };

	  BN.prototype.byteLength = function byteLength () {
	    return Math.ceil(this.bitLength() / 8);
	  };

	  BN.prototype.toTwos = function toTwos (width) {
	    if (this.negative !== 0) {
	      return this.abs().inotn(width).iaddn(1);
	    }
	    return this.clone();
	  };

	  BN.prototype.fromTwos = function fromTwos (width) {
	    if (this.testn(width - 1)) {
	      return this.notn(width).iaddn(1).ineg();
	    }
	    return this.clone();
	  };

	  BN.prototype.isNeg = function isNeg () {
	    return this.negative !== 0;
	  };

	  // Return negative clone of `this`
	  BN.prototype.neg = function neg () {
	    return this.clone().ineg();
	  };

	  BN.prototype.ineg = function ineg () {
	    if (!this.isZero()) {
	      this.negative ^= 1;
	    }

	    return this;
	  };

	  // Or `num` with `this` in-place
	  BN.prototype.iuor = function iuor (num) {
	    while (this.length < num.length) {
	      this.words[this.length++] = 0;
	    }

	    for (var i = 0; i < num.length; i++) {
	      this.words[i] = this.words[i] | num.words[i];
	    }

	    return this.strip();
	  };

	  BN.prototype.ior = function ior (num) {
	    assert((this.negative | num.negative) === 0);
	    return this.iuor(num);
	  };

	  // Or `num` with `this`
	  BN.prototype.or = function or (num) {
	    if (this.length > num.length) return this.clone().ior(num);
	    return num.clone().ior(this);
	  };

	  BN.prototype.uor = function uor (num) {
	    if (this.length > num.length) return this.clone().iuor(num);
	    return num.clone().iuor(this);
	  };

	  // And `num` with `this` in-place
	  BN.prototype.iuand = function iuand (num) {
	    // b = min-length(num, this)
	    var b;
	    if (this.length > num.length) {
	      b = num;
	    } else {
	      b = this;
	    }

	    for (var i = 0; i < b.length; i++) {
	      this.words[i] = this.words[i] & num.words[i];
	    }

	    this.length = b.length;

	    return this.strip();
	  };

	  BN.prototype.iand = function iand (num) {
	    assert((this.negative | num.negative) === 0);
	    return this.iuand(num);
	  };

	  // And `num` with `this`
	  BN.prototype.and = function and (num) {
	    if (this.length > num.length) return this.clone().iand(num);
	    return num.clone().iand(this);
	  };

	  BN.prototype.uand = function uand (num) {
	    if (this.length > num.length) return this.clone().iuand(num);
	    return num.clone().iuand(this);
	  };

	  // Xor `num` with `this` in-place
	  BN.prototype.iuxor = function iuxor (num) {
	    // a.length > b.length
	    var a;
	    var b;
	    if (this.length > num.length) {
	      a = this;
	      b = num;
	    } else {
	      a = num;
	      b = this;
	    }

	    for (var i = 0; i < b.length; i++) {
	      this.words[i] = a.words[i] ^ b.words[i];
	    }

	    if (this !== a) {
	      for (; i < a.length; i++) {
	        this.words[i] = a.words[i];
	      }
	    }

	    this.length = a.length;

	    return this.strip();
	  };

	  BN.prototype.ixor = function ixor (num) {
	    assert((this.negative | num.negative) === 0);
	    return this.iuxor(num);
	  };

	  // Xor `num` with `this`
	  BN.prototype.xor = function xor (num) {
	    if (this.length > num.length) return this.clone().ixor(num);
	    return num.clone().ixor(this);
	  };

	  BN.prototype.uxor = function uxor (num) {
	    if (this.length > num.length) return this.clone().iuxor(num);
	    return num.clone().iuxor(this);
	  };

	  // Not ``this`` with ``width`` bitwidth
	  BN.prototype.inotn = function inotn (width) {
	    assert(typeof width === 'number' && width >= 0);

	    var bytesNeeded = Math.ceil(width / 26) | 0;
	    var bitsLeft = width % 26;

	    // Extend the buffer with leading zeroes
	    this._expand(bytesNeeded);

	    if (bitsLeft > 0) {
	      bytesNeeded--;
	    }

	    // Handle complete words
	    for (var i = 0; i < bytesNeeded; i++) {
	      this.words[i] = ~this.words[i] & 0x3ffffff;
	    }

	    // Handle the residue
	    if (bitsLeft > 0) {
	      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
	    }

	    // And remove leading zeroes
	    return this.strip();
	  };

	  BN.prototype.notn = function notn (width) {
	    return this.clone().inotn(width);
	  };

	  // Set `bit` of `this`
	  BN.prototype.setn = function setn (bit, val) {
	    assert(typeof bit === 'number' && bit >= 0);

	    var off = (bit / 26) | 0;
	    var wbit = bit % 26;

	    this._expand(off + 1);

	    if (val) {
	      this.words[off] = this.words[off] | (1 << wbit);
	    } else {
	      this.words[off] = this.words[off] & ~(1 << wbit);
	    }

	    return this.strip();
	  };

	  // Add `num` to `this` in-place
	  BN.prototype.iadd = function iadd (num) {
	    var r;

	    // negative + positive
	    if (this.negative !== 0 && num.negative === 0) {
	      this.negative = 0;
	      r = this.isub(num);
	      this.negative ^= 1;
	      return this._normSign();

	    // positive + negative
	    } else if (this.negative === 0 && num.negative !== 0) {
	      num.negative = 0;
	      r = this.isub(num);
	      num.negative = 1;
	      return r._normSign();
	    }

	    // a.length > b.length
	    var a, b;
	    if (this.length > num.length) {
	      a = this;
	      b = num;
	    } else {
	      a = num;
	      b = this;
	    }

	    var carry = 0;
	    for (var i = 0; i < b.length; i++) {
	      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
	      this.words[i] = r & 0x3ffffff;
	      carry = r >>> 26;
	    }
	    for (; carry !== 0 && i < a.length; i++) {
	      r = (a.words[i] | 0) + carry;
	      this.words[i] = r & 0x3ffffff;
	      carry = r >>> 26;
	    }

	    this.length = a.length;
	    if (carry !== 0) {
	      this.words[this.length] = carry;
	      this.length++;
	    // Copy the rest of the words
	    } else if (a !== this) {
	      for (; i < a.length; i++) {
	        this.words[i] = a.words[i];
	      }
	    }

	    return this;
	  };

	  // Add `num` to `this`
	  BN.prototype.add = function add (num) {
	    var res;
	    if (num.negative !== 0 && this.negative === 0) {
	      num.negative = 0;
	      res = this.sub(num);
	      num.negative ^= 1;
	      return res;
	    } else if (num.negative === 0 && this.negative !== 0) {
	      this.negative = 0;
	      res = num.sub(this);
	      this.negative = 1;
	      return res;
	    }

	    if (this.length > num.length) return this.clone().iadd(num);

	    return num.clone().iadd(this);
	  };

	  // Subtract `num` from `this` in-place
	  BN.prototype.isub = function isub (num) {
	    // this - (-num) = this + num
	    if (num.negative !== 0) {
	      num.negative = 0;
	      var r = this.iadd(num);
	      num.negative = 1;
	      return r._normSign();

	    // -this - num = -(this + num)
	    } else if (this.negative !== 0) {
	      this.negative = 0;
	      this.iadd(num);
	      this.negative = 1;
	      return this._normSign();
	    }

	    // At this point both numbers are positive
	    var cmp = this.cmp(num);

	    // Optimization - zeroify
	    if (cmp === 0) {
	      this.negative = 0;
	      this.length = 1;
	      this.words[0] = 0;
	      return this;
	    }

	    // a > b
	    var a, b;
	    if (cmp > 0) {
	      a = this;
	      b = num;
	    } else {
	      a = num;
	      b = this;
	    }

	    var carry = 0;
	    for (var i = 0; i < b.length; i++) {
	      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
	      carry = r >> 26;
	      this.words[i] = r & 0x3ffffff;
	    }
	    for (; carry !== 0 && i < a.length; i++) {
	      r = (a.words[i] | 0) + carry;
	      carry = r >> 26;
	      this.words[i] = r & 0x3ffffff;
	    }

	    // Copy rest of the words
	    if (carry === 0 && i < a.length && a !== this) {
	      for (; i < a.length; i++) {
	        this.words[i] = a.words[i];
	      }
	    }

	    this.length = Math.max(this.length, i);

	    if (a !== this) {
	      this.negative = 1;
	    }

	    return this.strip();
	  };

	  // Subtract `num` from `this`
	  BN.prototype.sub = function sub (num) {
	    return this.clone().isub(num);
	  };

	  function smallMulTo (self, num, out) {
	    out.negative = num.negative ^ self.negative;
	    var len = (self.length + num.length) | 0;
	    out.length = len;
	    len = (len - 1) | 0;

	    // Peel one iteration (compiler can't do it, because of code complexity)
	    var a = self.words[0] | 0;
	    var b = num.words[0] | 0;
	    var r = a * b;

	    var lo = r & 0x3ffffff;
	    var carry = (r / 0x4000000) | 0;
	    out.words[0] = lo;

	    for (var k = 1; k < len; k++) {
	      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
	      // note that ncarry could be >= 0x3ffffff
	      var ncarry = carry >>> 26;
	      var rword = carry & 0x3ffffff;
	      var maxJ = Math.min(k, num.length - 1);
	      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
	        var i = (k - j) | 0;
	        a = self.words[i] | 0;
	        b = num.words[j] | 0;
	        r = a * b + rword;
	        ncarry += (r / 0x4000000) | 0;
	        rword = r & 0x3ffffff;
	      }
	      out.words[k] = rword | 0;
	      carry = ncarry | 0;
	    }
	    if (carry !== 0) {
	      out.words[k] = carry | 0;
	    } else {
	      out.length--;
	    }

	    return out.strip();
	  }

	  // TODO(indutny): it may be reasonable to omit it for users who don't need
	  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
	  // multiplication (like elliptic secp256k1).
	  var comb10MulTo = function comb10MulTo (self, num, out) {
	    var a = self.words;
	    var b = num.words;
	    var o = out.words;
	    var c = 0;
	    var lo;
	    var mid;
	    var hi;
	    var a0 = a[0] | 0;
	    var al0 = a0 & 0x1fff;
	    var ah0 = a0 >>> 13;
	    var a1 = a[1] | 0;
	    var al1 = a1 & 0x1fff;
	    var ah1 = a1 >>> 13;
	    var a2 = a[2] | 0;
	    var al2 = a2 & 0x1fff;
	    var ah2 = a2 >>> 13;
	    var a3 = a[3] | 0;
	    var al3 = a3 & 0x1fff;
	    var ah3 = a3 >>> 13;
	    var a4 = a[4] | 0;
	    var al4 = a4 & 0x1fff;
	    var ah4 = a4 >>> 13;
	    var a5 = a[5] | 0;
	    var al5 = a5 & 0x1fff;
	    var ah5 = a5 >>> 13;
	    var a6 = a[6] | 0;
	    var al6 = a6 & 0x1fff;
	    var ah6 = a6 >>> 13;
	    var a7 = a[7] | 0;
	    var al7 = a7 & 0x1fff;
	    var ah7 = a7 >>> 13;
	    var a8 = a[8] | 0;
	    var al8 = a8 & 0x1fff;
	    var ah8 = a8 >>> 13;
	    var a9 = a[9] | 0;
	    var al9 = a9 & 0x1fff;
	    var ah9 = a9 >>> 13;
	    var b0 = b[0] | 0;
	    var bl0 = b0 & 0x1fff;
	    var bh0 = b0 >>> 13;
	    var b1 = b[1] | 0;
	    var bl1 = b1 & 0x1fff;
	    var bh1 = b1 >>> 13;
	    var b2 = b[2] | 0;
	    var bl2 = b2 & 0x1fff;
	    var bh2 = b2 >>> 13;
	    var b3 = b[3] | 0;
	    var bl3 = b3 & 0x1fff;
	    var bh3 = b3 >>> 13;
	    var b4 = b[4] | 0;
	    var bl4 = b4 & 0x1fff;
	    var bh4 = b4 >>> 13;
	    var b5 = b[5] | 0;
	    var bl5 = b5 & 0x1fff;
	    var bh5 = b5 >>> 13;
	    var b6 = b[6] | 0;
	    var bl6 = b6 & 0x1fff;
	    var bh6 = b6 >>> 13;
	    var b7 = b[7] | 0;
	    var bl7 = b7 & 0x1fff;
	    var bh7 = b7 >>> 13;
	    var b8 = b[8] | 0;
	    var bl8 = b8 & 0x1fff;
	    var bh8 = b8 >>> 13;
	    var b9 = b[9] | 0;
	    var bl9 = b9 & 0x1fff;
	    var bh9 = b9 >>> 13;

	    out.negative = self.negative ^ num.negative;
	    out.length = 19;
	    /* k = 0 */
	    lo = Math.imul(al0, bl0);
	    mid = Math.imul(al0, bh0);
	    mid = (mid + Math.imul(ah0, bl0)) | 0;
	    hi = Math.imul(ah0, bh0);
	    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
	    w0 &= 0x3ffffff;
	    /* k = 1 */
	    lo = Math.imul(al1, bl0);
	    mid = Math.imul(al1, bh0);
	    mid = (mid + Math.imul(ah1, bl0)) | 0;
	    hi = Math.imul(ah1, bh0);
	    lo = (lo + Math.imul(al0, bl1)) | 0;
	    mid = (mid + Math.imul(al0, bh1)) | 0;
	    mid = (mid + Math.imul(ah0, bl1)) | 0;
	    hi = (hi + Math.imul(ah0, bh1)) | 0;
	    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
	    w1 &= 0x3ffffff;
	    /* k = 2 */
	    lo = Math.imul(al2, bl0);
	    mid = Math.imul(al2, bh0);
	    mid = (mid + Math.imul(ah2, bl0)) | 0;
	    hi = Math.imul(ah2, bh0);
	    lo = (lo + Math.imul(al1, bl1)) | 0;
	    mid = (mid + Math.imul(al1, bh1)) | 0;
	    mid = (mid + Math.imul(ah1, bl1)) | 0;
	    hi = (hi + Math.imul(ah1, bh1)) | 0;
	    lo = (lo + Math.imul(al0, bl2)) | 0;
	    mid = (mid + Math.imul(al0, bh2)) | 0;
	    mid = (mid + Math.imul(ah0, bl2)) | 0;
	    hi = (hi + Math.imul(ah0, bh2)) | 0;
	    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
	    w2 &= 0x3ffffff;
	    /* k = 3 */
	    lo = Math.imul(al3, bl0);
	    mid = Math.imul(al3, bh0);
	    mid = (mid + Math.imul(ah3, bl0)) | 0;
	    hi = Math.imul(ah3, bh0);
	    lo = (lo + Math.imul(al2, bl1)) | 0;
	    mid = (mid + Math.imul(al2, bh1)) | 0;
	    mid = (mid + Math.imul(ah2, bl1)) | 0;
	    hi = (hi + Math.imul(ah2, bh1)) | 0;
	    lo = (lo + Math.imul(al1, bl2)) | 0;
	    mid = (mid + Math.imul(al1, bh2)) | 0;
	    mid = (mid + Math.imul(ah1, bl2)) | 0;
	    hi = (hi + Math.imul(ah1, bh2)) | 0;
	    lo = (lo + Math.imul(al0, bl3)) | 0;
	    mid = (mid + Math.imul(al0, bh3)) | 0;
	    mid = (mid + Math.imul(ah0, bl3)) | 0;
	    hi = (hi + Math.imul(ah0, bh3)) | 0;
	    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
	    w3 &= 0x3ffffff;
	    /* k = 4 */
	    lo = Math.imul(al4, bl0);
	    mid = Math.imul(al4, bh0);
	    mid = (mid + Math.imul(ah4, bl0)) | 0;
	    hi = Math.imul(ah4, bh0);
	    lo = (lo + Math.imul(al3, bl1)) | 0;
	    mid = (mid + Math.imul(al3, bh1)) | 0;
	    mid = (mid + Math.imul(ah3, bl1)) | 0;
	    hi = (hi + Math.imul(ah3, bh1)) | 0;
	    lo = (lo + Math.imul(al2, bl2)) | 0;
	    mid = (mid + Math.imul(al2, bh2)) | 0;
	    mid = (mid + Math.imul(ah2, bl2)) | 0;
	    hi = (hi + Math.imul(ah2, bh2)) | 0;
	    lo = (lo + Math.imul(al1, bl3)) | 0;
	    mid = (mid + Math.imul(al1, bh3)) | 0;
	    mid = (mid + Math.imul(ah1, bl3)) | 0;
	    hi = (hi + Math.imul(ah1, bh3)) | 0;
	    lo = (lo + Math.imul(al0, bl4)) | 0;
	    mid = (mid + Math.imul(al0, bh4)) | 0;
	    mid = (mid + Math.imul(ah0, bl4)) | 0;
	    hi = (hi + Math.imul(ah0, bh4)) | 0;
	    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
	    w4 &= 0x3ffffff;
	    /* k = 5 */
	    lo = Math.imul(al5, bl0);
	    mid = Math.imul(al5, bh0);
	    mid = (mid + Math.imul(ah5, bl0)) | 0;
	    hi = Math.imul(ah5, bh0);
	    lo = (lo + Math.imul(al4, bl1)) | 0;
	    mid = (mid + Math.imul(al4, bh1)) | 0;
	    mid = (mid + Math.imul(ah4, bl1)) | 0;
	    hi = (hi + Math.imul(ah4, bh1)) | 0;
	    lo = (lo + Math.imul(al3, bl2)) | 0;
	    mid = (mid + Math.imul(al3, bh2)) | 0;
	    mid = (mid + Math.imul(ah3, bl2)) | 0;
	    hi = (hi + Math.imul(ah3, bh2)) | 0;
	    lo = (lo + Math.imul(al2, bl3)) | 0;
	    mid = (mid + Math.imul(al2, bh3)) | 0;
	    mid = (mid + Math.imul(ah2, bl3)) | 0;
	    hi = (hi + Math.imul(ah2, bh3)) | 0;
	    lo = (lo + Math.imul(al1, bl4)) | 0;
	    mid = (mid + Math.imul(al1, bh4)) | 0;
	    mid = (mid + Math.imul(ah1, bl4)) | 0;
	    hi = (hi + Math.imul(ah1, bh4)) | 0;
	    lo = (lo + Math.imul(al0, bl5)) | 0;
	    mid = (mid + Math.imul(al0, bh5)) | 0;
	    mid = (mid + Math.imul(ah0, bl5)) | 0;
	    hi = (hi + Math.imul(ah0, bh5)) | 0;
	    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
	    w5 &= 0x3ffffff;
	    /* k = 6 */
	    lo = Math.imul(al6, bl0);
	    mid = Math.imul(al6, bh0);
	    mid = (mid + Math.imul(ah6, bl0)) | 0;
	    hi = Math.imul(ah6, bh0);
	    lo = (lo + Math.imul(al5, bl1)) | 0;
	    mid = (mid + Math.imul(al5, bh1)) | 0;
	    mid = (mid + Math.imul(ah5, bl1)) | 0;
	    hi = (hi + Math.imul(ah5, bh1)) | 0;
	    lo = (lo + Math.imul(al4, bl2)) | 0;
	    mid = (mid + Math.imul(al4, bh2)) | 0;
	    mid = (mid + Math.imul(ah4, bl2)) | 0;
	    hi = (hi + Math.imul(ah4, bh2)) | 0;
	    lo = (lo + Math.imul(al3, bl3)) | 0;
	    mid = (mid + Math.imul(al3, bh3)) | 0;
	    mid = (mid + Math.imul(ah3, bl3)) | 0;
	    hi = (hi + Math.imul(ah3, bh3)) | 0;
	    lo = (lo + Math.imul(al2, bl4)) | 0;
	    mid = (mid + Math.imul(al2, bh4)) | 0;
	    mid = (mid + Math.imul(ah2, bl4)) | 0;
	    hi = (hi + Math.imul(ah2, bh4)) | 0;
	    lo = (lo + Math.imul(al1, bl5)) | 0;
	    mid = (mid + Math.imul(al1, bh5)) | 0;
	    mid = (mid + Math.imul(ah1, bl5)) | 0;
	    hi = (hi + Math.imul(ah1, bh5)) | 0;
	    lo = (lo + Math.imul(al0, bl6)) | 0;
	    mid = (mid + Math.imul(al0, bh6)) | 0;
	    mid = (mid + Math.imul(ah0, bl6)) | 0;
	    hi = (hi + Math.imul(ah0, bh6)) | 0;
	    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
	    w6 &= 0x3ffffff;
	    /* k = 7 */
	    lo = Math.imul(al7, bl0);
	    mid = Math.imul(al7, bh0);
	    mid = (mid + Math.imul(ah7, bl0)) | 0;
	    hi = Math.imul(ah7, bh0);
	    lo = (lo + Math.imul(al6, bl1)) | 0;
	    mid = (mid + Math.imul(al6, bh1)) | 0;
	    mid = (mid + Math.imul(ah6, bl1)) | 0;
	    hi = (hi + Math.imul(ah6, bh1)) | 0;
	    lo = (lo + Math.imul(al5, bl2)) | 0;
	    mid = (mid + Math.imul(al5, bh2)) | 0;
	    mid = (mid + Math.imul(ah5, bl2)) | 0;
	    hi = (hi + Math.imul(ah5, bh2)) | 0;
	    lo = (lo + Math.imul(al4, bl3)) | 0;
	    mid = (mid + Math.imul(al4, bh3)) | 0;
	    mid = (mid + Math.imul(ah4, bl3)) | 0;
	    hi = (hi + Math.imul(ah4, bh3)) | 0;
	    lo = (lo + Math.imul(al3, bl4)) | 0;
	    mid = (mid + Math.imul(al3, bh4)) | 0;
	    mid = (mid + Math.imul(ah3, bl4)) | 0;
	    hi = (hi + Math.imul(ah3, bh4)) | 0;
	    lo = (lo + Math.imul(al2, bl5)) | 0;
	    mid = (mid + Math.imul(al2, bh5)) | 0;
	    mid = (mid + Math.imul(ah2, bl5)) | 0;
	    hi = (hi + Math.imul(ah2, bh5)) | 0;
	    lo = (lo + Math.imul(al1, bl6)) | 0;
	    mid = (mid + Math.imul(al1, bh6)) | 0;
	    mid = (mid + Math.imul(ah1, bl6)) | 0;
	    hi = (hi + Math.imul(ah1, bh6)) | 0;
	    lo = (lo + Math.imul(al0, bl7)) | 0;
	    mid = (mid + Math.imul(al0, bh7)) | 0;
	    mid = (mid + Math.imul(ah0, bl7)) | 0;
	    hi = (hi + Math.imul(ah0, bh7)) | 0;
	    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
	    w7 &= 0x3ffffff;
	    /* k = 8 */
	    lo = Math.imul(al8, bl0);
	    mid = Math.imul(al8, bh0);
	    mid = (mid + Math.imul(ah8, bl0)) | 0;
	    hi = Math.imul(ah8, bh0);
	    lo = (lo + Math.imul(al7, bl1)) | 0;
	    mid = (mid + Math.imul(al7, bh1)) | 0;
	    mid = (mid + Math.imul(ah7, bl1)) | 0;
	    hi = (hi + Math.imul(ah7, bh1)) | 0;
	    lo = (lo + Math.imul(al6, bl2)) | 0;
	    mid = (mid + Math.imul(al6, bh2)) | 0;
	    mid = (mid + Math.imul(ah6, bl2)) | 0;
	    hi = (hi + Math.imul(ah6, bh2)) | 0;
	    lo = (lo + Math.imul(al5, bl3)) | 0;
	    mid = (mid + Math.imul(al5, bh3)) | 0;
	    mid = (mid + Math.imul(ah5, bl3)) | 0;
	    hi = (hi + Math.imul(ah5, bh3)) | 0;
	    lo = (lo + Math.imul(al4, bl4)) | 0;
	    mid = (mid + Math.imul(al4, bh4)) | 0;
	    mid = (mid + Math.imul(ah4, bl4)) | 0;
	    hi = (hi + Math.imul(ah4, bh4)) | 0;
	    lo = (lo + Math.imul(al3, bl5)) | 0;
	    mid = (mid + Math.imul(al3, bh5)) | 0;
	    mid = (mid + Math.imul(ah3, bl5)) | 0;
	    hi = (hi + Math.imul(ah3, bh5)) | 0;
	    lo = (lo + Math.imul(al2, bl6)) | 0;
	    mid = (mid + Math.imul(al2, bh6)) | 0;
	    mid = (mid + Math.imul(ah2, bl6)) | 0;
	    hi = (hi + Math.imul(ah2, bh6)) | 0;
	    lo = (lo + Math.imul(al1, bl7)) | 0;
	    mid = (mid + Math.imul(al1, bh7)) | 0;
	    mid = (mid + Math.imul(ah1, bl7)) | 0;
	    hi = (hi + Math.imul(ah1, bh7)) | 0;
	    lo = (lo + Math.imul(al0, bl8)) | 0;
	    mid = (mid + Math.imul(al0, bh8)) | 0;
	    mid = (mid + Math.imul(ah0, bl8)) | 0;
	    hi = (hi + Math.imul(ah0, bh8)) | 0;
	    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
	    w8 &= 0x3ffffff;
	    /* k = 9 */
	    lo = Math.imul(al9, bl0);
	    mid = Math.imul(al9, bh0);
	    mid = (mid + Math.imul(ah9, bl0)) | 0;
	    hi = Math.imul(ah9, bh0);
	    lo = (lo + Math.imul(al8, bl1)) | 0;
	    mid = (mid + Math.imul(al8, bh1)) | 0;
	    mid = (mid + Math.imul(ah8, bl1)) | 0;
	    hi = (hi + Math.imul(ah8, bh1)) | 0;
	    lo = (lo + Math.imul(al7, bl2)) | 0;
	    mid = (mid + Math.imul(al7, bh2)) | 0;
	    mid = (mid + Math.imul(ah7, bl2)) | 0;
	    hi = (hi + Math.imul(ah7, bh2)) | 0;
	    lo = (lo + Math.imul(al6, bl3)) | 0;
	    mid = (mid + Math.imul(al6, bh3)) | 0;
	    mid = (mid + Math.imul(ah6, bl3)) | 0;
	    hi = (hi + Math.imul(ah6, bh3)) | 0;
	    lo = (lo + Math.imul(al5, bl4)) | 0;
	    mid = (mid + Math.imul(al5, bh4)) | 0;
	    mid = (mid + Math.imul(ah5, bl4)) | 0;
	    hi = (hi + Math.imul(ah5, bh4)) | 0;
	    lo = (lo + Math.imul(al4, bl5)) | 0;
	    mid = (mid + Math.imul(al4, bh5)) | 0;
	    mid = (mid + Math.imul(ah4, bl5)) | 0;
	    hi = (hi + Math.imul(ah4, bh5)) | 0;
	    lo = (lo + Math.imul(al3, bl6)) | 0;
	    mid = (mid + Math.imul(al3, bh6)) | 0;
	    mid = (mid + Math.imul(ah3, bl6)) | 0;
	    hi = (hi + Math.imul(ah3, bh6)) | 0;
	    lo = (lo + Math.imul(al2, bl7)) | 0;
	    mid = (mid + Math.imul(al2, bh7)) | 0;
	    mid = (mid + Math.imul(ah2, bl7)) | 0;
	    hi = (hi + Math.imul(ah2, bh7)) | 0;
	    lo = (lo + Math.imul(al1, bl8)) | 0;
	    mid = (mid + Math.imul(al1, bh8)) | 0;
	    mid = (mid + Math.imul(ah1, bl8)) | 0;
	    hi = (hi + Math.imul(ah1, bh8)) | 0;
	    lo = (lo + Math.imul(al0, bl9)) | 0;
	    mid = (mid + Math.imul(al0, bh9)) | 0;
	    mid = (mid + Math.imul(ah0, bl9)) | 0;
	    hi = (hi + Math.imul(ah0, bh9)) | 0;
	    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
	    w9 &= 0x3ffffff;
	    /* k = 10 */
	    lo = Math.imul(al9, bl1);
	    mid = Math.imul(al9, bh1);
	    mid = (mid + Math.imul(ah9, bl1)) | 0;
	    hi = Math.imul(ah9, bh1);
	    lo = (lo + Math.imul(al8, bl2)) | 0;
	    mid = (mid + Math.imul(al8, bh2)) | 0;
	    mid = (mid + Math.imul(ah8, bl2)) | 0;
	    hi = (hi + Math.imul(ah8, bh2)) | 0;
	    lo = (lo + Math.imul(al7, bl3)) | 0;
	    mid = (mid + Math.imul(al7, bh3)) | 0;
	    mid = (mid + Math.imul(ah7, bl3)) | 0;
	    hi = (hi + Math.imul(ah7, bh3)) | 0;
	    lo = (lo + Math.imul(al6, bl4)) | 0;
	    mid = (mid + Math.imul(al6, bh4)) | 0;
	    mid = (mid + Math.imul(ah6, bl4)) | 0;
	    hi = (hi + Math.imul(ah6, bh4)) | 0;
	    lo = (lo + Math.imul(al5, bl5)) | 0;
	    mid = (mid + Math.imul(al5, bh5)) | 0;
	    mid = (mid + Math.imul(ah5, bl5)) | 0;
	    hi = (hi + Math.imul(ah5, bh5)) | 0;
	    lo = (lo + Math.imul(al4, bl6)) | 0;
	    mid = (mid + Math.imul(al4, bh6)) | 0;
	    mid = (mid + Math.imul(ah4, bl6)) | 0;
	    hi = (hi + Math.imul(ah4, bh6)) | 0;
	    lo = (lo + Math.imul(al3, bl7)) | 0;
	    mid = (mid + Math.imul(al3, bh7)) | 0;
	    mid = (mid + Math.imul(ah3, bl7)) | 0;
	    hi = (hi + Math.imul(ah3, bh7)) | 0;
	    lo = (lo + Math.imul(al2, bl8)) | 0;
	    mid = (mid + Math.imul(al2, bh8)) | 0;
	    mid = (mid + Math.imul(ah2, bl8)) | 0;
	    hi = (hi + Math.imul(ah2, bh8)) | 0;
	    lo = (lo + Math.imul(al1, bl9)) | 0;
	    mid = (mid + Math.imul(al1, bh9)) | 0;
	    mid = (mid + Math.imul(ah1, bl9)) | 0;
	    hi = (hi + Math.imul(ah1, bh9)) | 0;
	    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
	    w10 &= 0x3ffffff;
	    /* k = 11 */
	    lo = Math.imul(al9, bl2);
	    mid = Math.imul(al9, bh2);
	    mid = (mid + Math.imul(ah9, bl2)) | 0;
	    hi = Math.imul(ah9, bh2);
	    lo = (lo + Math.imul(al8, bl3)) | 0;
	    mid = (mid + Math.imul(al8, bh3)) | 0;
	    mid = (mid + Math.imul(ah8, bl3)) | 0;
	    hi = (hi + Math.imul(ah8, bh3)) | 0;
	    lo = (lo + Math.imul(al7, bl4)) | 0;
	    mid = (mid + Math.imul(al7, bh4)) | 0;
	    mid = (mid + Math.imul(ah7, bl4)) | 0;
	    hi = (hi + Math.imul(ah7, bh4)) | 0;
	    lo = (lo + Math.imul(al6, bl5)) | 0;
	    mid = (mid + Math.imul(al6, bh5)) | 0;
	    mid = (mid + Math.imul(ah6, bl5)) | 0;
	    hi = (hi + Math.imul(ah6, bh5)) | 0;
	    lo = (lo + Math.imul(al5, bl6)) | 0;
	    mid = (mid + Math.imul(al5, bh6)) | 0;
	    mid = (mid + Math.imul(ah5, bl6)) | 0;
	    hi = (hi + Math.imul(ah5, bh6)) | 0;
	    lo = (lo + Math.imul(al4, bl7)) | 0;
	    mid = (mid + Math.imul(al4, bh7)) | 0;
	    mid = (mid + Math.imul(ah4, bl7)) | 0;
	    hi = (hi + Math.imul(ah4, bh7)) | 0;
	    lo = (lo + Math.imul(al3, bl8)) | 0;
	    mid = (mid + Math.imul(al3, bh8)) | 0;
	    mid = (mid + Math.imul(ah3, bl8)) | 0;
	    hi = (hi + Math.imul(ah3, bh8)) | 0;
	    lo = (lo + Math.imul(al2, bl9)) | 0;
	    mid = (mid + Math.imul(al2, bh9)) | 0;
	    mid = (mid + Math.imul(ah2, bl9)) | 0;
	    hi = (hi + Math.imul(ah2, bh9)) | 0;
	    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
	    w11 &= 0x3ffffff;
	    /* k = 12 */
	    lo = Math.imul(al9, bl3);
	    mid = Math.imul(al9, bh3);
	    mid = (mid + Math.imul(ah9, bl3)) | 0;
	    hi = Math.imul(ah9, bh3);
	    lo = (lo + Math.imul(al8, bl4)) | 0;
	    mid = (mid + Math.imul(al8, bh4)) | 0;
	    mid = (mid + Math.imul(ah8, bl4)) | 0;
	    hi = (hi + Math.imul(ah8, bh4)) | 0;
	    lo = (lo + Math.imul(al7, bl5)) | 0;
	    mid = (mid + Math.imul(al7, bh5)) | 0;
	    mid = (mid + Math.imul(ah7, bl5)) | 0;
	    hi = (hi + Math.imul(ah7, bh5)) | 0;
	    lo = (lo + Math.imul(al6, bl6)) | 0;
	    mid = (mid + Math.imul(al6, bh6)) | 0;
	    mid = (mid + Math.imul(ah6, bl6)) | 0;
	    hi = (hi + Math.imul(ah6, bh6)) | 0;
	    lo = (lo + Math.imul(al5, bl7)) | 0;
	    mid = (mid + Math.imul(al5, bh7)) | 0;
	    mid = (mid + Math.imul(ah5, bl7)) | 0;
	    hi = (hi + Math.imul(ah5, bh7)) | 0;
	    lo = (lo + Math.imul(al4, bl8)) | 0;
	    mid = (mid + Math.imul(al4, bh8)) | 0;
	    mid = (mid + Math.imul(ah4, bl8)) | 0;
	    hi = (hi + Math.imul(ah4, bh8)) | 0;
	    lo = (lo + Math.imul(al3, bl9)) | 0;
	    mid = (mid + Math.imul(al3, bh9)) | 0;
	    mid = (mid + Math.imul(ah3, bl9)) | 0;
	    hi = (hi + Math.imul(ah3, bh9)) | 0;
	    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
	    w12 &= 0x3ffffff;
	    /* k = 13 */
	    lo = Math.imul(al9, bl4);
	    mid = Math.imul(al9, bh4);
	    mid = (mid + Math.imul(ah9, bl4)) | 0;
	    hi = Math.imul(ah9, bh4);
	    lo = (lo + Math.imul(al8, bl5)) | 0;
	    mid = (mid + Math.imul(al8, bh5)) | 0;
	    mid = (mid + Math.imul(ah8, bl5)) | 0;
	    hi = (hi + Math.imul(ah8, bh5)) | 0;
	    lo = (lo + Math.imul(al7, bl6)) | 0;
	    mid = (mid + Math.imul(al7, bh6)) | 0;
	    mid = (mid + Math.imul(ah7, bl6)) | 0;
	    hi = (hi + Math.imul(ah7, bh6)) | 0;
	    lo = (lo + Math.imul(al6, bl7)) | 0;
	    mid = (mid + Math.imul(al6, bh7)) | 0;
	    mid = (mid + Math.imul(ah6, bl7)) | 0;
	    hi = (hi + Math.imul(ah6, bh7)) | 0;
	    lo = (lo + Math.imul(al5, bl8)) | 0;
	    mid = (mid + Math.imul(al5, bh8)) | 0;
	    mid = (mid + Math.imul(ah5, bl8)) | 0;
	    hi = (hi + Math.imul(ah5, bh8)) | 0;
	    lo = (lo + Math.imul(al4, bl9)) | 0;
	    mid = (mid + Math.imul(al4, bh9)) | 0;
	    mid = (mid + Math.imul(ah4, bl9)) | 0;
	    hi = (hi + Math.imul(ah4, bh9)) | 0;
	    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
	    w13 &= 0x3ffffff;
	    /* k = 14 */
	    lo = Math.imul(al9, bl5);
	    mid = Math.imul(al9, bh5);
	    mid = (mid + Math.imul(ah9, bl5)) | 0;
	    hi = Math.imul(ah9, bh5);
	    lo = (lo + Math.imul(al8, bl6)) | 0;
	    mid = (mid + Math.imul(al8, bh6)) | 0;
	    mid = (mid + Math.imul(ah8, bl6)) | 0;
	    hi = (hi + Math.imul(ah8, bh6)) | 0;
	    lo = (lo + Math.imul(al7, bl7)) | 0;
	    mid = (mid + Math.imul(al7, bh7)) | 0;
	    mid = (mid + Math.imul(ah7, bl7)) | 0;
	    hi = (hi + Math.imul(ah7, bh7)) | 0;
	    lo = (lo + Math.imul(al6, bl8)) | 0;
	    mid = (mid + Math.imul(al6, bh8)) | 0;
	    mid = (mid + Math.imul(ah6, bl8)) | 0;
	    hi = (hi + Math.imul(ah6, bh8)) | 0;
	    lo = (lo + Math.imul(al5, bl9)) | 0;
	    mid = (mid + Math.imul(al5, bh9)) | 0;
	    mid = (mid + Math.imul(ah5, bl9)) | 0;
	    hi = (hi + Math.imul(ah5, bh9)) | 0;
	    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
	    w14 &= 0x3ffffff;
	    /* k = 15 */
	    lo = Math.imul(al9, bl6);
	    mid = Math.imul(al9, bh6);
	    mid = (mid + Math.imul(ah9, bl6)) | 0;
	    hi = Math.imul(ah9, bh6);
	    lo = (lo + Math.imul(al8, bl7)) | 0;
	    mid = (mid + Math.imul(al8, bh7)) | 0;
	    mid = (mid + Math.imul(ah8, bl7)) | 0;
	    hi = (hi + Math.imul(ah8, bh7)) | 0;
	    lo = (lo + Math.imul(al7, bl8)) | 0;
	    mid = (mid + Math.imul(al7, bh8)) | 0;
	    mid = (mid + Math.imul(ah7, bl8)) | 0;
	    hi = (hi + Math.imul(ah7, bh8)) | 0;
	    lo = (lo + Math.imul(al6, bl9)) | 0;
	    mid = (mid + Math.imul(al6, bh9)) | 0;
	    mid = (mid + Math.imul(ah6, bl9)) | 0;
	    hi = (hi + Math.imul(ah6, bh9)) | 0;
	    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
	    w15 &= 0x3ffffff;
	    /* k = 16 */
	    lo = Math.imul(al9, bl7);
	    mid = Math.imul(al9, bh7);
	    mid = (mid + Math.imul(ah9, bl7)) | 0;
	    hi = Math.imul(ah9, bh7);
	    lo = (lo + Math.imul(al8, bl8)) | 0;
	    mid = (mid + Math.imul(al8, bh8)) | 0;
	    mid = (mid + Math.imul(ah8, bl8)) | 0;
	    hi = (hi + Math.imul(ah8, bh8)) | 0;
	    lo = (lo + Math.imul(al7, bl9)) | 0;
	    mid = (mid + Math.imul(al7, bh9)) | 0;
	    mid = (mid + Math.imul(ah7, bl9)) | 0;
	    hi = (hi + Math.imul(ah7, bh9)) | 0;
	    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
	    w16 &= 0x3ffffff;
	    /* k = 17 */
	    lo = Math.imul(al9, bl8);
	    mid = Math.imul(al9, bh8);
	    mid = (mid + Math.imul(ah9, bl8)) | 0;
	    hi = Math.imul(ah9, bh8);
	    lo = (lo + Math.imul(al8, bl9)) | 0;
	    mid = (mid + Math.imul(al8, bh9)) | 0;
	    mid = (mid + Math.imul(ah8, bl9)) | 0;
	    hi = (hi + Math.imul(ah8, bh9)) | 0;
	    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
	    w17 &= 0x3ffffff;
	    /* k = 18 */
	    lo = Math.imul(al9, bl9);
	    mid = Math.imul(al9, bh9);
	    mid = (mid + Math.imul(ah9, bl9)) | 0;
	    hi = Math.imul(ah9, bh9);
	    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
	    w18 &= 0x3ffffff;
	    o[0] = w0;
	    o[1] = w1;
	    o[2] = w2;
	    o[3] = w3;
	    o[4] = w4;
	    o[5] = w5;
	    o[6] = w6;
	    o[7] = w7;
	    o[8] = w8;
	    o[9] = w9;
	    o[10] = w10;
	    o[11] = w11;
	    o[12] = w12;
	    o[13] = w13;
	    o[14] = w14;
	    o[15] = w15;
	    o[16] = w16;
	    o[17] = w17;
	    o[18] = w18;
	    if (c !== 0) {
	      o[19] = c;
	      out.length++;
	    }
	    return out;
	  };

	  // Polyfill comb
	  if (!Math.imul) {
	    comb10MulTo = smallMulTo;
	  }

	  function bigMulTo (self, num, out) {
	    out.negative = num.negative ^ self.negative;
	    out.length = self.length + num.length;

	    var carry = 0;
	    var hncarry = 0;
	    for (var k = 0; k < out.length - 1; k++) {
	      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
	      // note that ncarry could be >= 0x3ffffff
	      var ncarry = hncarry;
	      hncarry = 0;
	      var rword = carry & 0x3ffffff;
	      var maxJ = Math.min(k, num.length - 1);
	      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
	        var i = k - j;
	        var a = self.words[i] | 0;
	        var b = num.words[j] | 0;
	        var r = a * b;

	        var lo = r & 0x3ffffff;
	        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
	        lo = (lo + rword) | 0;
	        rword = lo & 0x3ffffff;
	        ncarry = (ncarry + (lo >>> 26)) | 0;

	        hncarry += ncarry >>> 26;
	        ncarry &= 0x3ffffff;
	      }
	      out.words[k] = rword;
	      carry = ncarry;
	      ncarry = hncarry;
	    }
	    if (carry !== 0) {
	      out.words[k] = carry;
	    } else {
	      out.length--;
	    }

	    return out.strip();
	  }

	  function jumboMulTo (self, num, out) {
	    var fftm = new FFTM();
	    return fftm.mulp(self, num, out);
	  }

	  BN.prototype.mulTo = function mulTo (num, out) {
	    var res;
	    var len = this.length + num.length;
	    if (this.length === 10 && num.length === 10) {
	      res = comb10MulTo(this, num, out);
	    } else if (len < 63) {
	      res = smallMulTo(this, num, out);
	    } else if (len < 1024) {
	      res = bigMulTo(this, num, out);
	    } else {
	      res = jumboMulTo(this, num, out);
	    }

	    return res;
	  };

	  // Cooley-Tukey algorithm for FFT
	  // slightly revisited to rely on looping instead of recursion

	  function FFTM (x, y) {
	    this.x = x;
	    this.y = y;
	  }

	  FFTM.prototype.makeRBT = function makeRBT (N) {
	    var t = new Array(N);
	    var l = BN.prototype._countBits(N) - 1;
	    for (var i = 0; i < N; i++) {
	      t[i] = this.revBin(i, l, N);
	    }

	    return t;
	  };

	  // Returns binary-reversed representation of `x`
	  FFTM.prototype.revBin = function revBin (x, l, N) {
	    if (x === 0 || x === N - 1) return x;

	    var rb = 0;
	    for (var i = 0; i < l; i++) {
	      rb |= (x & 1) << (l - i - 1);
	      x >>= 1;
	    }

	    return rb;
	  };

	  // Performs "tweedling" phase, therefore 'emulating'
	  // behaviour of the recursive algorithm
	  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
	    for (var i = 0; i < N; i++) {
	      rtws[i] = rws[rbt[i]];
	      itws[i] = iws[rbt[i]];
	    }
	  };

	  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
	    this.permute(rbt, rws, iws, rtws, itws, N);

	    for (var s = 1; s < N; s <<= 1) {
	      var l = s << 1;

	      var rtwdf = Math.cos(2 * Math.PI / l);
	      var itwdf = Math.sin(2 * Math.PI / l);

	      for (var p = 0; p < N; p += l) {
	        var rtwdf_ = rtwdf;
	        var itwdf_ = itwdf;

	        for (var j = 0; j < s; j++) {
	          var re = rtws[p + j];
	          var ie = itws[p + j];

	          var ro = rtws[p + j + s];
	          var io = itws[p + j + s];

	          var rx = rtwdf_ * ro - itwdf_ * io;

	          io = rtwdf_ * io + itwdf_ * ro;
	          ro = rx;

	          rtws[p + j] = re + ro;
	          itws[p + j] = ie + io;

	          rtws[p + j + s] = re - ro;
	          itws[p + j + s] = ie - io;

	          /* jshint maxdepth : false */
	          if (j !== l) {
	            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

	            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
	            rtwdf_ = rx;
	          }
	        }
	      }
	    }
	  };

	  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
	    var N = Math.max(m, n) | 1;
	    var odd = N & 1;
	    var i = 0;
	    for (N = N / 2 | 0; N; N = N >>> 1) {
	      i++;
	    }

	    return 1 << i + 1 + odd;
	  };

	  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
	    if (N <= 1) return;

	    for (var i = 0; i < N / 2; i++) {
	      var t = rws[i];

	      rws[i] = rws[N - i - 1];
	      rws[N - i - 1] = t;

	      t = iws[i];

	      iws[i] = -iws[N - i - 1];
	      iws[N - i - 1] = -t;
	    }
	  };

	  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
	    var carry = 0;
	    for (var i = 0; i < N / 2; i++) {
	      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
	        Math.round(ws[2 * i] / N) +
	        carry;

	      ws[i] = w & 0x3ffffff;

	      if (w < 0x4000000) {
	        carry = 0;
	      } else {
	        carry = w / 0x4000000 | 0;
	      }
	    }

	    return ws;
	  };

	  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
	    var carry = 0;
	    for (var i = 0; i < len; i++) {
	      carry = carry + (ws[i] | 0);

	      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
	      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
	    }

	    // Pad with zeroes
	    for (i = 2 * len; i < N; ++i) {
	      rws[i] = 0;
	    }

	    assert(carry === 0);
	    assert((carry & ~0x1fff) === 0);
	  };

	  FFTM.prototype.stub = function stub (N) {
	    var ph = new Array(N);
	    for (var i = 0; i < N; i++) {
	      ph[i] = 0;
	    }

	    return ph;
	  };

	  FFTM.prototype.mulp = function mulp (x, y, out) {
	    var N = 2 * this.guessLen13b(x.length, y.length);

	    var rbt = this.makeRBT(N);

	    var _ = this.stub(N);

	    var rws = new Array(N);
	    var rwst = new Array(N);
	    var iwst = new Array(N);

	    var nrws = new Array(N);
	    var nrwst = new Array(N);
	    var niwst = new Array(N);

	    var rmws = out.words;
	    rmws.length = N;

	    this.convert13b(x.words, x.length, rws, N);
	    this.convert13b(y.words, y.length, nrws, N);

	    this.transform(rws, _, rwst, iwst, N, rbt);
	    this.transform(nrws, _, nrwst, niwst, N, rbt);

	    for (var i = 0; i < N; i++) {
	      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
	      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
	      rwst[i] = rx;
	    }

	    this.conjugate(rwst, iwst, N);
	    this.transform(rwst, iwst, rmws, _, N, rbt);
	    this.conjugate(rmws, _, N);
	    this.normalize13b(rmws, N);

	    out.negative = x.negative ^ y.negative;
	    out.length = x.length + y.length;
	    return out.strip();
	  };

	  // Multiply `this` by `num`
	  BN.prototype.mul = function mul (num) {
	    var out = new BN(null);
	    out.words = new Array(this.length + num.length);
	    return this.mulTo(num, out);
	  };

	  // Multiply employing FFT
	  BN.prototype.mulf = function mulf (num) {
	    var out = new BN(null);
	    out.words = new Array(this.length + num.length);
	    return jumboMulTo(this, num, out);
	  };

	  // In-place Multiplication
	  BN.prototype.imul = function imul (num) {
	    return this.clone().mulTo(num, this);
	  };

	  BN.prototype.imuln = function imuln (num) {
	    assert(typeof num === 'number');
	    assert(num < 0x4000000);

	    // Carry
	    var carry = 0;
	    for (var i = 0; i < this.length; i++) {
	      var w = (this.words[i] | 0) * num;
	      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
	      carry >>= 26;
	      carry += (w / 0x4000000) | 0;
	      // NOTE: lo is 27bit maximum
	      carry += lo >>> 26;
	      this.words[i] = lo & 0x3ffffff;
	    }

	    if (carry !== 0) {
	      this.words[i] = carry;
	      this.length++;
	    }

	    return this;
	  };

	  BN.prototype.muln = function muln (num) {
	    return this.clone().imuln(num);
	  };

	  // `this` * `this`
	  BN.prototype.sqr = function sqr () {
	    return this.mul(this);
	  };

	  // `this` * `this` in-place
	  BN.prototype.isqr = function isqr () {
	    return this.imul(this.clone());
	  };

	  // Math.pow(`this`, `num`)
	  BN.prototype.pow = function pow (num) {
	    var w = toBitArray(num);
	    if (w.length === 0) return new BN(1);

	    // Skip leading zeroes
	    var res = this;
	    for (var i = 0; i < w.length; i++, res = res.sqr()) {
	      if (w[i] !== 0) break;
	    }

	    if (++i < w.length) {
	      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
	        if (w[i] === 0) continue;

	        res = res.mul(q);
	      }
	    }

	    return res;
	  };

	  // Shift-left in-place
	  BN.prototype.iushln = function iushln (bits) {
	    assert(typeof bits === 'number' && bits >= 0);
	    var r = bits % 26;
	    var s = (bits - r) / 26;
	    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
	    var i;

	    if (r !== 0) {
	      var carry = 0;

	      for (i = 0; i < this.length; i++) {
	        var newCarry = this.words[i] & carryMask;
	        var c = ((this.words[i] | 0) - newCarry) << r;
	        this.words[i] = c | carry;
	        carry = newCarry >>> (26 - r);
	      }

	      if (carry) {
	        this.words[i] = carry;
	        this.length++;
	      }
	    }

	    if (s !== 0) {
	      for (i = this.length - 1; i >= 0; i--) {
	        this.words[i + s] = this.words[i];
	      }

	      for (i = 0; i < s; i++) {
	        this.words[i] = 0;
	      }

	      this.length += s;
	    }

	    return this.strip();
	  };

	  BN.prototype.ishln = function ishln (bits) {
	    // TODO(indutny): implement me
	    assert(this.negative === 0);
	    return this.iushln(bits);
	  };

	  // Shift-right in-place
	  // NOTE: `hint` is a lowest bit before trailing zeroes
	  // NOTE: if `extended` is present - it will be filled with destroyed bits
	  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
	    assert(typeof bits === 'number' && bits >= 0);
	    var h;
	    if (hint) {
	      h = (hint - (hint % 26)) / 26;
	    } else {
	      h = 0;
	    }

	    var r = bits % 26;
	    var s = Math.min((bits - r) / 26, this.length);
	    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
	    var maskedWords = extended;

	    h -= s;
	    h = Math.max(0, h);

	    // Extended mode, copy masked part
	    if (maskedWords) {
	      for (var i = 0; i < s; i++) {
	        maskedWords.words[i] = this.words[i];
	      }
	      maskedWords.length = s;
	    }

	    if (s === 0) ; else if (this.length > s) {
	      this.length -= s;
	      for (i = 0; i < this.length; i++) {
	        this.words[i] = this.words[i + s];
	      }
	    } else {
	      this.words[0] = 0;
	      this.length = 1;
	    }

	    var carry = 0;
	    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
	      var word = this.words[i] | 0;
	      this.words[i] = (carry << (26 - r)) | (word >>> r);
	      carry = word & mask;
	    }

	    // Push carried bits as a mask
	    if (maskedWords && carry !== 0) {
	      maskedWords.words[maskedWords.length++] = carry;
	    }

	    if (this.length === 0) {
	      this.words[0] = 0;
	      this.length = 1;
	    }

	    return this.strip();
	  };

	  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
	    // TODO(indutny): implement me
	    assert(this.negative === 0);
	    return this.iushrn(bits, hint, extended);
	  };

	  // Shift-left
	  BN.prototype.shln = function shln (bits) {
	    return this.clone().ishln(bits);
	  };

	  BN.prototype.ushln = function ushln (bits) {
	    return this.clone().iushln(bits);
	  };

	  // Shift-right
	  BN.prototype.shrn = function shrn (bits) {
	    return this.clone().ishrn(bits);
	  };

	  BN.prototype.ushrn = function ushrn (bits) {
	    return this.clone().iushrn(bits);
	  };

	  // Test if n bit is set
	  BN.prototype.testn = function testn (bit) {
	    assert(typeof bit === 'number' && bit >= 0);
	    var r = bit % 26;
	    var s = (bit - r) / 26;
	    var q = 1 << r;

	    // Fast case: bit is much higher than all existing words
	    if (this.length <= s) return false;

	    // Check bit and return
	    var w = this.words[s];

	    return !!(w & q);
	  };

	  // Return only lowers bits of number (in-place)
	  BN.prototype.imaskn = function imaskn (bits) {
	    assert(typeof bits === 'number' && bits >= 0);
	    var r = bits % 26;
	    var s = (bits - r) / 26;

	    assert(this.negative === 0, 'imaskn works only with positive numbers');

	    if (this.length <= s) {
	      return this;
	    }

	    if (r !== 0) {
	      s++;
	    }
	    this.length = Math.min(s, this.length);

	    if (r !== 0) {
	      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
	      this.words[this.length - 1] &= mask;
	    }

	    return this.strip();
	  };

	  // Return only lowers bits of number
	  BN.prototype.maskn = function maskn (bits) {
	    return this.clone().imaskn(bits);
	  };

	  // Add plain number `num` to `this`
	  BN.prototype.iaddn = function iaddn (num) {
	    assert(typeof num === 'number');
	    assert(num < 0x4000000);
	    if (num < 0) return this.isubn(-num);

	    // Possible sign change
	    if (this.negative !== 0) {
	      if (this.length === 1 && (this.words[0] | 0) < num) {
	        this.words[0] = num - (this.words[0] | 0);
	        this.negative = 0;
	        return this;
	      }

	      this.negative = 0;
	      this.isubn(num);
	      this.negative = 1;
	      return this;
	    }

	    // Add without checks
	    return this._iaddn(num);
	  };

	  BN.prototype._iaddn = function _iaddn (num) {
	    this.words[0] += num;

	    // Carry
	    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
	      this.words[i] -= 0x4000000;
	      if (i === this.length - 1) {
	        this.words[i + 1] = 1;
	      } else {
	        this.words[i + 1]++;
	      }
	    }
	    this.length = Math.max(this.length, i + 1);

	    return this;
	  };

	  // Subtract plain number `num` from `this`
	  BN.prototype.isubn = function isubn (num) {
	    assert(typeof num === 'number');
	    assert(num < 0x4000000);
	    if (num < 0) return this.iaddn(-num);

	    if (this.negative !== 0) {
	      this.negative = 0;
	      this.iaddn(num);
	      this.negative = 1;
	      return this;
	    }

	    this.words[0] -= num;

	    if (this.length === 1 && this.words[0] < 0) {
	      this.words[0] = -this.words[0];
	      this.negative = 1;
	    } else {
	      // Carry
	      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
	        this.words[i] += 0x4000000;
	        this.words[i + 1] -= 1;
	      }
	    }

	    return this.strip();
	  };

	  BN.prototype.addn = function addn (num) {
	    return this.clone().iaddn(num);
	  };

	  BN.prototype.subn = function subn (num) {
	    return this.clone().isubn(num);
	  };

	  BN.prototype.iabs = function iabs () {
	    this.negative = 0;

	    return this;
	  };

	  BN.prototype.abs = function abs () {
	    return this.clone().iabs();
	  };

	  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
	    var len = num.length + shift;
	    var i;

	    this._expand(len);

	    var w;
	    var carry = 0;
	    for (i = 0; i < num.length; i++) {
	      w = (this.words[i + shift] | 0) + carry;
	      var right = (num.words[i] | 0) * mul;
	      w -= right & 0x3ffffff;
	      carry = (w >> 26) - ((right / 0x4000000) | 0);
	      this.words[i + shift] = w & 0x3ffffff;
	    }
	    for (; i < this.length - shift; i++) {
	      w = (this.words[i + shift] | 0) + carry;
	      carry = w >> 26;
	      this.words[i + shift] = w & 0x3ffffff;
	    }

	    if (carry === 0) return this.strip();

	    // Subtraction overflow
	    assert(carry === -1);
	    carry = 0;
	    for (i = 0; i < this.length; i++) {
	      w = -(this.words[i] | 0) + carry;
	      carry = w >> 26;
	      this.words[i] = w & 0x3ffffff;
	    }
	    this.negative = 1;

	    return this.strip();
	  };

	  BN.prototype._wordDiv = function _wordDiv (num, mode) {
	    var shift = this.length - num.length;

	    var a = this.clone();
	    var b = num;

	    // Normalize
	    var bhi = b.words[b.length - 1] | 0;
	    var bhiBits = this._countBits(bhi);
	    shift = 26 - bhiBits;
	    if (shift !== 0) {
	      b = b.ushln(shift);
	      a.iushln(shift);
	      bhi = b.words[b.length - 1] | 0;
	    }

	    // Initialize quotient
	    var m = a.length - b.length;
	    var q;

	    if (mode !== 'mod') {
	      q = new BN(null);
	      q.length = m + 1;
	      q.words = new Array(q.length);
	      for (var i = 0; i < q.length; i++) {
	        q.words[i] = 0;
	      }
	    }

	    var diff = a.clone()._ishlnsubmul(b, 1, m);
	    if (diff.negative === 0) {
	      a = diff;
	      if (q) {
	        q.words[m] = 1;
	      }
	    }

	    for (var j = m - 1; j >= 0; j--) {
	      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
	        (a.words[b.length + j - 1] | 0);

	      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
	      // (0x7ffffff)
	      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

	      a._ishlnsubmul(b, qj, j);
	      while (a.negative !== 0) {
	        qj--;
	        a.negative = 0;
	        a._ishlnsubmul(b, 1, j);
	        if (!a.isZero()) {
	          a.negative ^= 1;
	        }
	      }
	      if (q) {
	        q.words[j] = qj;
	      }
	    }
	    if (q) {
	      q.strip();
	    }
	    a.strip();

	    // Denormalize
	    if (mode !== 'div' && shift !== 0) {
	      a.iushrn(shift);
	    }

	    return {
	      div: q || null,
	      mod: a
	    };
	  };

	  // NOTE: 1) `mode` can be set to `mod` to request mod only,
	  //       to `div` to request div only, or be absent to
	  //       request both div & mod
	  //       2) `positive` is true if unsigned mod is requested
	  BN.prototype.divmod = function divmod (num, mode, positive) {
	    assert(!num.isZero());

	    if (this.isZero()) {
	      return {
	        div: new BN(0),
	        mod: new BN(0)
	      };
	    }

	    var div, mod, res;
	    if (this.negative !== 0 && num.negative === 0) {
	      res = this.neg().divmod(num, mode);

	      if (mode !== 'mod') {
	        div = res.div.neg();
	      }

	      if (mode !== 'div') {
	        mod = res.mod.neg();
	        if (positive && mod.negative !== 0) {
	          mod.iadd(num);
	        }
	      }

	      return {
	        div: div,
	        mod: mod
	      };
	    }

	    if (this.negative === 0 && num.negative !== 0) {
	      res = this.divmod(num.neg(), mode);

	      if (mode !== 'mod') {
	        div = res.div.neg();
	      }

	      return {
	        div: div,
	        mod: res.mod
	      };
	    }

	    if ((this.negative & num.negative) !== 0) {
	      res = this.neg().divmod(num.neg(), mode);

	      if (mode !== 'div') {
	        mod = res.mod.neg();
	        if (positive && mod.negative !== 0) {
	          mod.isub(num);
	        }
	      }

	      return {
	        div: res.div,
	        mod: mod
	      };
	    }

	    // Both numbers are positive at this point

	    // Strip both numbers to approximate shift value
	    if (num.length > this.length || this.cmp(num) < 0) {
	      return {
	        div: new BN(0),
	        mod: this
	      };
	    }

	    // Very short reduction
	    if (num.length === 1) {
	      if (mode === 'div') {
	        return {
	          div: this.divn(num.words[0]),
	          mod: null
	        };
	      }

	      if (mode === 'mod') {
	        return {
	          div: null,
	          mod: new BN(this.modn(num.words[0]))
	        };
	      }

	      return {
	        div: this.divn(num.words[0]),
	        mod: new BN(this.modn(num.words[0]))
	      };
	    }

	    return this._wordDiv(num, mode);
	  };

	  // Find `this` / `num`
	  BN.prototype.div = function div (num) {
	    return this.divmod(num, 'div', false).div;
	  };

	  // Find `this` % `num`
	  BN.prototype.mod = function mod (num) {
	    return this.divmod(num, 'mod', false).mod;
	  };

	  BN.prototype.umod = function umod (num) {
	    return this.divmod(num, 'mod', true).mod;
	  };

	  // Find Round(`this` / `num`)
	  BN.prototype.divRound = function divRound (num) {
	    var dm = this.divmod(num);

	    // Fast case - exact division
	    if (dm.mod.isZero()) return dm.div;

	    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

	    var half = num.ushrn(1);
	    var r2 = num.andln(1);
	    var cmp = mod.cmp(half);

	    // Round down
	    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

	    // Round up
	    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
	  };

	  BN.prototype.modn = function modn (num) {
	    assert(num <= 0x3ffffff);
	    var p = (1 << 26) % num;

	    var acc = 0;
	    for (var i = this.length - 1; i >= 0; i--) {
	      acc = (p * acc + (this.words[i] | 0)) % num;
	    }

	    return acc;
	  };

	  // In-place division by number
	  BN.prototype.idivn = function idivn (num) {
	    assert(num <= 0x3ffffff);

	    var carry = 0;
	    for (var i = this.length - 1; i >= 0; i--) {
	      var w = (this.words[i] | 0) + carry * 0x4000000;
	      this.words[i] = (w / num) | 0;
	      carry = w % num;
	    }

	    return this.strip();
	  };

	  BN.prototype.divn = function divn (num) {
	    return this.clone().idivn(num);
	  };

	  BN.prototype.egcd = function egcd (p) {
	    assert(p.negative === 0);
	    assert(!p.isZero());

	    var x = this;
	    var y = p.clone();

	    if (x.negative !== 0) {
	      x = x.umod(p);
	    } else {
	      x = x.clone();
	    }

	    // A * x + B * y = x
	    var A = new BN(1);
	    var B = new BN(0);

	    // C * x + D * y = y
	    var C = new BN(0);
	    var D = new BN(1);

	    var g = 0;

	    while (x.isEven() && y.isEven()) {
	      x.iushrn(1);
	      y.iushrn(1);
	      ++g;
	    }

	    var yp = y.clone();
	    var xp = x.clone();

	    while (!x.isZero()) {
	      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
	      if (i > 0) {
	        x.iushrn(i);
	        while (i-- > 0) {
	          if (A.isOdd() || B.isOdd()) {
	            A.iadd(yp);
	            B.isub(xp);
	          }

	          A.iushrn(1);
	          B.iushrn(1);
	        }
	      }

	      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
	      if (j > 0) {
	        y.iushrn(j);
	        while (j-- > 0) {
	          if (C.isOdd() || D.isOdd()) {
	            C.iadd(yp);
	            D.isub(xp);
	          }

	          C.iushrn(1);
	          D.iushrn(1);
	        }
	      }

	      if (x.cmp(y) >= 0) {
	        x.isub(y);
	        A.isub(C);
	        B.isub(D);
	      } else {
	        y.isub(x);
	        C.isub(A);
	        D.isub(B);
	      }
	    }

	    return {
	      a: C,
	      b: D,
	      gcd: y.iushln(g)
	    };
	  };

	  // This is reduced incarnation of the binary EEA
	  // above, designated to invert members of the
	  // _prime_ fields F(p) at a maximal speed
	  BN.prototype._invmp = function _invmp (p) {
	    assert(p.negative === 0);
	    assert(!p.isZero());

	    var a = this;
	    var b = p.clone();

	    if (a.negative !== 0) {
	      a = a.umod(p);
	    } else {
	      a = a.clone();
	    }

	    var x1 = new BN(1);
	    var x2 = new BN(0);

	    var delta = b.clone();

	    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
	      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
	      if (i > 0) {
	        a.iushrn(i);
	        while (i-- > 0) {
	          if (x1.isOdd()) {
	            x1.iadd(delta);
	          }

	          x1.iushrn(1);
	        }
	      }

	      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
	      if (j > 0) {
	        b.iushrn(j);
	        while (j-- > 0) {
	          if (x2.isOdd()) {
	            x2.iadd(delta);
	          }

	          x2.iushrn(1);
	        }
	      }

	      if (a.cmp(b) >= 0) {
	        a.isub(b);
	        x1.isub(x2);
	      } else {
	        b.isub(a);
	        x2.isub(x1);
	      }
	    }

	    var res;
	    if (a.cmpn(1) === 0) {
	      res = x1;
	    } else {
	      res = x2;
	    }

	    if (res.cmpn(0) < 0) {
	      res.iadd(p);
	    }

	    return res;
	  };

	  BN.prototype.gcd = function gcd (num) {
	    if (this.isZero()) return num.abs();
	    if (num.isZero()) return this.abs();

	    var a = this.clone();
	    var b = num.clone();
	    a.negative = 0;
	    b.negative = 0;

	    // Remove common factor of two
	    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
	      a.iushrn(1);
	      b.iushrn(1);
	    }

	    do {
	      while (a.isEven()) {
	        a.iushrn(1);
	      }
	      while (b.isEven()) {
	        b.iushrn(1);
	      }

	      var r = a.cmp(b);
	      if (r < 0) {
	        // Swap `a` and `b` to make `a` always bigger than `b`
	        var t = a;
	        a = b;
	        b = t;
	      } else if (r === 0 || b.cmpn(1) === 0) {
	        break;
	      }

	      a.isub(b);
	    } while (true);

	    return b.iushln(shift);
	  };

	  // Invert number in the field F(num)
	  BN.prototype.invm = function invm (num) {
	    return this.egcd(num).a.umod(num);
	  };

	  BN.prototype.isEven = function isEven () {
	    return (this.words[0] & 1) === 0;
	  };

	  BN.prototype.isOdd = function isOdd () {
	    return (this.words[0] & 1) === 1;
	  };

	  // And first word and num
	  BN.prototype.andln = function andln (num) {
	    return this.words[0] & num;
	  };

	  // Increment at the bit position in-line
	  BN.prototype.bincn = function bincn (bit) {
	    assert(typeof bit === 'number');
	    var r = bit % 26;
	    var s = (bit - r) / 26;
	    var q = 1 << r;

	    // Fast case: bit is much higher than all existing words
	    if (this.length <= s) {
	      this._expand(s + 1);
	      this.words[s] |= q;
	      return this;
	    }

	    // Add bit and propagate, if needed
	    var carry = q;
	    for (var i = s; carry !== 0 && i < this.length; i++) {
	      var w = this.words[i] | 0;
	      w += carry;
	      carry = w >>> 26;
	      w &= 0x3ffffff;
	      this.words[i] = w;
	    }
	    if (carry !== 0) {
	      this.words[i] = carry;
	      this.length++;
	    }
	    return this;
	  };

	  BN.prototype.isZero = function isZero () {
	    return this.length === 1 && this.words[0] === 0;
	  };

	  BN.prototype.cmpn = function cmpn (num) {
	    var negative = num < 0;

	    if (this.negative !== 0 && !negative) return -1;
	    if (this.negative === 0 && negative) return 1;

	    this.strip();

	    var res;
	    if (this.length > 1) {
	      res = 1;
	    } else {
	      if (negative) {
	        num = -num;
	      }

	      assert(num <= 0x3ffffff, 'Number is too big');

	      var w = this.words[0] | 0;
	      res = w === num ? 0 : w < num ? -1 : 1;
	    }
	    if (this.negative !== 0) return -res | 0;
	    return res;
	  };

	  // Compare two numbers and return:
	  // 1 - if `this` > `num`
	  // 0 - if `this` == `num`
	  // -1 - if `this` < `num`
	  BN.prototype.cmp = function cmp (num) {
	    if (this.negative !== 0 && num.negative === 0) return -1;
	    if (this.negative === 0 && num.negative !== 0) return 1;

	    var res = this.ucmp(num);
	    if (this.negative !== 0) return -res | 0;
	    return res;
	  };

	  // Unsigned comparison
	  BN.prototype.ucmp = function ucmp (num) {
	    // At this point both numbers have the same sign
	    if (this.length > num.length) return 1;
	    if (this.length < num.length) return -1;

	    var res = 0;
	    for (var i = this.length - 1; i >= 0; i--) {
	      var a = this.words[i] | 0;
	      var b = num.words[i] | 0;

	      if (a === b) continue;
	      if (a < b) {
	        res = -1;
	      } else if (a > b) {
	        res = 1;
	      }
	      break;
	    }
	    return res;
	  };

	  BN.prototype.gtn = function gtn (num) {
	    return this.cmpn(num) === 1;
	  };

	  BN.prototype.gt = function gt (num) {
	    return this.cmp(num) === 1;
	  };

	  BN.prototype.gten = function gten (num) {
	    return this.cmpn(num) >= 0;
	  };

	  BN.prototype.gte = function gte (num) {
	    return this.cmp(num) >= 0;
	  };

	  BN.prototype.ltn = function ltn (num) {
	    return this.cmpn(num) === -1;
	  };

	  BN.prototype.lt = function lt (num) {
	    return this.cmp(num) === -1;
	  };

	  BN.prototype.lten = function lten (num) {
	    return this.cmpn(num) <= 0;
	  };

	  BN.prototype.lte = function lte (num) {
	    return this.cmp(num) <= 0;
	  };

	  BN.prototype.eqn = function eqn (num) {
	    return this.cmpn(num) === 0;
	  };

	  BN.prototype.eq = function eq (num) {
	    return this.cmp(num) === 0;
	  };

	  //
	  // A reduce context, could be using montgomery or something better, depending
	  // on the `m` itself.
	  //
	  BN.red = function red (num) {
	    return new Red(num);
	  };

	  BN.prototype.toRed = function toRed (ctx) {
	    assert(!this.red, 'Already a number in reduction context');
	    assert(this.negative === 0, 'red works only with positives');
	    return ctx.convertTo(this)._forceRed(ctx);
	  };

	  BN.prototype.fromRed = function fromRed () {
	    assert(this.red, 'fromRed works only with numbers in reduction context');
	    return this.red.convertFrom(this);
	  };

	  BN.prototype._forceRed = function _forceRed (ctx) {
	    this.red = ctx;
	    return this;
	  };

	  BN.prototype.forceRed = function forceRed (ctx) {
	    assert(!this.red, 'Already a number in reduction context');
	    return this._forceRed(ctx);
	  };

	  BN.prototype.redAdd = function redAdd (num) {
	    assert(this.red, 'redAdd works only with red numbers');
	    return this.red.add(this, num);
	  };

	  BN.prototype.redIAdd = function redIAdd (num) {
	    assert(this.red, 'redIAdd works only with red numbers');
	    return this.red.iadd(this, num);
	  };

	  BN.prototype.redSub = function redSub (num) {
	    assert(this.red, 'redSub works only with red numbers');
	    return this.red.sub(this, num);
	  };

	  BN.prototype.redISub = function redISub (num) {
	    assert(this.red, 'redISub works only with red numbers');
	    return this.red.isub(this, num);
	  };

	  BN.prototype.redShl = function redShl (num) {
	    assert(this.red, 'redShl works only with red numbers');
	    return this.red.shl(this, num);
	  };

	  BN.prototype.redMul = function redMul (num) {
	    assert(this.red, 'redMul works only with red numbers');
	    this.red._verify2(this, num);
	    return this.red.mul(this, num);
	  };

	  BN.prototype.redIMul = function redIMul (num) {
	    assert(this.red, 'redMul works only with red numbers');
	    this.red._verify2(this, num);
	    return this.red.imul(this, num);
	  };

	  BN.prototype.redSqr = function redSqr () {
	    assert(this.red, 'redSqr works only with red numbers');
	    this.red._verify1(this);
	    return this.red.sqr(this);
	  };

	  BN.prototype.redISqr = function redISqr () {
	    assert(this.red, 'redISqr works only with red numbers');
	    this.red._verify1(this);
	    return this.red.isqr(this);
	  };

	  // Square root over p
	  BN.prototype.redSqrt = function redSqrt () {
	    assert(this.red, 'redSqrt works only with red numbers');
	    this.red._verify1(this);
	    return this.red.sqrt(this);
	  };

	  BN.prototype.redInvm = function redInvm () {
	    assert(this.red, 'redInvm works only with red numbers');
	    this.red._verify1(this);
	    return this.red.invm(this);
	  };

	  // Return negative clone of `this` % `red modulo`
	  BN.prototype.redNeg = function redNeg () {
	    assert(this.red, 'redNeg works only with red numbers');
	    this.red._verify1(this);
	    return this.red.neg(this);
	  };

	  BN.prototype.redPow = function redPow (num) {
	    assert(this.red && !num.red, 'redPow(normalNum)');
	    this.red._verify1(this);
	    return this.red.pow(this, num);
	  };

	  // Prime numbers with efficient reduction
	  var primes = {
	    k256: null,
	    p224: null,
	    p192: null,
	    p25519: null
	  };

	  // Pseudo-Mersenne prime
	  function MPrime (name, p) {
	    // P = 2 ^ N - K
	    this.name = name;
	    this.p = new BN(p, 16);
	    this.n = this.p.bitLength();
	    this.k = new BN(1).iushln(this.n).isub(this.p);

	    this.tmp = this._tmp();
	  }

	  MPrime.prototype._tmp = function _tmp () {
	    var tmp = new BN(null);
	    tmp.words = new Array(Math.ceil(this.n / 13));
	    return tmp;
	  };

	  MPrime.prototype.ireduce = function ireduce (num) {
	    // Assumes that `num` is less than `P^2`
	    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
	    var r = num;
	    var rlen;

	    do {
	      this.split(r, this.tmp);
	      r = this.imulK(r);
	      r = r.iadd(this.tmp);
	      rlen = r.bitLength();
	    } while (rlen > this.n);

	    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
	    if (cmp === 0) {
	      r.words[0] = 0;
	      r.length = 1;
	    } else if (cmp > 0) {
	      r.isub(this.p);
	    } else {
	      if (r.strip !== undefined) {
	        // r is BN v4 instance
	        r.strip();
	      } else {
	        // r is BN v5 instance
	        r._strip();
	      }
	    }

	    return r;
	  };

	  MPrime.prototype.split = function split (input, out) {
	    input.iushrn(this.n, 0, out);
	  };

	  MPrime.prototype.imulK = function imulK (num) {
	    return num.imul(this.k);
	  };

	  function K256 () {
	    MPrime.call(
	      this,
	      'k256',
	      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
	  }
	  inherits(K256, MPrime);

	  K256.prototype.split = function split (input, output) {
	    // 256 = 9 * 26 + 22
	    var mask = 0x3fffff;

	    var outLen = Math.min(input.length, 9);
	    for (var i = 0; i < outLen; i++) {
	      output.words[i] = input.words[i];
	    }
	    output.length = outLen;

	    if (input.length <= 9) {
	      input.words[0] = 0;
	      input.length = 1;
	      return;
	    }

	    // Shift by 9 limbs
	    var prev = input.words[9];
	    output.words[output.length++] = prev & mask;

	    for (i = 10; i < input.length; i++) {
	      var next = input.words[i] | 0;
	      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
	      prev = next;
	    }
	    prev >>>= 22;
	    input.words[i - 10] = prev;
	    if (prev === 0 && input.length > 10) {
	      input.length -= 10;
	    } else {
	      input.length -= 9;
	    }
	  };

	  K256.prototype.imulK = function imulK (num) {
	    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
	    num.words[num.length] = 0;
	    num.words[num.length + 1] = 0;
	    num.length += 2;

	    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
	    var lo = 0;
	    for (var i = 0; i < num.length; i++) {
	      var w = num.words[i] | 0;
	      lo += w * 0x3d1;
	      num.words[i] = lo & 0x3ffffff;
	      lo = w * 0x40 + ((lo / 0x4000000) | 0);
	    }

	    // Fast length reduction
	    if (num.words[num.length - 1] === 0) {
	      num.length--;
	      if (num.words[num.length - 1] === 0) {
	        num.length--;
	      }
	    }
	    return num;
	  };

	  function P224 () {
	    MPrime.call(
	      this,
	      'p224',
	      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
	  }
	  inherits(P224, MPrime);

	  function P192 () {
	    MPrime.call(
	      this,
	      'p192',
	      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
	  }
	  inherits(P192, MPrime);

	  function P25519 () {
	    // 2 ^ 255 - 19
	    MPrime.call(
	      this,
	      '25519',
	      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
	  }
	  inherits(P25519, MPrime);

	  P25519.prototype.imulK = function imulK (num) {
	    // K = 0x13
	    var carry = 0;
	    for (var i = 0; i < num.length; i++) {
	      var hi = (num.words[i] | 0) * 0x13 + carry;
	      var lo = hi & 0x3ffffff;
	      hi >>>= 26;

	      num.words[i] = lo;
	      carry = hi;
	    }
	    if (carry !== 0) {
	      num.words[num.length++] = carry;
	    }
	    return num;
	  };

	  // Exported mostly for testing purposes, use plain name instead
	  BN._prime = function prime (name) {
	    // Cached version of prime
	    if (primes[name]) return primes[name];

	    var prime;
	    if (name === 'k256') {
	      prime = new K256();
	    } else if (name === 'p224') {
	      prime = new P224();
	    } else if (name === 'p192') {
	      prime = new P192();
	    } else if (name === 'p25519') {
	      prime = new P25519();
	    } else {
	      throw new Error('Unknown prime ' + name);
	    }
	    primes[name] = prime;

	    return prime;
	  };

	  //
	  // Base reduction engine
	  //
	  function Red (m) {
	    if (typeof m === 'string') {
	      var prime = BN._prime(m);
	      this.m = prime.p;
	      this.prime = prime;
	    } else {
	      assert(m.gtn(1), 'modulus must be greater than 1');
	      this.m = m;
	      this.prime = null;
	    }
	  }

	  Red.prototype._verify1 = function _verify1 (a) {
	    assert(a.negative === 0, 'red works only with positives');
	    assert(a.red, 'red works only with red numbers');
	  };

	  Red.prototype._verify2 = function _verify2 (a, b) {
	    assert((a.negative | b.negative) === 0, 'red works only with positives');
	    assert(a.red && a.red === b.red,
	      'red works only with red numbers');
	  };

	  Red.prototype.imod = function imod (a) {
	    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
	    return a.umod(this.m)._forceRed(this);
	  };

	  Red.prototype.neg = function neg (a) {
	    if (a.isZero()) {
	      return a.clone();
	    }

	    return this.m.sub(a)._forceRed(this);
	  };

	  Red.prototype.add = function add (a, b) {
	    this._verify2(a, b);

	    var res = a.add(b);
	    if (res.cmp(this.m) >= 0) {
	      res.isub(this.m);
	    }
	    return res._forceRed(this);
	  };

	  Red.prototype.iadd = function iadd (a, b) {
	    this._verify2(a, b);

	    var res = a.iadd(b);
	    if (res.cmp(this.m) >= 0) {
	      res.isub(this.m);
	    }
	    return res;
	  };

	  Red.prototype.sub = function sub (a, b) {
	    this._verify2(a, b);

	    var res = a.sub(b);
	    if (res.cmpn(0) < 0) {
	      res.iadd(this.m);
	    }
	    return res._forceRed(this);
	  };

	  Red.prototype.isub = function isub (a, b) {
	    this._verify2(a, b);

	    var res = a.isub(b);
	    if (res.cmpn(0) < 0) {
	      res.iadd(this.m);
	    }
	    return res;
	  };

	  Red.prototype.shl = function shl (a, num) {
	    this._verify1(a);
	    return this.imod(a.ushln(num));
	  };

	  Red.prototype.imul = function imul (a, b) {
	    this._verify2(a, b);
	    return this.imod(a.imul(b));
	  };

	  Red.prototype.mul = function mul (a, b) {
	    this._verify2(a, b);
	    return this.imod(a.mul(b));
	  };

	  Red.prototype.isqr = function isqr (a) {
	    return this.imul(a, a.clone());
	  };

	  Red.prototype.sqr = function sqr (a) {
	    return this.mul(a, a);
	  };

	  Red.prototype.sqrt = function sqrt (a) {
	    if (a.isZero()) return a.clone();

	    var mod3 = this.m.andln(3);
	    assert(mod3 % 2 === 1);

	    // Fast case
	    if (mod3 === 3) {
	      var pow = this.m.add(new BN(1)).iushrn(2);
	      return this.pow(a, pow);
	    }

	    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
	    //
	    // Find Q and S, that Q * 2 ^ S = (P - 1)
	    var q = this.m.subn(1);
	    var s = 0;
	    while (!q.isZero() && q.andln(1) === 0) {
	      s++;
	      q.iushrn(1);
	    }
	    assert(!q.isZero());

	    var one = new BN(1).toRed(this);
	    var nOne = one.redNeg();

	    // Find quadratic non-residue
	    // NOTE: Max is such because of generalized Riemann hypothesis.
	    var lpow = this.m.subn(1).iushrn(1);
	    var z = this.m.bitLength();
	    z = new BN(2 * z * z).toRed(this);

	    while (this.pow(z, lpow).cmp(nOne) !== 0) {
	      z.redIAdd(nOne);
	    }

	    var c = this.pow(z, q);
	    var r = this.pow(a, q.addn(1).iushrn(1));
	    var t = this.pow(a, q);
	    var m = s;
	    while (t.cmp(one) !== 0) {
	      var tmp = t;
	      for (var i = 0; tmp.cmp(one) !== 0; i++) {
	        tmp = tmp.redSqr();
	      }
	      assert(i < m);
	      var b = this.pow(c, new BN(1).iushln(m - i - 1));

	      r = r.redMul(b);
	      c = b.redSqr();
	      t = t.redMul(c);
	      m = i;
	    }

	    return r;
	  };

	  Red.prototype.invm = function invm (a) {
	    var inv = a._invmp(this.m);
	    if (inv.negative !== 0) {
	      inv.negative = 0;
	      return this.imod(inv).redNeg();
	    } else {
	      return this.imod(inv);
	    }
	  };

	  Red.prototype.pow = function pow (a, num) {
	    if (num.isZero()) return new BN(1).toRed(this);
	    if (num.cmpn(1) === 0) return a.clone();

	    var windowSize = 4;
	    var wnd = new Array(1 << windowSize);
	    wnd[0] = new BN(1).toRed(this);
	    wnd[1] = a;
	    for (var i = 2; i < wnd.length; i++) {
	      wnd[i] = this.mul(wnd[i - 1], a);
	    }

	    var res = wnd[0];
	    var current = 0;
	    var currentLen = 0;
	    var start = num.bitLength() % 26;
	    if (start === 0) {
	      start = 26;
	    }

	    for (i = num.length - 1; i >= 0; i--) {
	      var word = num.words[i];
	      for (var j = start - 1; j >= 0; j--) {
	        var bit = (word >> j) & 1;
	        if (res !== wnd[0]) {
	          res = this.sqr(res);
	        }

	        if (bit === 0 && current === 0) {
	          currentLen = 0;
	          continue;
	        }

	        current <<= 1;
	        current |= bit;
	        currentLen++;
	        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

	        res = this.mul(res, wnd[current]);
	        currentLen = 0;
	        current = 0;
	      }
	      start = 26;
	    }

	    return res;
	  };

	  Red.prototype.convertTo = function convertTo (num) {
	    var r = num.umod(this.m);

	    return r === num ? r.clone() : r;
	  };

	  Red.prototype.convertFrom = function convertFrom (num) {
	    var res = num.clone();
	    res.red = null;
	    return res;
	  };

	  //
	  // Montgomery method engine
	  //

	  BN.mont = function mont (num) {
	    return new Mont(num);
	  };

	  function Mont (m) {
	    Red.call(this, m);

	    this.shift = this.m.bitLength();
	    if (this.shift % 26 !== 0) {
	      this.shift += 26 - (this.shift % 26);
	    }

	    this.r = new BN(1).iushln(this.shift);
	    this.r2 = this.imod(this.r.sqr());
	    this.rinv = this.r._invmp(this.m);

	    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
	    this.minv = this.minv.umod(this.r);
	    this.minv = this.r.sub(this.minv);
	  }
	  inherits(Mont, Red);

	  Mont.prototype.convertTo = function convertTo (num) {
	    return this.imod(num.ushln(this.shift));
	  };

	  Mont.prototype.convertFrom = function convertFrom (num) {
	    var r = this.imod(num.mul(this.rinv));
	    r.red = null;
	    return r;
	  };

	  Mont.prototype.imul = function imul (a, b) {
	    if (a.isZero() || b.isZero()) {
	      a.words[0] = 0;
	      a.length = 1;
	      return a;
	    }

	    var t = a.imul(b);
	    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
	    var u = t.isub(c).iushrn(this.shift);
	    var res = u;

	    if (u.cmp(this.m) >= 0) {
	      res = u.isub(this.m);
	    } else if (u.cmpn(0) < 0) {
	      res = u.iadd(this.m);
	    }

	    return res._forceRed(this);
	  };

	  Mont.prototype.mul = function mul (a, b) {
	    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

	    var t = a.mul(b);
	    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
	    var u = t.isub(c).iushrn(this.shift);
	    var res = u;
	    if (u.cmp(this.m) >= 0) {
	      res = u.isub(this.m);
	    } else if (u.cmpn(0) < 0) {
	      res = u.iadd(this.m);
	    }

	    return res._forceRed(this);
	  };

	  Mont.prototype.invm = function invm (a) {
	    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
	    var res = this.imod(a._invmp(this.m).mul(this.r2));
	    return res._forceRed(this);
	  };
	})(module, commonjsGlobal); 
} (bn$2));

var bnExports$1 = bn$2.exports;

var errors$4 = {exports: {}};

var _$d = {};

_$d.isArray = t => Array.isArray(t);
_$d.isNumber = t => typeof t === 'number';
_$d.isObject = t => t && typeof t === 'object';
_$d.isString = t => typeof t === 'string';
_$d.isUndefined = t => typeof t === 'undefined';
_$d.isFunction = t => typeof t === 'function';
_$d.isNull = t => t === null;
_$d.isDate = t => t instanceof Date;
_$d.extend = (a, b) => Object.assign(a, b);
_$d.noop = () => { };
_$d.every = (a, f) => a.every(f || (t => t));
_$d.map = (a, f) => Array.from(a).map(f || (t => t));
_$d.includes = (a, e) => a.includes(e);
_$d.each = (a, f) => a.forEach(f);
_$d.clone = o => Object.assign({}, o);
_$d.pick = (object, keys) => {
  const obj = {};
  keys.forEach(key => {
    if (typeof object[key] !== 'undefined') { obj[key] = object[key]; }
  });
  return obj
};
_$d.values = o => Object.values(o);
_$d.filter = (a, f) => a.filter(f);
_$d.reduce = (a, f, s) => a.reduce(f, s);
_$d.without = (a, n) => a.filter(t => t !== n);
_$d.shuffle = a => {
  const result = a.slice(0);
  for (let i = result.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [result[i], result[j]] = [result[j], result[i]];
  }
  return result
};
_$d.difference = (a, b) => a.filter(t => !b.includes(t));
_$d.findIndex = (a, f) => a.findIndex(f);
_$d.some = (a, f) => a.some(f);
_$d.range = n => [...Array(n).keys()];

var __1 = _$d;

var spec$1;
var hasRequiredSpec;

function requireSpec () {
	if (hasRequiredSpec) return spec$1;
	hasRequiredSpec = 1;

	var docsURL = 'https://docs.moneybutton.com/';

	spec$1 = [{
	  name: 'InvalidB58Char',
	  message: 'Invalid Base58 character: {0} in {1}'
	}, {
	  name: 'InvalidB58Checksum',
	  message: 'Invalid Base58 checksum for {0}'
	}, {
	  name: 'InvalidNetwork',
	  message: 'Invalid version for network: got {0}'
	}, {
	  name: 'InvalidState',
	  message: 'Invalid state: {0}'
	}, {
	  name: 'NotImplemented',
	  message: 'Function {0} was not implemented yet'
	}, {
	  name: 'InvalidNetworkArgument',
	  message: 'Invalid network: must be "livenet" or "testnet", got {0}'
	}, {
	  name: 'InvalidArgument',
	  message: function () {
	    return 'Invalid Argument' + (arguments[0] ? (': ' + arguments[0]) : '') +
	      (arguments[1] ? (' Documentation: ' + docsURL + arguments[1]) : '')
	  }
	}, {
	  name: 'AbstractMethodInvoked',
	  message: 'Abstract Method Invocation: {0}'
	}, {
	  name: 'InvalidArgumentType',
	  message: function () {
	    return 'Invalid Argument for ' + arguments[2] + ', expected ' + arguments[1] + ' but got ' + typeof arguments[0]
	  }
	}, {
	  name: 'Unit',
	  message: 'Internal Error on Unit {0}',
	  errors: [{
	    'name': 'UnknownCode',
	    'message': 'Unrecognized unit code: {0}'
	  }, {
	    'name': 'InvalidRate',
	    'message': 'Invalid exchange rate: {0}'
	  }]
	}, {
	  name: 'MerkleBlock',
	  message: 'Internal Error on MerkleBlock {0}',
	  errors: [{
	    'name': 'InvalidMerkleTree',
	    'message': 'This MerkleBlock contain an invalid Merkle Tree'
	  }]
	}, {
	  name: 'Transaction',
	  message: 'Internal Error on Transaction {0}',
	  errors: [{
	    name: 'Input',
	    message: 'Internal Error on Input {0}',
	    errors: [{
	      name: 'MissingScript',
	      message: 'Need a script to create an input'
	    }, {
	      name: 'UnsupportedScript',
	      message: 'Unsupported input script type: {0}'
	    }, {
	      name: 'MissingPreviousOutput',
	      message: 'No previous output information.'
	    }]
	  }, {
	    name: 'NeedMoreInfo',
	    message: '{0}'
	  }, {
	    name: 'InvalidSorting',
	    message: 'The sorting function provided did not return the change output as one of the array elements'
	  }, {
	    name: 'InvalidOutputAmountSum',
	    message: '{0}'
	  }, {
	    name: 'MissingSignatures',
	    message: 'Some inputs have not been fully signed'
	  }, {
	    name: 'InvalidIndex',
	    message: 'Invalid index: {0} is not between 0, {1}'
	  }, {
	    name: 'UnableToVerifySignature',
	    message: 'Unable to verify signature: {0}'
	  }, {
	    name: 'DustOutputs',
	    message: 'Dust amount detected in one output'
	  }, {
	    name: 'InvalidSatoshis',
	    message: 'Output satoshis are invalid'
	  }, {
	    name: 'FeeError',
	    message: 'Internal Error on Fee {0}',
	    errors: [{
	      name: 'TooSmall',
	      message: 'Fee is too small: {0}'
	    }, {
	      name: 'TooLarge',
	      message: 'Fee is too large: {0}'
	    }, {
	      name: 'Different',
	      message: 'Unspent value is different from specified fee: {0}'
	    }]
	  }, {
	    name: 'ChangeAddressMissing',
	    message: 'Change address is missing'
	  }, {
	    name: 'BlockHeightTooHigh',
	    message: 'Block Height can be at most 2^32 -1'
	  }, {
	    name: 'NLockTimeOutOfRange',
	    message: 'Block Height can only be between 0 and 499 999 999'
	  }, {
	    name: 'LockTimeTooEarly',
	    message: 'Lock Time can\'t be earlier than UNIX date 500 000 000'
	  }, {
	    name: 'TransactionAlreadySealed',
	    message: 'Cannot update sealed transaction'
	  }]
	}, {
	  name: 'Script',
	  message: 'Internal Error on Script {0}',
	  errors: [{
	    name: 'UnrecognizedAddress',
	    message: 'Expected argument {0} to be an address'
	  }, {
	    name: 'CantDeriveAddress',
	    message: 'Can\'t derive address associated with script {0}, needs to be p2pkh in, p2pkh out, p2sh in, or p2sh out.'
	  }, {
	    name: 'InvalidBuffer',
	    message: 'Invalid script buffer: can\'t parse valid script from given buffer {0}'
	  }]
	}, {
	  name: 'HDPrivateKey',
	  message: 'Internal Error on HDPrivateKey {0}',
	  errors: [{
	    name: 'InvalidDerivationArgument',
	    message: 'Invalid derivation argument {0}, expected string, or number and boolean'
	  }, {
	    name: 'InvalidEntropyArgument',
	    message: 'Invalid entropy: must be an hexa string or binary buffer, got {0}',
	    errors: [{
	      name: 'TooMuchEntropy',
	      message: 'Invalid entropy: more than 512 bits is non standard, got "{0}"'
	    }, {
	      name: 'NotEnoughEntropy',
	      message: 'Invalid entropy: at least 128 bits needed, got "{0}"'
	    }]
	  }, {
	    name: 'InvalidLength',
	    message: 'Invalid length for xprivkey string in {0}'
	  }, {
	    name: 'InvalidPath',
	    message: 'Invalid derivation path: {0}'
	  }, {
	    name: 'UnrecognizedArgument',
	    message: 'Invalid argument: creating a HDPrivateKey requires a string, buffer, json or object, got "{0}"'
	  }]
	}, {
	  name: 'HDPublicKey',
	  message: 'Internal Error on HDPublicKey {0}',
	  errors: [{
	    name: 'ArgumentIsPrivateExtended',
	    message: 'Argument is an extended private key: {0}'
	  }, {
	    name: 'InvalidDerivationArgument',
	    message: 'Invalid derivation argument: got {0}'
	  }, {
	    name: 'InvalidLength',
	    message: 'Invalid length for xpubkey: got "{0}"'
	  }, {
	    name: 'InvalidPath',
	    message: 'Invalid derivation path, it should look like: "m/1/100", got "{0}"'
	  }, {
	    name: 'InvalidIndexCantDeriveHardened',
	    message: 'Invalid argument: creating a hardened path requires an HDPrivateKey'
	  }, {
	    name: 'MustSupplyArgument',
	    message: 'Must supply an argument to create a HDPublicKey'
	  }, {
	    name: 'UnrecognizedArgument',
	    message: 'Invalid argument for creation, must be string, json, buffer, or object'
	  }]
	}];
	return spec$1;
}

var _$c = __1;

function format (message, args) {
  return message
    .replace('{0}', args[0])
    .replace('{1}', args[1])
    .replace('{2}', args[2])
}
var traverseNode = function (parent, errorDefinition) {
  var NodeError = function () {
    if (_$c.isString(errorDefinition.message)) {
      this.message = format(errorDefinition.message, arguments);
    } else if (_$c.isFunction(errorDefinition.message)) {
      this.message = errorDefinition.message.apply(null, arguments);
    } else {
      throw new Error('Invalid error definition for ' + errorDefinition.name)
    }
    this.stack = this.message + '\n' + (new Error()).stack;
  };
  NodeError.prototype = Object.create(parent.prototype);
  NodeError.prototype.name = parent.prototype.name + errorDefinition.name;
  parent[errorDefinition.name] = NodeError;
  if (errorDefinition.errors) {
    childDefinitions(NodeError, errorDefinition.errors);
  }
  return NodeError
};

var childDefinitions = function (parent, childDefinitions) {
  _$c.each(childDefinitions, function (childDefinition) {
    traverseNode(parent, childDefinition);
  });
};

var traverseRoot = function (parent, errorsDefinition) {
  childDefinitions(parent, errorsDefinition);
  return parent
};

var mvc$2 = {};
mvc$2.Error = function () {
  this.message = 'Internal error';
  this.stack = this.message + '\n' + (new Error()).stack;
};
mvc$2.Error.prototype = Object.create(Error.prototype);
mvc$2.Error.prototype.name = 'mvc.Error';

var data$1 = requireSpec();
traverseRoot(mvc$2.Error, data$1);

errors$4.exports = mvc$2.Error;

errors$4.exports.extend = function (spec) {
  return traverseNode(mvc$2.Error, spec)
};

var errorsExports = errors$4.exports;

var errors$3 = errorsExports;
var _$b = __1;

var preconditions = {
  checkState: function (condition, message) {
    if (!condition) {
      throw new errors$3.InvalidState(message)
    }
  },
  checkArgument: function (condition, argumentName, message, docsPath) {
    if (!condition) {
      throw new errors$3.InvalidArgument(argumentName, message, docsPath)
    }
  },
  checkArgumentType: function (argument, type, argumentName) {
    argumentName = argumentName || '(unknown name)';
    if (_$b.isString(type)) {
      if (type === 'Buffer') {
        var buffer = require$$2$1; // './buffer' fails on cordova & RN
        if (!buffer.Buffer.isBuffer(argument)) {
          throw new errors$3.InvalidArgumentType(argument, type, argumentName)
        }
      } else if (typeof argument !== type) { // eslint-disable-line
        throw new errors$3.InvalidArgumentType(argument, type, argumentName)
      }
    } else {
      if (!(argument instanceof type)) {
        throw new errors$3.InvalidArgumentType(argument, type.name, argumentName)
      }
    }
  }
};

var BN$e = bnExports$1;
var $$9 = preconditions;
var _$a = __1;

var reversebuf = function (buf) {
  var buf2 = Buffer.alloc(buf.length);
  for (var i = 0; i < buf.length; i++) {
    buf2[i] = buf[buf.length - 1 - i];
  }
  return buf2
};

BN$e.Zero = new BN$e(0);
BN$e.One = new BN$e(1);
BN$e.Minus1 = new BN$e(-1);

/**
 * Convert a number into a big number.
 *
 * @param {number} n Any positive or negative integer.
 */
BN$e.fromNumber = function (n) {
  $$9.checkArgument(_$a.isNumber(n));
  return new BN$e(n)
};

/**
 * Convert a string number into a big number.
 *
 * @param {string} str Any positive or negative integer formatted as a string.
 * @param {number} base The base of the number, defaults to 10.
 */
BN$e.fromString = function (str, base) {
  $$9.checkArgument(_$a.isString(str));
  return new BN$e(str, base)
};

/**
 * Convert a buffer (such as a 256 bit binary private key) into a big number.
 * Sometimes these numbers can be formatted either as 'big endian' or 'little
 * endian', and so there is an opts parameter that lets you specify which
 * endianness is specified.
 *
 * @param {Buffer} buf A buffer number, such as a 256 bit hash or key.
 * @param {Object} opts With a property 'endian' that can be either 'big' or 'little'. Defaults big endian (most significant digit first).
 */
BN$e.fromBuffer = function (buf, opts) {
  if (typeof opts !== 'undefined' && opts.endian === 'little') {
    buf = reversebuf(buf);
  }
  var hex = buf.toString('hex');
  var bn = new BN$e(hex, 16);
  return bn
};

/**
 * Instantiate a BigNumber from a "signed magnitude buffer". (a buffer where the
 * most significant bit represents the sign (0 = positive, 1 = negative)
 *
 * @param {Buffer} buf A buffer number, such as a 256 bit hash or key.
 * @param {Object} opts With a property 'endian' that can be either 'big' or 'little'. Defaults big endian (most significant digit first).
 */
BN$e.fromSM = function (buf, opts) {
  var ret;
  if (buf.length === 0) {
    return BN$e.fromBuffer(Buffer.from([0]))
  }

  var endian = 'big';
  if (opts) {
    endian = opts.endian;
  }
  if (endian === 'little') {
    buf = reversebuf(buf);
  }

  if (buf[0] & 0x80) {
    buf[0] = buf[0] & 0x7f;
    ret = BN$e.fromBuffer(buf);
    ret.neg().copy(ret);
  } else {
    ret = BN$e.fromBuffer(buf);
  }
  return ret
};

/**
 * Convert a big number into a number.
 */
BN$e.prototype.toNumber = function () {
  return parseInt(this.toString(10), 10)
};

/**
 * Convert a big number into a buffer. This is somewhat ambiguous, so there is
 * an opts parameter that let's you specify the endianness or the size.
 * opts.endian can be either 'big' or 'little' and opts.size can be any
 * sufficiently large number of bytes. If you always want to create a 32 byte
 * big endian number, then specify opts = { endian: 'big', size: 32 }
 *
 * @param {Object} opts Defaults to { endian: 'big', size: 32 }
 */
BN$e.prototype.toBuffer = function (opts) {
  var buf, hex;
  if (opts && opts.size) {
    hex = this.toString(16, 2);
    var natlen = hex.length / 2;
    buf = Buffer.from(hex, 'hex');

    if (natlen === opts.size) ; else if (natlen > opts.size) {
      buf = BN$e.trim(buf, natlen);
    } else if (natlen < opts.size) {
      buf = BN$e.pad(buf, natlen, opts.size);
    }
  } else {
    hex = this.toString(16, 2);
    buf = Buffer.from(hex, 'hex');
  }

  if (typeof opts !== 'undefined' && opts.endian === 'little') {
    buf = reversebuf(buf);
  }

  return buf
};

/**
 * For big numbers that are either positive or negative, you can convert to
 * "sign magnitude" format whereby the first bit specifies whether the number is
 * positive or negative.
 */
BN$e.prototype.toSMBigEndian = function () {
  var buf;
  if (this.cmp(BN$e.Zero) === -1) {
    buf = this.neg().toBuffer();
    if (buf[0] & 0x80) {
      buf = Buffer.concat([Buffer.from([0x80]), buf]);
    } else {
      buf[0] = buf[0] | 0x80;
    }
  } else {
    buf = this.toBuffer();
    if (buf[0] & 0x80) {
      buf = Buffer.concat([Buffer.from([0x00]), buf]);
    }
  }

  if (buf.length === 1 & buf[0] === 0) {
    buf = Buffer.from([]);
  }
  return buf
};

/**
 * For big numbers that are either positive or negative, you can convert to
 * "sign magnitude" format whereby the first bit specifies whether the number is
 * positive or negative.
 *
 * @param {Object} opts Defaults to { endian: 'big' }
 */
BN$e.prototype.toSM = function (opts) {
  var endian = opts ? opts.endian : 'big';
  var buf = this.toSMBigEndian();

  if (endian === 'little') {
    buf = reversebuf(buf);
  }
  return buf
};

/**
 * Create a BN from a "ScriptNum": This is analogous to the constructor for
 * CScriptNum in bitcoind. Many ops in bitcoind's script interpreter use
 * CScriptNum, which is not really a proper bignum. Instead, an error is thrown
 * if trying to input a number bigger than 4 bytes. We copy that behavior here.
 * A third argument, `size`, is provided to extend the hard limit of 4 bytes, as
 * some usages require more than 4 bytes.
 *
 * @param {Buffer} buf A buffer of a number.
 * @param {boolean} fRequireMinimal Whether to require minimal size encoding.
 * @param {number} size The maximum size.
 */
BN$e.fromScriptNumBuffer = function (buf, fRequireMinimal, size) {
  // don't limit numSize default
  var nMaxNumSize = size || Number.MAX_SAFE_INTEGER;
  $$9.checkArgument(buf.length <= nMaxNumSize, new Error('script number overflow'));
  if (fRequireMinimal && buf.length > 0) {
    // Check that the number is encoded with the minimum possible
    // number of bytes.
    //
    // If the most-significant-byte - excluding the sign bit - is zero
    // then we're not minimal. Note how this test also rejects the
    // negative-zero encoding, 0x80.
    if ((buf[buf.length - 1] & 0x7f) === 0) {
      // One exception: if there's more than one byte and the most
      // significant bit of the second-most-significant-byte is set
      // it would conflict with the sign bit. An example of this case
      // is +-255, which encode to 0xff00 and 0xff80 respectively.
      // (big-endian).
      if (buf.length <= 1 || (buf[buf.length - 2] & 0x80) === 0) {
        throw new Error('non-minimally encoded script number')
      }
    }
  }
  return BN$e.fromSM(buf, {
    endian: 'little'
  })
};

/**
 * The corollary to the above, with the notable exception that we do not throw
 * an error if the output is larger than four bytes. (Which can happen if
 * performing a numerical operation that results in an overflow to more than 4
 * bytes).
 */
BN$e.prototype.toScriptNumBuffer = function () {
  return this.toSM({
    endian: 'little'
  })
};

/**
 * Trims a buffer if it starts with zeros.
 *
 * @param {Buffer} buf A buffer formatted number.
 * @param {number} natlen The natural length of the number.
 */
BN$e.trim = function (buf, natlen) {
  return buf.slice(natlen - buf.length, buf.length)
};

/**
 * Adds extra zeros to the start of a number.
 *
 * @param {Buffer} buf A buffer formatted number.
 * @param {number} natlen The natural length of the number.
 * @param {number} size How big to pad the number in bytes.
 */
BN$e.pad = function (buf, natlen, size) {
  var rbuf = Buffer.alloc(size);
  for (var i = 0; i < buf.length; i++) {
    rbuf[rbuf.length - 1 - i] = buf[buf.length - 1 - i];
  }
  for (i = 0; i < size - natlen; i++) {
    rbuf[i] = 0;
  }
  return rbuf
};
/**
 * Convert a big number into a hex string. This is somewhat ambiguous, so there
 * is an opts parameter that let's you specify the endianness or the size.
 * opts.endian can be either 'big' or 'little' and opts.size can be any
 * sufficiently large number of bytes. If you always want to create a 32 byte
 * big endian number, then specify opts = { endian: 'big', size: 32 }
 *
 * @param {Object} opts Defaults to { endian: 'big', size: 32 }
 */
BN$e.prototype.toHex = function (...args) {
  return this.toBuffer(...args).toString('hex')
};

/**
 * Convert a hex string (such as a 256 bit binary private key) into a big
 * number. Sometimes these numbers can be formatted either as 'big endian' or
 * 'little endian', and so there is an opts parameter that lets you specify
 * which endianness is specified.
 *
 * @param {Buffer} buf A buffer number, such as a 256 bit hash or key.
 * @param {Object} opts With a property 'endian' that can be either 'big' or 'little'. Defaults big endian (most significant digit first).
 */
BN$e.fromHex = function (hex, ...args) {
  return BN$e.fromBuffer(Buffer.from(hex, 'hex'), ...args)
};

var bn$1 = BN$e;

var elliptic = {};

var name = "elliptic";
var version$1 = "6.5.4";
var description = "EC cryptography";
var main = "lib/elliptic.js";
var files = [
	"lib"
];
var scripts = {
	lint: "eslint lib test",
	"lint:fix": "npm run lint -- --fix",
	unit: "istanbul test _mocha --reporter=spec test/index.js",
	test: "npm run lint && npm run unit",
	version: "grunt dist && git add dist/"
};
var repository = {
	type: "git",
	url: "git@github.com:indutny/elliptic"
};
var keywords = [
	"EC",
	"Elliptic",
	"curve",
	"Cryptography"
];
var author = "Fedor Indutny <fedor@indutny.com>";
var license = "MIT";
var bugs = {
	url: "https://github.com/indutny/elliptic/issues"
};
var homepage = "https://github.com/indutny/elliptic";
var devDependencies = {
	brfs: "^2.0.2",
	coveralls: "^3.1.0",
	eslint: "^7.6.0",
	grunt: "^1.2.1",
	"grunt-browserify": "^5.3.0",
	"grunt-cli": "^1.3.2",
	"grunt-contrib-connect": "^3.0.0",
	"grunt-contrib-copy": "^1.0.0",
	"grunt-contrib-uglify": "^5.0.0",
	"grunt-mocha-istanbul": "^5.0.2",
	"grunt-saucelabs": "^9.0.1",
	istanbul: "^0.4.5",
	mocha: "^8.0.1"
};
var dependencies = {
	"bn.js": "^4.11.9",
	brorand: "^1.1.0",
	"hash.js": "^1.0.0",
	"hmac-drbg": "^1.0.1",
	inherits: "^2.0.4",
	"minimalistic-assert": "^1.0.1",
	"minimalistic-crypto-utils": "^1.0.1"
};
var require$$0$2 = {
	name: name,
	version: version$1,
	description: description,
	main: main,
	files: files,
	scripts: scripts,
	repository: repository,
	keywords: keywords,
	author: author,
	license: license,
	bugs: bugs,
	homepage: homepage,
	devDependencies: devDependencies,
	dependencies: dependencies
};

var utils$o = {};

var bn = {exports: {}};

bn.exports;

(function (module) {
	(function (module, exports) {

	  // Utils
	  function assert (val, msg) {
	    if (!val) throw new Error(msg || 'Assertion failed');
	  }

	  // Could use `inherits` module, but don't want to move from single file
	  // architecture yet.
	  function inherits (ctor, superCtor) {
	    ctor.super_ = superCtor;
	    var TempCtor = function () {};
	    TempCtor.prototype = superCtor.prototype;
	    ctor.prototype = new TempCtor();
	    ctor.prototype.constructor = ctor;
	  }

	  // BN

	  function BN (number, base, endian) {
	    if (BN.isBN(number)) {
	      return number;
	    }

	    this.negative = 0;
	    this.words = null;
	    this.length = 0;

	    // Reduction context
	    this.red = null;

	    if (number !== null) {
	      if (base === 'le' || base === 'be') {
	        endian = base;
	        base = 10;
	      }

	      this._init(number || 0, base || 10, endian || 'be');
	    }
	  }
	  if (typeof module === 'object') {
	    module.exports = BN;
	  } else {
	    exports.BN = BN;
	  }

	  BN.BN = BN;
	  BN.wordSize = 26;

	  var Buffer;
	  try {
	    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
	      Buffer = window.Buffer;
	    } else {
	      Buffer = require('buffer').Buffer;
	    }
	  } catch (e) {
	  }

	  BN.isBN = function isBN (num) {
	    if (num instanceof BN) {
	      return true;
	    }

	    return num !== null && typeof num === 'object' &&
	      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
	  };

	  BN.max = function max (left, right) {
	    if (left.cmp(right) > 0) return left;
	    return right;
	  };

	  BN.min = function min (left, right) {
	    if (left.cmp(right) < 0) return left;
	    return right;
	  };

	  BN.prototype._init = function init (number, base, endian) {
	    if (typeof number === 'number') {
	      return this._initNumber(number, base, endian);
	    }

	    if (typeof number === 'object') {
	      return this._initArray(number, base, endian);
	    }

	    if (base === 'hex') {
	      base = 16;
	    }
	    assert(base === (base | 0) && base >= 2 && base <= 36);

	    number = number.toString().replace(/\s+/g, '');
	    var start = 0;
	    if (number[0] === '-') {
	      start++;
	      this.negative = 1;
	    }

	    if (start < number.length) {
	      if (base === 16) {
	        this._parseHex(number, start, endian);
	      } else {
	        this._parseBase(number, base, start);
	        if (endian === 'le') {
	          this._initArray(this.toArray(), base, endian);
	        }
	      }
	    }
	  };

	  BN.prototype._initNumber = function _initNumber (number, base, endian) {
	    if (number < 0) {
	      this.negative = 1;
	      number = -number;
	    }
	    if (number < 0x4000000) {
	      this.words = [ number & 0x3ffffff ];
	      this.length = 1;
	    } else if (number < 0x10000000000000) {
	      this.words = [
	        number & 0x3ffffff,
	        (number / 0x4000000) & 0x3ffffff
	      ];
	      this.length = 2;
	    } else {
	      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
	      this.words = [
	        number & 0x3ffffff,
	        (number / 0x4000000) & 0x3ffffff,
	        1
	      ];
	      this.length = 3;
	    }

	    if (endian !== 'le') return;

	    // Reverse the bytes
	    this._initArray(this.toArray(), base, endian);
	  };

	  BN.prototype._initArray = function _initArray (number, base, endian) {
	    // Perhaps a Uint8Array
	    assert(typeof number.length === 'number');
	    if (number.length <= 0) {
	      this.words = [ 0 ];
	      this.length = 1;
	      return this;
	    }

	    this.length = Math.ceil(number.length / 3);
	    this.words = new Array(this.length);
	    for (var i = 0; i < this.length; i++) {
	      this.words[i] = 0;
	    }

	    var j, w;
	    var off = 0;
	    if (endian === 'be') {
	      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
	        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
	        this.words[j] |= (w << off) & 0x3ffffff;
	        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
	        off += 24;
	        if (off >= 26) {
	          off -= 26;
	          j++;
	        }
	      }
	    } else if (endian === 'le') {
	      for (i = 0, j = 0; i < number.length; i += 3) {
	        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
	        this.words[j] |= (w << off) & 0x3ffffff;
	        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
	        off += 24;
	        if (off >= 26) {
	          off -= 26;
	          j++;
	        }
	      }
	    }
	    return this.strip();
	  };

	  function parseHex4Bits (string, index) {
	    var c = string.charCodeAt(index);
	    // 'A' - 'F'
	    if (c >= 65 && c <= 70) {
	      return c - 55;
	    // 'a' - 'f'
	    } else if (c >= 97 && c <= 102) {
	      return c - 87;
	    // '0' - '9'
	    } else {
	      return (c - 48) & 0xf;
	    }
	  }

	  function parseHexByte (string, lowerBound, index) {
	    var r = parseHex4Bits(string, index);
	    if (index - 1 >= lowerBound) {
	      r |= parseHex4Bits(string, index - 1) << 4;
	    }
	    return r;
	  }

	  BN.prototype._parseHex = function _parseHex (number, start, endian) {
	    // Create possibly bigger array to ensure that it fits the number
	    this.length = Math.ceil((number.length - start) / 6);
	    this.words = new Array(this.length);
	    for (var i = 0; i < this.length; i++) {
	      this.words[i] = 0;
	    }

	    // 24-bits chunks
	    var off = 0;
	    var j = 0;

	    var w;
	    if (endian === 'be') {
	      for (i = number.length - 1; i >= start; i -= 2) {
	        w = parseHexByte(number, start, i) << off;
	        this.words[j] |= w & 0x3ffffff;
	        if (off >= 18) {
	          off -= 18;
	          j += 1;
	          this.words[j] |= w >>> 26;
	        } else {
	          off += 8;
	        }
	      }
	    } else {
	      var parseLength = number.length - start;
	      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
	        w = parseHexByte(number, start, i) << off;
	        this.words[j] |= w & 0x3ffffff;
	        if (off >= 18) {
	          off -= 18;
	          j += 1;
	          this.words[j] |= w >>> 26;
	        } else {
	          off += 8;
	        }
	      }
	    }

	    this.strip();
	  };

	  function parseBase (str, start, end, mul) {
	    var r = 0;
	    var len = Math.min(str.length, end);
	    for (var i = start; i < len; i++) {
	      var c = str.charCodeAt(i) - 48;

	      r *= mul;

	      // 'a'
	      if (c >= 49) {
	        r += c - 49 + 0xa;

	      // 'A'
	      } else if (c >= 17) {
	        r += c - 17 + 0xa;

	      // '0' - '9'
	      } else {
	        r += c;
	      }
	    }
	    return r;
	  }

	  BN.prototype._parseBase = function _parseBase (number, base, start) {
	    // Initialize as zero
	    this.words = [ 0 ];
	    this.length = 1;

	    // Find length of limb in base
	    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
	      limbLen++;
	    }
	    limbLen--;
	    limbPow = (limbPow / base) | 0;

	    var total = number.length - start;
	    var mod = total % limbLen;
	    var end = Math.min(total, total - mod) + start;

	    var word = 0;
	    for (var i = start; i < end; i += limbLen) {
	      word = parseBase(number, i, i + limbLen, base);

	      this.imuln(limbPow);
	      if (this.words[0] + word < 0x4000000) {
	        this.words[0] += word;
	      } else {
	        this._iaddn(word);
	      }
	    }

	    if (mod !== 0) {
	      var pow = 1;
	      word = parseBase(number, i, number.length, base);

	      for (i = 0; i < mod; i++) {
	        pow *= base;
	      }

	      this.imuln(pow);
	      if (this.words[0] + word < 0x4000000) {
	        this.words[0] += word;
	      } else {
	        this._iaddn(word);
	      }
	    }

	    this.strip();
	  };

	  BN.prototype.copy = function copy (dest) {
	    dest.words = new Array(this.length);
	    for (var i = 0; i < this.length; i++) {
	      dest.words[i] = this.words[i];
	    }
	    dest.length = this.length;
	    dest.negative = this.negative;
	    dest.red = this.red;
	  };

	  BN.prototype.clone = function clone () {
	    var r = new BN(null);
	    this.copy(r);
	    return r;
	  };

	  BN.prototype._expand = function _expand (size) {
	    while (this.length < size) {
	      this.words[this.length++] = 0;
	    }
	    return this;
	  };

	  // Remove leading `0` from `this`
	  BN.prototype.strip = function strip () {
	    while (this.length > 1 && this.words[this.length - 1] === 0) {
	      this.length--;
	    }
	    return this._normSign();
	  };

	  BN.prototype._normSign = function _normSign () {
	    // -0 = 0
	    if (this.length === 1 && this.words[0] === 0) {
	      this.negative = 0;
	    }
	    return this;
	  };

	  BN.prototype.inspect = function inspect () {
	    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
	  };

	  /*

	  var zeros = [];
	  var groupSizes = [];
	  var groupBases = [];

	  var s = '';
	  var i = -1;
	  while (++i < BN.wordSize) {
	    zeros[i] = s;
	    s += '0';
	  }
	  groupSizes[0] = 0;
	  groupSizes[1] = 0;
	  groupBases[0] = 0;
	  groupBases[1] = 0;
	  var base = 2 - 1;
	  while (++base < 36 + 1) {
	    var groupSize = 0;
	    var groupBase = 1;
	    while (groupBase < (1 << BN.wordSize) / base) {
	      groupBase *= base;
	      groupSize += 1;
	    }
	    groupSizes[base] = groupSize;
	    groupBases[base] = groupBase;
	  }

	  */

	  var zeros = [
	    '',
	    '0',
	    '00',
	    '000',
	    '0000',
	    '00000',
	    '000000',
	    '0000000',
	    '00000000',
	    '000000000',
	    '0000000000',
	    '00000000000',
	    '000000000000',
	    '0000000000000',
	    '00000000000000',
	    '000000000000000',
	    '0000000000000000',
	    '00000000000000000',
	    '000000000000000000',
	    '0000000000000000000',
	    '00000000000000000000',
	    '000000000000000000000',
	    '0000000000000000000000',
	    '00000000000000000000000',
	    '000000000000000000000000',
	    '0000000000000000000000000'
	  ];

	  var groupSizes = [
	    0, 0,
	    25, 16, 12, 11, 10, 9, 8,
	    8, 7, 7, 7, 7, 6, 6,
	    6, 6, 6, 6, 6, 5, 5,
	    5, 5, 5, 5, 5, 5, 5,
	    5, 5, 5, 5, 5, 5, 5
	  ];

	  var groupBases = [
	    0, 0,
	    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
	    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
	    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
	    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
	    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
	  ];

	  BN.prototype.toString = function toString (base, padding) {
	    base = base || 10;
	    padding = padding | 0 || 1;

	    var out;
	    if (base === 16 || base === 'hex') {
	      out = '';
	      var off = 0;
	      var carry = 0;
	      for (var i = 0; i < this.length; i++) {
	        var w = this.words[i];
	        var word = (((w << off) | carry) & 0xffffff).toString(16);
	        carry = (w >>> (24 - off)) & 0xffffff;
	        if (carry !== 0 || i !== this.length - 1) {
	          out = zeros[6 - word.length] + word + out;
	        } else {
	          out = word + out;
	        }
	        off += 2;
	        if (off >= 26) {
	          off -= 26;
	          i--;
	        }
	      }
	      if (carry !== 0) {
	        out = carry.toString(16) + out;
	      }
	      while (out.length % padding !== 0) {
	        out = '0' + out;
	      }
	      if (this.negative !== 0) {
	        out = '-' + out;
	      }
	      return out;
	    }

	    if (base === (base | 0) && base >= 2 && base <= 36) {
	      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
	      var groupSize = groupSizes[base];
	      // var groupBase = Math.pow(base, groupSize);
	      var groupBase = groupBases[base];
	      out = '';
	      var c = this.clone();
	      c.negative = 0;
	      while (!c.isZero()) {
	        var r = c.modn(groupBase).toString(base);
	        c = c.idivn(groupBase);

	        if (!c.isZero()) {
	          out = zeros[groupSize - r.length] + r + out;
	        } else {
	          out = r + out;
	        }
	      }
	      if (this.isZero()) {
	        out = '0' + out;
	      }
	      while (out.length % padding !== 0) {
	        out = '0' + out;
	      }
	      if (this.negative !== 0) {
	        out = '-' + out;
	      }
	      return out;
	    }

	    assert(false, 'Base should be between 2 and 36');
	  };

	  BN.prototype.toNumber = function toNumber () {
	    var ret = this.words[0];
	    if (this.length === 2) {
	      ret += this.words[1] * 0x4000000;
	    } else if (this.length === 3 && this.words[2] === 0x01) {
	      // NOTE: at this stage it is known that the top bit is set
	      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
	    } else if (this.length > 2) {
	      assert(false, 'Number can only safely store up to 53 bits');
	    }
	    return (this.negative !== 0) ? -ret : ret;
	  };

	  BN.prototype.toJSON = function toJSON () {
	    return this.toString(16);
	  };

	  BN.prototype.toBuffer = function toBuffer (endian, length) {
	    assert(typeof Buffer !== 'undefined');
	    return this.toArrayLike(Buffer, endian, length);
	  };

	  BN.prototype.toArray = function toArray (endian, length) {
	    return this.toArrayLike(Array, endian, length);
	  };

	  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
	    var byteLength = this.byteLength();
	    var reqLength = length || Math.max(1, byteLength);
	    assert(byteLength <= reqLength, 'byte array longer than desired length');
	    assert(reqLength > 0, 'Requested array length <= 0');

	    this.strip();
	    var littleEndian = endian === 'le';
	    var res = new ArrayType(reqLength);

	    var b, i;
	    var q = this.clone();
	    if (!littleEndian) {
	      // Assume big-endian
	      for (i = 0; i < reqLength - byteLength; i++) {
	        res[i] = 0;
	      }

	      for (i = 0; !q.isZero(); i++) {
	        b = q.andln(0xff);
	        q.iushrn(8);

	        res[reqLength - i - 1] = b;
	      }
	    } else {
	      for (i = 0; !q.isZero(); i++) {
	        b = q.andln(0xff);
	        q.iushrn(8);

	        res[i] = b;
	      }

	      for (; i < reqLength; i++) {
	        res[i] = 0;
	      }
	    }

	    return res;
	  };

	  if (Math.clz32) {
	    BN.prototype._countBits = function _countBits (w) {
	      return 32 - Math.clz32(w);
	    };
	  } else {
	    BN.prototype._countBits = function _countBits (w) {
	      var t = w;
	      var r = 0;
	      if (t >= 0x1000) {
	        r += 13;
	        t >>>= 13;
	      }
	      if (t >= 0x40) {
	        r += 7;
	        t >>>= 7;
	      }
	      if (t >= 0x8) {
	        r += 4;
	        t >>>= 4;
	      }
	      if (t >= 0x02) {
	        r += 2;
	        t >>>= 2;
	      }
	      return r + t;
	    };
	  }

	  BN.prototype._zeroBits = function _zeroBits (w) {
	    // Short-cut
	    if (w === 0) return 26;

	    var t = w;
	    var r = 0;
	    if ((t & 0x1fff) === 0) {
	      r += 13;
	      t >>>= 13;
	    }
	    if ((t & 0x7f) === 0) {
	      r += 7;
	      t >>>= 7;
	    }
	    if ((t & 0xf) === 0) {
	      r += 4;
	      t >>>= 4;
	    }
	    if ((t & 0x3) === 0) {
	      r += 2;
	      t >>>= 2;
	    }
	    if ((t & 0x1) === 0) {
	      r++;
	    }
	    return r;
	  };

	  // Return number of used bits in a BN
	  BN.prototype.bitLength = function bitLength () {
	    var w = this.words[this.length - 1];
	    var hi = this._countBits(w);
	    return (this.length - 1) * 26 + hi;
	  };

	  function toBitArray (num) {
	    var w = new Array(num.bitLength());

	    for (var bit = 0; bit < w.length; bit++) {
	      var off = (bit / 26) | 0;
	      var wbit = bit % 26;

	      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
	    }

	    return w;
	  }

	  // Number of trailing zero bits
	  BN.prototype.zeroBits = function zeroBits () {
	    if (this.isZero()) return 0;

	    var r = 0;
	    for (var i = 0; i < this.length; i++) {
	      var b = this._zeroBits(this.words[i]);
	      r += b;
	      if (b !== 26) break;
	    }
	    return r;
	  };

	  BN.prototype.byteLength = function byteLength () {
	    return Math.ceil(this.bitLength() / 8);
	  };

	  BN.prototype.toTwos = function toTwos (width) {
	    if (this.negative !== 0) {
	      return this.abs().inotn(width).iaddn(1);
	    }
	    return this.clone();
	  };

	  BN.prototype.fromTwos = function fromTwos (width) {
	    if (this.testn(width - 1)) {
	      return this.notn(width).iaddn(1).ineg();
	    }
	    return this.clone();
	  };

	  BN.prototype.isNeg = function isNeg () {
	    return this.negative !== 0;
	  };

	  // Return negative clone of `this`
	  BN.prototype.neg = function neg () {
	    return this.clone().ineg();
	  };

	  BN.prototype.ineg = function ineg () {
	    if (!this.isZero()) {
	      this.negative ^= 1;
	    }

	    return this;
	  };

	  // Or `num` with `this` in-place
	  BN.prototype.iuor = function iuor (num) {
	    while (this.length < num.length) {
	      this.words[this.length++] = 0;
	    }

	    for (var i = 0; i < num.length; i++) {
	      this.words[i] = this.words[i] | num.words[i];
	    }

	    return this.strip();
	  };

	  BN.prototype.ior = function ior (num) {
	    assert((this.negative | num.negative) === 0);
	    return this.iuor(num);
	  };

	  // Or `num` with `this`
	  BN.prototype.or = function or (num) {
	    if (this.length > num.length) return this.clone().ior(num);
	    return num.clone().ior(this);
	  };

	  BN.prototype.uor = function uor (num) {
	    if (this.length > num.length) return this.clone().iuor(num);
	    return num.clone().iuor(this);
	  };

	  // And `num` with `this` in-place
	  BN.prototype.iuand = function iuand (num) {
	    // b = min-length(num, this)
	    var b;
	    if (this.length > num.length) {
	      b = num;
	    } else {
	      b = this;
	    }

	    for (var i = 0; i < b.length; i++) {
	      this.words[i] = this.words[i] & num.words[i];
	    }

	    this.length = b.length;

	    return this.strip();
	  };

	  BN.prototype.iand = function iand (num) {
	    assert((this.negative | num.negative) === 0);
	    return this.iuand(num);
	  };

	  // And `num` with `this`
	  BN.prototype.and = function and (num) {
	    if (this.length > num.length) return this.clone().iand(num);
	    return num.clone().iand(this);
	  };

	  BN.prototype.uand = function uand (num) {
	    if (this.length > num.length) return this.clone().iuand(num);
	    return num.clone().iuand(this);
	  };

	  // Xor `num` with `this` in-place
	  BN.prototype.iuxor = function iuxor (num) {
	    // a.length > b.length
	    var a;
	    var b;
	    if (this.length > num.length) {
	      a = this;
	      b = num;
	    } else {
	      a = num;
	      b = this;
	    }

	    for (var i = 0; i < b.length; i++) {
	      this.words[i] = a.words[i] ^ b.words[i];
	    }

	    if (this !== a) {
	      for (; i < a.length; i++) {
	        this.words[i] = a.words[i];
	      }
	    }

	    this.length = a.length;

	    return this.strip();
	  };

	  BN.prototype.ixor = function ixor (num) {
	    assert((this.negative | num.negative) === 0);
	    return this.iuxor(num);
	  };

	  // Xor `num` with `this`
	  BN.prototype.xor = function xor (num) {
	    if (this.length > num.length) return this.clone().ixor(num);
	    return num.clone().ixor(this);
	  };

	  BN.prototype.uxor = function uxor (num) {
	    if (this.length > num.length) return this.clone().iuxor(num);
	    return num.clone().iuxor(this);
	  };

	  // Not ``this`` with ``width`` bitwidth
	  BN.prototype.inotn = function inotn (width) {
	    assert(typeof width === 'number' && width >= 0);

	    var bytesNeeded = Math.ceil(width / 26) | 0;
	    var bitsLeft = width % 26;

	    // Extend the buffer with leading zeroes
	    this._expand(bytesNeeded);

	    if (bitsLeft > 0) {
	      bytesNeeded--;
	    }

	    // Handle complete words
	    for (var i = 0; i < bytesNeeded; i++) {
	      this.words[i] = ~this.words[i] & 0x3ffffff;
	    }

	    // Handle the residue
	    if (bitsLeft > 0) {
	      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
	    }

	    // And remove leading zeroes
	    return this.strip();
	  };

	  BN.prototype.notn = function notn (width) {
	    return this.clone().inotn(width);
	  };

	  // Set `bit` of `this`
	  BN.prototype.setn = function setn (bit, val) {
	    assert(typeof bit === 'number' && bit >= 0);

	    var off = (bit / 26) | 0;
	    var wbit = bit % 26;

	    this._expand(off + 1);

	    if (val) {
	      this.words[off] = this.words[off] | (1 << wbit);
	    } else {
	      this.words[off] = this.words[off] & ~(1 << wbit);
	    }

	    return this.strip();
	  };

	  // Add `num` to `this` in-place
	  BN.prototype.iadd = function iadd (num) {
	    var r;

	    // negative + positive
	    if (this.negative !== 0 && num.negative === 0) {
	      this.negative = 0;
	      r = this.isub(num);
	      this.negative ^= 1;
	      return this._normSign();

	    // positive + negative
	    } else if (this.negative === 0 && num.negative !== 0) {
	      num.negative = 0;
	      r = this.isub(num);
	      num.negative = 1;
	      return r._normSign();
	    }

	    // a.length > b.length
	    var a, b;
	    if (this.length > num.length) {
	      a = this;
	      b = num;
	    } else {
	      a = num;
	      b = this;
	    }

	    var carry = 0;
	    for (var i = 0; i < b.length; i++) {
	      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
	      this.words[i] = r & 0x3ffffff;
	      carry = r >>> 26;
	    }
	    for (; carry !== 0 && i < a.length; i++) {
	      r = (a.words[i] | 0) + carry;
	      this.words[i] = r & 0x3ffffff;
	      carry = r >>> 26;
	    }

	    this.length = a.length;
	    if (carry !== 0) {
	      this.words[this.length] = carry;
	      this.length++;
	    // Copy the rest of the words
	    } else if (a !== this) {
	      for (; i < a.length; i++) {
	        this.words[i] = a.words[i];
	      }
	    }

	    return this;
	  };

	  // Add `num` to `this`
	  BN.prototype.add = function add (num) {
	    var res;
	    if (num.negative !== 0 && this.negative === 0) {
	      num.negative = 0;
	      res = this.sub(num);
	      num.negative ^= 1;
	      return res;
	    } else if (num.negative === 0 && this.negative !== 0) {
	      this.negative = 0;
	      res = num.sub(this);
	      this.negative = 1;
	      return res;
	    }

	    if (this.length > num.length) return this.clone().iadd(num);

	    return num.clone().iadd(this);
	  };

	  // Subtract `num` from `this` in-place
	  BN.prototype.isub = function isub (num) {
	    // this - (-num) = this + num
	    if (num.negative !== 0) {
	      num.negative = 0;
	      var r = this.iadd(num);
	      num.negative = 1;
	      return r._normSign();

	    // -this - num = -(this + num)
	    } else if (this.negative !== 0) {
	      this.negative = 0;
	      this.iadd(num);
	      this.negative = 1;
	      return this._normSign();
	    }

	    // At this point both numbers are positive
	    var cmp = this.cmp(num);

	    // Optimization - zeroify
	    if (cmp === 0) {
	      this.negative = 0;
	      this.length = 1;
	      this.words[0] = 0;
	      return this;
	    }

	    // a > b
	    var a, b;
	    if (cmp > 0) {
	      a = this;
	      b = num;
	    } else {
	      a = num;
	      b = this;
	    }

	    var carry = 0;
	    for (var i = 0; i < b.length; i++) {
	      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
	      carry = r >> 26;
	      this.words[i] = r & 0x3ffffff;
	    }
	    for (; carry !== 0 && i < a.length; i++) {
	      r = (a.words[i] | 0) + carry;
	      carry = r >> 26;
	      this.words[i] = r & 0x3ffffff;
	    }

	    // Copy rest of the words
	    if (carry === 0 && i < a.length && a !== this) {
	      for (; i < a.length; i++) {
	        this.words[i] = a.words[i];
	      }
	    }

	    this.length = Math.max(this.length, i);

	    if (a !== this) {
	      this.negative = 1;
	    }

	    return this.strip();
	  };

	  // Subtract `num` from `this`
	  BN.prototype.sub = function sub (num) {
	    return this.clone().isub(num);
	  };

	  function smallMulTo (self, num, out) {
	    out.negative = num.negative ^ self.negative;
	    var len = (self.length + num.length) | 0;
	    out.length = len;
	    len = (len - 1) | 0;

	    // Peel one iteration (compiler can't do it, because of code complexity)
	    var a = self.words[0] | 0;
	    var b = num.words[0] | 0;
	    var r = a * b;

	    var lo = r & 0x3ffffff;
	    var carry = (r / 0x4000000) | 0;
	    out.words[0] = lo;

	    for (var k = 1; k < len; k++) {
	      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
	      // note that ncarry could be >= 0x3ffffff
	      var ncarry = carry >>> 26;
	      var rword = carry & 0x3ffffff;
	      var maxJ = Math.min(k, num.length - 1);
	      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
	        var i = (k - j) | 0;
	        a = self.words[i] | 0;
	        b = num.words[j] | 0;
	        r = a * b + rword;
	        ncarry += (r / 0x4000000) | 0;
	        rword = r & 0x3ffffff;
	      }
	      out.words[k] = rword | 0;
	      carry = ncarry | 0;
	    }
	    if (carry !== 0) {
	      out.words[k] = carry | 0;
	    } else {
	      out.length--;
	    }

	    return out.strip();
	  }

	  // TODO(indutny): it may be reasonable to omit it for users who don't need
	  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
	  // multiplication (like elliptic secp256k1).
	  var comb10MulTo = function comb10MulTo (self, num, out) {
	    var a = self.words;
	    var b = num.words;
	    var o = out.words;
	    var c = 0;
	    var lo;
	    var mid;
	    var hi;
	    var a0 = a[0] | 0;
	    var al0 = a0 & 0x1fff;
	    var ah0 = a0 >>> 13;
	    var a1 = a[1] | 0;
	    var al1 = a1 & 0x1fff;
	    var ah1 = a1 >>> 13;
	    var a2 = a[2] | 0;
	    var al2 = a2 & 0x1fff;
	    var ah2 = a2 >>> 13;
	    var a3 = a[3] | 0;
	    var al3 = a3 & 0x1fff;
	    var ah3 = a3 >>> 13;
	    var a4 = a[4] | 0;
	    var al4 = a4 & 0x1fff;
	    var ah4 = a4 >>> 13;
	    var a5 = a[5] | 0;
	    var al5 = a5 & 0x1fff;
	    var ah5 = a5 >>> 13;
	    var a6 = a[6] | 0;
	    var al6 = a6 & 0x1fff;
	    var ah6 = a6 >>> 13;
	    var a7 = a[7] | 0;
	    var al7 = a7 & 0x1fff;
	    var ah7 = a7 >>> 13;
	    var a8 = a[8] | 0;
	    var al8 = a8 & 0x1fff;
	    var ah8 = a8 >>> 13;
	    var a9 = a[9] | 0;
	    var al9 = a9 & 0x1fff;
	    var ah9 = a9 >>> 13;
	    var b0 = b[0] | 0;
	    var bl0 = b0 & 0x1fff;
	    var bh0 = b0 >>> 13;
	    var b1 = b[1] | 0;
	    var bl1 = b1 & 0x1fff;
	    var bh1 = b1 >>> 13;
	    var b2 = b[2] | 0;
	    var bl2 = b2 & 0x1fff;
	    var bh2 = b2 >>> 13;
	    var b3 = b[3] | 0;
	    var bl3 = b3 & 0x1fff;
	    var bh3 = b3 >>> 13;
	    var b4 = b[4] | 0;
	    var bl4 = b4 & 0x1fff;
	    var bh4 = b4 >>> 13;
	    var b5 = b[5] | 0;
	    var bl5 = b5 & 0x1fff;
	    var bh5 = b5 >>> 13;
	    var b6 = b[6] | 0;
	    var bl6 = b6 & 0x1fff;
	    var bh6 = b6 >>> 13;
	    var b7 = b[7] | 0;
	    var bl7 = b7 & 0x1fff;
	    var bh7 = b7 >>> 13;
	    var b8 = b[8] | 0;
	    var bl8 = b8 & 0x1fff;
	    var bh8 = b8 >>> 13;
	    var b9 = b[9] | 0;
	    var bl9 = b9 & 0x1fff;
	    var bh9 = b9 >>> 13;

	    out.negative = self.negative ^ num.negative;
	    out.length = 19;
	    /* k = 0 */
	    lo = Math.imul(al0, bl0);
	    mid = Math.imul(al0, bh0);
	    mid = (mid + Math.imul(ah0, bl0)) | 0;
	    hi = Math.imul(ah0, bh0);
	    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
	    w0 &= 0x3ffffff;
	    /* k = 1 */
	    lo = Math.imul(al1, bl0);
	    mid = Math.imul(al1, bh0);
	    mid = (mid + Math.imul(ah1, bl0)) | 0;
	    hi = Math.imul(ah1, bh0);
	    lo = (lo + Math.imul(al0, bl1)) | 0;
	    mid = (mid + Math.imul(al0, bh1)) | 0;
	    mid = (mid + Math.imul(ah0, bl1)) | 0;
	    hi = (hi + Math.imul(ah0, bh1)) | 0;
	    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
	    w1 &= 0x3ffffff;
	    /* k = 2 */
	    lo = Math.imul(al2, bl0);
	    mid = Math.imul(al2, bh0);
	    mid = (mid + Math.imul(ah2, bl0)) | 0;
	    hi = Math.imul(ah2, bh0);
	    lo = (lo + Math.imul(al1, bl1)) | 0;
	    mid = (mid + Math.imul(al1, bh1)) | 0;
	    mid = (mid + Math.imul(ah1, bl1)) | 0;
	    hi = (hi + Math.imul(ah1, bh1)) | 0;
	    lo = (lo + Math.imul(al0, bl2)) | 0;
	    mid = (mid + Math.imul(al0, bh2)) | 0;
	    mid = (mid + Math.imul(ah0, bl2)) | 0;
	    hi = (hi + Math.imul(ah0, bh2)) | 0;
	    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
	    w2 &= 0x3ffffff;
	    /* k = 3 */
	    lo = Math.imul(al3, bl0);
	    mid = Math.imul(al3, bh0);
	    mid = (mid + Math.imul(ah3, bl0)) | 0;
	    hi = Math.imul(ah3, bh0);
	    lo = (lo + Math.imul(al2, bl1)) | 0;
	    mid = (mid + Math.imul(al2, bh1)) | 0;
	    mid = (mid + Math.imul(ah2, bl1)) | 0;
	    hi = (hi + Math.imul(ah2, bh1)) | 0;
	    lo = (lo + Math.imul(al1, bl2)) | 0;
	    mid = (mid + Math.imul(al1, bh2)) | 0;
	    mid = (mid + Math.imul(ah1, bl2)) | 0;
	    hi = (hi + Math.imul(ah1, bh2)) | 0;
	    lo = (lo + Math.imul(al0, bl3)) | 0;
	    mid = (mid + Math.imul(al0, bh3)) | 0;
	    mid = (mid + Math.imul(ah0, bl3)) | 0;
	    hi = (hi + Math.imul(ah0, bh3)) | 0;
	    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
	    w3 &= 0x3ffffff;
	    /* k = 4 */
	    lo = Math.imul(al4, bl0);
	    mid = Math.imul(al4, bh0);
	    mid = (mid + Math.imul(ah4, bl0)) | 0;
	    hi = Math.imul(ah4, bh0);
	    lo = (lo + Math.imul(al3, bl1)) | 0;
	    mid = (mid + Math.imul(al3, bh1)) | 0;
	    mid = (mid + Math.imul(ah3, bl1)) | 0;
	    hi = (hi + Math.imul(ah3, bh1)) | 0;
	    lo = (lo + Math.imul(al2, bl2)) | 0;
	    mid = (mid + Math.imul(al2, bh2)) | 0;
	    mid = (mid + Math.imul(ah2, bl2)) | 0;
	    hi = (hi + Math.imul(ah2, bh2)) | 0;
	    lo = (lo + Math.imul(al1, bl3)) | 0;
	    mid = (mid + Math.imul(al1, bh3)) | 0;
	    mid = (mid + Math.imul(ah1, bl3)) | 0;
	    hi = (hi + Math.imul(ah1, bh3)) | 0;
	    lo = (lo + Math.imul(al0, bl4)) | 0;
	    mid = (mid + Math.imul(al0, bh4)) | 0;
	    mid = (mid + Math.imul(ah0, bl4)) | 0;
	    hi = (hi + Math.imul(ah0, bh4)) | 0;
	    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
	    w4 &= 0x3ffffff;
	    /* k = 5 */
	    lo = Math.imul(al5, bl0);
	    mid = Math.imul(al5, bh0);
	    mid = (mid + Math.imul(ah5, bl0)) | 0;
	    hi = Math.imul(ah5, bh0);
	    lo = (lo + Math.imul(al4, bl1)) | 0;
	    mid = (mid + Math.imul(al4, bh1)) | 0;
	    mid = (mid + Math.imul(ah4, bl1)) | 0;
	    hi = (hi + Math.imul(ah4, bh1)) | 0;
	    lo = (lo + Math.imul(al3, bl2)) | 0;
	    mid = (mid + Math.imul(al3, bh2)) | 0;
	    mid = (mid + Math.imul(ah3, bl2)) | 0;
	    hi = (hi + Math.imul(ah3, bh2)) | 0;
	    lo = (lo + Math.imul(al2, bl3)) | 0;
	    mid = (mid + Math.imul(al2, bh3)) | 0;
	    mid = (mid + Math.imul(ah2, bl3)) | 0;
	    hi = (hi + Math.imul(ah2, bh3)) | 0;
	    lo = (lo + Math.imul(al1, bl4)) | 0;
	    mid = (mid + Math.imul(al1, bh4)) | 0;
	    mid = (mid + Math.imul(ah1, bl4)) | 0;
	    hi = (hi + Math.imul(ah1, bh4)) | 0;
	    lo = (lo + Math.imul(al0, bl5)) | 0;
	    mid = (mid + Math.imul(al0, bh5)) | 0;
	    mid = (mid + Math.imul(ah0, bl5)) | 0;
	    hi = (hi + Math.imul(ah0, bh5)) | 0;
	    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
	    w5 &= 0x3ffffff;
	    /* k = 6 */
	    lo = Math.imul(al6, bl0);
	    mid = Math.imul(al6, bh0);
	    mid = (mid + Math.imul(ah6, bl0)) | 0;
	    hi = Math.imul(ah6, bh0);
	    lo = (lo + Math.imul(al5, bl1)) | 0;
	    mid = (mid + Math.imul(al5, bh1)) | 0;
	    mid = (mid + Math.imul(ah5, bl1)) | 0;
	    hi = (hi + Math.imul(ah5, bh1)) | 0;
	    lo = (lo + Math.imul(al4, bl2)) | 0;
	    mid = (mid + Math.imul(al4, bh2)) | 0;
	    mid = (mid + Math.imul(ah4, bl2)) | 0;
	    hi = (hi + Math.imul(ah4, bh2)) | 0;
	    lo = (lo + Math.imul(al3, bl3)) | 0;
	    mid = (mid + Math.imul(al3, bh3)) | 0;
	    mid = (mid + Math.imul(ah3, bl3)) | 0;
	    hi = (hi + Math.imul(ah3, bh3)) | 0;
	    lo = (lo + Math.imul(al2, bl4)) | 0;
	    mid = (mid + Math.imul(al2, bh4)) | 0;
	    mid = (mid + Math.imul(ah2, bl4)) | 0;
	    hi = (hi + Math.imul(ah2, bh4)) | 0;
	    lo = (lo + Math.imul(al1, bl5)) | 0;
	    mid = (mid + Math.imul(al1, bh5)) | 0;
	    mid = (mid + Math.imul(ah1, bl5)) | 0;
	    hi = (hi + Math.imul(ah1, bh5)) | 0;
	    lo = (lo + Math.imul(al0, bl6)) | 0;
	    mid = (mid + Math.imul(al0, bh6)) | 0;
	    mid = (mid + Math.imul(ah0, bl6)) | 0;
	    hi = (hi + Math.imul(ah0, bh6)) | 0;
	    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
	    w6 &= 0x3ffffff;
	    /* k = 7 */
	    lo = Math.imul(al7, bl0);
	    mid = Math.imul(al7, bh0);
	    mid = (mid + Math.imul(ah7, bl0)) | 0;
	    hi = Math.imul(ah7, bh0);
	    lo = (lo + Math.imul(al6, bl1)) | 0;
	    mid = (mid + Math.imul(al6, bh1)) | 0;
	    mid = (mid + Math.imul(ah6, bl1)) | 0;
	    hi = (hi + Math.imul(ah6, bh1)) | 0;
	    lo = (lo + Math.imul(al5, bl2)) | 0;
	    mid = (mid + Math.imul(al5, bh2)) | 0;
	    mid = (mid + Math.imul(ah5, bl2)) | 0;
	    hi = (hi + Math.imul(ah5, bh2)) | 0;
	    lo = (lo + Math.imul(al4, bl3)) | 0;
	    mid = (mid + Math.imul(al4, bh3)) | 0;
	    mid = (mid + Math.imul(ah4, bl3)) | 0;
	    hi = (hi + Math.imul(ah4, bh3)) | 0;
	    lo = (lo + Math.imul(al3, bl4)) | 0;
	    mid = (mid + Math.imul(al3, bh4)) | 0;
	    mid = (mid + Math.imul(ah3, bl4)) | 0;
	    hi = (hi + Math.imul(ah3, bh4)) | 0;
	    lo = (lo + Math.imul(al2, bl5)) | 0;
	    mid = (mid + Math.imul(al2, bh5)) | 0;
	    mid = (mid + Math.imul(ah2, bl5)) | 0;
	    hi = (hi + Math.imul(ah2, bh5)) | 0;
	    lo = (lo + Math.imul(al1, bl6)) | 0;
	    mid = (mid + Math.imul(al1, bh6)) | 0;
	    mid = (mid + Math.imul(ah1, bl6)) | 0;
	    hi = (hi + Math.imul(ah1, bh6)) | 0;
	    lo = (lo + Math.imul(al0, bl7)) | 0;
	    mid = (mid + Math.imul(al0, bh7)) | 0;
	    mid = (mid + Math.imul(ah0, bl7)) | 0;
	    hi = (hi + Math.imul(ah0, bh7)) | 0;
	    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
	    w7 &= 0x3ffffff;
	    /* k = 8 */
	    lo = Math.imul(al8, bl0);
	    mid = Math.imul(al8, bh0);
	    mid = (mid + Math.imul(ah8, bl0)) | 0;
	    hi = Math.imul(ah8, bh0);
	    lo = (lo + Math.imul(al7, bl1)) | 0;
	    mid = (mid + Math.imul(al7, bh1)) | 0;
	    mid = (mid + Math.imul(ah7, bl1)) | 0;
	    hi = (hi + Math.imul(ah7, bh1)) | 0;
	    lo = (lo + Math.imul(al6, bl2)) | 0;
	    mid = (mid + Math.imul(al6, bh2)) | 0;
	    mid = (mid + Math.imul(ah6, bl2)) | 0;
	    hi = (hi + Math.imul(ah6, bh2)) | 0;
	    lo = (lo + Math.imul(al5, bl3)) | 0;
	    mid = (mid + Math.imul(al5, bh3)) | 0;
	    mid = (mid + Math.imul(ah5, bl3)) | 0;
	    hi = (hi + Math.imul(ah5, bh3)) | 0;
	    lo = (lo + Math.imul(al4, bl4)) | 0;
	    mid = (mid + Math.imul(al4, bh4)) | 0;
	    mid = (mid + Math.imul(ah4, bl4)) | 0;
	    hi = (hi + Math.imul(ah4, bh4)) | 0;
	    lo = (lo + Math.imul(al3, bl5)) | 0;
	    mid = (mid + Math.imul(al3, bh5)) | 0;
	    mid = (mid + Math.imul(ah3, bl5)) | 0;
	    hi = (hi + Math.imul(ah3, bh5)) | 0;
	    lo = (lo + Math.imul(al2, bl6)) | 0;
	    mid = (mid + Math.imul(al2, bh6)) | 0;
	    mid = (mid + Math.imul(ah2, bl6)) | 0;
	    hi = (hi + Math.imul(ah2, bh6)) | 0;
	    lo = (lo + Math.imul(al1, bl7)) | 0;
	    mid = (mid + Math.imul(al1, bh7)) | 0;
	    mid = (mid + Math.imul(ah1, bl7)) | 0;
	    hi = (hi + Math.imul(ah1, bh7)) | 0;
	    lo = (lo + Math.imul(al0, bl8)) | 0;
	    mid = (mid + Math.imul(al0, bh8)) | 0;
	    mid = (mid + Math.imul(ah0, bl8)) | 0;
	    hi = (hi + Math.imul(ah0, bh8)) | 0;
	    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
	    w8 &= 0x3ffffff;
	    /* k = 9 */
	    lo = Math.imul(al9, bl0);
	    mid = Math.imul(al9, bh0);
	    mid = (mid + Math.imul(ah9, bl0)) | 0;
	    hi = Math.imul(ah9, bh0);
	    lo = (lo + Math.imul(al8, bl1)) | 0;
	    mid = (mid + Math.imul(al8, bh1)) | 0;
	    mid = (mid + Math.imul(ah8, bl1)) | 0;
	    hi = (hi + Math.imul(ah8, bh1)) | 0;
	    lo = (lo + Math.imul(al7, bl2)) | 0;
	    mid = (mid + Math.imul(al7, bh2)) | 0;
	    mid = (mid + Math.imul(ah7, bl2)) | 0;
	    hi = (hi + Math.imul(ah7, bh2)) | 0;
	    lo = (lo + Math.imul(al6, bl3)) | 0;
	    mid = (mid + Math.imul(al6, bh3)) | 0;
	    mid = (mid + Math.imul(ah6, bl3)) | 0;
	    hi = (hi + Math.imul(ah6, bh3)) | 0;
	    lo = (lo + Math.imul(al5, bl4)) | 0;
	    mid = (mid + Math.imul(al5, bh4)) | 0;
	    mid = (mid + Math.imul(ah5, bl4)) | 0;
	    hi = (hi + Math.imul(ah5, bh4)) | 0;
	    lo = (lo + Math.imul(al4, bl5)) | 0;
	    mid = (mid + Math.imul(al4, bh5)) | 0;
	    mid = (mid + Math.imul(ah4, bl5)) | 0;
	    hi = (hi + Math.imul(ah4, bh5)) | 0;
	    lo = (lo + Math.imul(al3, bl6)) | 0;
	    mid = (mid + Math.imul(al3, bh6)) | 0;
	    mid = (mid + Math.imul(ah3, bl6)) | 0;
	    hi = (hi + Math.imul(ah3, bh6)) | 0;
	    lo = (lo + Math.imul(al2, bl7)) | 0;
	    mid = (mid + Math.imul(al2, bh7)) | 0;
	    mid = (mid + Math.imul(ah2, bl7)) | 0;
	    hi = (hi + Math.imul(ah2, bh7)) | 0;
	    lo = (lo + Math.imul(al1, bl8)) | 0;
	    mid = (mid + Math.imul(al1, bh8)) | 0;
	    mid = (mid + Math.imul(ah1, bl8)) | 0;
	    hi = (hi + Math.imul(ah1, bh8)) | 0;
	    lo = (lo + Math.imul(al0, bl9)) | 0;
	    mid = (mid + Math.imul(al0, bh9)) | 0;
	    mid = (mid + Math.imul(ah0, bl9)) | 0;
	    hi = (hi + Math.imul(ah0, bh9)) | 0;
	    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
	    w9 &= 0x3ffffff;
	    /* k = 10 */
	    lo = Math.imul(al9, bl1);
	    mid = Math.imul(al9, bh1);
	    mid = (mid + Math.imul(ah9, bl1)) | 0;
	    hi = Math.imul(ah9, bh1);
	    lo = (lo + Math.imul(al8, bl2)) | 0;
	    mid = (mid + Math.imul(al8, bh2)) | 0;
	    mid = (mid + Math.imul(ah8, bl2)) | 0;
	    hi = (hi + Math.imul(ah8, bh2)) | 0;
	    lo = (lo + Math.imul(al7, bl3)) | 0;
	    mid = (mid + Math.imul(al7, bh3)) | 0;
	    mid = (mid + Math.imul(ah7, bl3)) | 0;
	    hi = (hi + Math.imul(ah7, bh3)) | 0;
	    lo = (lo + Math.imul(al6, bl4)) | 0;
	    mid = (mid + Math.imul(al6, bh4)) | 0;
	    mid = (mid + Math.imul(ah6, bl4)) | 0;
	    hi = (hi + Math.imul(ah6, bh4)) | 0;
	    lo = (lo + Math.imul(al5, bl5)) | 0;
	    mid = (mid + Math.imul(al5, bh5)) | 0;
	    mid = (mid + Math.imul(ah5, bl5)) | 0;
	    hi = (hi + Math.imul(ah5, bh5)) | 0;
	    lo = (lo + Math.imul(al4, bl6)) | 0;
	    mid = (mid + Math.imul(al4, bh6)) | 0;
	    mid = (mid + Math.imul(ah4, bl6)) | 0;
	    hi = (hi + Math.imul(ah4, bh6)) | 0;
	    lo = (lo + Math.imul(al3, bl7)) | 0;
	    mid = (mid + Math.imul(al3, bh7)) | 0;
	    mid = (mid + Math.imul(ah3, bl7)) | 0;
	    hi = (hi + Math.imul(ah3, bh7)) | 0;
	    lo = (lo + Math.imul(al2, bl8)) | 0;
	    mid = (mid + Math.imul(al2, bh8)) | 0;
	    mid = (mid + Math.imul(ah2, bl8)) | 0;
	    hi = (hi + Math.imul(ah2, bh8)) | 0;
	    lo = (lo + Math.imul(al1, bl9)) | 0;
	    mid = (mid + Math.imul(al1, bh9)) | 0;
	    mid = (mid + Math.imul(ah1, bl9)) | 0;
	    hi = (hi + Math.imul(ah1, bh9)) | 0;
	    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
	    w10 &= 0x3ffffff;
	    /* k = 11 */
	    lo = Math.imul(al9, bl2);
	    mid = Math.imul(al9, bh2);
	    mid = (mid + Math.imul(ah9, bl2)) | 0;
	    hi = Math.imul(ah9, bh2);
	    lo = (lo + Math.imul(al8, bl3)) | 0;
	    mid = (mid + Math.imul(al8, bh3)) | 0;
	    mid = (mid + Math.imul(ah8, bl3)) | 0;
	    hi = (hi + Math.imul(ah8, bh3)) | 0;
	    lo = (lo + Math.imul(al7, bl4)) | 0;
	    mid = (mid + Math.imul(al7, bh4)) | 0;
	    mid = (mid + Math.imul(ah7, bl4)) | 0;
	    hi = (hi + Math.imul(ah7, bh4)) | 0;
	    lo = (lo + Math.imul(al6, bl5)) | 0;
	    mid = (mid + Math.imul(al6, bh5)) | 0;
	    mid = (mid + Math.imul(ah6, bl5)) | 0;
	    hi = (hi + Math.imul(ah6, bh5)) | 0;
	    lo = (lo + Math.imul(al5, bl6)) | 0;
	    mid = (mid + Math.imul(al5, bh6)) | 0;
	    mid = (mid + Math.imul(ah5, bl6)) | 0;
	    hi = (hi + Math.imul(ah5, bh6)) | 0;
	    lo = (lo + Math.imul(al4, bl7)) | 0;
	    mid = (mid + Math.imul(al4, bh7)) | 0;
	    mid = (mid + Math.imul(ah4, bl7)) | 0;
	    hi = (hi + Math.imul(ah4, bh7)) | 0;
	    lo = (lo + Math.imul(al3, bl8)) | 0;
	    mid = (mid + Math.imul(al3, bh8)) | 0;
	    mid = (mid + Math.imul(ah3, bl8)) | 0;
	    hi = (hi + Math.imul(ah3, bh8)) | 0;
	    lo = (lo + Math.imul(al2, bl9)) | 0;
	    mid = (mid + Math.imul(al2, bh9)) | 0;
	    mid = (mid + Math.imul(ah2, bl9)) | 0;
	    hi = (hi + Math.imul(ah2, bh9)) | 0;
	    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
	    w11 &= 0x3ffffff;
	    /* k = 12 */
	    lo = Math.imul(al9, bl3);
	    mid = Math.imul(al9, bh3);
	    mid = (mid + Math.imul(ah9, bl3)) | 0;
	    hi = Math.imul(ah9, bh3);
	    lo = (lo + Math.imul(al8, bl4)) | 0;
	    mid = (mid + Math.imul(al8, bh4)) | 0;
	    mid = (mid + Math.imul(ah8, bl4)) | 0;
	    hi = (hi + Math.imul(ah8, bh4)) | 0;
	    lo = (lo + Math.imul(al7, bl5)) | 0;
	    mid = (mid + Math.imul(al7, bh5)) | 0;
	    mid = (mid + Math.imul(ah7, bl5)) | 0;
	    hi = (hi + Math.imul(ah7, bh5)) | 0;
	    lo = (lo + Math.imul(al6, bl6)) | 0;
	    mid = (mid + Math.imul(al6, bh6)) | 0;
	    mid = (mid + Math.imul(ah6, bl6)) | 0;
	    hi = (hi + Math.imul(ah6, bh6)) | 0;
	    lo = (lo + Math.imul(al5, bl7)) | 0;
	    mid = (mid + Math.imul(al5, bh7)) | 0;
	    mid = (mid + Math.imul(ah5, bl7)) | 0;
	    hi = (hi + Math.imul(ah5, bh7)) | 0;
	    lo = (lo + Math.imul(al4, bl8)) | 0;
	    mid = (mid + Math.imul(al4, bh8)) | 0;
	    mid = (mid + Math.imul(ah4, bl8)) | 0;
	    hi = (hi + Math.imul(ah4, bh8)) | 0;
	    lo = (lo + Math.imul(al3, bl9)) | 0;
	    mid = (mid + Math.imul(al3, bh9)) | 0;
	    mid = (mid + Math.imul(ah3, bl9)) | 0;
	    hi = (hi + Math.imul(ah3, bh9)) | 0;
	    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
	    w12 &= 0x3ffffff;
	    /* k = 13 */
	    lo = Math.imul(al9, bl4);
	    mid = Math.imul(al9, bh4);
	    mid = (mid + Math.imul(ah9, bl4)) | 0;
	    hi = Math.imul(ah9, bh4);
	    lo = (lo + Math.imul(al8, bl5)) | 0;
	    mid = (mid + Math.imul(al8, bh5)) | 0;
	    mid = (mid + Math.imul(ah8, bl5)) | 0;
	    hi = (hi + Math.imul(ah8, bh5)) | 0;
	    lo = (lo + Math.imul(al7, bl6)) | 0;
	    mid = (mid + Math.imul(al7, bh6)) | 0;
	    mid = (mid + Math.imul(ah7, bl6)) | 0;
	    hi = (hi + Math.imul(ah7, bh6)) | 0;
	    lo = (lo + Math.imul(al6, bl7)) | 0;
	    mid = (mid + Math.imul(al6, bh7)) | 0;
	    mid = (mid + Math.imul(ah6, bl7)) | 0;
	    hi = (hi + Math.imul(ah6, bh7)) | 0;
	    lo = (lo + Math.imul(al5, bl8)) | 0;
	    mid = (mid + Math.imul(al5, bh8)) | 0;
	    mid = (mid + Math.imul(ah5, bl8)) | 0;
	    hi = (hi + Math.imul(ah5, bh8)) | 0;
	    lo = (lo + Math.imul(al4, bl9)) | 0;
	    mid = (mid + Math.imul(al4, bh9)) | 0;
	    mid = (mid + Math.imul(ah4, bl9)) | 0;
	    hi = (hi + Math.imul(ah4, bh9)) | 0;
	    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
	    w13 &= 0x3ffffff;
	    /* k = 14 */
	    lo = Math.imul(al9, bl5);
	    mid = Math.imul(al9, bh5);
	    mid = (mid + Math.imul(ah9, bl5)) | 0;
	    hi = Math.imul(ah9, bh5);
	    lo = (lo + Math.imul(al8, bl6)) | 0;
	    mid = (mid + Math.imul(al8, bh6)) | 0;
	    mid = (mid + Math.imul(ah8, bl6)) | 0;
	    hi = (hi + Math.imul(ah8, bh6)) | 0;
	    lo = (lo + Math.imul(al7, bl7)) | 0;
	    mid = (mid + Math.imul(al7, bh7)) | 0;
	    mid = (mid + Math.imul(ah7, bl7)) | 0;
	    hi = (hi + Math.imul(ah7, bh7)) | 0;
	    lo = (lo + Math.imul(al6, bl8)) | 0;
	    mid = (mid + Math.imul(al6, bh8)) | 0;
	    mid = (mid + Math.imul(ah6, bl8)) | 0;
	    hi = (hi + Math.imul(ah6, bh8)) | 0;
	    lo = (lo + Math.imul(al5, bl9)) | 0;
	    mid = (mid + Math.imul(al5, bh9)) | 0;
	    mid = (mid + Math.imul(ah5, bl9)) | 0;
	    hi = (hi + Math.imul(ah5, bh9)) | 0;
	    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
	    w14 &= 0x3ffffff;
	    /* k = 15 */
	    lo = Math.imul(al9, bl6);
	    mid = Math.imul(al9, bh6);
	    mid = (mid + Math.imul(ah9, bl6)) | 0;
	    hi = Math.imul(ah9, bh6);
	    lo = (lo + Math.imul(al8, bl7)) | 0;
	    mid = (mid + Math.imul(al8, bh7)) | 0;
	    mid = (mid + Math.imul(ah8, bl7)) | 0;
	    hi = (hi + Math.imul(ah8, bh7)) | 0;
	    lo = (lo + Math.imul(al7, bl8)) | 0;
	    mid = (mid + Math.imul(al7, bh8)) | 0;
	    mid = (mid + Math.imul(ah7, bl8)) | 0;
	    hi = (hi + Math.imul(ah7, bh8)) | 0;
	    lo = (lo + Math.imul(al6, bl9)) | 0;
	    mid = (mid + Math.imul(al6, bh9)) | 0;
	    mid = (mid + Math.imul(ah6, bl9)) | 0;
	    hi = (hi + Math.imul(ah6, bh9)) | 0;
	    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
	    w15 &= 0x3ffffff;
	    /* k = 16 */
	    lo = Math.imul(al9, bl7);
	    mid = Math.imul(al9, bh7);
	    mid = (mid + Math.imul(ah9, bl7)) | 0;
	    hi = Math.imul(ah9, bh7);
	    lo = (lo + Math.imul(al8, bl8)) | 0;
	    mid = (mid + Math.imul(al8, bh8)) | 0;
	    mid = (mid + Math.imul(ah8, bl8)) | 0;
	    hi = (hi + Math.imul(ah8, bh8)) | 0;
	    lo = (lo + Math.imul(al7, bl9)) | 0;
	    mid = (mid + Math.imul(al7, bh9)) | 0;
	    mid = (mid + Math.imul(ah7, bl9)) | 0;
	    hi = (hi + Math.imul(ah7, bh9)) | 0;
	    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
	    w16 &= 0x3ffffff;
	    /* k = 17 */
	    lo = Math.imul(al9, bl8);
	    mid = Math.imul(al9, bh8);
	    mid = (mid + Math.imul(ah9, bl8)) | 0;
	    hi = Math.imul(ah9, bh8);
	    lo = (lo + Math.imul(al8, bl9)) | 0;
	    mid = (mid + Math.imul(al8, bh9)) | 0;
	    mid = (mid + Math.imul(ah8, bl9)) | 0;
	    hi = (hi + Math.imul(ah8, bh9)) | 0;
	    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
	    w17 &= 0x3ffffff;
	    /* k = 18 */
	    lo = Math.imul(al9, bl9);
	    mid = Math.imul(al9, bh9);
	    mid = (mid + Math.imul(ah9, bl9)) | 0;
	    hi = Math.imul(ah9, bh9);
	    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
	    w18 &= 0x3ffffff;
	    o[0] = w0;
	    o[1] = w1;
	    o[2] = w2;
	    o[3] = w3;
	    o[4] = w4;
	    o[5] = w5;
	    o[6] = w6;
	    o[7] = w7;
	    o[8] = w8;
	    o[9] = w9;
	    o[10] = w10;
	    o[11] = w11;
	    o[12] = w12;
	    o[13] = w13;
	    o[14] = w14;
	    o[15] = w15;
	    o[16] = w16;
	    o[17] = w17;
	    o[18] = w18;
	    if (c !== 0) {
	      o[19] = c;
	      out.length++;
	    }
	    return out;
	  };

	  // Polyfill comb
	  if (!Math.imul) {
	    comb10MulTo = smallMulTo;
	  }

	  function bigMulTo (self, num, out) {
	    out.negative = num.negative ^ self.negative;
	    out.length = self.length + num.length;

	    var carry = 0;
	    var hncarry = 0;
	    for (var k = 0; k < out.length - 1; k++) {
	      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
	      // note that ncarry could be >= 0x3ffffff
	      var ncarry = hncarry;
	      hncarry = 0;
	      var rword = carry & 0x3ffffff;
	      var maxJ = Math.min(k, num.length - 1);
	      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
	        var i = k - j;
	        var a = self.words[i] | 0;
	        var b = num.words[j] | 0;
	        var r = a * b;

	        var lo = r & 0x3ffffff;
	        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
	        lo = (lo + rword) | 0;
	        rword = lo & 0x3ffffff;
	        ncarry = (ncarry + (lo >>> 26)) | 0;

	        hncarry += ncarry >>> 26;
	        ncarry &= 0x3ffffff;
	      }
	      out.words[k] = rword;
	      carry = ncarry;
	      ncarry = hncarry;
	    }
	    if (carry !== 0) {
	      out.words[k] = carry;
	    } else {
	      out.length--;
	    }

	    return out.strip();
	  }

	  function jumboMulTo (self, num, out) {
	    var fftm = new FFTM();
	    return fftm.mulp(self, num, out);
	  }

	  BN.prototype.mulTo = function mulTo (num, out) {
	    var res;
	    var len = this.length + num.length;
	    if (this.length === 10 && num.length === 10) {
	      res = comb10MulTo(this, num, out);
	    } else if (len < 63) {
	      res = smallMulTo(this, num, out);
	    } else if (len < 1024) {
	      res = bigMulTo(this, num, out);
	    } else {
	      res = jumboMulTo(this, num, out);
	    }

	    return res;
	  };

	  // Cooley-Tukey algorithm for FFT
	  // slightly revisited to rely on looping instead of recursion

	  function FFTM (x, y) {
	    this.x = x;
	    this.y = y;
	  }

	  FFTM.prototype.makeRBT = function makeRBT (N) {
	    var t = new Array(N);
	    var l = BN.prototype._countBits(N) - 1;
	    for (var i = 0; i < N; i++) {
	      t[i] = this.revBin(i, l, N);
	    }

	    return t;
	  };

	  // Returns binary-reversed representation of `x`
	  FFTM.prototype.revBin = function revBin (x, l, N) {
	    if (x === 0 || x === N - 1) return x;

	    var rb = 0;
	    for (var i = 0; i < l; i++) {
	      rb |= (x & 1) << (l - i - 1);
	      x >>= 1;
	    }

	    return rb;
	  };

	  // Performs "tweedling" phase, therefore 'emulating'
	  // behaviour of the recursive algorithm
	  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
	    for (var i = 0; i < N; i++) {
	      rtws[i] = rws[rbt[i]];
	      itws[i] = iws[rbt[i]];
	    }
	  };

	  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
	    this.permute(rbt, rws, iws, rtws, itws, N);

	    for (var s = 1; s < N; s <<= 1) {
	      var l = s << 1;

	      var rtwdf = Math.cos(2 * Math.PI / l);
	      var itwdf = Math.sin(2 * Math.PI / l);

	      for (var p = 0; p < N; p += l) {
	        var rtwdf_ = rtwdf;
	        var itwdf_ = itwdf;

	        for (var j = 0; j < s; j++) {
	          var re = rtws[p + j];
	          var ie = itws[p + j];

	          var ro = rtws[p + j + s];
	          var io = itws[p + j + s];

	          var rx = rtwdf_ * ro - itwdf_ * io;

	          io = rtwdf_ * io + itwdf_ * ro;
	          ro = rx;

	          rtws[p + j] = re + ro;
	          itws[p + j] = ie + io;

	          rtws[p + j + s] = re - ro;
	          itws[p + j + s] = ie - io;

	          /* jshint maxdepth : false */
	          if (j !== l) {
	            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

	            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
	            rtwdf_ = rx;
	          }
	        }
	      }
	    }
	  };

	  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
	    var N = Math.max(m, n) | 1;
	    var odd = N & 1;
	    var i = 0;
	    for (N = N / 2 | 0; N; N = N >>> 1) {
	      i++;
	    }

	    return 1 << i + 1 + odd;
	  };

	  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
	    if (N <= 1) return;

	    for (var i = 0; i < N / 2; i++) {
	      var t = rws[i];

	      rws[i] = rws[N - i - 1];
	      rws[N - i - 1] = t;

	      t = iws[i];

	      iws[i] = -iws[N - i - 1];
	      iws[N - i - 1] = -t;
	    }
	  };

	  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
	    var carry = 0;
	    for (var i = 0; i < N / 2; i++) {
	      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
	        Math.round(ws[2 * i] / N) +
	        carry;

	      ws[i] = w & 0x3ffffff;

	      if (w < 0x4000000) {
	        carry = 0;
	      } else {
	        carry = w / 0x4000000 | 0;
	      }
	    }

	    return ws;
	  };

	  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
	    var carry = 0;
	    for (var i = 0; i < len; i++) {
	      carry = carry + (ws[i] | 0);

	      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
	      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
	    }

	    // Pad with zeroes
	    for (i = 2 * len; i < N; ++i) {
	      rws[i] = 0;
	    }

	    assert(carry === 0);
	    assert((carry & ~0x1fff) === 0);
	  };

	  FFTM.prototype.stub = function stub (N) {
	    var ph = new Array(N);
	    for (var i = 0; i < N; i++) {
	      ph[i] = 0;
	    }

	    return ph;
	  };

	  FFTM.prototype.mulp = function mulp (x, y, out) {
	    var N = 2 * this.guessLen13b(x.length, y.length);

	    var rbt = this.makeRBT(N);

	    var _ = this.stub(N);

	    var rws = new Array(N);
	    var rwst = new Array(N);
	    var iwst = new Array(N);

	    var nrws = new Array(N);
	    var nrwst = new Array(N);
	    var niwst = new Array(N);

	    var rmws = out.words;
	    rmws.length = N;

	    this.convert13b(x.words, x.length, rws, N);
	    this.convert13b(y.words, y.length, nrws, N);

	    this.transform(rws, _, rwst, iwst, N, rbt);
	    this.transform(nrws, _, nrwst, niwst, N, rbt);

	    for (var i = 0; i < N; i++) {
	      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
	      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
	      rwst[i] = rx;
	    }

	    this.conjugate(rwst, iwst, N);
	    this.transform(rwst, iwst, rmws, _, N, rbt);
	    this.conjugate(rmws, _, N);
	    this.normalize13b(rmws, N);

	    out.negative = x.negative ^ y.negative;
	    out.length = x.length + y.length;
	    return out.strip();
	  };

	  // Multiply `this` by `num`
	  BN.prototype.mul = function mul (num) {
	    var out = new BN(null);
	    out.words = new Array(this.length + num.length);
	    return this.mulTo(num, out);
	  };

	  // Multiply employing FFT
	  BN.prototype.mulf = function mulf (num) {
	    var out = new BN(null);
	    out.words = new Array(this.length + num.length);
	    return jumboMulTo(this, num, out);
	  };

	  // In-place Multiplication
	  BN.prototype.imul = function imul (num) {
	    return this.clone().mulTo(num, this);
	  };

	  BN.prototype.imuln = function imuln (num) {
	    assert(typeof num === 'number');
	    assert(num < 0x4000000);

	    // Carry
	    var carry = 0;
	    for (var i = 0; i < this.length; i++) {
	      var w = (this.words[i] | 0) * num;
	      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
	      carry >>= 26;
	      carry += (w / 0x4000000) | 0;
	      // NOTE: lo is 27bit maximum
	      carry += lo >>> 26;
	      this.words[i] = lo & 0x3ffffff;
	    }

	    if (carry !== 0) {
	      this.words[i] = carry;
	      this.length++;
	    }

	    return this;
	  };

	  BN.prototype.muln = function muln (num) {
	    return this.clone().imuln(num);
	  };

	  // `this` * `this`
	  BN.prototype.sqr = function sqr () {
	    return this.mul(this);
	  };

	  // `this` * `this` in-place
	  BN.prototype.isqr = function isqr () {
	    return this.imul(this.clone());
	  };

	  // Math.pow(`this`, `num`)
	  BN.prototype.pow = function pow (num) {
	    var w = toBitArray(num);
	    if (w.length === 0) return new BN(1);

	    // Skip leading zeroes
	    var res = this;
	    for (var i = 0; i < w.length; i++, res = res.sqr()) {
	      if (w[i] !== 0) break;
	    }

	    if (++i < w.length) {
	      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
	        if (w[i] === 0) continue;

	        res = res.mul(q);
	      }
	    }

	    return res;
	  };

	  // Shift-left in-place
	  BN.prototype.iushln = function iushln (bits) {
	    assert(typeof bits === 'number' && bits >= 0);
	    var r = bits % 26;
	    var s = (bits - r) / 26;
	    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
	    var i;

	    if (r !== 0) {
	      var carry = 0;

	      for (i = 0; i < this.length; i++) {
	        var newCarry = this.words[i] & carryMask;
	        var c = ((this.words[i] | 0) - newCarry) << r;
	        this.words[i] = c | carry;
	        carry = newCarry >>> (26 - r);
	      }

	      if (carry) {
	        this.words[i] = carry;
	        this.length++;
	      }
	    }

	    if (s !== 0) {
	      for (i = this.length - 1; i >= 0; i--) {
	        this.words[i + s] = this.words[i];
	      }

	      for (i = 0; i < s; i++) {
	        this.words[i] = 0;
	      }

	      this.length += s;
	    }

	    return this.strip();
	  };

	  BN.prototype.ishln = function ishln (bits) {
	    // TODO(indutny): implement me
	    assert(this.negative === 0);
	    return this.iushln(bits);
	  };

	  // Shift-right in-place
	  // NOTE: `hint` is a lowest bit before trailing zeroes
	  // NOTE: if `extended` is present - it will be filled with destroyed bits
	  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
	    assert(typeof bits === 'number' && bits >= 0);
	    var h;
	    if (hint) {
	      h = (hint - (hint % 26)) / 26;
	    } else {
	      h = 0;
	    }

	    var r = bits % 26;
	    var s = Math.min((bits - r) / 26, this.length);
	    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
	    var maskedWords = extended;

	    h -= s;
	    h = Math.max(0, h);

	    // Extended mode, copy masked part
	    if (maskedWords) {
	      for (var i = 0; i < s; i++) {
	        maskedWords.words[i] = this.words[i];
	      }
	      maskedWords.length = s;
	    }

	    if (s === 0) ; else if (this.length > s) {
	      this.length -= s;
	      for (i = 0; i < this.length; i++) {
	        this.words[i] = this.words[i + s];
	      }
	    } else {
	      this.words[0] = 0;
	      this.length = 1;
	    }

	    var carry = 0;
	    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
	      var word = this.words[i] | 0;
	      this.words[i] = (carry << (26 - r)) | (word >>> r);
	      carry = word & mask;
	    }

	    // Push carried bits as a mask
	    if (maskedWords && carry !== 0) {
	      maskedWords.words[maskedWords.length++] = carry;
	    }

	    if (this.length === 0) {
	      this.words[0] = 0;
	      this.length = 1;
	    }

	    return this.strip();
	  };

	  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
	    // TODO(indutny): implement me
	    assert(this.negative === 0);
	    return this.iushrn(bits, hint, extended);
	  };

	  // Shift-left
	  BN.prototype.shln = function shln (bits) {
	    return this.clone().ishln(bits);
	  };

	  BN.prototype.ushln = function ushln (bits) {
	    return this.clone().iushln(bits);
	  };

	  // Shift-right
	  BN.prototype.shrn = function shrn (bits) {
	    return this.clone().ishrn(bits);
	  };

	  BN.prototype.ushrn = function ushrn (bits) {
	    return this.clone().iushrn(bits);
	  };

	  // Test if n bit is set
	  BN.prototype.testn = function testn (bit) {
	    assert(typeof bit === 'number' && bit >= 0);
	    var r = bit % 26;
	    var s = (bit - r) / 26;
	    var q = 1 << r;

	    // Fast case: bit is much higher than all existing words
	    if (this.length <= s) return false;

	    // Check bit and return
	    var w = this.words[s];

	    return !!(w & q);
	  };

	  // Return only lowers bits of number (in-place)
	  BN.prototype.imaskn = function imaskn (bits) {
	    assert(typeof bits === 'number' && bits >= 0);
	    var r = bits % 26;
	    var s = (bits - r) / 26;

	    assert(this.negative === 0, 'imaskn works only with positive numbers');

	    if (this.length <= s) {
	      return this;
	    }

	    if (r !== 0) {
	      s++;
	    }
	    this.length = Math.min(s, this.length);

	    if (r !== 0) {
	      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
	      this.words[this.length - 1] &= mask;
	    }

	    return this.strip();
	  };

	  // Return only lowers bits of number
	  BN.prototype.maskn = function maskn (bits) {
	    return this.clone().imaskn(bits);
	  };

	  // Add plain number `num` to `this`
	  BN.prototype.iaddn = function iaddn (num) {
	    assert(typeof num === 'number');
	    assert(num < 0x4000000);
	    if (num < 0) return this.isubn(-num);

	    // Possible sign change
	    if (this.negative !== 0) {
	      if (this.length === 1 && (this.words[0] | 0) < num) {
	        this.words[0] = num - (this.words[0] | 0);
	        this.negative = 0;
	        return this;
	      }

	      this.negative = 0;
	      this.isubn(num);
	      this.negative = 1;
	      return this;
	    }

	    // Add without checks
	    return this._iaddn(num);
	  };

	  BN.prototype._iaddn = function _iaddn (num) {
	    this.words[0] += num;

	    // Carry
	    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
	      this.words[i] -= 0x4000000;
	      if (i === this.length - 1) {
	        this.words[i + 1] = 1;
	      } else {
	        this.words[i + 1]++;
	      }
	    }
	    this.length = Math.max(this.length, i + 1);

	    return this;
	  };

	  // Subtract plain number `num` from `this`
	  BN.prototype.isubn = function isubn (num) {
	    assert(typeof num === 'number');
	    assert(num < 0x4000000);
	    if (num < 0) return this.iaddn(-num);

	    if (this.negative !== 0) {
	      this.negative = 0;
	      this.iaddn(num);
	      this.negative = 1;
	      return this;
	    }

	    this.words[0] -= num;

	    if (this.length === 1 && this.words[0] < 0) {
	      this.words[0] = -this.words[0];
	      this.negative = 1;
	    } else {
	      // Carry
	      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
	        this.words[i] += 0x4000000;
	        this.words[i + 1] -= 1;
	      }
	    }

	    return this.strip();
	  };

	  BN.prototype.addn = function addn (num) {
	    return this.clone().iaddn(num);
	  };

	  BN.prototype.subn = function subn (num) {
	    return this.clone().isubn(num);
	  };

	  BN.prototype.iabs = function iabs () {
	    this.negative = 0;

	    return this;
	  };

	  BN.prototype.abs = function abs () {
	    return this.clone().iabs();
	  };

	  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
	    var len = num.length + shift;
	    var i;

	    this._expand(len);

	    var w;
	    var carry = 0;
	    for (i = 0; i < num.length; i++) {
	      w = (this.words[i + shift] | 0) + carry;
	      var right = (num.words[i] | 0) * mul;
	      w -= right & 0x3ffffff;
	      carry = (w >> 26) - ((right / 0x4000000) | 0);
	      this.words[i + shift] = w & 0x3ffffff;
	    }
	    for (; i < this.length - shift; i++) {
	      w = (this.words[i + shift] | 0) + carry;
	      carry = w >> 26;
	      this.words[i + shift] = w & 0x3ffffff;
	    }

	    if (carry === 0) return this.strip();

	    // Subtraction overflow
	    assert(carry === -1);
	    carry = 0;
	    for (i = 0; i < this.length; i++) {
	      w = -(this.words[i] | 0) + carry;
	      carry = w >> 26;
	      this.words[i] = w & 0x3ffffff;
	    }
	    this.negative = 1;

	    return this.strip();
	  };

	  BN.prototype._wordDiv = function _wordDiv (num, mode) {
	    var shift = this.length - num.length;

	    var a = this.clone();
	    var b = num;

	    // Normalize
	    var bhi = b.words[b.length - 1] | 0;
	    var bhiBits = this._countBits(bhi);
	    shift = 26 - bhiBits;
	    if (shift !== 0) {
	      b = b.ushln(shift);
	      a.iushln(shift);
	      bhi = b.words[b.length - 1] | 0;
	    }

	    // Initialize quotient
	    var m = a.length - b.length;
	    var q;

	    if (mode !== 'mod') {
	      q = new BN(null);
	      q.length = m + 1;
	      q.words = new Array(q.length);
	      for (var i = 0; i < q.length; i++) {
	        q.words[i] = 0;
	      }
	    }

	    var diff = a.clone()._ishlnsubmul(b, 1, m);
	    if (diff.negative === 0) {
	      a = diff;
	      if (q) {
	        q.words[m] = 1;
	      }
	    }

	    for (var j = m - 1; j >= 0; j--) {
	      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
	        (a.words[b.length + j - 1] | 0);

	      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
	      // (0x7ffffff)
	      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

	      a._ishlnsubmul(b, qj, j);
	      while (a.negative !== 0) {
	        qj--;
	        a.negative = 0;
	        a._ishlnsubmul(b, 1, j);
	        if (!a.isZero()) {
	          a.negative ^= 1;
	        }
	      }
	      if (q) {
	        q.words[j] = qj;
	      }
	    }
	    if (q) {
	      q.strip();
	    }
	    a.strip();

	    // Denormalize
	    if (mode !== 'div' && shift !== 0) {
	      a.iushrn(shift);
	    }

	    return {
	      div: q || null,
	      mod: a
	    };
	  };

	  // NOTE: 1) `mode` can be set to `mod` to request mod only,
	  //       to `div` to request div only, or be absent to
	  //       request both div & mod
	  //       2) `positive` is true if unsigned mod is requested
	  BN.prototype.divmod = function divmod (num, mode, positive) {
	    assert(!num.isZero());

	    if (this.isZero()) {
	      return {
	        div: new BN(0),
	        mod: new BN(0)
	      };
	    }

	    var div, mod, res;
	    if (this.negative !== 0 && num.negative === 0) {
	      res = this.neg().divmod(num, mode);

	      if (mode !== 'mod') {
	        div = res.div.neg();
	      }

	      if (mode !== 'div') {
	        mod = res.mod.neg();
	        if (positive && mod.negative !== 0) {
	          mod.iadd(num);
	        }
	      }

	      return {
	        div: div,
	        mod: mod
	      };
	    }

	    if (this.negative === 0 && num.negative !== 0) {
	      res = this.divmod(num.neg(), mode);

	      if (mode !== 'mod') {
	        div = res.div.neg();
	      }

	      return {
	        div: div,
	        mod: res.mod
	      };
	    }

	    if ((this.negative & num.negative) !== 0) {
	      res = this.neg().divmod(num.neg(), mode);

	      if (mode !== 'div') {
	        mod = res.mod.neg();
	        if (positive && mod.negative !== 0) {
	          mod.isub(num);
	        }
	      }

	      return {
	        div: res.div,
	        mod: mod
	      };
	    }

	    // Both numbers are positive at this point

	    // Strip both numbers to approximate shift value
	    if (num.length > this.length || this.cmp(num) < 0) {
	      return {
	        div: new BN(0),
	        mod: this
	      };
	    }

	    // Very short reduction
	    if (num.length === 1) {
	      if (mode === 'div') {
	        return {
	          div: this.divn(num.words[0]),
	          mod: null
	        };
	      }

	      if (mode === 'mod') {
	        return {
	          div: null,
	          mod: new BN(this.modn(num.words[0]))
	        };
	      }

	      return {
	        div: this.divn(num.words[0]),
	        mod: new BN(this.modn(num.words[0]))
	      };
	    }

	    return this._wordDiv(num, mode);
	  };

	  // Find `this` / `num`
	  BN.prototype.div = function div (num) {
	    return this.divmod(num, 'div', false).div;
	  };

	  // Find `this` % `num`
	  BN.prototype.mod = function mod (num) {
	    return this.divmod(num, 'mod', false).mod;
	  };

	  BN.prototype.umod = function umod (num) {
	    return this.divmod(num, 'mod', true).mod;
	  };

	  // Find Round(`this` / `num`)
	  BN.prototype.divRound = function divRound (num) {
	    var dm = this.divmod(num);

	    // Fast case - exact division
	    if (dm.mod.isZero()) return dm.div;

	    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

	    var half = num.ushrn(1);
	    var r2 = num.andln(1);
	    var cmp = mod.cmp(half);

	    // Round down
	    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

	    // Round up
	    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
	  };

	  BN.prototype.modn = function modn (num) {
	    assert(num <= 0x3ffffff);
	    var p = (1 << 26) % num;

	    var acc = 0;
	    for (var i = this.length - 1; i >= 0; i--) {
	      acc = (p * acc + (this.words[i] | 0)) % num;
	    }

	    return acc;
	  };

	  // In-place division by number
	  BN.prototype.idivn = function idivn (num) {
	    assert(num <= 0x3ffffff);

	    var carry = 0;
	    for (var i = this.length - 1; i >= 0; i--) {
	      var w = (this.words[i] | 0) + carry * 0x4000000;
	      this.words[i] = (w / num) | 0;
	      carry = w % num;
	    }

	    return this.strip();
	  };

	  BN.prototype.divn = function divn (num) {
	    return this.clone().idivn(num);
	  };

	  BN.prototype.egcd = function egcd (p) {
	    assert(p.negative === 0);
	    assert(!p.isZero());

	    var x = this;
	    var y = p.clone();

	    if (x.negative !== 0) {
	      x = x.umod(p);
	    } else {
	      x = x.clone();
	    }

	    // A * x + B * y = x
	    var A = new BN(1);
	    var B = new BN(0);

	    // C * x + D * y = y
	    var C = new BN(0);
	    var D = new BN(1);

	    var g = 0;

	    while (x.isEven() && y.isEven()) {
	      x.iushrn(1);
	      y.iushrn(1);
	      ++g;
	    }

	    var yp = y.clone();
	    var xp = x.clone();

	    while (!x.isZero()) {
	      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
	      if (i > 0) {
	        x.iushrn(i);
	        while (i-- > 0) {
	          if (A.isOdd() || B.isOdd()) {
	            A.iadd(yp);
	            B.isub(xp);
	          }

	          A.iushrn(1);
	          B.iushrn(1);
	        }
	      }

	      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
	      if (j > 0) {
	        y.iushrn(j);
	        while (j-- > 0) {
	          if (C.isOdd() || D.isOdd()) {
	            C.iadd(yp);
	            D.isub(xp);
	          }

	          C.iushrn(1);
	          D.iushrn(1);
	        }
	      }

	      if (x.cmp(y) >= 0) {
	        x.isub(y);
	        A.isub(C);
	        B.isub(D);
	      } else {
	        y.isub(x);
	        C.isub(A);
	        D.isub(B);
	      }
	    }

	    return {
	      a: C,
	      b: D,
	      gcd: y.iushln(g)
	    };
	  };

	  // This is reduced incarnation of the binary EEA
	  // above, designated to invert members of the
	  // _prime_ fields F(p) at a maximal speed
	  BN.prototype._invmp = function _invmp (p) {
	    assert(p.negative === 0);
	    assert(!p.isZero());

	    var a = this;
	    var b = p.clone();

	    if (a.negative !== 0) {
	      a = a.umod(p);
	    } else {
	      a = a.clone();
	    }

	    var x1 = new BN(1);
	    var x2 = new BN(0);

	    var delta = b.clone();

	    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
	      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
	      if (i > 0) {
	        a.iushrn(i);
	        while (i-- > 0) {
	          if (x1.isOdd()) {
	            x1.iadd(delta);
	          }

	          x1.iushrn(1);
	        }
	      }

	      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
	      if (j > 0) {
	        b.iushrn(j);
	        while (j-- > 0) {
	          if (x2.isOdd()) {
	            x2.iadd(delta);
	          }

	          x2.iushrn(1);
	        }
	      }

	      if (a.cmp(b) >= 0) {
	        a.isub(b);
	        x1.isub(x2);
	      } else {
	        b.isub(a);
	        x2.isub(x1);
	      }
	    }

	    var res;
	    if (a.cmpn(1) === 0) {
	      res = x1;
	    } else {
	      res = x2;
	    }

	    if (res.cmpn(0) < 0) {
	      res.iadd(p);
	    }

	    return res;
	  };

	  BN.prototype.gcd = function gcd (num) {
	    if (this.isZero()) return num.abs();
	    if (num.isZero()) return this.abs();

	    var a = this.clone();
	    var b = num.clone();
	    a.negative = 0;
	    b.negative = 0;

	    // Remove common factor of two
	    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
	      a.iushrn(1);
	      b.iushrn(1);
	    }

	    do {
	      while (a.isEven()) {
	        a.iushrn(1);
	      }
	      while (b.isEven()) {
	        b.iushrn(1);
	      }

	      var r = a.cmp(b);
	      if (r < 0) {
	        // Swap `a` and `b` to make `a` always bigger than `b`
	        var t = a;
	        a = b;
	        b = t;
	      } else if (r === 0 || b.cmpn(1) === 0) {
	        break;
	      }

	      a.isub(b);
	    } while (true);

	    return b.iushln(shift);
	  };

	  // Invert number in the field F(num)
	  BN.prototype.invm = function invm (num) {
	    return this.egcd(num).a.umod(num);
	  };

	  BN.prototype.isEven = function isEven () {
	    return (this.words[0] & 1) === 0;
	  };

	  BN.prototype.isOdd = function isOdd () {
	    return (this.words[0] & 1) === 1;
	  };

	  // And first word and num
	  BN.prototype.andln = function andln (num) {
	    return this.words[0] & num;
	  };

	  // Increment at the bit position in-line
	  BN.prototype.bincn = function bincn (bit) {
	    assert(typeof bit === 'number');
	    var r = bit % 26;
	    var s = (bit - r) / 26;
	    var q = 1 << r;

	    // Fast case: bit is much higher than all existing words
	    if (this.length <= s) {
	      this._expand(s + 1);
	      this.words[s] |= q;
	      return this;
	    }

	    // Add bit and propagate, if needed
	    var carry = q;
	    for (var i = s; carry !== 0 && i < this.length; i++) {
	      var w = this.words[i] | 0;
	      w += carry;
	      carry = w >>> 26;
	      w &= 0x3ffffff;
	      this.words[i] = w;
	    }
	    if (carry !== 0) {
	      this.words[i] = carry;
	      this.length++;
	    }
	    return this;
	  };

	  BN.prototype.isZero = function isZero () {
	    return this.length === 1 && this.words[0] === 0;
	  };

	  BN.prototype.cmpn = function cmpn (num) {
	    var negative = num < 0;

	    if (this.negative !== 0 && !negative) return -1;
	    if (this.negative === 0 && negative) return 1;

	    this.strip();

	    var res;
	    if (this.length > 1) {
	      res = 1;
	    } else {
	      if (negative) {
	        num = -num;
	      }

	      assert(num <= 0x3ffffff, 'Number is too big');

	      var w = this.words[0] | 0;
	      res = w === num ? 0 : w < num ? -1 : 1;
	    }
	    if (this.negative !== 0) return -res | 0;
	    return res;
	  };

	  // Compare two numbers and return:
	  // 1 - if `this` > `num`
	  // 0 - if `this` == `num`
	  // -1 - if `this` < `num`
	  BN.prototype.cmp = function cmp (num) {
	    if (this.negative !== 0 && num.negative === 0) return -1;
	    if (this.negative === 0 && num.negative !== 0) return 1;

	    var res = this.ucmp(num);
	    if (this.negative !== 0) return -res | 0;
	    return res;
	  };

	  // Unsigned comparison
	  BN.prototype.ucmp = function ucmp (num) {
	    // At this point both numbers have the same sign
	    if (this.length > num.length) return 1;
	    if (this.length < num.length) return -1;

	    var res = 0;
	    for (var i = this.length - 1; i >= 0; i--) {
	      var a = this.words[i] | 0;
	      var b = num.words[i] | 0;

	      if (a === b) continue;
	      if (a < b) {
	        res = -1;
	      } else if (a > b) {
	        res = 1;
	      }
	      break;
	    }
	    return res;
	  };

	  BN.prototype.gtn = function gtn (num) {
	    return this.cmpn(num) === 1;
	  };

	  BN.prototype.gt = function gt (num) {
	    return this.cmp(num) === 1;
	  };

	  BN.prototype.gten = function gten (num) {
	    return this.cmpn(num) >= 0;
	  };

	  BN.prototype.gte = function gte (num) {
	    return this.cmp(num) >= 0;
	  };

	  BN.prototype.ltn = function ltn (num) {
	    return this.cmpn(num) === -1;
	  };

	  BN.prototype.lt = function lt (num) {
	    return this.cmp(num) === -1;
	  };

	  BN.prototype.lten = function lten (num) {
	    return this.cmpn(num) <= 0;
	  };

	  BN.prototype.lte = function lte (num) {
	    return this.cmp(num) <= 0;
	  };

	  BN.prototype.eqn = function eqn (num) {
	    return this.cmpn(num) === 0;
	  };

	  BN.prototype.eq = function eq (num) {
	    return this.cmp(num) === 0;
	  };

	  //
	  // A reduce context, could be using montgomery or something better, depending
	  // on the `m` itself.
	  //
	  BN.red = function red (num) {
	    return new Red(num);
	  };

	  BN.prototype.toRed = function toRed (ctx) {
	    assert(!this.red, 'Already a number in reduction context');
	    assert(this.negative === 0, 'red works only with positives');
	    return ctx.convertTo(this)._forceRed(ctx);
	  };

	  BN.prototype.fromRed = function fromRed () {
	    assert(this.red, 'fromRed works only with numbers in reduction context');
	    return this.red.convertFrom(this);
	  };

	  BN.prototype._forceRed = function _forceRed (ctx) {
	    this.red = ctx;
	    return this;
	  };

	  BN.prototype.forceRed = function forceRed (ctx) {
	    assert(!this.red, 'Already a number in reduction context');
	    return this._forceRed(ctx);
	  };

	  BN.prototype.redAdd = function redAdd (num) {
	    assert(this.red, 'redAdd works only with red numbers');
	    return this.red.add(this, num);
	  };

	  BN.prototype.redIAdd = function redIAdd (num) {
	    assert(this.red, 'redIAdd works only with red numbers');
	    return this.red.iadd(this, num);
	  };

	  BN.prototype.redSub = function redSub (num) {
	    assert(this.red, 'redSub works only with red numbers');
	    return this.red.sub(this, num);
	  };

	  BN.prototype.redISub = function redISub (num) {
	    assert(this.red, 'redISub works only with red numbers');
	    return this.red.isub(this, num);
	  };

	  BN.prototype.redShl = function redShl (num) {
	    assert(this.red, 'redShl works only with red numbers');
	    return this.red.shl(this, num);
	  };

	  BN.prototype.redMul = function redMul (num) {
	    assert(this.red, 'redMul works only with red numbers');
	    this.red._verify2(this, num);
	    return this.red.mul(this, num);
	  };

	  BN.prototype.redIMul = function redIMul (num) {
	    assert(this.red, 'redMul works only with red numbers');
	    this.red._verify2(this, num);
	    return this.red.imul(this, num);
	  };

	  BN.prototype.redSqr = function redSqr () {
	    assert(this.red, 'redSqr works only with red numbers');
	    this.red._verify1(this);
	    return this.red.sqr(this);
	  };

	  BN.prototype.redISqr = function redISqr () {
	    assert(this.red, 'redISqr works only with red numbers');
	    this.red._verify1(this);
	    return this.red.isqr(this);
	  };

	  // Square root over p
	  BN.prototype.redSqrt = function redSqrt () {
	    assert(this.red, 'redSqrt works only with red numbers');
	    this.red._verify1(this);
	    return this.red.sqrt(this);
	  };

	  BN.prototype.redInvm = function redInvm () {
	    assert(this.red, 'redInvm works only with red numbers');
	    this.red._verify1(this);
	    return this.red.invm(this);
	  };

	  // Return negative clone of `this` % `red modulo`
	  BN.prototype.redNeg = function redNeg () {
	    assert(this.red, 'redNeg works only with red numbers');
	    this.red._verify1(this);
	    return this.red.neg(this);
	  };

	  BN.prototype.redPow = function redPow (num) {
	    assert(this.red && !num.red, 'redPow(normalNum)');
	    this.red._verify1(this);
	    return this.red.pow(this, num);
	  };

	  // Prime numbers with efficient reduction
	  var primes = {
	    k256: null,
	    p224: null,
	    p192: null,
	    p25519: null
	  };

	  // Pseudo-Mersenne prime
	  function MPrime (name, p) {
	    // P = 2 ^ N - K
	    this.name = name;
	    this.p = new BN(p, 16);
	    this.n = this.p.bitLength();
	    this.k = new BN(1).iushln(this.n).isub(this.p);

	    this.tmp = this._tmp();
	  }

	  MPrime.prototype._tmp = function _tmp () {
	    var tmp = new BN(null);
	    tmp.words = new Array(Math.ceil(this.n / 13));
	    return tmp;
	  };

	  MPrime.prototype.ireduce = function ireduce (num) {
	    // Assumes that `num` is less than `P^2`
	    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
	    var r = num;
	    var rlen;

	    do {
	      this.split(r, this.tmp);
	      r = this.imulK(r);
	      r = r.iadd(this.tmp);
	      rlen = r.bitLength();
	    } while (rlen > this.n);

	    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
	    if (cmp === 0) {
	      r.words[0] = 0;
	      r.length = 1;
	    } else if (cmp > 0) {
	      r.isub(this.p);
	    } else {
	      if (r.strip !== undefined) {
	        // r is BN v4 instance
	        r.strip();
	      } else {
	        // r is BN v5 instance
	        r._strip();
	      }
	    }

	    return r;
	  };

	  MPrime.prototype.split = function split (input, out) {
	    input.iushrn(this.n, 0, out);
	  };

	  MPrime.prototype.imulK = function imulK (num) {
	    return num.imul(this.k);
	  };

	  function K256 () {
	    MPrime.call(
	      this,
	      'k256',
	      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
	  }
	  inherits(K256, MPrime);

	  K256.prototype.split = function split (input, output) {
	    // 256 = 9 * 26 + 22
	    var mask = 0x3fffff;

	    var outLen = Math.min(input.length, 9);
	    for (var i = 0; i < outLen; i++) {
	      output.words[i] = input.words[i];
	    }
	    output.length = outLen;

	    if (input.length <= 9) {
	      input.words[0] = 0;
	      input.length = 1;
	      return;
	    }

	    // Shift by 9 limbs
	    var prev = input.words[9];
	    output.words[output.length++] = prev & mask;

	    for (i = 10; i < input.length; i++) {
	      var next = input.words[i] | 0;
	      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
	      prev = next;
	    }
	    prev >>>= 22;
	    input.words[i - 10] = prev;
	    if (prev === 0 && input.length > 10) {
	      input.length -= 10;
	    } else {
	      input.length -= 9;
	    }
	  };

	  K256.prototype.imulK = function imulK (num) {
	    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
	    num.words[num.length] = 0;
	    num.words[num.length + 1] = 0;
	    num.length += 2;

	    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
	    var lo = 0;
	    for (var i = 0; i < num.length; i++) {
	      var w = num.words[i] | 0;
	      lo += w * 0x3d1;
	      num.words[i] = lo & 0x3ffffff;
	      lo = w * 0x40 + ((lo / 0x4000000) | 0);
	    }

	    // Fast length reduction
	    if (num.words[num.length - 1] === 0) {
	      num.length--;
	      if (num.words[num.length - 1] === 0) {
	        num.length--;
	      }
	    }
	    return num;
	  };

	  function P224 () {
	    MPrime.call(
	      this,
	      'p224',
	      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
	  }
	  inherits(P224, MPrime);

	  function P192 () {
	    MPrime.call(
	      this,
	      'p192',
	      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
	  }
	  inherits(P192, MPrime);

	  function P25519 () {
	    // 2 ^ 255 - 19
	    MPrime.call(
	      this,
	      '25519',
	      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
	  }
	  inherits(P25519, MPrime);

	  P25519.prototype.imulK = function imulK (num) {
	    // K = 0x13
	    var carry = 0;
	    for (var i = 0; i < num.length; i++) {
	      var hi = (num.words[i] | 0) * 0x13 + carry;
	      var lo = hi & 0x3ffffff;
	      hi >>>= 26;

	      num.words[i] = lo;
	      carry = hi;
	    }
	    if (carry !== 0) {
	      num.words[num.length++] = carry;
	    }
	    return num;
	  };

	  // Exported mostly for testing purposes, use plain name instead
	  BN._prime = function prime (name) {
	    // Cached version of prime
	    if (primes[name]) return primes[name];

	    var prime;
	    if (name === 'k256') {
	      prime = new K256();
	    } else if (name === 'p224') {
	      prime = new P224();
	    } else if (name === 'p192') {
	      prime = new P192();
	    } else if (name === 'p25519') {
	      prime = new P25519();
	    } else {
	      throw new Error('Unknown prime ' + name);
	    }
	    primes[name] = prime;

	    return prime;
	  };

	  //
	  // Base reduction engine
	  //
	  function Red (m) {
	    if (typeof m === 'string') {
	      var prime = BN._prime(m);
	      this.m = prime.p;
	      this.prime = prime;
	    } else {
	      assert(m.gtn(1), 'modulus must be greater than 1');
	      this.m = m;
	      this.prime = null;
	    }
	  }

	  Red.prototype._verify1 = function _verify1 (a) {
	    assert(a.negative === 0, 'red works only with positives');
	    assert(a.red, 'red works only with red numbers');
	  };

	  Red.prototype._verify2 = function _verify2 (a, b) {
	    assert((a.negative | b.negative) === 0, 'red works only with positives');
	    assert(a.red && a.red === b.red,
	      'red works only with red numbers');
	  };

	  Red.prototype.imod = function imod (a) {
	    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
	    return a.umod(this.m)._forceRed(this);
	  };

	  Red.prototype.neg = function neg (a) {
	    if (a.isZero()) {
	      return a.clone();
	    }

	    return this.m.sub(a)._forceRed(this);
	  };

	  Red.prototype.add = function add (a, b) {
	    this._verify2(a, b);

	    var res = a.add(b);
	    if (res.cmp(this.m) >= 0) {
	      res.isub(this.m);
	    }
	    return res._forceRed(this);
	  };

	  Red.prototype.iadd = function iadd (a, b) {
	    this._verify2(a, b);

	    var res = a.iadd(b);
	    if (res.cmp(this.m) >= 0) {
	      res.isub(this.m);
	    }
	    return res;
	  };

	  Red.prototype.sub = function sub (a, b) {
	    this._verify2(a, b);

	    var res = a.sub(b);
	    if (res.cmpn(0) < 0) {
	      res.iadd(this.m);
	    }
	    return res._forceRed(this);
	  };

	  Red.prototype.isub = function isub (a, b) {
	    this._verify2(a, b);

	    var res = a.isub(b);
	    if (res.cmpn(0) < 0) {
	      res.iadd(this.m);
	    }
	    return res;
	  };

	  Red.prototype.shl = function shl (a, num) {
	    this._verify1(a);
	    return this.imod(a.ushln(num));
	  };

	  Red.prototype.imul = function imul (a, b) {
	    this._verify2(a, b);
	    return this.imod(a.imul(b));
	  };

	  Red.prototype.mul = function mul (a, b) {
	    this._verify2(a, b);
	    return this.imod(a.mul(b));
	  };

	  Red.prototype.isqr = function isqr (a) {
	    return this.imul(a, a.clone());
	  };

	  Red.prototype.sqr = function sqr (a) {
	    return this.mul(a, a);
	  };

	  Red.prototype.sqrt = function sqrt (a) {
	    if (a.isZero()) return a.clone();

	    var mod3 = this.m.andln(3);
	    assert(mod3 % 2 === 1);

	    // Fast case
	    if (mod3 === 3) {
	      var pow = this.m.add(new BN(1)).iushrn(2);
	      return this.pow(a, pow);
	    }

	    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
	    //
	    // Find Q and S, that Q * 2 ^ S = (P - 1)
	    var q = this.m.subn(1);
	    var s = 0;
	    while (!q.isZero() && q.andln(1) === 0) {
	      s++;
	      q.iushrn(1);
	    }
	    assert(!q.isZero());

	    var one = new BN(1).toRed(this);
	    var nOne = one.redNeg();

	    // Find quadratic non-residue
	    // NOTE: Max is such because of generalized Riemann hypothesis.
	    var lpow = this.m.subn(1).iushrn(1);
	    var z = this.m.bitLength();
	    z = new BN(2 * z * z).toRed(this);

	    while (this.pow(z, lpow).cmp(nOne) !== 0) {
	      z.redIAdd(nOne);
	    }

	    var c = this.pow(z, q);
	    var r = this.pow(a, q.addn(1).iushrn(1));
	    var t = this.pow(a, q);
	    var m = s;
	    while (t.cmp(one) !== 0) {
	      var tmp = t;
	      for (var i = 0; tmp.cmp(one) !== 0; i++) {
	        tmp = tmp.redSqr();
	      }
	      assert(i < m);
	      var b = this.pow(c, new BN(1).iushln(m - i - 1));

	      r = r.redMul(b);
	      c = b.redSqr();
	      t = t.redMul(c);
	      m = i;
	    }

	    return r;
	  };

	  Red.prototype.invm = function invm (a) {
	    var inv = a._invmp(this.m);
	    if (inv.negative !== 0) {
	      inv.negative = 0;
	      return this.imod(inv).redNeg();
	    } else {
	      return this.imod(inv);
	    }
	  };

	  Red.prototype.pow = function pow (a, num) {
	    if (num.isZero()) return new BN(1).toRed(this);
	    if (num.cmpn(1) === 0) return a.clone();

	    var windowSize = 4;
	    var wnd = new Array(1 << windowSize);
	    wnd[0] = new BN(1).toRed(this);
	    wnd[1] = a;
	    for (var i = 2; i < wnd.length; i++) {
	      wnd[i] = this.mul(wnd[i - 1], a);
	    }

	    var res = wnd[0];
	    var current = 0;
	    var currentLen = 0;
	    var start = num.bitLength() % 26;
	    if (start === 0) {
	      start = 26;
	    }

	    for (i = num.length - 1; i >= 0; i--) {
	      var word = num.words[i];
	      for (var j = start - 1; j >= 0; j--) {
	        var bit = (word >> j) & 1;
	        if (res !== wnd[0]) {
	          res = this.sqr(res);
	        }

	        if (bit === 0 && current === 0) {
	          currentLen = 0;
	          continue;
	        }

	        current <<= 1;
	        current |= bit;
	        currentLen++;
	        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

	        res = this.mul(res, wnd[current]);
	        currentLen = 0;
	        current = 0;
	      }
	      start = 26;
	    }

	    return res;
	  };

	  Red.prototype.convertTo = function convertTo (num) {
	    var r = num.umod(this.m);

	    return r === num ? r.clone() : r;
	  };

	  Red.prototype.convertFrom = function convertFrom (num) {
	    var res = num.clone();
	    res.red = null;
	    return res;
	  };

	  //
	  // Montgomery method engine
	  //

	  BN.mont = function mont (num) {
	    return new Mont(num);
	  };

	  function Mont (m) {
	    Red.call(this, m);

	    this.shift = this.m.bitLength();
	    if (this.shift % 26 !== 0) {
	      this.shift += 26 - (this.shift % 26);
	    }

	    this.r = new BN(1).iushln(this.shift);
	    this.r2 = this.imod(this.r.sqr());
	    this.rinv = this.r._invmp(this.m);

	    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
	    this.minv = this.minv.umod(this.r);
	    this.minv = this.r.sub(this.minv);
	  }
	  inherits(Mont, Red);

	  Mont.prototype.convertTo = function convertTo (num) {
	    return this.imod(num.ushln(this.shift));
	  };

	  Mont.prototype.convertFrom = function convertFrom (num) {
	    var r = this.imod(num.mul(this.rinv));
	    r.red = null;
	    return r;
	  };

	  Mont.prototype.imul = function imul (a, b) {
	    if (a.isZero() || b.isZero()) {
	      a.words[0] = 0;
	      a.length = 1;
	      return a;
	    }

	    var t = a.imul(b);
	    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
	    var u = t.isub(c).iushrn(this.shift);
	    var res = u;

	    if (u.cmp(this.m) >= 0) {
	      res = u.isub(this.m);
	    } else if (u.cmpn(0) < 0) {
	      res = u.iadd(this.m);
	    }

	    return res._forceRed(this);
	  };

	  Mont.prototype.mul = function mul (a, b) {
	    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

	    var t = a.mul(b);
	    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
	    var u = t.isub(c).iushrn(this.shift);
	    var res = u;
	    if (u.cmp(this.m) >= 0) {
	      res = u.isub(this.m);
	    } else if (u.cmpn(0) < 0) {
	      res = u.iadd(this.m);
	    }

	    return res._forceRed(this);
	  };

	  Mont.prototype.invm = function invm (a) {
	    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
	    var res = this.imod(a._invmp(this.m).mul(this.r2));
	    return res._forceRed(this);
	  };
	})(module, commonjsGlobal); 
} (bn));

var bnExports = bn.exports;

var minimalisticAssert = assert$c;

function assert$c(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
}

assert$c.equal = function assertEqual(l, r, msg) {
  if (l != r)
    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
};

var utils$n = {};

(function (exports) {

	var utils = exports;

	function toArray(msg, enc) {
	  if (Array.isArray(msg))
	    return msg.slice();
	  if (!msg)
	    return [];
	  var res = [];
	  if (typeof msg !== 'string') {
	    for (var i = 0; i < msg.length; i++)
	      res[i] = msg[i] | 0;
	    return res;
	  }
	  if (enc === 'hex') {
	    msg = msg.replace(/[^a-z0-9]+/ig, '');
	    if (msg.length % 2 !== 0)
	      msg = '0' + msg;
	    for (var i = 0; i < msg.length; i += 2)
	      res.push(parseInt(msg[i] + msg[i + 1], 16));
	  } else {
	    for (var i = 0; i < msg.length; i++) {
	      var c = msg.charCodeAt(i);
	      var hi = c >> 8;
	      var lo = c & 0xff;
	      if (hi)
	        res.push(hi, lo);
	      else
	        res.push(lo);
	    }
	  }
	  return res;
	}
	utils.toArray = toArray;

	function zero2(word) {
	  if (word.length === 1)
	    return '0' + word;
	  else
	    return word;
	}
	utils.zero2 = zero2;

	function toHex(msg) {
	  var res = '';
	  for (var i = 0; i < msg.length; i++)
	    res += zero2(msg[i].toString(16));
	  return res;
	}
	utils.toHex = toHex;

	utils.encode = function encode(arr, enc) {
	  if (enc === 'hex')
	    return toHex(arr);
	  else
	    return arr;
	}; 
} (utils$n));

(function (exports) {

	var utils = exports;
	var BN = bnExports;
	var minAssert = minimalisticAssert;
	var minUtils = utils$n;

	utils.assert = minAssert;
	utils.toArray = minUtils.toArray;
	utils.zero2 = minUtils.zero2;
	utils.toHex = minUtils.toHex;
	utils.encode = minUtils.encode;

	// Represent num in a w-NAF form
	function getNAF(num, w, bits) {
	  var naf = new Array(Math.max(num.bitLength(), bits) + 1);
	  naf.fill(0);

	  var ws = 1 << (w + 1);
	  var k = num.clone();

	  for (var i = 0; i < naf.length; i++) {
	    var z;
	    var mod = k.andln(ws - 1);
	    if (k.isOdd()) {
	      if (mod > (ws >> 1) - 1)
	        z = (ws >> 1) - mod;
	      else
	        z = mod;
	      k.isubn(z);
	    } else {
	      z = 0;
	    }

	    naf[i] = z;
	    k.iushrn(1);
	  }

	  return naf;
	}
	utils.getNAF = getNAF;

	// Represent k1, k2 in a Joint Sparse Form
	function getJSF(k1, k2) {
	  var jsf = [
	    [],
	    [],
	  ];

	  k1 = k1.clone();
	  k2 = k2.clone();
	  var d1 = 0;
	  var d2 = 0;
	  var m8;
	  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
	    // First phase
	    var m14 = (k1.andln(3) + d1) & 3;
	    var m24 = (k2.andln(3) + d2) & 3;
	    if (m14 === 3)
	      m14 = -1;
	    if (m24 === 3)
	      m24 = -1;
	    var u1;
	    if ((m14 & 1) === 0) {
	      u1 = 0;
	    } else {
	      m8 = (k1.andln(7) + d1) & 7;
	      if ((m8 === 3 || m8 === 5) && m24 === 2)
	        u1 = -m14;
	      else
	        u1 = m14;
	    }
	    jsf[0].push(u1);

	    var u2;
	    if ((m24 & 1) === 0) {
	      u2 = 0;
	    } else {
	      m8 = (k2.andln(7) + d2) & 7;
	      if ((m8 === 3 || m8 === 5) && m14 === 2)
	        u2 = -m24;
	      else
	        u2 = m24;
	    }
	    jsf[1].push(u2);

	    // Second phase
	    if (2 * d1 === u1 + 1)
	      d1 = 1 - d1;
	    if (2 * d2 === u2 + 1)
	      d2 = 1 - d2;
	    k1.iushrn(1);
	    k2.iushrn(1);
	  }

	  return jsf;
	}
	utils.getJSF = getJSF;

	function cachedProperty(obj, name, computer) {
	  var key = '_' + name;
	  obj.prototype[name] = function cachedProperty() {
	    return this[key] !== undefined ? this[key] :
	      this[key] = computer.call(this);
	  };
	}
	utils.cachedProperty = cachedProperty;

	function parseBytes(bytes) {
	  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :
	    bytes;
	}
	utils.parseBytes = parseBytes;

	function intFromLE(bytes) {
	  return new BN(bytes, 'hex', 'le');
	}
	utils.intFromLE = intFromLE; 
} (utils$o));

var brorand = {exports: {}};

var r;

brorand.exports = function rand(len) {
  if (!r)
    r = new Rand(null);

  return r.generate(len);
};

function Rand(rand) {
  this.rand = rand;
}
brorand.exports.Rand = Rand;

Rand.prototype.generate = function generate(len) {
  return this._rand(len);
};

// Emulate crypto API using randy
Rand.prototype._rand = function _rand(n) {
  if (this.rand.getBytes)
    return this.rand.getBytes(n);

  var res = new Uint8Array(n);
  for (var i = 0; i < res.length; i++)
    res[i] = this.rand.getByte();
  return res;
};

if (typeof self === 'object') {
  if (self.crypto && self.crypto.getRandomValues) {
    // Modern browsers
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.crypto.getRandomValues(arr);
      return arr;
    };
  } else if (self.msCrypto && self.msCrypto.getRandomValues) {
    // IE
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.msCrypto.getRandomValues(arr);
      return arr;
    };

  // Safari's WebWorkers do not have `crypto`
  } else if (typeof window === 'object') {
    // Old junk
    Rand.prototype._rand = function() {
      throw new Error('Not implemented yet');
    };
  }
} else {
  // Node.js or Web worker with no crypto support
  try {
    var crypto$1 = require('crypto');
    if (typeof crypto$1.randomBytes !== 'function')
      throw new Error('Not supported');

    Rand.prototype._rand = function _rand(n) {
      return crypto$1.randomBytes(n);
    };
  } catch (e) {
  }
}

var brorandExports = brorand.exports;

var curve = {};

var BN$d = bnExports;
var utils$m = utils$o;
var getNAF = utils$m.getNAF;
var getJSF = utils$m.getJSF;
var assert$b = utils$m.assert;

function BaseCurve(type, conf) {
  this.type = type;
  this.p = new BN$d(conf.p, 16);

  // Use Montgomery, when there is no fast reduction for the prime
  this.red = conf.prime ? BN$d.red(conf.prime) : BN$d.mont(this.p);

  // Useful for many curves
  this.zero = new BN$d(0).toRed(this.red);
  this.one = new BN$d(1).toRed(this.red);
  this.two = new BN$d(2).toRed(this.red);

  // Curve configuration, optional
  this.n = conf.n && new BN$d(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);

  // Temporary arrays
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);

  this._bitLength = this.n ? this.n.bitLength() : 0;

  // Generalized Greg Maxwell's trick
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
var base$1 = BaseCurve;

BaseCurve.prototype.point = function point() {
  throw new Error('Not implemented');
};

BaseCurve.prototype.validate = function validate() {
  throw new Error('Not implemented');
};

BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
  assert$b(p.precomputed);
  var doubles = p._getDoubles();

  var naf = getNAF(k, 1, this._bitLength);
  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);
  I /= 3;

  // Translate into more windowed form
  var repr = [];
  var j;
  var nafW;
  for (j = 0; j < naf.length; j += doubles.step) {
    nafW = 0;
    for (var l = j + doubles.step - 1; l >= j; l--)
      nafW = (nafW << 1) + naf[l];
    repr.push(nafW);
  }

  var a = this.jpoint(null, null, null);
  var b = this.jpoint(null, null, null);
  for (var i = I; i > 0; i--) {
    for (j = 0; j < repr.length; j++) {
      nafW = repr[j];
      if (nafW === i)
        b = b.mixedAdd(doubles.points[j]);
      else if (nafW === -i)
        b = b.mixedAdd(doubles.points[j].neg());
    }
    a = a.add(b);
  }
  return a.toP();
};

BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
  var w = 4;

  // Precompute window
  var nafPoints = p._getNAFPoints(w);
  w = nafPoints.wnd;
  var wnd = nafPoints.points;

  // Get NAF form
  var naf = getNAF(k, w, this._bitLength);

  // Add `this`*(N+1) for every w-NAF index
  var acc = this.jpoint(null, null, null);
  for (var i = naf.length - 1; i >= 0; i--) {
    // Count zeroes
    for (var l = 0; i >= 0 && naf[i] === 0; i--)
      l++;
    if (i >= 0)
      l++;
    acc = acc.dblp(l);

    if (i < 0)
      break;
    var z = naf[i];
    assert$b(z !== 0);
    if (p.type === 'affine') {
      // J +- P
      if (z > 0)
        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);
      else
        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());
    } else {
      // J +- J
      if (z > 0)
        acc = acc.add(wnd[(z - 1) >> 1]);
      else
        acc = acc.add(wnd[(-z - 1) >> 1].neg());
    }
  }
  return p.type === 'affine' ? acc.toP() : acc;
};

BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,
  points,
  coeffs,
  len,
  jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;

  // Fill all arrays
  var max = 0;
  var i;
  var j;
  var p;
  for (i = 0; i < len; i++) {
    p = points[i];
    var nafPoints = p._getNAFPoints(defW);
    wndWidth[i] = nafPoints.wnd;
    wnd[i] = nafPoints.points;
  }

  // Comb small window NAFs
  for (i = len - 1; i >= 1; i -= 2) {
    var a = i - 1;
    var b = i;
    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
      max = Math.max(naf[a].length, max);
      max = Math.max(naf[b].length, max);
      continue;
    }

    var comb = [
      points[a], /* 1 */
      null, /* 3 */
      null, /* 5 */
      points[b], /* 7 */
    ];

    // Try to avoid Projective points, if possible
    if (points[a].y.cmp(points[b].y) === 0) {
      comb[1] = points[a].add(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].add(points[b].neg());
    } else {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    }

    var index = [
      -3, /* -1 -1 */
      -1, /* -1 0 */
      -5, /* -1 1 */
      -7, /* 0 -1 */
      0, /* 0 0 */
      7, /* 0 1 */
      5, /* 1 -1 */
      1, /* 1 0 */
      3,  /* 1 1 */
    ];

    var jsf = getJSF(coeffs[a], coeffs[b]);
    max = Math.max(jsf[0].length, max);
    naf[a] = new Array(max);
    naf[b] = new Array(max);
    for (j = 0; j < max; j++) {
      var ja = jsf[0][j] | 0;
      var jb = jsf[1][j] | 0;

      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b][j] = 0;
      wnd[a] = comb;
    }
  }

  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (i = max; i >= 0; i--) {
    var k = 0;

    while (i >= 0) {
      var zero = true;
      for (j = 0; j < len; j++) {
        tmp[j] = naf[j][i] | 0;
        if (tmp[j] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k++;
      i--;
    }
    if (i >= 0)
      k++;
    acc = acc.dblp(k);
    if (i < 0)
      break;

    for (j = 0; j < len; j++) {
      var z = tmp[j];
      if (z === 0)
        continue;
      else if (z > 0)
        p = wnd[j][(z - 1) >> 1];
      else if (z < 0)
        p = wnd[j][(-z - 1) >> 1].neg();

      if (p.type === 'affine')
        acc = acc.mixedAdd(p);
      else
        acc = acc.add(p);
    }
  }
  // Zeroify references
  for (i = 0; i < len; i++)
    wnd[i] = null;

  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};

function BasePoint(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;

BasePoint.prototype.eq = function eq(/*other*/) {
  throw new Error('Not implemented');
};

BasePoint.prototype.validate = function validate() {
  return this.curve.validate(this);
};

BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  bytes = utils$m.toArray(bytes, enc);

  var len = this.p.byteLength();

  // uncompressed, hybrid-odd, hybrid-even
  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&
      bytes.length - 1 === 2 * len) {
    if (bytes[0] === 0x06)
      assert$b(bytes[bytes.length - 1] % 2 === 0);
    else if (bytes[0] === 0x07)
      assert$b(bytes[bytes.length - 1] % 2 === 1);

    var res =  this.point(bytes.slice(1, 1 + len),
      bytes.slice(1 + len, 1 + 2 * len));

    return res;
  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&
              bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
  }
  throw new Error('Unknown point format');
};

BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};

BasePoint.prototype._encode = function _encode(compact) {
  var len = this.curve.p.byteLength();
  var x = this.getX().toArray('be', len);

  if (compact)
    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);

  return [ 0x04 ].concat(x, this.getY().toArray('be', len));
};

BasePoint.prototype.encode = function encode(enc, compact) {
  return utils$m.encode(this._encode(compact), enc);
};

BasePoint.prototype.precompute = function precompute(power) {
  if (this.precomputed)
    return this;

  var precomputed = {
    doubles: null,
    naf: null,
    beta: null,
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;

  return this;
};

BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
  if (!this.precomputed)
    return false;

  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;

  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};

BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;

  var doubles = [ this ];
  var acc = this;
  for (var i = 0; i < power; i += step) {
    for (var j = 0; j < step; j++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step: step,
    points: doubles,
  };
};

BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;

  var res = [ this ];
  var max = (1 << wnd) - 1;
  var dbl = max === 1 ? null : this.dbl();
  for (var i = 1; i < max; i++)
    res[i] = res[i - 1].add(dbl);
  return {
    wnd: wnd,
    points: res,
  };
};

BasePoint.prototype._getBeta = function _getBeta() {
  return null;
};

BasePoint.prototype.dblp = function dblp(k) {
  var r = this;
  for (var i = 0; i < k; i++)
    r = r.dbl();
  return r;
};

var inherits$5 = {exports: {}};

var inherits_browser$1 = {exports: {}};

var hasRequiredInherits_browser$1;

function requireInherits_browser$1 () {
	if (hasRequiredInherits_browser$1) return inherits_browser$1.exports;
	hasRequiredInherits_browser$1 = 1;
	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  inherits_browser$1.exports = function inherits(ctor, superCtor) {
	    if (superCtor) {
	      ctor.super_ = superCtor;
	      ctor.prototype = Object.create(superCtor.prototype, {
	        constructor: {
	          value: ctor,
	          enumerable: false,
	          writable: true,
	          configurable: true
	        }
	      });
	    }
	  };
	} else {
	  // old school shim for old browsers
	  inherits_browser$1.exports = function inherits(ctor, superCtor) {
	    if (superCtor) {
	      ctor.super_ = superCtor;
	      var TempCtor = function () {};
	      TempCtor.prototype = superCtor.prototype;
	      ctor.prototype = new TempCtor();
	      ctor.prototype.constructor = ctor;
	    }
	  };
	}
	return inherits_browser$1.exports;
}

try {
  var util$1 = require('util');
  /* istanbul ignore next */
  if (typeof util$1.inherits !== 'function') throw '';
  inherits$5.exports = util$1.inherits;
} catch (e) {
  /* istanbul ignore next */
  inherits$5.exports = requireInherits_browser$1();
}

var inheritsExports$1 = inherits$5.exports;

var utils$l = utils$o;
var BN$c = bnExports;
var inherits$4 = inheritsExports$1;
var Base$3 = base$1;

var assert$a = utils$l.assert;

function ShortCurve(conf) {
  Base$3.call(this, 'short', conf);

  this.a = new BN$c(conf.a, 16).toRed(this.red);
  this.b = new BN$c(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();

  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;

  // If the curve is endomorphic, precalculate beta and lambda
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits$4(ShortCurve, Base$3);
var short = ShortCurve;

ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
  // No efficient endomorphism
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;

  // Compute beta and lambda, that lambda * P = (beta * Px; Py)
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new BN$c(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    // Choose the smallest beta
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new BN$c(conf.lambda, 16);
  } else {
    // Choose the lambda that is matching selected beta
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert$a(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }

  // Get basis vectors, used for balanced length-two representation
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new BN$c(vec.a, 16),
        b: new BN$c(vec.b, 16),
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }

  return {
    beta: beta,
    lambda: lambda,
    basis: basis,
  };
};

ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
  // Find roots of for x^2 + x + 1 in F
  // Root = (-1 +- Sqrt(-3)) / 2
  //
  var red = num === this.p ? this.red : BN$c.mont(num);
  var tinv = new BN$c(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();

  var s = new BN$c(3).toRed(red).redNeg().redSqrt().redMul(tinv);

  var l1 = ntinv.redAdd(s).fromRed();
  var l2 = ntinv.redSub(s).fromRed();
  return [ l1, l2 ];
};

ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  // aprxSqrt >= sqrt(this.n)
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));

  // 3.74
  // Run EGCD, until r(L + 1) < aprxSqrt
  var u = lambda;
  var v = this.n.clone();
  var x1 = new BN$c(1);
  var y1 = new BN$c(0);
  var x2 = new BN$c(0);
  var y2 = new BN$c(1);

  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
  var a0;
  var b0;
  // First vector
  var a1;
  var b1;
  // Second vector
  var a2;
  var b2;

  var prevR;
  var i = 0;
  var r;
  var x;
  while (u.cmpn(0) !== 0) {
    var q = v.div(u);
    r = v.sub(q.mul(u));
    x = x2.sub(q.mul(x1));
    var y = y2.sub(q.mul(y1));

    if (!a1 && r.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r.neg();
      b1 = x;
    } else if (a1 && ++i === 2) {
      break;
    }
    prevR = r;

    v = u;
    u = r;
    x2 = x1;
    x1 = x;
    y2 = y1;
    y1 = y;
  }
  a2 = r.neg();
  b2 = x;

  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }

  // Normalize signs
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }

  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 },
  ];
};

ShortCurve.prototype._endoSplit = function _endoSplit(k) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];

  var c1 = v2.b.mul(k).divRound(this.n);
  var c2 = v1.b.neg().mul(k).divRound(this.n);

  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);

  // Calculate answer
  var k1 = k.sub(p1).sub(p2);
  var k2 = q1.add(q2).neg();
  return { k1: k1, k2: k2 };
};

ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN$c(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  // XXX Is there any way to tell if the number is odd without converting it
  // to non-red form?
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

ShortCurve.prototype.validate = function validate(point) {
  if (point.inf)
    return true;

  var x = point.x;
  var y = point.y;

  var ax = this.a.redMul(x);
  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
  return y.redSqr().redISub(rhs).cmpn(0) === 0;
};

ShortCurve.prototype._endoWnafMulAdd =
    function _endoWnafMulAdd(points, coeffs, jacobianResult) {
      var npoints = this._endoWnafT1;
      var ncoeffs = this._endoWnafT2;
      for (var i = 0; i < points.length; i++) {
        var split = this._endoSplit(coeffs[i]);
        var p = points[i];
        var beta = p._getBeta();

        if (split.k1.negative) {
          split.k1.ineg();
          p = p.neg(true);
        }
        if (split.k2.negative) {
          split.k2.ineg();
          beta = beta.neg(true);
        }

        npoints[i * 2] = p;
        npoints[i * 2 + 1] = beta;
        ncoeffs[i * 2] = split.k1;
        ncoeffs[i * 2 + 1] = split.k2;
      }
      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);

      // Clean-up references to points and coefficients
      for (var j = 0; j < i * 2; j++) {
        npoints[j] = null;
        ncoeffs[j] = null;
      }
      return res;
    };

function Point$3(curve, x, y, isRed) {
  Base$3.BasePoint.call(this, curve, 'affine');
  if (x === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new BN$c(x, 16);
    this.y = new BN$c(y, 16);
    // Force redgomery representation when loading from JSON
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits$4(Point$3, Base$3.BasePoint);

ShortCurve.prototype.point = function point(x, y, isRed) {
  return new Point$3(this, x, y, isRed);
};

ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point$3.fromJSON(this, obj, red);
};

Point$3.prototype._getBeta = function _getBeta() {
  if (!this.curve.endo)
    return;

  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;

  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = function(p) {
      return curve.point(p.x.redMul(curve.endo.beta), p.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul),
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul),
      },
    };
  }
  return beta;
};

Point$3.prototype.toJSON = function toJSON() {
  if (!this.precomputed)
    return [ this.x, this.y ];

  return [ this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1),
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1),
    },
  } ];
};

Point$3.fromJSON = function fromJSON(curve, obj, red) {
  if (typeof obj === 'string')
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;

  function obj2point(obj) {
    return curve.point(obj[0], obj[1], red);
  }

  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [ res ].concat(pre.doubles.points.map(obj2point)),
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [ res ].concat(pre.naf.points.map(obj2point)),
    },
  };
  return res;
};

Point$3.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) + '>';
};

Point$3.prototype.isInfinity = function isInfinity() {
  return this.inf;
};

Point$3.prototype.add = function add(p) {
  // O + P = P
  if (this.inf)
    return p;

  // P + O = P
  if (p.inf)
    return this;

  // P + P = 2P
  if (this.eq(p))
    return this.dbl();

  // P + (-P) = O
  if (this.neg().eq(p))
    return this.curve.point(null, null);

  // P + Q = O
  if (this.x.cmp(p.x) === 0)
    return this.curve.point(null, null);

  var c = this.y.redSub(p.y);
  if (c.cmpn(0) !== 0)
    c = c.redMul(this.x.redSub(p.x).redInvm());
  var nx = c.redSqr().redISub(this.x).redISub(p.x);
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point$3.prototype.dbl = function dbl() {
  if (this.inf)
    return this;

  // 2P = O
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);

  var a = this.curve.a;

  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);

  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point$3.prototype.getX = function getX() {
  return this.x.fromRed();
};

Point$3.prototype.getY = function getY() {
  return this.y.fromRed();
};

Point$3.prototype.mul = function mul(k) {
  k = new BN$c(k, 16);
  if (this.isInfinity())
    return this;
  else if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([ this ], [ k ]);
  else
    return this.curve._wnafMul(this, k);
};

Point$3.prototype.mulAdd = function mulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};

Point$3.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};

Point$3.prototype.eq = function eq(p) {
  return this === p ||
         this.inf === p.inf &&
             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
};

Point$3.prototype.neg = function neg(_precompute) {
  if (this.inf)
    return this;

  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p) {
      return p.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate),
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate),
      },
    };
  }
  return res;
};

Point$3.prototype.toJ = function toJ() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);

  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};

function JPoint(curve, x, y, z) {
  Base$3.BasePoint.call(this, curve, 'jacobian');
  if (x === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new BN$c(0);
  } else {
    this.x = new BN$c(x, 16);
    this.y = new BN$c(y, 16);
    this.z = new BN$c(z, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);

  this.zOne = this.z === this.curve.one;
}
inherits$4(JPoint, Base$3.BasePoint);

ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
  return new JPoint(this, x, y, z);
};

JPoint.prototype.toP = function toP() {
  if (this.isInfinity())
    return this.curve.point(null, null);

  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);

  return this.curve.point(ax, ay);
};

JPoint.prototype.neg = function neg() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};

JPoint.prototype.add = function add(p) {
  // O + P = P
  if (this.isInfinity())
    return p;

  // P + O = P
  if (p.isInfinity())
    return this;

  // 12M + 4S + 7A
  var pz2 = p.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p.z));
  var s2 = p.y.redMul(z2.redMul(this.z));

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p.z).redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mixedAdd = function mixedAdd(p) {
  // O + P = P
  if (this.isInfinity())
    return p.toJ();

  // P + O = P
  if (p.isInfinity())
    return this;

  // 8M + 3S + 7A
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p.x.redMul(z2);
  var s1 = this.y;
  var s2 = p.y.redMul(z2).redMul(this.z);

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.dblp = function dblp(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();

  var i;
  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;
    for (i = 0; i < pow; i++)
      r = r.dbl();
    return r;
  }

  // 1M + 2S + 1A + N * (4S + 5M + 8A)
  // N = 1 => 6M + 6S + 9A
  var a = this.curve.a;
  var tinv = this.curve.tinv;

  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  // Reuse results
  var jyd = jy.redAdd(jy);
  for (i = 0; i < pow; i++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

    var t1 = jx.redMul(jyd2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i + 1 < pow)
      jz4 = jz4.redMul(jyd4);

    jx = nx;
    jz = nz;
    jyd = dny;
  }

  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};

JPoint.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};

JPoint.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 14A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a; a = 0
    var m = xx.redAdd(xx).redIAdd(xx);
    // T = M ^ 2 - 2*S
    var t = m.redSqr().redISub(s).redISub(s);

    // 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);

    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2*Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-dbl-2009-l
    // 2M + 5S + 13A

    // A = X1^2
    var a = this.x.redSqr();
    // B = Y1^2
    var b = this.y.redSqr();
    // C = B^2
    var c = b.redSqr();
    // D = 2 * ((X1 + B)^2 - A - C)
    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
    d = d.redIAdd(d);
    // E = 3 * A
    var e = a.redAdd(a).redIAdd(a);
    // F = E^2
    var f = e.redSqr();

    // 8 * C
    var c8 = c.redIAdd(c);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);

    // X3 = F - 2 * D
    nx = f.redISub(d).redISub(d);
    // Y3 = E * (D - X3) - 8 * C
    ny = e.redMul(d.redISub(nx)).redISub(c8);
    // Z3 = 2 * Y1 * Z1
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 15A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a
    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    // T = M^2 - 2 * S
    var t = m.redSqr().redISub(s).redISub(s);
    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2 * Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
    // 3M + 5S

    // delta = Z1^2
    var delta = this.z.redSqr();
    // gamma = Y1^2
    var gamma = this.y.redSqr();
    // beta = X1 * gamma
    var beta = this.x.redMul(gamma);
    // alpha = 3 * (X1 - delta) * (X1 + delta)
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    // X3 = alpha^2 - 8 * beta
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    // Z3 = (Y1 + Z1)^2 - gamma - delta
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._dbl = function _dbl() {
  var a = this.curve.a;

  // 4M + 6S + 10A
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();

  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);

  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.trpl = function trpl() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);

  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
  // 5M + 10S + ...

  // XX = X1^2
  var xx = this.x.redSqr();
  // YY = Y1^2
  var yy = this.y.redSqr();
  // ZZ = Z1^2
  var zz = this.z.redSqr();
  // YYYY = YY^2
  var yyyy = yy.redSqr();
  // M = 3 * XX + a * ZZ2; a = 0
  var m = xx.redAdd(xx).redIAdd(xx);
  // MM = M^2
  var mm = m.redSqr();
  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm);
  // EE = E^2
  var ee = e.redSqr();
  // T = 16*YYYY
  var t = yyyy.redIAdd(yyyy);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  // U = (M + E)^2 - MM - EE - T
  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
  // X3 = 4 * (X1 * EE - 4 * YY * U)
  var yyu4 = yy.redMul(u);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  // Z3 = (Z1 + E)^2 - ZZ - EE
  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mul = function mul(k, kbase) {
  k = new BN$c(k, kbase);

  return this.curve._wnafMul(this, k);
};

JPoint.prototype.eq = function eq(p) {
  if (p.type === 'affine')
    return this.eq(p.toJ());

  if (this === p)
    return true;

  // x1 * z2^2 == x2 * z1^2
  var z2 = this.z.redSqr();
  var pz2 = p.z.redSqr();
  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
    return false;

  // y1 * z2^3 == y2 * z1^3
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p.z);
  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
};

JPoint.prototype.eqXToP = function eqXToP(x) {
  var zs = this.z.redSqr();
  var rx = x.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(zs);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};

JPoint.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC JPoint Infinity>';
  return '<EC JPoint x: ' + this.x.toString(16, 2) +
      ' y: ' + this.y.toString(16, 2) +
      ' z: ' + this.z.toString(16, 2) + '>';
};

JPoint.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

var BN$b = bnExports;
var inherits$3 = inheritsExports$1;
var Base$2 = base$1;

var utils$k = utils$o;

function MontCurve(conf) {
  Base$2.call(this, 'mont', conf);

  this.a = new BN$b(conf.a, 16).toRed(this.red);
  this.b = new BN$b(conf.b, 16).toRed(this.red);
  this.i4 = new BN$b(4).toRed(this.red).redInvm();
  this.two = new BN$b(2).toRed(this.red);
  this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits$3(MontCurve, Base$2);
var mont = MontCurve;

MontCurve.prototype.validate = function validate(point) {
  var x = point.normalize().x;
  var x2 = x.redSqr();
  var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
  var y = rhs.redSqrt();

  return y.redSqr().cmp(rhs) === 0;
};

function Point$2(curve, x, z) {
  Base$2.BasePoint.call(this, curve, 'projective');
  if (x === null && z === null) {
    this.x = this.curve.one;
    this.z = this.curve.zero;
  } else {
    this.x = new BN$b(x, 16);
    this.z = new BN$b(z, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
  }
}
inherits$3(Point$2, Base$2.BasePoint);

MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  return this.point(utils$k.toArray(bytes, enc), 1);
};

MontCurve.prototype.point = function point(x, z) {
  return new Point$2(this, x, z);
};

MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point$2.fromJSON(this, obj);
};

Point$2.prototype.precompute = function precompute() {
  // No-op
};

Point$2.prototype._encode = function _encode() {
  return this.getX().toArray('be', this.curve.p.byteLength());
};

Point$2.fromJSON = function fromJSON(curve, obj) {
  return new Point$2(curve, obj[0], obj[1] || curve.one);
};

Point$2.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point$2.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

Point$2.prototype.dbl = function dbl() {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
  // 2M + 2S + 4A

  // A = X1 + Z1
  var a = this.x.redAdd(this.z);
  // AA = A^2
  var aa = a.redSqr();
  // B = X1 - Z1
  var b = this.x.redSub(this.z);
  // BB = B^2
  var bb = b.redSqr();
  // C = AA - BB
  var c = aa.redSub(bb);
  // X3 = AA * BB
  var nx = aa.redMul(bb);
  // Z3 = C * (BB + A24 * C)
  var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
  return this.curve.point(nx, nz);
};

Point$2.prototype.add = function add() {
  throw new Error('Not supported on Montgomery curve');
};

Point$2.prototype.diffAdd = function diffAdd(p, diff) {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
  // 4M + 2S + 6A

  // A = X2 + Z2
  var a = this.x.redAdd(this.z);
  // B = X2 - Z2
  var b = this.x.redSub(this.z);
  // C = X3 + Z3
  var c = p.x.redAdd(p.z);
  // D = X3 - Z3
  var d = p.x.redSub(p.z);
  // DA = D * A
  var da = d.redMul(a);
  // CB = C * B
  var cb = c.redMul(b);
  // X5 = Z1 * (DA + CB)^2
  var nx = diff.z.redMul(da.redAdd(cb).redSqr());
  // Z5 = X1 * (DA - CB)^2
  var nz = diff.x.redMul(da.redISub(cb).redSqr());
  return this.curve.point(nx, nz);
};

Point$2.prototype.mul = function mul(k) {
  var t = k.clone();
  var a = this; // (N / 2) * Q + Q
  var b = this.curve.point(null, null); // (N / 2) * Q
  var c = this; // Q

  for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
    bits.push(t.andln(1));

  for (var i = bits.length - 1; i >= 0; i--) {
    if (bits[i] === 0) {
      // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
      a = a.diffAdd(b, c);
      // N * Q = 2 * ((N / 2) * Q + Q))
      b = b.dbl();
    } else {
      // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
      b = a.diffAdd(b, c);
      // N * Q + Q = 2 * ((N / 2) * Q + Q)
      a = a.dbl();
    }
  }
  return b;
};

Point$2.prototype.mulAdd = function mulAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point$2.prototype.jumlAdd = function jumlAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point$2.prototype.eq = function eq(other) {
  return this.getX().cmp(other.getX()) === 0;
};

Point$2.prototype.normalize = function normalize() {
  this.x = this.x.redMul(this.z.redInvm());
  this.z = this.curve.one;
  return this;
};

Point$2.prototype.getX = function getX() {
  // Normalize coordinates
  this.normalize();

  return this.x.fromRed();
};

var utils$j = utils$o;
var BN$a = bnExports;
var inherits$2 = inheritsExports$1;
var Base$1 = base$1;

var assert$9 = utils$j.assert;

function EdwardsCurve(conf) {
  // NOTE: Important as we are creating point in Base.call()
  this.twisted = (conf.a | 0) !== 1;
  this.mOneA = this.twisted && (conf.a | 0) === -1;
  this.extended = this.mOneA;

  Base$1.call(this, 'edwards', conf);

  this.a = new BN$a(conf.a, 16).umod(this.red.m);
  this.a = this.a.toRed(this.red);
  this.c = new BN$a(conf.c, 16).toRed(this.red);
  this.c2 = this.c.redSqr();
  this.d = new BN$a(conf.d, 16).toRed(this.red);
  this.dd = this.d.redAdd(this.d);

  assert$9(!this.twisted || this.c.fromRed().cmpn(1) === 0);
  this.oneC = (conf.c | 0) === 1;
}
inherits$2(EdwardsCurve, Base$1);
var edwards = EdwardsCurve;

EdwardsCurve.prototype._mulA = function _mulA(num) {
  if (this.mOneA)
    return num.redNeg();
  else
    return this.a.redMul(num);
};

EdwardsCurve.prototype._mulC = function _mulC(num) {
  if (this.oneC)
    return num;
  else
    return this.c.redMul(num);
};

// Just for compatibility with Short curve
EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
  return this.point(x, y, z, t);
};

EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN$a(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var x2 = x.redSqr();
  var rhs = this.c2.redSub(this.a.redMul(x2));
  var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));

  var y2 = rhs.redMul(lhs.redInvm());
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
  y = new BN$a(y, 16);
  if (!y.red)
    y = y.toRed(this.red);

  // x^2 = (y^2 - c^2) / (c^2 d y^2 - a)
  var y2 = y.redSqr();
  var lhs = y2.redSub(this.c2);
  var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
  var x2 = lhs.redMul(rhs.redInvm());

  if (x2.cmp(this.zero) === 0) {
    if (odd)
      throw new Error('invalid point');
    else
      return this.point(this.zero, y);
  }

  var x = x2.redSqrt();
  if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  if (x.fromRed().isOdd() !== odd)
    x = x.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.validate = function validate(point) {
  if (point.isInfinity())
    return true;

  // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)
  point.normalize();

  var x2 = point.x.redSqr();
  var y2 = point.y.redSqr();
  var lhs = x2.redMul(this.a).redAdd(y2);
  var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));

  return lhs.cmp(rhs) === 0;
};

function Point$1(curve, x, y, z, t) {
  Base$1.BasePoint.call(this, curve, 'projective');
  if (x === null && y === null && z === null) {
    this.x = this.curve.zero;
    this.y = this.curve.one;
    this.z = this.curve.one;
    this.t = this.curve.zero;
    this.zOne = true;
  } else {
    this.x = new BN$a(x, 16);
    this.y = new BN$a(y, 16);
    this.z = z ? new BN$a(z, 16) : this.curve.one;
    this.t = t && new BN$a(t, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
    if (this.t && !this.t.red)
      this.t = this.t.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;

    // Use extended coordinates
    if (this.curve.extended && !this.t) {
      this.t = this.x.redMul(this.y);
      if (!this.zOne)
        this.t = this.t.redMul(this.z.redInvm());
    }
  }
}
inherits$2(Point$1, Base$1.BasePoint);

EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point$1.fromJSON(this, obj);
};

EdwardsCurve.prototype.point = function point(x, y, z, t) {
  return new Point$1(this, x, y, z, t);
};

Point$1.fromJSON = function fromJSON(curve, obj) {
  return new Point$1(curve, obj[0], obj[1], obj[2]);
};

Point$1.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point$1.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.x.cmpn(0) === 0 &&
    (this.y.cmp(this.z) === 0 ||
    (this.zOne && this.y.cmp(this.curve.c) === 0));
};

Point$1.prototype._extDbl = function _extDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #doubling-dbl-2008-hwcd
  // 4M + 4S

  // A = X1^2
  var a = this.x.redSqr();
  // B = Y1^2
  var b = this.y.redSqr();
  // C = 2 * Z1^2
  var c = this.z.redSqr();
  c = c.redIAdd(c);
  // D = a * A
  var d = this.curve._mulA(a);
  // E = (X1 + Y1)^2 - A - B
  var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
  // G = D + B
  var g = d.redAdd(b);
  // F = G - C
  var f = g.redSub(c);
  // H = D - B
  var h = d.redSub(b);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point$1.prototype._projDbl = function _projDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #doubling-dbl-2008-bbjlp
  //     #doubling-dbl-2007-bl
  // and others
  // Generally 3M + 4S or 2M + 4S

  // B = (X1 + Y1)^2
  var b = this.x.redAdd(this.y).redSqr();
  // C = X1^2
  var c = this.x.redSqr();
  // D = Y1^2
  var d = this.y.redSqr();

  var nx;
  var ny;
  var nz;
  var e;
  var h;
  var j;
  if (this.curve.twisted) {
    // E = a * C
    e = this.curve._mulA(c);
    // F = E + D
    var f = e.redAdd(d);
    if (this.zOne) {
      // X3 = (B - C - D) * (F - 2)
      nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F^2 - 2 * F
      nz = f.redSqr().redSub(f).redSub(f);
    } else {
      // H = Z1^2
      h = this.z.redSqr();
      // J = F - 2 * H
      j = f.redSub(h).redISub(h);
      // X3 = (B-C-D)*J
      nx = b.redSub(c).redISub(d).redMul(j);
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F * J
      nz = f.redMul(j);
    }
  } else {
    // E = C + D
    e = c.redAdd(d);
    // H = (c * Z1)^2
    h = this.curve._mulC(this.z).redSqr();
    // J = E - 2 * H
    j = e.redSub(h).redSub(h);
    // X3 = c * (B - E) * J
    nx = this.curve._mulC(b.redISub(e)).redMul(j);
    // Y3 = c * E * (C - D)
    ny = this.curve._mulC(e).redMul(c.redISub(d));
    // Z3 = E * J
    nz = e.redMul(j);
  }
  return this.curve.point(nx, ny, nz);
};

Point$1.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  // Double in extended coordinates
  if (this.curve.extended)
    return this._extDbl();
  else
    return this._projDbl();
};

Point$1.prototype._extAdd = function _extAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #addition-add-2008-hwcd-3
  // 8M

  // A = (Y1 - X1) * (Y2 - X2)
  var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
  // B = (Y1 + X1) * (Y2 + X2)
  var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
  // C = T1 * k * T2
  var c = this.t.redMul(this.curve.dd).redMul(p.t);
  // D = Z1 * 2 * Z2
  var d = this.z.redMul(p.z.redAdd(p.z));
  // E = B - A
  var e = b.redSub(a);
  // F = D - C
  var f = d.redSub(c);
  // G = D + C
  var g = d.redAdd(c);
  // H = B + A
  var h = b.redAdd(a);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point$1.prototype._projAdd = function _projAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #addition-add-2008-bbjlp
  //     #addition-add-2007-bl
  // 10M + 1S

  // A = Z1 * Z2
  var a = this.z.redMul(p.z);
  // B = A^2
  var b = a.redSqr();
  // C = X1 * X2
  var c = this.x.redMul(p.x);
  // D = Y1 * Y2
  var d = this.y.redMul(p.y);
  // E = d * C * D
  var e = this.curve.d.redMul(c).redMul(d);
  // F = B - E
  var f = b.redSub(e);
  // G = B + E
  var g = b.redAdd(e);
  // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)
  var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
  var nx = a.redMul(f).redMul(tmp);
  var ny;
  var nz;
  if (this.curve.twisted) {
    // Y3 = A * G * (D - a * C)
    ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
    // Z3 = F * G
    nz = f.redMul(g);
  } else {
    // Y3 = A * G * (D - C)
    ny = a.redMul(g).redMul(d.redSub(c));
    // Z3 = c * F * G
    nz = this.curve._mulC(f).redMul(g);
  }
  return this.curve.point(nx, ny, nz);
};

Point$1.prototype.add = function add(p) {
  if (this.isInfinity())
    return p;
  if (p.isInfinity())
    return this;

  if (this.curve.extended)
    return this._extAdd(p);
  else
    return this._projAdd(p);
};

Point$1.prototype.mul = function mul(k) {
  if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else
    return this.curve._wnafMul(this, k);
};

Point$1.prototype.mulAdd = function mulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, false);
};

Point$1.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, true);
};

Point$1.prototype.normalize = function normalize() {
  if (this.zOne)
    return this;

  // Normalize coordinates
  var zi = this.z.redInvm();
  this.x = this.x.redMul(zi);
  this.y = this.y.redMul(zi);
  if (this.t)
    this.t = this.t.redMul(zi);
  this.z = this.curve.one;
  this.zOne = true;
  return this;
};

Point$1.prototype.neg = function neg() {
  return this.curve.point(this.x.redNeg(),
    this.y,
    this.z,
    this.t && this.t.redNeg());
};

Point$1.prototype.getX = function getX() {
  this.normalize();
  return this.x.fromRed();
};

Point$1.prototype.getY = function getY() {
  this.normalize();
  return this.y.fromRed();
};

Point$1.prototype.eq = function eq(other) {
  return this === other ||
         this.getX().cmp(other.getX()) === 0 &&
         this.getY().cmp(other.getY()) === 0;
};

Point$1.prototype.eqXToP = function eqXToP(x) {
  var rx = x.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(this.z);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};

// Compatibility with BaseCurve
Point$1.prototype.toP = Point$1.prototype.normalize;
Point$1.prototype.mixedAdd = Point$1.prototype.add;

(function (exports) {

	var curve = exports;

	curve.base = base$1;
	curve.short = short;
	curve.mont = mont;
	curve.edwards = edwards; 
} (curve));

var curves$2 = {};

var hash$4 = {};

var utils$i = {};

var hasRequiredUtils;

function requireUtils () {
	if (hasRequiredUtils) return utils$i;
	hasRequiredUtils = 1;

	var assert = minimalisticAssert;
	var inherits = inheritsExports$1;

	utils$i.inherits = inherits;

	function isSurrogatePair(msg, i) {
	  if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {
	    return false;
	  }
	  if (i < 0 || i + 1 >= msg.length) {
	    return false;
	  }
	  return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;
	}

	function toArray(msg, enc) {
	  if (Array.isArray(msg))
	    return msg.slice();
	  if (!msg)
	    return [];
	  var res = [];
	  if (typeof msg === 'string') {
	    if (!enc) {
	      // Inspired by stringToUtf8ByteArray() in closure-library by Google
	      // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143
	      // Apache License 2.0
	      // https://github.com/google/closure-library/blob/master/LICENSE
	      var p = 0;
	      for (var i = 0; i < msg.length; i++) {
	        var c = msg.charCodeAt(i);
	        if (c < 128) {
	          res[p++] = c;
	        } else if (c < 2048) {
	          res[p++] = (c >> 6) | 192;
	          res[p++] = (c & 63) | 128;
	        } else if (isSurrogatePair(msg, i)) {
	          c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);
	          res[p++] = (c >> 18) | 240;
	          res[p++] = ((c >> 12) & 63) | 128;
	          res[p++] = ((c >> 6) & 63) | 128;
	          res[p++] = (c & 63) | 128;
	        } else {
	          res[p++] = (c >> 12) | 224;
	          res[p++] = ((c >> 6) & 63) | 128;
	          res[p++] = (c & 63) | 128;
	        }
	      }
	    } else if (enc === 'hex') {
	      msg = msg.replace(/[^a-z0-9]+/ig, '');
	      if (msg.length % 2 !== 0)
	        msg = '0' + msg;
	      for (i = 0; i < msg.length; i += 2)
	        res.push(parseInt(msg[i] + msg[i + 1], 16));
	    }
	  } else {
	    for (i = 0; i < msg.length; i++)
	      res[i] = msg[i] | 0;
	  }
	  return res;
	}
	utils$i.toArray = toArray;

	function toHex(msg) {
	  var res = '';
	  for (var i = 0; i < msg.length; i++)
	    res += zero2(msg[i].toString(16));
	  return res;
	}
	utils$i.toHex = toHex;

	function htonl(w) {
	  var res = (w >>> 24) |
	            ((w >>> 8) & 0xff00) |
	            ((w << 8) & 0xff0000) |
	            ((w & 0xff) << 24);
	  return res >>> 0;
	}
	utils$i.htonl = htonl;

	function toHex32(msg, endian) {
	  var res = '';
	  for (var i = 0; i < msg.length; i++) {
	    var w = msg[i];
	    if (endian === 'little')
	      w = htonl(w);
	    res += zero8(w.toString(16));
	  }
	  return res;
	}
	utils$i.toHex32 = toHex32;

	function zero2(word) {
	  if (word.length === 1)
	    return '0' + word;
	  else
	    return word;
	}
	utils$i.zero2 = zero2;

	function zero8(word) {
	  if (word.length === 7)
	    return '0' + word;
	  else if (word.length === 6)
	    return '00' + word;
	  else if (word.length === 5)
	    return '000' + word;
	  else if (word.length === 4)
	    return '0000' + word;
	  else if (word.length === 3)
	    return '00000' + word;
	  else if (word.length === 2)
	    return '000000' + word;
	  else if (word.length === 1)
	    return '0000000' + word;
	  else
	    return word;
	}
	utils$i.zero8 = zero8;

	function join32(msg, start, end, endian) {
	  var len = end - start;
	  assert(len % 4 === 0);
	  var res = new Array(len / 4);
	  for (var i = 0, k = start; i < res.length; i++, k += 4) {
	    var w;
	    if (endian === 'big')
	      w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
	    else
	      w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
	    res[i] = w >>> 0;
	  }
	  return res;
	}
	utils$i.join32 = join32;

	function split32(msg, endian) {
	  var res = new Array(msg.length * 4);
	  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
	    var m = msg[i];
	    if (endian === 'big') {
	      res[k] = m >>> 24;
	      res[k + 1] = (m >>> 16) & 0xff;
	      res[k + 2] = (m >>> 8) & 0xff;
	      res[k + 3] = m & 0xff;
	    } else {
	      res[k + 3] = m >>> 24;
	      res[k + 2] = (m >>> 16) & 0xff;
	      res[k + 1] = (m >>> 8) & 0xff;
	      res[k] = m & 0xff;
	    }
	  }
	  return res;
	}
	utils$i.split32 = split32;

	function rotr32(w, b) {
	  return (w >>> b) | (w << (32 - b));
	}
	utils$i.rotr32 = rotr32;

	function rotl32(w, b) {
	  return (w << b) | (w >>> (32 - b));
	}
	utils$i.rotl32 = rotl32;

	function sum32(a, b) {
	  return (a + b) >>> 0;
	}
	utils$i.sum32 = sum32;

	function sum32_3(a, b, c) {
	  return (a + b + c) >>> 0;
	}
	utils$i.sum32_3 = sum32_3;

	function sum32_4(a, b, c, d) {
	  return (a + b + c + d) >>> 0;
	}
	utils$i.sum32_4 = sum32_4;

	function sum32_5(a, b, c, d, e) {
	  return (a + b + c + d + e) >>> 0;
	}
	utils$i.sum32_5 = sum32_5;

	function sum64(buf, pos, ah, al) {
	  var bh = buf[pos];
	  var bl = buf[pos + 1];

	  var lo = (al + bl) >>> 0;
	  var hi = (lo < al ? 1 : 0) + ah + bh;
	  buf[pos] = hi >>> 0;
	  buf[pos + 1] = lo;
	}
	utils$i.sum64 = sum64;

	function sum64_hi(ah, al, bh, bl) {
	  var lo = (al + bl) >>> 0;
	  var hi = (lo < al ? 1 : 0) + ah + bh;
	  return hi >>> 0;
	}
	utils$i.sum64_hi = sum64_hi;

	function sum64_lo(ah, al, bh, bl) {
	  var lo = al + bl;
	  return lo >>> 0;
	}
	utils$i.sum64_lo = sum64_lo;

	function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
	  var carry = 0;
	  var lo = al;
	  lo = (lo + bl) >>> 0;
	  carry += lo < al ? 1 : 0;
	  lo = (lo + cl) >>> 0;
	  carry += lo < cl ? 1 : 0;
	  lo = (lo + dl) >>> 0;
	  carry += lo < dl ? 1 : 0;

	  var hi = ah + bh + ch + dh + carry;
	  return hi >>> 0;
	}
	utils$i.sum64_4_hi = sum64_4_hi;

	function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
	  var lo = al + bl + cl + dl;
	  return lo >>> 0;
	}
	utils$i.sum64_4_lo = sum64_4_lo;

	function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
	  var carry = 0;
	  var lo = al;
	  lo = (lo + bl) >>> 0;
	  carry += lo < al ? 1 : 0;
	  lo = (lo + cl) >>> 0;
	  carry += lo < cl ? 1 : 0;
	  lo = (lo + dl) >>> 0;
	  carry += lo < dl ? 1 : 0;
	  lo = (lo + el) >>> 0;
	  carry += lo < el ? 1 : 0;

	  var hi = ah + bh + ch + dh + eh + carry;
	  return hi >>> 0;
	}
	utils$i.sum64_5_hi = sum64_5_hi;

	function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
	  var lo = al + bl + cl + dl + el;

	  return lo >>> 0;
	}
	utils$i.sum64_5_lo = sum64_5_lo;

	function rotr64_hi(ah, al, num) {
	  var r = (al << (32 - num)) | (ah >>> num);
	  return r >>> 0;
	}
	utils$i.rotr64_hi = rotr64_hi;

	function rotr64_lo(ah, al, num) {
	  var r = (ah << (32 - num)) | (al >>> num);
	  return r >>> 0;
	}
	utils$i.rotr64_lo = rotr64_lo;

	function shr64_hi(ah, al, num) {
	  return ah >>> num;
	}
	utils$i.shr64_hi = shr64_hi;

	function shr64_lo(ah, al, num) {
	  var r = (ah << (32 - num)) | (al >>> num);
	  return r >>> 0;
	}
	utils$i.shr64_lo = shr64_lo;
	return utils$i;
}

var common$2 = {};

var hasRequiredCommon$2;

function requireCommon$2 () {
	if (hasRequiredCommon$2) return common$2;
	hasRequiredCommon$2 = 1;

	var utils = requireUtils();
	var assert = minimalisticAssert;

	function BlockHash() {
	  this.pending = null;
	  this.pendingTotal = 0;
	  this.blockSize = this.constructor.blockSize;
	  this.outSize = this.constructor.outSize;
	  this.hmacStrength = this.constructor.hmacStrength;
	  this.padLength = this.constructor.padLength / 8;
	  this.endian = 'big';

	  this._delta8 = this.blockSize / 8;
	  this._delta32 = this.blockSize / 32;
	}
	common$2.BlockHash = BlockHash;

	BlockHash.prototype.update = function update(msg, enc) {
	  // Convert message to array, pad it, and join into 32bit blocks
	  msg = utils.toArray(msg, enc);
	  if (!this.pending)
	    this.pending = msg;
	  else
	    this.pending = this.pending.concat(msg);
	  this.pendingTotal += msg.length;

	  // Enough data, try updating
	  if (this.pending.length >= this._delta8) {
	    msg = this.pending;

	    // Process pending data in blocks
	    var r = msg.length % this._delta8;
	    this.pending = msg.slice(msg.length - r, msg.length);
	    if (this.pending.length === 0)
	      this.pending = null;

	    msg = utils.join32(msg, 0, msg.length - r, this.endian);
	    for (var i = 0; i < msg.length; i += this._delta32)
	      this._update(msg, i, i + this._delta32);
	  }

	  return this;
	};

	BlockHash.prototype.digest = function digest(enc) {
	  this.update(this._pad());
	  assert(this.pending === null);

	  return this._digest(enc);
	};

	BlockHash.prototype._pad = function pad() {
	  var len = this.pendingTotal;
	  var bytes = this._delta8;
	  var k = bytes - ((len + this.padLength) % bytes);
	  var res = new Array(k + this.padLength);
	  res[0] = 0x80;
	  for (var i = 1; i < k; i++)
	    res[i] = 0;

	  // Append length
	  len <<= 3;
	  if (this.endian === 'big') {
	    for (var t = 8; t < this.padLength; t++)
	      res[i++] = 0;

	    res[i++] = 0;
	    res[i++] = 0;
	    res[i++] = 0;
	    res[i++] = 0;
	    res[i++] = (len >>> 24) & 0xff;
	    res[i++] = (len >>> 16) & 0xff;
	    res[i++] = (len >>> 8) & 0xff;
	    res[i++] = len & 0xff;
	  } else {
	    res[i++] = len & 0xff;
	    res[i++] = (len >>> 8) & 0xff;
	    res[i++] = (len >>> 16) & 0xff;
	    res[i++] = (len >>> 24) & 0xff;
	    res[i++] = 0;
	    res[i++] = 0;
	    res[i++] = 0;
	    res[i++] = 0;

	    for (t = 8; t < this.padLength; t++)
	      res[i++] = 0;
	  }

	  return res;
	};
	return common$2;
}

var sha = {};

var common$1 = {};

var hasRequiredCommon$1;

function requireCommon$1 () {
	if (hasRequiredCommon$1) return common$1;
	hasRequiredCommon$1 = 1;

	var utils = requireUtils();
	var rotr32 = utils.rotr32;

	function ft_1(s, x, y, z) {
	  if (s === 0)
	    return ch32(x, y, z);
	  if (s === 1 || s === 3)
	    return p32(x, y, z);
	  if (s === 2)
	    return maj32(x, y, z);
	}
	common$1.ft_1 = ft_1;

	function ch32(x, y, z) {
	  return (x & y) ^ ((~x) & z);
	}
	common$1.ch32 = ch32;

	function maj32(x, y, z) {
	  return (x & y) ^ (x & z) ^ (y & z);
	}
	common$1.maj32 = maj32;

	function p32(x, y, z) {
	  return x ^ y ^ z;
	}
	common$1.p32 = p32;

	function s0_256(x) {
	  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
	}
	common$1.s0_256 = s0_256;

	function s1_256(x) {
	  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
	}
	common$1.s1_256 = s1_256;

	function g0_256(x) {
	  return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);
	}
	common$1.g0_256 = g0_256;

	function g1_256(x) {
	  return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);
	}
	common$1.g1_256 = g1_256;
	return common$1;
}

var _1;
var hasRequired_1;

function require_1 () {
	if (hasRequired_1) return _1;
	hasRequired_1 = 1;

	var utils = requireUtils();
	var common = requireCommon$2();
	var shaCommon = requireCommon$1();

	var rotl32 = utils.rotl32;
	var sum32 = utils.sum32;
	var sum32_5 = utils.sum32_5;
	var ft_1 = shaCommon.ft_1;
	var BlockHash = common.BlockHash;

	var sha1_K = [
	  0x5A827999, 0x6ED9EBA1,
	  0x8F1BBCDC, 0xCA62C1D6
	];

	function SHA1() {
	  if (!(this instanceof SHA1))
	    return new SHA1();

	  BlockHash.call(this);
	  this.h = [
	    0x67452301, 0xefcdab89, 0x98badcfe,
	    0x10325476, 0xc3d2e1f0 ];
	  this.W = new Array(80);
	}

	utils.inherits(SHA1, BlockHash);
	_1 = SHA1;

	SHA1.blockSize = 512;
	SHA1.outSize = 160;
	SHA1.hmacStrength = 80;
	SHA1.padLength = 64;

	SHA1.prototype._update = function _update(msg, start) {
	  var W = this.W;

	  for (var i = 0; i < 16; i++)
	    W[i] = msg[start + i];

	  for(; i < W.length; i++)
	    W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

	  var a = this.h[0];
	  var b = this.h[1];
	  var c = this.h[2];
	  var d = this.h[3];
	  var e = this.h[4];

	  for (i = 0; i < W.length; i++) {
	    var s = ~~(i / 20);
	    var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
	    e = d;
	    d = c;
	    c = rotl32(b, 30);
	    b = a;
	    a = t;
	  }

	  this.h[0] = sum32(this.h[0], a);
	  this.h[1] = sum32(this.h[1], b);
	  this.h[2] = sum32(this.h[2], c);
	  this.h[3] = sum32(this.h[3], d);
	  this.h[4] = sum32(this.h[4], e);
	};

	SHA1.prototype._digest = function digest(enc) {
	  if (enc === 'hex')
	    return utils.toHex32(this.h, 'big');
	  else
	    return utils.split32(this.h, 'big');
	};
	return _1;
}

var _256;
var hasRequired_256;

function require_256 () {
	if (hasRequired_256) return _256;
	hasRequired_256 = 1;

	var utils = requireUtils();
	var common = requireCommon$2();
	var shaCommon = requireCommon$1();
	var assert = minimalisticAssert;

	var sum32 = utils.sum32;
	var sum32_4 = utils.sum32_4;
	var sum32_5 = utils.sum32_5;
	var ch32 = shaCommon.ch32;
	var maj32 = shaCommon.maj32;
	var s0_256 = shaCommon.s0_256;
	var s1_256 = shaCommon.s1_256;
	var g0_256 = shaCommon.g0_256;
	var g1_256 = shaCommon.g1_256;

	var BlockHash = common.BlockHash;

	var sha256_K = [
	  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
	  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
	  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
	  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
	  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
	  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
	  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
	  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
	  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
	  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
	  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
	  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
	  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
	  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
	  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
	  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
	];

	function SHA256() {
	  if (!(this instanceof SHA256))
	    return new SHA256();

	  BlockHash.call(this);
	  this.h = [
	    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
	    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
	  ];
	  this.k = sha256_K;
	  this.W = new Array(64);
	}
	utils.inherits(SHA256, BlockHash);
	_256 = SHA256;

	SHA256.blockSize = 512;
	SHA256.outSize = 256;
	SHA256.hmacStrength = 192;
	SHA256.padLength = 64;

	SHA256.prototype._update = function _update(msg, start) {
	  var W = this.W;

	  for (var i = 0; i < 16; i++)
	    W[i] = msg[start + i];
	  for (; i < W.length; i++)
	    W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);

	  var a = this.h[0];
	  var b = this.h[1];
	  var c = this.h[2];
	  var d = this.h[3];
	  var e = this.h[4];
	  var f = this.h[5];
	  var g = this.h[6];
	  var h = this.h[7];

	  assert(this.k.length === W.length);
	  for (i = 0; i < W.length; i++) {
	    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
	    var T2 = sum32(s0_256(a), maj32(a, b, c));
	    h = g;
	    g = f;
	    f = e;
	    e = sum32(d, T1);
	    d = c;
	    c = b;
	    b = a;
	    a = sum32(T1, T2);
	  }

	  this.h[0] = sum32(this.h[0], a);
	  this.h[1] = sum32(this.h[1], b);
	  this.h[2] = sum32(this.h[2], c);
	  this.h[3] = sum32(this.h[3], d);
	  this.h[4] = sum32(this.h[4], e);
	  this.h[5] = sum32(this.h[5], f);
	  this.h[6] = sum32(this.h[6], g);
	  this.h[7] = sum32(this.h[7], h);
	};

	SHA256.prototype._digest = function digest(enc) {
	  if (enc === 'hex')
	    return utils.toHex32(this.h, 'big');
	  else
	    return utils.split32(this.h, 'big');
	};
	return _256;
}

var _224;
var hasRequired_224;

function require_224 () {
	if (hasRequired_224) return _224;
	hasRequired_224 = 1;

	var utils = requireUtils();
	var SHA256 = require_256();

	function SHA224() {
	  if (!(this instanceof SHA224))
	    return new SHA224();

	  SHA256.call(this);
	  this.h = [
	    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
	    0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4 ];
	}
	utils.inherits(SHA224, SHA256);
	_224 = SHA224;

	SHA224.blockSize = 512;
	SHA224.outSize = 224;
	SHA224.hmacStrength = 192;
	SHA224.padLength = 64;

	SHA224.prototype._digest = function digest(enc) {
	  // Just truncate output
	  if (enc === 'hex')
	    return utils.toHex32(this.h.slice(0, 7), 'big');
	  else
	    return utils.split32(this.h.slice(0, 7), 'big');
	};
	return _224;
}

var _512;
var hasRequired_512;

function require_512 () {
	if (hasRequired_512) return _512;
	hasRequired_512 = 1;

	var utils = requireUtils();
	var common = requireCommon$2();
	var assert = minimalisticAssert;

	var rotr64_hi = utils.rotr64_hi;
	var rotr64_lo = utils.rotr64_lo;
	var shr64_hi = utils.shr64_hi;
	var shr64_lo = utils.shr64_lo;
	var sum64 = utils.sum64;
	var sum64_hi = utils.sum64_hi;
	var sum64_lo = utils.sum64_lo;
	var sum64_4_hi = utils.sum64_4_hi;
	var sum64_4_lo = utils.sum64_4_lo;
	var sum64_5_hi = utils.sum64_5_hi;
	var sum64_5_lo = utils.sum64_5_lo;

	var BlockHash = common.BlockHash;

	var sha512_K = [
	  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
	  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
	  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
	  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
	  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
	  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
	  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
	  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
	  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
	  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
	  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
	  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
	  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
	  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
	  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
	  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
	  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
	  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
	  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
	  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
	  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
	  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
	  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
	  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
	  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
	  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
	  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
	  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
	  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
	  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
	  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
	  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
	  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
	  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
	  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
	  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
	  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
	  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
	  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
	  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
	];

	function SHA512() {
	  if (!(this instanceof SHA512))
	    return new SHA512();

	  BlockHash.call(this);
	  this.h = [
	    0x6a09e667, 0xf3bcc908,
	    0xbb67ae85, 0x84caa73b,
	    0x3c6ef372, 0xfe94f82b,
	    0xa54ff53a, 0x5f1d36f1,
	    0x510e527f, 0xade682d1,
	    0x9b05688c, 0x2b3e6c1f,
	    0x1f83d9ab, 0xfb41bd6b,
	    0x5be0cd19, 0x137e2179 ];
	  this.k = sha512_K;
	  this.W = new Array(160);
	}
	utils.inherits(SHA512, BlockHash);
	_512 = SHA512;

	SHA512.blockSize = 1024;
	SHA512.outSize = 512;
	SHA512.hmacStrength = 192;
	SHA512.padLength = 128;

	SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
	  var W = this.W;

	  // 32 x 32bit words
	  for (var i = 0; i < 32; i++)
	    W[i] = msg[start + i];
	  for (; i < W.length; i += 2) {
	    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2
	    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
	    var c1_hi = W[i - 14];  // i - 7
	    var c1_lo = W[i - 13];
	    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15
	    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
	    var c3_hi = W[i - 32];  // i - 16
	    var c3_lo = W[i - 31];

	    W[i] = sum64_4_hi(
	      c0_hi, c0_lo,
	      c1_hi, c1_lo,
	      c2_hi, c2_lo,
	      c3_hi, c3_lo);
	    W[i + 1] = sum64_4_lo(
	      c0_hi, c0_lo,
	      c1_hi, c1_lo,
	      c2_hi, c2_lo,
	      c3_hi, c3_lo);
	  }
	};

	SHA512.prototype._update = function _update(msg, start) {
	  this._prepareBlock(msg, start);

	  var W = this.W;

	  var ah = this.h[0];
	  var al = this.h[1];
	  var bh = this.h[2];
	  var bl = this.h[3];
	  var ch = this.h[4];
	  var cl = this.h[5];
	  var dh = this.h[6];
	  var dl = this.h[7];
	  var eh = this.h[8];
	  var el = this.h[9];
	  var fh = this.h[10];
	  var fl = this.h[11];
	  var gh = this.h[12];
	  var gl = this.h[13];
	  var hh = this.h[14];
	  var hl = this.h[15];

	  assert(this.k.length === W.length);
	  for (var i = 0; i < W.length; i += 2) {
	    var c0_hi = hh;
	    var c0_lo = hl;
	    var c1_hi = s1_512_hi(eh, el);
	    var c1_lo = s1_512_lo(eh, el);
	    var c2_hi = ch64_hi(eh, el, fh, fl, gh);
	    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
	    var c3_hi = this.k[i];
	    var c3_lo = this.k[i + 1];
	    var c4_hi = W[i];
	    var c4_lo = W[i + 1];

	    var T1_hi = sum64_5_hi(
	      c0_hi, c0_lo,
	      c1_hi, c1_lo,
	      c2_hi, c2_lo,
	      c3_hi, c3_lo,
	      c4_hi, c4_lo);
	    var T1_lo = sum64_5_lo(
	      c0_hi, c0_lo,
	      c1_hi, c1_lo,
	      c2_hi, c2_lo,
	      c3_hi, c3_lo,
	      c4_hi, c4_lo);

	    c0_hi = s0_512_hi(ah, al);
	    c0_lo = s0_512_lo(ah, al);
	    c1_hi = maj64_hi(ah, al, bh, bl, ch);
	    c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);

	    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
	    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);

	    hh = gh;
	    hl = gl;

	    gh = fh;
	    gl = fl;

	    fh = eh;
	    fl = el;

	    eh = sum64_hi(dh, dl, T1_hi, T1_lo);
	    el = sum64_lo(dl, dl, T1_hi, T1_lo);

	    dh = ch;
	    dl = cl;

	    ch = bh;
	    cl = bl;

	    bh = ah;
	    bl = al;

	    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
	    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
	  }

	  sum64(this.h, 0, ah, al);
	  sum64(this.h, 2, bh, bl);
	  sum64(this.h, 4, ch, cl);
	  sum64(this.h, 6, dh, dl);
	  sum64(this.h, 8, eh, el);
	  sum64(this.h, 10, fh, fl);
	  sum64(this.h, 12, gh, gl);
	  sum64(this.h, 14, hh, hl);
	};

	SHA512.prototype._digest = function digest(enc) {
	  if (enc === 'hex')
	    return utils.toHex32(this.h, 'big');
	  else
	    return utils.split32(this.h, 'big');
	};

	function ch64_hi(xh, xl, yh, yl, zh) {
	  var r = (xh & yh) ^ ((~xh) & zh);
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function ch64_lo(xh, xl, yh, yl, zh, zl) {
	  var r = (xl & yl) ^ ((~xl) & zl);
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function maj64_hi(xh, xl, yh, yl, zh) {
	  var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function maj64_lo(xh, xl, yh, yl, zh, zl) {
	  var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function s0_512_hi(xh, xl) {
	  var c0_hi = rotr64_hi(xh, xl, 28);
	  var c1_hi = rotr64_hi(xl, xh, 2);  // 34
	  var c2_hi = rotr64_hi(xl, xh, 7);  // 39

	  var r = c0_hi ^ c1_hi ^ c2_hi;
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function s0_512_lo(xh, xl) {
	  var c0_lo = rotr64_lo(xh, xl, 28);
	  var c1_lo = rotr64_lo(xl, xh, 2);  // 34
	  var c2_lo = rotr64_lo(xl, xh, 7);  // 39

	  var r = c0_lo ^ c1_lo ^ c2_lo;
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function s1_512_hi(xh, xl) {
	  var c0_hi = rotr64_hi(xh, xl, 14);
	  var c1_hi = rotr64_hi(xh, xl, 18);
	  var c2_hi = rotr64_hi(xl, xh, 9);  // 41

	  var r = c0_hi ^ c1_hi ^ c2_hi;
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function s1_512_lo(xh, xl) {
	  var c0_lo = rotr64_lo(xh, xl, 14);
	  var c1_lo = rotr64_lo(xh, xl, 18);
	  var c2_lo = rotr64_lo(xl, xh, 9);  // 41

	  var r = c0_lo ^ c1_lo ^ c2_lo;
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function g0_512_hi(xh, xl) {
	  var c0_hi = rotr64_hi(xh, xl, 1);
	  var c1_hi = rotr64_hi(xh, xl, 8);
	  var c2_hi = shr64_hi(xh, xl, 7);

	  var r = c0_hi ^ c1_hi ^ c2_hi;
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function g0_512_lo(xh, xl) {
	  var c0_lo = rotr64_lo(xh, xl, 1);
	  var c1_lo = rotr64_lo(xh, xl, 8);
	  var c2_lo = shr64_lo(xh, xl, 7);

	  var r = c0_lo ^ c1_lo ^ c2_lo;
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function g1_512_hi(xh, xl) {
	  var c0_hi = rotr64_hi(xh, xl, 19);
	  var c1_hi = rotr64_hi(xl, xh, 29);  // 61
	  var c2_hi = shr64_hi(xh, xl, 6);

	  var r = c0_hi ^ c1_hi ^ c2_hi;
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function g1_512_lo(xh, xl) {
	  var c0_lo = rotr64_lo(xh, xl, 19);
	  var c1_lo = rotr64_lo(xl, xh, 29);  // 61
	  var c2_lo = shr64_lo(xh, xl, 6);

	  var r = c0_lo ^ c1_lo ^ c2_lo;
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}
	return _512;
}

var _384;
var hasRequired_384;

function require_384 () {
	if (hasRequired_384) return _384;
	hasRequired_384 = 1;

	var utils = requireUtils();

	var SHA512 = require_512();

	function SHA384() {
	  if (!(this instanceof SHA384))
	    return new SHA384();

	  SHA512.call(this);
	  this.h = [
	    0xcbbb9d5d, 0xc1059ed8,
	    0x629a292a, 0x367cd507,
	    0x9159015a, 0x3070dd17,
	    0x152fecd8, 0xf70e5939,
	    0x67332667, 0xffc00b31,
	    0x8eb44a87, 0x68581511,
	    0xdb0c2e0d, 0x64f98fa7,
	    0x47b5481d, 0xbefa4fa4 ];
	}
	utils.inherits(SHA384, SHA512);
	_384 = SHA384;

	SHA384.blockSize = 1024;
	SHA384.outSize = 384;
	SHA384.hmacStrength = 192;
	SHA384.padLength = 128;

	SHA384.prototype._digest = function digest(enc) {
	  if (enc === 'hex')
	    return utils.toHex32(this.h.slice(0, 12), 'big');
	  else
	    return utils.split32(this.h.slice(0, 12), 'big');
	};
	return _384;
}

var hasRequiredSha;

function requireSha () {
	if (hasRequiredSha) return sha;
	hasRequiredSha = 1;

	sha.sha1 = require_1();
	sha.sha224 = require_224();
	sha.sha256 = require_256();
	sha.sha384 = require_384();
	sha.sha512 = require_512();
	return sha;
}

var ripemd = {};

var hasRequiredRipemd;

function requireRipemd () {
	if (hasRequiredRipemd) return ripemd;
	hasRequiredRipemd = 1;

	var utils = requireUtils();
	var common = requireCommon$2();

	var rotl32 = utils.rotl32;
	var sum32 = utils.sum32;
	var sum32_3 = utils.sum32_3;
	var sum32_4 = utils.sum32_4;
	var BlockHash = common.BlockHash;

	function RIPEMD160() {
	  if (!(this instanceof RIPEMD160))
	    return new RIPEMD160();

	  BlockHash.call(this);

	  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];
	  this.endian = 'little';
	}
	utils.inherits(RIPEMD160, BlockHash);
	ripemd.ripemd160 = RIPEMD160;

	RIPEMD160.blockSize = 512;
	RIPEMD160.outSize = 160;
	RIPEMD160.hmacStrength = 192;
	RIPEMD160.padLength = 64;

	RIPEMD160.prototype._update = function update(msg, start) {
	  var A = this.h[0];
	  var B = this.h[1];
	  var C = this.h[2];
	  var D = this.h[3];
	  var E = this.h[4];
	  var Ah = A;
	  var Bh = B;
	  var Ch = C;
	  var Dh = D;
	  var Eh = E;
	  for (var j = 0; j < 80; j++) {
	    var T = sum32(
	      rotl32(
	        sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
	        s[j]),
	      E);
	    A = E;
	    E = D;
	    D = rotl32(C, 10);
	    C = B;
	    B = T;
	    T = sum32(
	      rotl32(
	        sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
	        sh[j]),
	      Eh);
	    Ah = Eh;
	    Eh = Dh;
	    Dh = rotl32(Ch, 10);
	    Ch = Bh;
	    Bh = T;
	  }
	  T = sum32_3(this.h[1], C, Dh);
	  this.h[1] = sum32_3(this.h[2], D, Eh);
	  this.h[2] = sum32_3(this.h[3], E, Ah);
	  this.h[3] = sum32_3(this.h[4], A, Bh);
	  this.h[4] = sum32_3(this.h[0], B, Ch);
	  this.h[0] = T;
	};

	RIPEMD160.prototype._digest = function digest(enc) {
	  if (enc === 'hex')
	    return utils.toHex32(this.h, 'little');
	  else
	    return utils.split32(this.h, 'little');
	};

	function f(j, x, y, z) {
	  if (j <= 15)
	    return x ^ y ^ z;
	  else if (j <= 31)
	    return (x & y) | ((~x) & z);
	  else if (j <= 47)
	    return (x | (~y)) ^ z;
	  else if (j <= 63)
	    return (x & z) | (y & (~z));
	  else
	    return x ^ (y | (~z));
	}

	function K(j) {
	  if (j <= 15)
	    return 0x00000000;
	  else if (j <= 31)
	    return 0x5a827999;
	  else if (j <= 47)
	    return 0x6ed9eba1;
	  else if (j <= 63)
	    return 0x8f1bbcdc;
	  else
	    return 0xa953fd4e;
	}

	function Kh(j) {
	  if (j <= 15)
	    return 0x50a28be6;
	  else if (j <= 31)
	    return 0x5c4dd124;
	  else if (j <= 47)
	    return 0x6d703ef3;
	  else if (j <= 63)
	    return 0x7a6d76e9;
	  else
	    return 0x00000000;
	}

	var r = [
	  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
	  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
	  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
	  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
	  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
	];

	var rh = [
	  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
	  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
	  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
	  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
	  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
	];

	var s = [
	  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
	  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
	  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
	  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
	  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
	];

	var sh = [
	  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
	  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
	  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
	  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
	  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
	];
	return ripemd;
}

var hmac$2;
var hasRequiredHmac$1;

function requireHmac$1 () {
	if (hasRequiredHmac$1) return hmac$2;
	hasRequiredHmac$1 = 1;

	var utils = requireUtils();
	var assert = minimalisticAssert;

	function Hmac(hash, key, enc) {
	  if (!(this instanceof Hmac))
	    return new Hmac(hash, key, enc);
	  this.Hash = hash;
	  this.blockSize = hash.blockSize / 8;
	  this.outSize = hash.outSize / 8;
	  this.inner = null;
	  this.outer = null;

	  this._init(utils.toArray(key, enc));
	}
	hmac$2 = Hmac;

	Hmac.prototype._init = function init(key) {
	  // Shorten key, if needed
	  if (key.length > this.blockSize)
	    key = new this.Hash().update(key).digest();
	  assert(key.length <= this.blockSize);

	  // Add padding to key
	  for (var i = key.length; i < this.blockSize; i++)
	    key.push(0);

	  for (i = 0; i < key.length; i++)
	    key[i] ^= 0x36;
	  this.inner = new this.Hash().update(key);

	  // 0x36 ^ 0x5c = 0x6a
	  for (i = 0; i < key.length; i++)
	    key[i] ^= 0x6a;
	  this.outer = new this.Hash().update(key);
	};

	Hmac.prototype.update = function update(msg, enc) {
	  this.inner.update(msg, enc);
	  return this;
	};

	Hmac.prototype.digest = function digest(enc) {
	  this.outer.update(this.inner.digest());
	  return this.outer.digest(enc);
	};
	return hmac$2;
}

var hasRequiredHash;

function requireHash () {
	if (hasRequiredHash) return hash$4;
	hasRequiredHash = 1;
	(function (exports) {
		var hash = exports;

		hash.utils = requireUtils();
		hash.common = requireCommon$2();
		hash.sha = requireSha();
		hash.ripemd = requireRipemd();
		hash.hmac = requireHmac$1();

		// Proxy hash functions to the main object
		hash.sha1 = hash.sha.sha1;
		hash.sha256 = hash.sha.sha256;
		hash.sha224 = hash.sha.sha224;
		hash.sha384 = hash.sha.sha384;
		hash.sha512 = hash.sha.sha512;
		hash.ripemd160 = hash.ripemd.ripemd160; 
	} (hash$4));
	return hash$4;
}

var secp256k1;
var hasRequiredSecp256k1;

function requireSecp256k1 () {
	if (hasRequiredSecp256k1) return secp256k1;
	hasRequiredSecp256k1 = 1;
	secp256k1 = {
	  doubles: {
	    step: 4,
	    points: [
	      [
	        'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',
	        'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821',
	      ],
	      [
	        '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',
	        '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf',
	      ],
	      [
	        '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',
	        'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695',
	      ],
	      [
	        '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',
	        '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9',
	      ],
	      [
	        '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',
	        '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36',
	      ],
	      [
	        '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',
	        '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f',
	      ],
	      [
	        'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',
	        '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999',
	      ],
	      [
	        '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',
	        'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09',
	      ],
	      [
	        'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',
	        '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d',
	      ],
	      [
	        'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',
	        'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088',
	      ],
	      [
	        'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',
	        '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d',
	      ],
	      [
	        '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',
	        '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8',
	      ],
	      [
	        '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',
	        '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a',
	      ],
	      [
	        '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',
	        '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453',
	      ],
	      [
	        '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',
	        '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160',
	      ],
	      [
	        '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',
	        '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0',
	      ],
	      [
	        '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',
	        '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6',
	      ],
	      [
	        '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',
	        '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589',
	      ],
	      [
	        '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',
	        'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17',
	      ],
	      [
	        'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',
	        '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda',
	      ],
	      [
	        'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',
	        '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd',
	      ],
	      [
	        '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',
	        '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2',
	      ],
	      [
	        '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',
	        '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6',
	      ],
	      [
	        'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',
	        '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f',
	      ],
	      [
	        '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',
	        'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01',
	      ],
	      [
	        'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',
	        '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3',
	      ],
	      [
	        'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',
	        'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f',
	      ],
	      [
	        'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',
	        '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7',
	      ],
	      [
	        'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',
	        'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78',
	      ],
	      [
	        'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',
	        '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1',
	      ],
	      [
	        '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',
	        'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150',
	      ],
	      [
	        '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',
	        '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82',
	      ],
	      [
	        'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',
	        '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc',
	      ],
	      [
	        '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',
	        'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b',
	      ],
	      [
	        'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',
	        '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51',
	      ],
	      [
	        'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',
	        '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45',
	      ],
	      [
	        'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',
	        'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120',
	      ],
	      [
	        '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',
	        '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84',
	      ],
	      [
	        '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',
	        '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d',
	      ],
	      [
	        '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',
	        'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d',
	      ],
	      [
	        '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',
	        '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8',
	      ],
	      [
	        'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',
	        '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8',
	      ],
	      [
	        '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',
	        '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac',
	      ],
	      [
	        '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',
	        'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f',
	      ],
	      [
	        '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',
	        '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962',
	      ],
	      [
	        'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',
	        '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907',
	      ],
	      [
	        '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',
	        'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec',
	      ],
	      [
	        'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',
	        'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d',
	      ],
	      [
	        'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',
	        '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414',
	      ],
	      [
	        '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',
	        'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd',
	      ],
	      [
	        '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',
	        'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0',
	      ],
	      [
	        'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',
	        '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811',
	      ],
	      [
	        'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',
	        '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1',
	      ],
	      [
	        'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',
	        '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c',
	      ],
	      [
	        '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',
	        'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73',
	      ],
	      [
	        '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',
	        '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd',
	      ],
	      [
	        'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',
	        'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405',
	      ],
	      [
	        '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',
	        'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589',
	      ],
	      [
	        '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',
	        '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e',
	      ],
	      [
	        '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',
	        '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27',
	      ],
	      [
	        'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',
	        'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1',
	      ],
	      [
	        '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',
	        '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482',
	      ],
	      [
	        '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',
	        '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945',
	      ],
	      [
	        'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',
	        '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573',
	      ],
	      [
	        'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',
	        'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82',
	      ],
	    ],
	  },
	  naf: {
	    wnd: 7,
	    points: [
	      [
	        'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',
	        '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672',
	      ],
	      [
	        '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',
	        'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6',
	      ],
	      [
	        '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',
	        '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da',
	      ],
	      [
	        'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',
	        'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37',
	      ],
	      [
	        '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',
	        'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b',
	      ],
	      [
	        'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',
	        'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81',
	      ],
	      [
	        'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',
	        '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58',
	      ],
	      [
	        'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',
	        '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77',
	      ],
	      [
	        '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',
	        '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a',
	      ],
	      [
	        '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',
	        '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c',
	      ],
	      [
	        '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',
	        '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67',
	      ],
	      [
	        '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',
	        '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402',
	      ],
	      [
	        'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',
	        'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55',
	      ],
	      [
	        'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',
	        '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482',
	      ],
	      [
	        '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',
	        'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82',
	      ],
	      [
	        '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',
	        'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396',
	      ],
	      [
	        '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',
	        '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49',
	      ],
	      [
	        '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',
	        '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf',
	      ],
	      [
	        '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',
	        '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a',
	      ],
	      [
	        '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',
	        'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7',
	      ],
	      [
	        'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',
	        'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933',
	      ],
	      [
	        '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',
	        '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a',
	      ],
	      [
	        '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',
	        '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6',
	      ],
	      [
	        'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',
	        'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37',
	      ],
	      [
	        '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',
	        '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e',
	      ],
	      [
	        'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',
	        'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6',
	      ],
	      [
	        'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',
	        'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476',
	      ],
	      [
	        '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',
	        '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40',
	      ],
	      [
	        '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',
	        '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61',
	      ],
	      [
	        '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',
	        '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683',
	      ],
	      [
	        'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',
	        '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5',
	      ],
	      [
	        '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',
	        '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b',
	      ],
	      [
	        'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',
	        '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417',
	      ],
	      [
	        '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',
	        'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868',
	      ],
	      [
	        '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',
	        'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a',
	      ],
	      [
	        'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',
	        'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6',
	      ],
	      [
	        '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',
	        '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996',
	      ],
	      [
	        '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',
	        'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e',
	      ],
	      [
	        'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',
	        'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d',
	      ],
	      [
	        '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',
	        '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2',
	      ],
	      [
	        '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',
	        'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e',
	      ],
	      [
	        '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',
	        '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437',
	      ],
	      [
	        '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',
	        'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311',
	      ],
	      [
	        'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',
	        '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4',
	      ],
	      [
	        '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',
	        '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575',
	      ],
	      [
	        '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',
	        'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d',
	      ],
	      [
	        '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',
	        'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d',
	      ],
	      [
	        'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',
	        'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629',
	      ],
	      [
	        'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',
	        'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06',
	      ],
	      [
	        '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',
	        '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374',
	      ],
	      [
	        '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',
	        '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee',
	      ],
	      [
	        'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',
	        '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1',
	      ],
	      [
	        'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',
	        'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b',
	      ],
	      [
	        '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',
	        '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661',
	      ],
	      [
	        '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',
	        '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6',
	      ],
	      [
	        'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',
	        '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e',
	      ],
	      [
	        '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',
	        '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d',
	      ],
	      [
	        'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',
	        'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc',
	      ],
	      [
	        '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',
	        'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4',
	      ],
	      [
	        '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',
	        '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c',
	      ],
	      [
	        'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',
	        '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b',
	      ],
	      [
	        'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',
	        '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913',
	      ],
	      [
	        '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',
	        '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154',
	      ],
	      [
	        '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',
	        '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865',
	      ],
	      [
	        '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',
	        'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc',
	      ],
	      [
	        '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',
	        'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224',
	      ],
	      [
	        '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',
	        '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e',
	      ],
	      [
	        '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',
	        '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6',
	      ],
	      [
	        '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',
	        '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511',
	      ],
	      [
	        '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',
	        'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b',
	      ],
	      [
	        'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',
	        'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2',
	      ],
	      [
	        '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',
	        'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c',
	      ],
	      [
	        'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',
	        '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3',
	      ],
	      [
	        'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',
	        '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d',
	      ],
	      [
	        'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',
	        '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700',
	      ],
	      [
	        'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',
	        '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4',
	      ],
	      [
	        '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',
	        'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196',
	      ],
	      [
	        '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',
	        '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4',
	      ],
	      [
	        '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',
	        'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257',
	      ],
	      [
	        'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',
	        'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13',
	      ],
	      [
	        'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',
	        '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096',
	      ],
	      [
	        'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',
	        'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38',
	      ],
	      [
	        'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',
	        '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f',
	      ],
	      [
	        '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',
	        '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448',
	      ],
	      [
	        'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',
	        '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a',
	      ],
	      [
	        'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',
	        '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4',
	      ],
	      [
	        '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',
	        '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437',
	      ],
	      [
	        '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',
	        'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7',
	      ],
	      [
	        'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',
	        '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d',
	      ],
	      [
	        'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',
	        '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a',
	      ],
	      [
	        'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',
	        '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54',
	      ],
	      [
	        '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',
	        '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77',
	      ],
	      [
	        'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',
	        'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517',
	      ],
	      [
	        '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',
	        'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10',
	      ],
	      [
	        'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',
	        'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125',
	      ],
	      [
	        'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',
	        '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e',
	      ],
	      [
	        '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',
	        'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1',
	      ],
	      [
	        'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',
	        '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2',
	      ],
	      [
	        'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',
	        '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423',
	      ],
	      [
	        'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',
	        '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8',
	      ],
	      [
	        '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',
	        'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758',
	      ],
	      [
	        '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',
	        'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375',
	      ],
	      [
	        'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',
	        '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d',
	      ],
	      [
	        '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',
	        'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec',
	      ],
	      [
	        '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',
	        '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0',
	      ],
	      [
	        '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',
	        'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c',
	      ],
	      [
	        'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',
	        'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4',
	      ],
	      [
	        '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',
	        'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f',
	      ],
	      [
	        '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',
	        '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649',
	      ],
	      [
	        '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',
	        'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826',
	      ],
	      [
	        '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',
	        '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5',
	      ],
	      [
	        'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',
	        'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87',
	      ],
	      [
	        '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',
	        '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b',
	      ],
	      [
	        'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',
	        '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc',
	      ],
	      [
	        '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',
	        '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c',
	      ],
	      [
	        'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',
	        'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f',
	      ],
	      [
	        'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',
	        '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a',
	      ],
	      [
	        'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',
	        'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46',
	      ],
	      [
	        '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',
	        'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f',
	      ],
	      [
	        '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',
	        '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03',
	      ],
	      [
	        '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',
	        'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08',
	      ],
	      [
	        '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',
	        '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8',
	      ],
	      [
	        '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',
	        '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373',
	      ],
	      [
	        '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',
	        'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3',
	      ],
	      [
	        '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',
	        '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8',
	      ],
	      [
	        '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',
	        '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1',
	      ],
	      [
	        '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',
	        '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9',
	      ],
	    ],
	  },
	};
	return secp256k1;
}

(function (exports) {

	var curves = exports;

	var hash = requireHash();
	var curve$1 = curve;
	var utils = utils$o;

	var assert = utils.assert;

	function PresetCurve(options) {
	  if (options.type === 'short')
	    this.curve = new curve$1.short(options);
	  else if (options.type === 'edwards')
	    this.curve = new curve$1.edwards(options);
	  else
	    this.curve = new curve$1.mont(options);
	  this.g = this.curve.g;
	  this.n = this.curve.n;
	  this.hash = options.hash;

	  assert(this.g.validate(), 'Invalid curve');
	  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
	}
	curves.PresetCurve = PresetCurve;

	function defineCurve(name, options) {
	  Object.defineProperty(curves, name, {
	    configurable: true,
	    enumerable: true,
	    get: function() {
	      var curve = new PresetCurve(options);
	      Object.defineProperty(curves, name, {
	        configurable: true,
	        enumerable: true,
	        value: curve,
	      });
	      return curve;
	    },
	  });
	}

	defineCurve('p192', {
	  type: 'short',
	  prime: 'p192',
	  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
	  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
	  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
	  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
	  hash: hash.sha256,
	  gRed: false,
	  g: [
	    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
	    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811',
	  ],
	});

	defineCurve('p224', {
	  type: 'short',
	  prime: 'p224',
	  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
	  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
	  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
	  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
	  hash: hash.sha256,
	  gRed: false,
	  g: [
	    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
	    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34',
	  ],
	});

	defineCurve('p256', {
	  type: 'short',
	  prime: null,
	  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
	  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
	  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
	  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
	  hash: hash.sha256,
	  gRed: false,
	  g: [
	    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
	    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5',
	  ],
	});

	defineCurve('p384', {
	  type: 'short',
	  prime: null,
	  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
	     'fffffffe ffffffff 00000000 00000000 ffffffff',
	  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
	     'fffffffe ffffffff 00000000 00000000 fffffffc',
	  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +
	     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
	  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +
	     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
	  hash: hash.sha384,
	  gRed: false,
	  g: [
	    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +
	    '5502f25d bf55296c 3a545e38 72760ab7',
	    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +
	    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f',
	  ],
	});

	defineCurve('p521', {
	  type: 'short',
	  prime: null,
	  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
	     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
	     'ffffffff ffffffff ffffffff ffffffff ffffffff',
	  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
	     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
	     'ffffffff ffffffff ffffffff ffffffff fffffffc',
	  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +
	     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +
	     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
	  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
	     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +
	     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
	  hash: hash.sha512,
	  gRed: false,
	  g: [
	    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +
	    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +
	    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',
	    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +
	    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +
	    '3fad0761 353c7086 a272c240 88be9476 9fd16650',
	  ],
	});

	defineCurve('curve25519', {
	  type: 'mont',
	  prime: 'p25519',
	  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
	  a: '76d06',
	  b: '1',
	  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
	  hash: hash.sha256,
	  gRed: false,
	  g: [
	    '9',
	  ],
	});

	defineCurve('ed25519', {
	  type: 'edwards',
	  prime: 'p25519',
	  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
	  a: '-1',
	  c: '1',
	  // -121665 * (121666^(-1)) (mod P)
	  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
	  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
	  hash: hash.sha256,
	  gRed: false,
	  g: [
	    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',

	    // 4/5
	    '6666666666666666666666666666666666666666666666666666666666666658',
	  ],
	});

	var pre;
	try {
	  pre = requireSecp256k1();
	} catch (e) {
	  pre = undefined;
	}

	defineCurve('secp256k1', {
	  type: 'short',
	  prime: 'k256',
	  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
	  a: '0',
	  b: '7',
	  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
	  h: '1',
	  hash: hash.sha256,

	  // Precomputed endomorphism
	  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
	  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
	  basis: [
	    {
	      a: '3086d221a7d46bcde86c90e49284eb15',
	      b: '-e4437ed6010e88286f547fa90abfe4c3',
	    },
	    {
	      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
	      b: '3086d221a7d46bcde86c90e49284eb15',
	    },
	  ],

	  gRed: false,
	  g: [
	    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
	    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
	    pre,
	  ],
	}); 
} (curves$2));

var hash$3 = requireHash();
var utils$h = utils$n;
var assert$8 = minimalisticAssert;

function HmacDRBG$1(options) {
  if (!(this instanceof HmacDRBG$1))
    return new HmacDRBG$1(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;

  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;

  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;

  var entropy = utils$h.toArray(options.entropy, options.entropyEnc || 'hex');
  var nonce = utils$h.toArray(options.nonce, options.nonceEnc || 'hex');
  var pers = utils$h.toArray(options.pers, options.persEnc || 'hex');
  assert$8(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
  this._init(entropy, nonce, pers);
}
var hmacDrbg = HmacDRBG$1;

HmacDRBG$1.prototype._init = function init(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);

  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i = 0; i < this.V.length; i++) {
    this.K[i] = 0x00;
    this.V[i] = 0x01;
  }

  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 0x1000000000000;  // 2^48
};

HmacDRBG$1.prototype._hmac = function hmac() {
  return new hash$3.hmac(this.hash, this.K);
};

HmacDRBG$1.prototype._update = function update(seed) {
  var kmac = this._hmac()
                 .update(this.V)
                 .update([ 0x00 ]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;

  this.K = this._hmac()
               .update(this.V)
               .update([ 0x01 ])
               .update(seed)
               .digest();
  this.V = this._hmac().update(this.V).digest();
};

HmacDRBG$1.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
  // Optional entropy enc
  if (typeof entropyEnc !== 'string') {
    addEnc = add;
    add = entropyEnc;
    entropyEnc = null;
  }

  entropy = utils$h.toArray(entropy, entropyEnc);
  add = utils$h.toArray(add, addEnc);

  assert$8(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

  this._update(entropy.concat(add || []));
  this._reseed = 1;
};

HmacDRBG$1.prototype.generate = function generate(len, enc, add, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error('Reseed is required');

  // Optional encoding
  if (typeof enc !== 'string') {
    addEnc = add;
    add = enc;
    enc = null;
  }

  // Optional additional data
  if (add) {
    add = utils$h.toArray(add, addEnc || 'hex');
    this._update(add);
  }

  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }

  var res = temp.slice(0, len);
  this._update(add);
  this._reseed++;
  return utils$h.encode(res, enc);
};

var BN$9 = bnExports;
var utils$g = utils$o;
var assert$7 = utils$g.assert;

function KeyPair$3(ec, options) {
  this.ec = ec;
  this.priv = null;
  this.pub = null;

  // KeyPair(ec, { priv: ..., pub: ... })
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
var key$1 = KeyPair$3;

KeyPair$3.fromPublic = function fromPublic(ec, pub, enc) {
  if (pub instanceof KeyPair$3)
    return pub;

  return new KeyPair$3(ec, {
    pub: pub,
    pubEnc: enc,
  });
};

KeyPair$3.fromPrivate = function fromPrivate(ec, priv, enc) {
  if (priv instanceof KeyPair$3)
    return priv;

  return new KeyPair$3(ec, {
    priv: priv,
    privEnc: enc,
  });
};

KeyPair$3.prototype.validate = function validate() {
  var pub = this.getPublic();

  if (pub.isInfinity())
    return { result: false, reason: 'Invalid public key' };
  if (!pub.validate())
    return { result: false, reason: 'Public key is not a point' };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: 'Public key * N != O' };

  return { result: true, reason: null };
};

KeyPair$3.prototype.getPublic = function getPublic(compact, enc) {
  // compact is optional argument
  if (typeof compact === 'string') {
    enc = compact;
    compact = null;
  }

  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);

  if (!enc)
    return this.pub;

  return this.pub.encode(enc, compact);
};

KeyPair$3.prototype.getPrivate = function getPrivate(enc) {
  if (enc === 'hex')
    return this.priv.toString(16, 2);
  else
    return this.priv;
};

KeyPair$3.prototype._importPrivate = function _importPrivate(key, enc) {
  this.priv = new BN$9(key, enc || 16);

  // Ensure that the priv won't be bigger than n, otherwise we may fail
  // in fixed multiplication method
  this.priv = this.priv.umod(this.ec.curve.n);
};

KeyPair$3.prototype._importPublic = function _importPublic(key, enc) {
  if (key.x || key.y) {
    // Montgomery points only have an `x` coordinate.
    // Weierstrass/Edwards points on the other hand have both `x` and
    // `y` coordinates.
    if (this.ec.curve.type === 'mont') {
      assert$7(key.x, 'Need x coordinate');
    } else if (this.ec.curve.type === 'short' ||
               this.ec.curve.type === 'edwards') {
      assert$7(key.x && key.y, 'Need both x and y coordinate');
    }
    this.pub = this.ec.curve.point(key.x, key.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key, enc);
};

// ECDH
KeyPair$3.prototype.derive = function derive(pub) {
  if(!pub.validate()) {
    assert$7(pub.validate(), 'public point not validated');
  }
  return pub.mul(this.priv).getX();
};

// ECDSA
KeyPair$3.prototype.sign = function sign(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};

KeyPair$3.prototype.verify = function verify(msg, signature) {
  return this.ec.verify(msg, signature, this);
};

KeyPair$3.prototype.inspect = function inspect() {
  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +
         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
};

var BN$8 = bnExports;

var utils$f = utils$o;
var assert$6 = utils$f.assert;

function Signature$4(options, enc) {
  if (options instanceof Signature$4)
    return options;

  if (this._importDER(options, enc))
    return;

  assert$6(options.r && options.s, 'Signature without r or s');
  this.r = new BN$8(options.r, 16);
  this.s = new BN$8(options.s, 16);
  if (options.recoveryParam === undefined)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
var signature$3 = Signature$4;

function Position() {
  this.place = 0;
}

function getLength(buf, p) {
  var initial = buf[p.place++];
  if (!(initial & 0x80)) {
    return initial;
  }
  var octetLen = initial & 0xf;

  // Indefinite length or overflow
  if (octetLen === 0 || octetLen > 4) {
    return false;
  }

  var val = 0;
  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
    val <<= 8;
    val |= buf[off];
    val >>>= 0;
  }

  // Leading zeroes
  if (val <= 0x7f) {
    return false;
  }

  p.place = off;
  return val;
}

function rmPadding(buf) {
  var i = 0;
  var len = buf.length - 1;
  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {
    i++;
  }
  if (i === 0) {
    return buf;
  }
  return buf.slice(i);
}

Signature$4.prototype._importDER = function _importDER(data, enc) {
  data = utils$f.toArray(data, enc);
  var p = new Position();
  if (data[p.place++] !== 0x30) {
    return false;
  }
  var len = getLength(data, p);
  if (len === false) {
    return false;
  }
  if ((len + p.place) !== data.length) {
    return false;
  }
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var rlen = getLength(data, p);
  if (rlen === false) {
    return false;
  }
  var r = data.slice(p.place, rlen + p.place);
  p.place += rlen;
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var slen = getLength(data, p);
  if (slen === false) {
    return false;
  }
  if (data.length !== slen + p.place) {
    return false;
  }
  var s = data.slice(p.place, slen + p.place);
  if (r[0] === 0) {
    if (r[1] & 0x80) {
      r = r.slice(1);
    } else {
      // Leading zeroes
      return false;
    }
  }
  if (s[0] === 0) {
    if (s[1] & 0x80) {
      s = s.slice(1);
    } else {
      // Leading zeroes
      return false;
    }
  }

  this.r = new BN$8(r);
  this.s = new BN$8(s);
  this.recoveryParam = null;

  return true;
};

function constructLength(arr, len) {
  if (len < 0x80) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 0x80);
  while (--octets) {
    arr.push((len >>> (octets << 3)) & 0xff);
  }
  arr.push(len);
}

Signature$4.prototype.toDER = function toDER(enc) {
  var r = this.r.toArray();
  var s = this.s.toArray();

  // Pad values
  if (r[0] & 0x80)
    r = [ 0 ].concat(r);
  // Pad values
  if (s[0] & 0x80)
    s = [ 0 ].concat(s);

  r = rmPadding(r);
  s = rmPadding(s);

  while (!s[0] && !(s[1] & 0x80)) {
    s = s.slice(1);
  }
  var arr = [ 0x02 ];
  constructLength(arr, r.length);
  arr = arr.concat(r);
  arr.push(0x02);
  constructLength(arr, s.length);
  var backHalf = arr.concat(s);
  var res = [ 0x30 ];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils$f.encode(res, enc);
};

var BN$7 = bnExports;
var HmacDRBG = hmacDrbg;
var utils$e = utils$o;
var curves$1 = curves$2;
var rand = brorandExports;
var assert$5 = utils$e.assert;

var KeyPair$2 = key$1;
var Signature$3 = signature$3;

function EC$1(options) {
  if (!(this instanceof EC$1))
    return new EC$1(options);

  // Shortcut `elliptic.ec(curve-name)`
  if (typeof options === 'string') {
    assert$5(Object.prototype.hasOwnProperty.call(curves$1, options),
      'Unknown curve ' + options);

    options = curves$1[options];
  }

  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
  if (options instanceof curves$1.PresetCurve)
    options = { curve: options };

  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;

  // Point on curve
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);

  // Hash for function for DRBG
  this.hash = options.hash || options.curve.hash;
}
var ec$1 = EC$1;

EC$1.prototype.keyPair = function keyPair(options) {
  return new KeyPair$2(this, options);
};

EC$1.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
  return KeyPair$2.fromPrivate(this, priv, enc);
};

EC$1.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
  return KeyPair$2.fromPublic(this, pub, enc);
};

EC$1.prototype.genKeyPair = function genKeyPair(options) {
  if (!options)
    options = {};

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8',
    entropy: options.entropy || rand(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || 'utf8',
    nonce: this.n.toArray(),
  });

  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new BN$7(2));
  for (;;) {
    var priv = new BN$7(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0)
      continue;

    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  }
};

EC$1.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};

EC$1.prototype.sign = function sign(msg, key, enc, options) {
  if (typeof enc === 'object') {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};

  key = this.keyFromPrivate(key, enc);
  msg = this._truncateToN(new BN$7(msg, 16));

  // Zero-extend key to provide enough entropy
  var bytes = this.n.byteLength();
  var bkey = key.getPrivate().toArray('be', bytes);

  // Zero-extend nonce to have the same byte size as N
  var nonce = msg.toArray('be', bytes);

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    entropy: bkey,
    nonce: nonce,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8',
  });

  // Number of bytes to generate
  var ns1 = this.n.sub(new BN$7(1));

  for (var iter = 0; ; iter++) {
    var k = options.k ?
      options.k(iter) :
      new BN$7(drbg.generate(this.n.byteLength()));
    k = this._truncateToN(k, true);
    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
      continue;

    var kp = this.g.mul(k);
    if (kp.isInfinity())
      continue;

    var kpX = kp.getX();
    var r = kpX.umod(this.n);
    if (r.cmpn(0) === 0)
      continue;

    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
    s = s.umod(this.n);
    if (s.cmpn(0) === 0)
      continue;

    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |
                        (kpX.cmp(r) !== 0 ? 2 : 0);

    // Use complement of `s`, if it is > `n / 2`
    if (options.canonical && s.cmp(this.nh) > 0) {
      s = this.n.sub(s);
      recoveryParam ^= 1;
    }

    return new Signature$3({ r: r, s: s, recoveryParam: recoveryParam });
  }
};

EC$1.prototype.verify = function verify(msg, signature, key, enc) {
  msg = this._truncateToN(new BN$7(msg, 16));
  key = this.keyFromPublic(key, enc);
  signature = new Signature$3(signature, 'hex');

  // Perform primitive values validation
  var r = signature.r;
  var s = signature.s;
  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
    return false;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
    return false;

  // Validate signature
  var sinv = s.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r).umod(this.n);
  var p;

  if (!this.curve._maxwellTrick) {
    p = this.g.mulAdd(u1, key.getPublic(), u2);
    if (p.isInfinity())
      return false;

    return p.getX().umod(this.n).cmp(r) === 0;
  }

  // NOTE: Greg Maxwell's trick, inspired by:
  // https://git.io/vad3K

  p = this.g.jmulAdd(u1, key.getPublic(), u2);
  if (p.isInfinity())
    return false;

  // Compare `p.x` of Jacobian point with `r`,
  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the
  // inverse of `p.z^2`
  return p.eqXToP(r);
};

EC$1.prototype.recoverPubKey = function(msg, signature, j, enc) {
  assert$5((3 & j) === j, 'The recovery param is more than two bits');
  signature = new Signature$3(signature, enc);

  var n = this.n;
  var e = new BN$7(msg);
  var r = signature.r;
  var s = signature.s;

  // A set LSB signifies that the y-coordinate is odd
  var isYOdd = j & 1;
  var isSecondKey = j >> 1;
  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error('Unable to find sencond key candinate');

  // 1.1. Let x = r + jn.
  if (isSecondKey)
    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
  else
    r = this.curve.pointFromX(r, isYOdd);

  var rInv = signature.r.invm(n);
  var s1 = n.sub(e).mul(rInv).umod(n);
  var s2 = s.mul(rInv).umod(n);

  // 1.6.1 Compute Q = r^-1 (sR -  eG)
  //               Q = r^-1 (sR + -eG)
  return this.g.mulAdd(s1, r, s2);
};

EC$1.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
  signature = new Signature$3(signature, enc);
  if (signature.recoveryParam !== null)
    return signature.recoveryParam;

  for (var i = 0; i < 4; i++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e, signature, i);
    } catch (e) {
      continue;
    }

    if (Qprime.eq(Q))
      return i;
  }
  throw new Error('Unable to find valid recovery factor');
};

var utils$d = utils$o;
var assert$4 = utils$d.assert;
var parseBytes$2 = utils$d.parseBytes;
var cachedProperty$2 = utils$d.cachedProperty;

/**
* @param {EDDSA} eddsa - instance
* @param {Object} params - public/private key parameters
*
* @param {Array<Byte>} [params.secret] - secret seed bytes
* @param {Point} [params.pub] - public key point (aka `A` in eddsa terms)
* @param {Array<Byte>} [params.pub] - public key point encoded as bytes
*
*/
function KeyPair$1(eddsa, params) {
  this.eddsa = eddsa;
  this._secret = parseBytes$2(params.secret);
  if (eddsa.isPoint(params.pub))
    this._pub = params.pub;
  else
    this._pubBytes = parseBytes$2(params.pub);
}

KeyPair$1.fromPublic = function fromPublic(eddsa, pub) {
  if (pub instanceof KeyPair$1)
    return pub;
  return new KeyPair$1(eddsa, { pub: pub });
};

KeyPair$1.fromSecret = function fromSecret(eddsa, secret) {
  if (secret instanceof KeyPair$1)
    return secret;
  return new KeyPair$1(eddsa, { secret: secret });
};

KeyPair$1.prototype.secret = function secret() {
  return this._secret;
};

cachedProperty$2(KeyPair$1, 'pubBytes', function pubBytes() {
  return this.eddsa.encodePoint(this.pub());
});

cachedProperty$2(KeyPair$1, 'pub', function pub() {
  if (this._pubBytes)
    return this.eddsa.decodePoint(this._pubBytes);
  return this.eddsa.g.mul(this.priv());
});

cachedProperty$2(KeyPair$1, 'privBytes', function privBytes() {
  var eddsa = this.eddsa;
  var hash = this.hash();
  var lastIx = eddsa.encodingLength - 1;

  var a = hash.slice(0, eddsa.encodingLength);
  a[0] &= 248;
  a[lastIx] &= 127;
  a[lastIx] |= 64;

  return a;
});

cachedProperty$2(KeyPair$1, 'priv', function priv() {
  return this.eddsa.decodeInt(this.privBytes());
});

cachedProperty$2(KeyPair$1, 'hash', function hash() {
  return this.eddsa.hash().update(this.secret()).digest();
});

cachedProperty$2(KeyPair$1, 'messagePrefix', function messagePrefix() {
  return this.hash().slice(this.eddsa.encodingLength);
});

KeyPair$1.prototype.sign = function sign(message) {
  assert$4(this._secret, 'KeyPair can only verify');
  return this.eddsa.sign(message, this);
};

KeyPair$1.prototype.verify = function verify(message, sig) {
  return this.eddsa.verify(message, sig, this);
};

KeyPair$1.prototype.getSecret = function getSecret(enc) {
  assert$4(this._secret, 'KeyPair is public only');
  return utils$d.encode(this.secret(), enc);
};

KeyPair$1.prototype.getPublic = function getPublic(enc) {
  return utils$d.encode(this.pubBytes(), enc);
};

var key = KeyPair$1;

var BN$6 = bnExports;
var utils$c = utils$o;
var assert$3 = utils$c.assert;
var cachedProperty$1 = utils$c.cachedProperty;
var parseBytes$1 = utils$c.parseBytes;

/**
* @param {EDDSA} eddsa - eddsa instance
* @param {Array<Bytes>|Object} sig -
* @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes
* @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes
* @param {Array<Bytes>} [sig.Rencoded] - R point encoded
* @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded
*/
function Signature$2(eddsa, sig) {
  this.eddsa = eddsa;

  if (typeof sig !== 'object')
    sig = parseBytes$1(sig);

  if (Array.isArray(sig)) {
    sig = {
      R: sig.slice(0, eddsa.encodingLength),
      S: sig.slice(eddsa.encodingLength),
    };
  }

  assert$3(sig.R && sig.S, 'Signature without R or S');

  if (eddsa.isPoint(sig.R))
    this._R = sig.R;
  if (sig.S instanceof BN$6)
    this._S = sig.S;

  this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
  this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
}

cachedProperty$1(Signature$2, 'S', function S() {
  return this.eddsa.decodeInt(this.Sencoded());
});

cachedProperty$1(Signature$2, 'R', function R() {
  return this.eddsa.decodePoint(this.Rencoded());
});

cachedProperty$1(Signature$2, 'Rencoded', function Rencoded() {
  return this.eddsa.encodePoint(this.R());
});

cachedProperty$1(Signature$2, 'Sencoded', function Sencoded() {
  return this.eddsa.encodeInt(this.S());
});

Signature$2.prototype.toBytes = function toBytes() {
  return this.Rencoded().concat(this.Sencoded());
};

Signature$2.prototype.toHex = function toHex() {
  return utils$c.encode(this.toBytes(), 'hex').toUpperCase();
};

var signature$2 = Signature$2;

var hash$2 = requireHash();
var curves = curves$2;
var utils$b = utils$o;
var assert$2 = utils$b.assert;
var parseBytes = utils$b.parseBytes;
var KeyPair = key;
var Signature$1 = signature$2;

function EDDSA(curve) {
  assert$2(curve === 'ed25519', 'only tested with ed25519 so far');

  if (!(this instanceof EDDSA))
    return new EDDSA(curve);

  curve = curves[curve].curve;
  this.curve = curve;
  this.g = curve.g;
  this.g.precompute(curve.n.bitLength() + 1);

  this.pointClass = curve.point().constructor;
  this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
  this.hash = hash$2.sha512;
}

var eddsa = EDDSA;

/**
* @param {Array|String} message - message bytes
* @param {Array|String|KeyPair} secret - secret bytes or a keypair
* @returns {Signature} - signature
*/
EDDSA.prototype.sign = function sign(message, secret) {
  message = parseBytes(message);
  var key = this.keyFromSecret(secret);
  var r = this.hashInt(key.messagePrefix(), message);
  var R = this.g.mul(r);
  var Rencoded = this.encodePoint(R);
  var s_ = this.hashInt(Rencoded, key.pubBytes(), message)
    .mul(key.priv());
  var S = r.add(s_).umod(this.curve.n);
  return this.makeSignature({ R: R, S: S, Rencoded: Rencoded });
};

/**
* @param {Array} message - message bytes
* @param {Array|String|Signature} sig - sig bytes
* @param {Array|String|Point|KeyPair} pub - public key
* @returns {Boolean} - true if public key matches sig of message
*/
EDDSA.prototype.verify = function verify(message, sig, pub) {
  message = parseBytes(message);
  sig = this.makeSignature(sig);
  var key = this.keyFromPublic(pub);
  var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
  var SG = this.g.mul(sig.S());
  var RplusAh = sig.R().add(key.pub().mul(h));
  return RplusAh.eq(SG);
};

EDDSA.prototype.hashInt = function hashInt() {
  var hash = this.hash();
  for (var i = 0; i < arguments.length; i++)
    hash.update(arguments[i]);
  return utils$b.intFromLE(hash.digest()).umod(this.curve.n);
};

EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
  return KeyPair.fromPublic(this, pub);
};

EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
  return KeyPair.fromSecret(this, secret);
};

EDDSA.prototype.makeSignature = function makeSignature(sig) {
  if (sig instanceof Signature$1)
    return sig;
  return new Signature$1(this, sig);
};

/**
* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2
*
* EDDSA defines methods for encoding and decoding points and integers. These are
* helper convenience methods, that pass along to utility functions implied
* parameters.
*
*/
EDDSA.prototype.encodePoint = function encodePoint(point) {
  var enc = point.getY().toArray('le', this.encodingLength);
  enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;
  return enc;
};

EDDSA.prototype.decodePoint = function decodePoint(bytes) {
  bytes = utils$b.parseBytes(bytes);

  var lastIx = bytes.length - 1;
  var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);
  var xIsOdd = (bytes[lastIx] & 0x80) !== 0;

  var y = utils$b.intFromLE(normed);
  return this.curve.pointFromY(y, xIsOdd);
};

EDDSA.prototype.encodeInt = function encodeInt(num) {
  return num.toArray('le', this.encodingLength);
};

EDDSA.prototype.decodeInt = function decodeInt(bytes) {
  return utils$b.intFromLE(bytes);
};

EDDSA.prototype.isPoint = function isPoint(val) {
  return val instanceof this.pointClass;
};

(function (exports) {

	var elliptic = exports;

	elliptic.version = require$$0$2.version;
	elliptic.utils = utils$o;
	elliptic.rand = brorandExports;
	elliptic.curve = curve;
	elliptic.curves = curves$2;

	// Protocols
	elliptic.ec = ec$1;
	elliptic.eddsa = eddsa; 
} (elliptic));

var BN$5 = bn$1;

var EC = elliptic.ec;
var ec = new EC('secp256k1');
var ecPoint = ec.curve.point.bind(ec.curve);
var ecPointFromX = ec.curve.pointFromX.bind(ec.curve);

/**
 * Instantiate a valid secp256k1 Point from the X and Y coordinates. This class
 * is just an extension of the secp256k1 code from the library "elliptic" by
 * Fedor Indutny. It includes a few extra features that are useful in Bitcoin.
 *
 * @param {BN|String} x - The X coordinate
 * @param {BN|String} y - The Y coordinate
 * @link https://github.com/indutny/elliptic
 * @augments elliptic.curve.point
 * @throws {Error} A validation error if exists
 * @returns {Point} An instance of Point
 * @constructor
 */
var Point = function Point (x, y, isRed) {
  try {
    var point = ecPoint(x, y, isRed);
  } catch (e) {
    throw new Error('Invalid Point')
  }
  point.validate();
  return point
};

Point.prototype = Object.getPrototypeOf(ec.curve.point());

/**
 *
 * Instantiate a valid secp256k1 Point from only the X coordinate. This is
 * useful to rederive a full point from the compressed form of a point.
 *
 * @param {boolean} odd - If the Y coordinate is odd
 * @param {BN|String} x - The X coordinate
 * @throws {Error} A validation error if exists
 * @returns {Point} An instance of Point
 */
Point.fromX = function fromX (odd, x) {
  try {
    var point = ecPointFromX(x, odd);
  } catch (e) {
    throw new Error('Invalid X')
  }
  point.validate();
  return point
};

/**
 *
 * Will return a secp256k1 ECDSA base point.
 *
 * @link https://en.bitcoin.it/wiki/Secp256k1
 * @returns {Point} An instance of the base point.
 */
Point.getG = function getG () {
  return ec.curve.g
};

/**
 *
 * Will return the max of range of valid private keys as governed by the
 * secp256k1 ECDSA standard.
 *
 * @link https://en.bitcoin.it/wiki/Private_key#Range_of_valid_ECDSA_private_keys
 * @returns {BN} A BN instance of the number of points on the curve
 */
Point.getN = function getN () {
  return new BN$5(ec.curve.n.toArray())
};

if (!Point.prototype._getX) { Point.prototype._getX = Point.prototype.getX; }

/**
 * Will return the X coordinate of the Point.
 *
 * @returns {BN} A BN instance of the X coordinate
 */
Point.prototype.getX = function getX () {
  return new BN$5(this._getX().toArray())
};

if (!Point.prototype._getY) { Point.prototype._getY = Point.prototype.getY; }

/**
 * Will return the Y coordinate of the Point.
 *
 * @returns {BN} A BN instance of the Y coordinate
 */
Point.prototype.getY = function getY () {
  return new BN$5(this._getY().toArray())
};

/**
 * Will determine if the point is valid.
 *
 * @link https://www.iacr.org/archive/pkc2003/25670211/25670211.pdf
 * @throws {Error} A validation error if exists
 * @returns {Point} An instance of the same Point
 */
Point.prototype.validate = function validate () {
  if (this.isInfinity()) {
    throw new Error('Point cannot be equal to Infinity')
  }

  var p2;
  try {
    p2 = ecPointFromX(this.getX(), this.getY().isOdd());
  } catch (e) {
    throw new Error('Point does not lie on the curve')
  }

  if (p2.y.cmp(this.y) !== 0) {
    throw new Error('Invalid y value for curve.')
  }

  // todo: needs test case
  if (!(this.mul(Point.getN()).isInfinity())) {
    throw new Error('Point times N must be infinity')
  }

  return this
};

/**
 * A "compressed" format point is the X part of the (X, Y) point plus an extra
 * bit (which takes an entire byte) to indicate whether the Y value is odd or
 * not. Storing points this way takes a bit less space, but requires a bit more
 * computation to rederive the full point.
 *
 * @param {Point} point An instance of Point.
 * @returns {Buffer} A compressed point in the form of a buffer.
 */
Point.pointToCompressed = function pointToCompressed (point) {
  var xbuf = point.getX().toBuffer({ size: 32 });
  var ybuf = point.getY().toBuffer({ size: 32 });

  var prefix;
  var odd = ybuf[ybuf.length - 1] % 2;
  if (odd) {
    prefix = Buffer.from([0x03]);
  } else {
    prefix = Buffer.from([0x02]);
  }
  return Buffer.concat([prefix, xbuf])
};

/**
 * Converts a compressed buffer into a point.
 *
 * @param {Buffer} buf A compressed point.
 * @returns {Point} A Point.
 */
Point.pointFromCompressed = function (buf) {
  if (buf.length !== 33) {
    throw new Error('invalid buffer length')
  }
  let prefix = buf[0];
  let odd;
  if (prefix === 0x03) {
    odd = true;
  } else if (prefix === 0x02) {
    odd = false;
  } else {
    throw new Error('invalid value of compressed prefix')
  }

  let xbuf = buf.slice(1, 33);
  let x = BN$5.fromBuffer(xbuf);
  return Point.fromX(odd, x)
};

/**
 * Convert point to a compressed buffer.
 *
 * @returns {Buffer} A compressed point.
 */
Point.prototype.toBuffer = function () {
  return Point.pointToCompressed(this)
};

/**
 * Convert point to a compressed hex string.
 *
 * @returns {string} A compressed point as a hex string.
 */
Point.prototype.toHex = function () {
  return this.toBuffer().toString('hex')
};

/**
 * Converts a compressed buffer into a point.
 *
 * @param {Buffer} buf A compressed point.
 * @returns {Point} A Point.
 */
Point.fromBuffer = function (buf) {
  return Point.pointFromCompressed(buf)
};

/**
 * Converts a compressed buffer into a point.
 *
 * @param {Buffer} hex A compressed point as a hex string.
 * @returns {Point} A Point.
 */
Point.fromHex = function (hex) {
  return Point.fromBuffer(Buffer.from(hex, 'hex'))
};

var point = Point;

var _$9 = __1;
var $$8 = preconditions;

/**
 * Determines whether a string contains only hexadecimal values
 *
 * @name JSUtil.isHexa
 * @param {string} value
 * @return {boolean} true if the string is the hexa representation of a number
 */
var isHexa = function isHexa (value) {
  if (!_$9.isString(value)) {
    return false
  }
  return /^[0-9a-fA-F]+$/.test(value)
};

/**
 * @namespace JSUtil
 */
var js = {
  /**
   * Test if an argument is a valid JSON object. If it is, returns a truthy
   * value (the json object decoded), so no double JSON.parse call is necessary
   *
   * @param {string} arg
   * @return {Object|boolean} false if the argument is not a JSON string.
   */
  isValidJSON: function isValidJSON (arg) {
    var parsed;
    if (!_$9.isString(arg)) {
      return false
    }
    try {
      parsed = JSON.parse(arg);
    } catch (e) {
      return false
    }
    if (typeof (parsed) === 'object') {
      return true
    }
    return false
  },
  isHexa: isHexa,
  isHexaString: isHexa,

  /**
   * Define immutable properties on a target object
   *
   * @param {Object} target - An object to be extended
   * @param {Object} values - An object of properties
   * @return {Object} The target object
   */
  defineImmutable: function defineImmutable (target, values) {
    Object.keys(values).forEach(function (key) {
      Object.defineProperty(target, key, {
        configurable: false,
        enumerable: true,
        value: values[key]
      });
    });
    return target
  },
  /**
   * Checks that a value is a natural number, a positive integer or zero.
   *
   * @param {*} value
   * @return {Boolean}
   */
  isNaturalNumber: function isNaturalNumber (value) {
    return typeof value === 'number' &&
      isFinite(value) &&
      Math.floor(value) === value &&
      value >= 0
  },

  /**
   * Transform a 4-byte integer (unsigned value) into a Buffer of length 4 (Big Endian Byte Order)
   *
   * @param {number} integer
   * @return {Buffer}
   */
  integerAsBuffer: function integerAsBuffer (integer) {
    $$8.checkArgumentType(integer, 'number', 'integer');
    const buf = Buffer.allocUnsafe(4);
    buf.writeUInt32BE(integer, 0);
    return buf
  }
};

var BN$4 = bn$1;
var _$8 = __1;
var $$7 = preconditions;
var JSUtil$2 = js;

var Signature = function Signature (r, s) {
  if (!(this instanceof Signature)) {
    return new Signature(r, s)
  }
  if (r instanceof BN$4) {
    this.set({
      r: r,
      s: s
    });
  } else if (r) {
    var obj = r;
    this.set(obj);
  }
};

Signature.prototype.set = function (obj) {
  this.r = obj.r || this.r || undefined;
  this.s = obj.s || this.s || undefined;

  this.i = typeof obj.i !== 'undefined' ? obj.i : this.i; // public key recovery parameter in range [0, 3]
  this.compressed = typeof obj.compressed !== 'undefined'
    ? obj.compressed : this.compressed; // whether the recovered pubkey is compressed
  this.nhashtype = obj.nhashtype || this.nhashtype || undefined;
  return this
};

Signature.fromCompact = function (buf) {
  $$7.checkArgument(isBuffer$2(buf), 'Argument is expected to be a Buffer');

  var sig = new Signature();

  var compressed = true;
  var i = buf.slice(0, 1)[0] - 27 - 4;
  if (i < 0) {
    compressed = false;
    i = i + 4;
  }

  var b2 = buf.slice(1, 33);
  var b3 = buf.slice(33, 65);

  $$7.checkArgument(i === 0 || i === 1 || i === 2 || i === 3, new Error('i must be 0, 1, 2, or 3'));
  $$7.checkArgument(b2.length === 32, new Error('r must be 32 bytes'));
  $$7.checkArgument(b3.length === 32, new Error('s must be 32 bytes'));

  sig.compressed = compressed;
  sig.i = i;
  sig.r = BN$4.fromBuffer(b2);
  sig.s = BN$4.fromBuffer(b3);

  return sig
};

Signature.fromDER = Signature.fromBuffer = function (buf, strict) {
  var obj = Signature.parseDER(buf, strict);
  var sig = new Signature();

  sig.r = obj.r;
  sig.s = obj.s;

  return sig
};

// The format used in a tx
Signature.fromTxFormat = function (buf) {
  var nhashtype = buf.readUInt8(buf.length - 1);
  var derbuf = buf.slice(0, buf.length - 1);
  var sig = Signature.fromDER(derbuf, false);
  sig.nhashtype = nhashtype;
  return sig
};

Signature.fromString = function (str) {
  var buf = Buffer.from(str, 'hex');
  return Signature.fromDER(buf)
};

/**
 * In order to mimic the non-strict DER encoding of OpenSSL, set strict = false.
 */
Signature.parseDER = function (buf, strict) {
  $$7.checkArgument(isBuffer$2(buf), new Error('DER formatted signature should be a buffer'));
  if (_$8.isUndefined(strict)) {
    strict = true;
  }

  var header = buf[0];
  $$7.checkArgument(header === 0x30, new Error('Header byte should be 0x30'));

  var length = buf[1];
  var buflength = buf.slice(2).length;
  $$7.checkArgument(!strict || length === buflength, new Error('Length byte should length of what follows'));

  length = length < buflength ? length : buflength;

  var rheader = buf[2 + 0];
  $$7.checkArgument(rheader === 0x02, new Error('Integer byte for r should be 0x02'));

  var rlength = buf[2 + 1];
  var rbuf = buf.slice(2 + 2, 2 + 2 + rlength);
  var r = BN$4.fromBuffer(rbuf);
  var rneg = buf[2 + 1 + 1] === 0x00;
  $$7.checkArgument(rlength === rbuf.length, new Error('Length of r incorrect'));

  var sheader = buf[2 + 2 + rlength + 0];
  $$7.checkArgument(sheader === 0x02, new Error('Integer byte for s should be 0x02'));

  var slength = buf[2 + 2 + rlength + 1];
  var sbuf = buf.slice(2 + 2 + rlength + 2, 2 + 2 + rlength + 2 + slength);
  var s = BN$4.fromBuffer(sbuf);
  var sneg = buf[2 + 2 + rlength + 2 + 2] === 0x00;
  $$7.checkArgument(slength === sbuf.length, new Error('Length of s incorrect'));

  var sumlength = 2 + 2 + rlength + 2 + slength;
  $$7.checkArgument(length === sumlength - 2, new Error('Length of signature incorrect'));

  var obj = {
    header: header,
    length: length,
    rheader: rheader,
    rlength: rlength,
    rneg: rneg,
    rbuf: rbuf,
    r: r,
    sheader: sheader,
    slength: slength,
    sneg: sneg,
    sbuf: sbuf,
    s: s
  };

  return obj
};

Signature.prototype.toCompact = function (i, compressed) {
  i = typeof i === 'number' ? i : this.i;
  compressed = typeof compressed === 'boolean' ? compressed : this.compressed;

  if (!(i === 0 || i === 1 || i === 2 || i === 3)) {
    throw new Error('i must be equal to 0, 1, 2, or 3')
  }

  var val = i + 27 + 4;
  if (compressed === false) {
    val = val - 4;
  }
  var b1 = Buffer.from([val]);
  var b2 = this.r.toBuffer({
    size: 32
  });
  var b3 = this.s.toBuffer({
    size: 32
  });
  return Buffer.concat([b1, b2, b3])
};

Signature.prototype.toBuffer = Signature.prototype.toDER = function () {
  var rnbuf = this.r.toBuffer();
  var snbuf = this.s.toBuffer();

  var rneg = !!(rnbuf[0] & 0x80);
  var sneg = !!(snbuf[0] & 0x80);

  var rbuf = rneg ? Buffer.concat([Buffer.from([0x00]), rnbuf]) : rnbuf;
  var sbuf = sneg ? Buffer.concat([Buffer.from([0x00]), snbuf]) : snbuf;

  var rlength = rbuf.length;
  var slength = sbuf.length;
  var length = 2 + rlength + 2 + slength;
  var rheader = 0x02;
  var sheader = 0x02;
  var header = 0x30;

  var der = Buffer.concat([Buffer.from([header, length, rheader, rlength]), rbuf, Buffer.from([sheader, slength]), sbuf]);
  return der
};

Signature.prototype.toString = function () {
  var buf = this.toDER();
  return buf.toString('hex')
};

/**
 * This function is translated from bitcoind's IsDERSignature and is used in
 * the script interpreter.  This "DER" format actually includes an extra byte,
 * the nhashtype, at the end. It is really the tx format, not DER format.
 *
 * A canonical signature exists of: [30] [total len] [02] [len R] [R] [02] [len S] [S] [hashtype]
 * Where R and S are not negative (their first byte has its highest bit not set), and not
 * excessively padded (do not start with a 0 byte, unless an otherwise negative number follows,
 * in which case a single 0 byte is necessary and even required).
 *
 * See https://bitcointalk.org/index.php?topic=8392.msg127623#msg127623
 */
Signature.isTxDER = function (buf) {
  if (buf.length < 9) {
    //  Non-canonical signature: too short
    return false
  }
  if (buf.length > 73) {
    // Non-canonical signature: too long
    return false
  }
  if (buf[0] !== 0x30) {
    //  Non-canonical signature: wrong type
    return false
  }
  if (buf[1] !== buf.length - 3) {
    //  Non-canonical signature: wrong length marker
    return false
  }
  var nLenR = buf[3];
  if (5 + nLenR >= buf.length) {
    //  Non-canonical signature: S length misplaced
    return false
  }
  var nLenS = buf[5 + nLenR];
  if ((nLenR + nLenS + 7) !== buf.length) {
    //  Non-canonical signature: R+S length mismatch
    return false
  }

  var R = buf.slice(4);
  if (buf[4 - 2] !== 0x02) {
    //  Non-canonical signature: R value type mismatch
    return false
  }
  if (nLenR === 0) {
    //  Non-canonical signature: R length is zero
    return false
  }
  if (R[0] & 0x80) {
    //  Non-canonical signature: R value negative
    return false
  }
  if (nLenR > 1 && (R[0] === 0x00) && !(R[1] & 0x80)) {
    //  Non-canonical signature: R value excessively padded
    return false
  }

  var S = buf.slice(6 + nLenR);
  if (buf[6 + nLenR - 2] !== 0x02) {
    //  Non-canonical signature: S value type mismatch
    return false
  }
  if (nLenS === 0) {
    //  Non-canonical signature: S length is zero
    return false
  }
  if (S[0] & 0x80) {
    //  Non-canonical signature: S value negative
    return false
  }
  if (nLenS > 1 && (S[0] === 0x00) && !(S[1] & 0x80)) {
    //  Non-canonical signature: S value excessively padded
    return false
  }
  return true
};

/**
 * Compares to bitcoind's IsLowDERSignature
 * See also ECDSA signature algorithm which enforces this.
 * See also BIP 62, "low S values in signatures"
 */
Signature.prototype.hasLowS = function () {
  if (this.s.lt(new BN$4(1)) ||
    this.s.gt(new BN$4('7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0', 'hex'))) {
    return false
  }
  return true
};

/**
 * @returns true if the nhashtype is exactly equal to one of the standard options or combinations thereof.
 * Translated from bitcoind's IsDefinedHashtypeSignature
 */
Signature.prototype.hasDefinedHashtype = function () {
  if (!JSUtil$2.isNaturalNumber(this.nhashtype)) {
    return false
  }
  // accept with or without Signature.SIGHASH_ANYONECANPAY by ignoring the bit
  var temp = this.nhashtype & 0x1F;
  if (temp < Signature.SIGHASH_ALL || temp > Signature.SIGHASH_SINGLE) {
    return false
  }
  return true
};

Signature.prototype.toTxFormat = function () {
  var derbuf = this.toDER();
  var buf = Buffer.alloc(1);
  buf.writeUInt8(this.nhashtype, 0);
  return Buffer.concat([derbuf, buf])
};

Signature.SIGHASH_ALL = 0x01;
Signature.SIGHASH_NONE = 0x02;
Signature.SIGHASH_SINGLE = 0x03;
Signature.SIGHASH_FORKID = 0x40;
Signature.SIGHASH_ANYONECANPAY = 0x80;

var signature$1 = Signature;

var browser$3 = true;

var hash$1 = {exports: {}};

var hash_browser = {exports: {}};

var hasRequiredHash_browser;

function requireHash_browser () {
	if (hasRequiredHash_browser) return hash_browser.exports;
	hasRequiredHash_browser = 1;
	(function (module) {

		var hash = requireHash();
		var $ = preconditions;

		var Hash = module.exports;

		/**
		 * A SHA or SHA1 hash, which is always 160 bits or 20 bytes long.
		 *
		 * See:
		 * https://en.wikipedia.org/wiki/SHA-1
		 *
		 * @param {Buffer} buf Data, a.k.a. pre-image, which can be any size.
		 * @returns {Buffer} The hash in the form of a buffer.
		 */
		Hash.sha1 = function (buf) {
		  $.checkArgument(isBuffer$2(buf));
		  return Buffer.from(hash.sha1().update(buf).digest('hex'), 'hex')
		};

		Hash.sha1.blocksize = 512;

		/**
		 * A SHA256 hash, which is always 256 bits or 32 bytes long.
		 *
		 * See:
		 * https://www.movable-type.co.uk/scripts/sha256.html
		 *
		 * @param {Buffer} buf Data, a.k.a. pre-image, which can be any size.
		 * @returns {Buffer} The hash in the form of a buffer.
		 */
		Hash.sha256 = function (buf) {
		  $.checkArgument(isBuffer$2(buf));
		  return Buffer.from(hash.sha256().update(buf).digest('hex'), 'hex')
		};

		Hash.sha256.blocksize = 512;


		Hash.sha256sha256 = function (buf) {
		  $.checkArgument(isBuffer$2(buf));
		  return Hash.sha256(Hash.sha256(buf))
		};

		/**
		 * A RIPEMD160 hash, which is always 160 bits or 20 bytes long.
		 *
		 * See:
		 * https://en.wikipedia.org/wiki/RIPEMD
		 *
		 * @param {Buffer} buf Data, a.k.a. pre-image, which can be any size.
		 * @returns {Buffer} The hash in the form of a buffer.
		 */
		Hash.ripemd160 = function (buf) {
		  $.checkArgument(isBuffer$2(buf));
		  return Buffer.from(hash.ripemd160().update(buf).digest('hex'), 'hex')
		};

		Hash.sha256ripemd160 = function (buf) {
		  $.checkArgument(isBuffer$2(buf));
		  return Hash.ripemd160(Hash.sha256(buf))
		};

		/**
		 * A SHA512 hash, which is always 512 bits or 64 bytes long.
		 *
		 * See:
		 * https://en.wikipedia.org/wiki/SHA-2
		 *
		 * @param {Buffer} buf Data, a.k.a. pre-image, which can be any size.
		 * @returns {Buffer} The hash in the form of a buffer.
		 */
		Hash.sha512 = function (buf) {
		  $.checkArgument(isBuffer$2(buf));
		  return Buffer.from(hash.sha512().update(buf).digest('hex'), 'hex')
		};

		Hash.sha512.blocksize = 1024;

		/**
		 * A way to do HMAC using any underlying hash function. If you ever find that
		 * you want to hash two pieces of data together, you should use HMAC instead of
		 * just using a hash function. Rather than doing hash(data1 + data2) you should
		 * do HMAC(data1, data2). Actually, rather than use HMAC directly, we recommend
		 * you use either sha256hmac or sha515hmac provided below.
		 *
		 * See:
		 * https://en.wikipedia.org/wiki/Length_extension_attack
		 * https://blog.skullsecurity.org/2012/everything-you-need-to-know-about-hash-length-extension-attacks
		 *
		 * @param {function} hashf Which hash function to use.
		 * @param {Buffer} data Data, which can be any size.
		 * @param {Buffer} key Key, which can be any size.
		 * @returns {Buffer} The HMAC in the form of a buffer.
		 */
		Hash.hmac = function (hashf, data, key) {
		  // http://en.wikipedia.org/wiki/Hash-based_message_authentication_code
		  // http://tools.ietf.org/html/rfc4868#section-2
		  $.checkArgument(isBuffer$2(data));
		  $.checkArgument(isBuffer$2(key));
		  $.checkArgument(hashf.blocksize);

		  var blocksize = hashf.blocksize / 8;

		  if (key.length > blocksize) {
		    key = hashf(key);
		  } else if (key < blocksize) {
		    var fill = Buffer.alloc(blocksize);
		    fill.fill(0);
		    key.copy(fill);
		    key = fill;
		  }

		  var oKey = Buffer.alloc(blocksize);
		  oKey.fill(0x5c);

		  var iKey = Buffer.alloc(blocksize);
		  iKey.fill(0x36);

		  var oKeyPad = Buffer.alloc(blocksize);
		  var iKeyPad = Buffer.alloc(blocksize);
		  for (var i = 0; i < blocksize; i++) {
		    oKeyPad[i] = oKey[i] ^ key[i];
		    iKeyPad[i] = iKey[i] ^ key[i];
		  }

		  return hashf(Buffer.concat([oKeyPad, hashf(Buffer.concat([iKeyPad, data]))]))
		};

		/**
		 * A SHA256 HMAC.
		 *
		 * @param {Buffer} data Data, which can be any size.
		 * @param {Buffer} key Key, which can be any size.
		 * @returns {Buffer} The HMAC in the form of a buffer.
		 */
		Hash.sha256hmac = function (data, key) {
		  return Hash.hmac(Hash.sha256, data, key)
		};

		/**
		 * A SHA512 HMAC.
		 *
		 * @param {Buffer} data Data, which can be any size.
		 * @param {Buffer} key Key, which can be any size.
		 * @returns {Buffer} The HMAC in the form of a buffer.
		 */
		Hash.sha512hmac = function (data, key) {
		  return Hash.hmac(Hash.sha512, data, key)
		}; 
	} (hash_browser));
	return hash_browser.exports;
}

hash$1.exports = requireHash_browser();

var hashExports = hash$1.exports;

var _$7 = __1;

var JSUtil$1 = js;
var networks = [];
var networkMaps = {};

/**
 * A network is merely a map containing values that correspond to version
 * numbers for each bitcoin network. Currently only supporting "livenet"
 * (a.k.a. "mainnet"), "testnet", "regtest" and "stn".
 * @constructor
 */
function Network () {}

Network.prototype.toString = function toString () {
  return this.name
};

/**
 * @function
 * @member Networks#get
 * Retrieves the network associated with a magic number or string.
 * @param {string|number|Network} arg
 * @param {string|Array} keys - if set, only check if the magic number associated with this name matches
 * @return Network
 */
function get (arg, keys) {
  if (~networks.indexOf(arg)) {
    return arg
  }
  if (keys) {
    if (!_$7.isArray(keys)) {
      keys = [keys];
    }
    for (var i = 0; i < networks.length; i++) {
      var network = networks[i];
      var filteredNet = _$7.pick(network, keys);
      var netValues = _$7.values(filteredNet);
      if (~netValues.indexOf(arg)) {
        return network
      }
    }
    return undefined
  }
  return networkMaps[arg]
}

/***
 * Derives an array from the given cashAddrPrefix to be used in the computation
 * of the address' checksum.
 *
 * @param {string} cashAddrPrefix Network cashAddrPrefix. E.g.: 'bitcoincash'.
 */
function cashAddrPrefixToArray (cashAddrPrefix) {
  var result = [];
  for (var i = 0; i < cashAddrPrefix.length; i++) {
    result.push(cashAddrPrefix.charCodeAt(i) & 31);
  }
  return result
}

/**
 * @function
 * @member Networks#add
 * Will add a custom Network
 * @param {Object} data
 * @param {string} data.name - The name of the network
 * @param {string} data.alias - The aliased name of the network
 * @param {Number} data.pubkeyhash - The publickey hash cashAddrPrefix
 * @param {Number} data.privatekey - The privatekey cashAddrPrefix
 * @param {Number} data.scripthash - The scripthash cashAddrPrefix
 * @param {Number} data.xpubkey - The extended public key magic
 * @param {Number} data.xprivkey - The extended private key magic
 * @param {Number} data.networkMagic - The network magic number
 * @param {Number} data.port - The network port
 * @param {Array}  data.dnsSeeds - An array of dns seeds
 * @return Network
 */
function addNetwork (data) {
  var network = new Network();

  JSUtil$1.defineImmutable(network, {
    name: data.name,
    alias: data.alias,
    pubkeyhash: data.pubkeyhash,
    privatekey: data.privatekey,
    scripthash: data.scripthash,
    xpubkey: data.xpubkey,
    xprivkey: data.xprivkey
  });

  var indexBy = data.indexBy || Object.keys(data);

  if (data.cashAddrPrefix) {
    _$7.extend(network, {
      cashAddrPrefix: data.cashAddrPrefix,
      cashAddrPrefixArray: cashAddrPrefixToArray(data.cashAddrPrefix)
    });
  }

  if (data.networkMagic) {
    _$7.extend(network, {
      networkMagic: JSUtil$1.integerAsBuffer(data.networkMagic)
    });
  }

  if (data.port) {
    _$7.extend(network, {
      port: data.port
    });
  }

  if (data.dnsSeeds) {
    _$7.extend(network, {
      dnsSeeds: data.dnsSeeds
    });
  }
  networks.push(network);
  indexNetworkBy(network, indexBy);
  return network
}

function indexNetworkBy (network, keys) {
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var networkValue = network[key];
    if (!_$7.isUndefined(networkValue) && !_$7.isObject(networkValue)) {
      networkMaps[networkValue] = network;
    }
  }
}

function unindexNetworkBy (network, values) {
  for (var index = 0; index < values.length; index++) {
    var value = values[index];
    if (networkMaps[value] === network) {
      delete networkMaps[value];
    }
  }
}

/**
 * @function
 * @member Networks#remove
 * Will remove a custom network
 * @param {Network} network
 */
function removeNetwork (network) {
  for (var i = 0; i < networks.length; i++) {
    if (networks[i] === network) {
      networks.splice(i, 1);
    }
  }
  unindexNetworkBy(network, Object.keys(networkMaps));
}

var networkMagic = {
  livenet: 0xe3e1f3e8,
  testnet: 0xf4e5f3f4,
  regtest: 0xdab5bffa,
  stn: 0xfbcec4f9
};

var dnsSeeds = [
  'seed.bitcoinsv.org',
  'seed.bitcoinunlimited.info'
];

var TESTNET = {
  PORT: 18333,
  NETWORK_MAGIC: networkMagic.testnet,
  DNS_SEEDS: dnsSeeds,
  PREFIX: 'testnet',
  CASHADDRPREFIX: 'bchtest'
};

var REGTEST = {
  PORT: 18444,
  NETWORK_MAGIC: networkMagic.regtest,
  DNS_SEEDS: [],
  PREFIX: 'regtest',
  CASHADDRPREFIX: 'bchreg'
};

var STN = {
  PORT: 9333,
  NETWORK_MAGIC: networkMagic.stn,
  DNS_SEEDS: ['stn-seed.bitcoinsv.io'],
  PREFIX: 'stn',
  CASHADDRPREFIX: 'mvcstn'
};

var liveNetwork = {
  name: 'livenet',
  alias: 'mainnet',
  prefix: 'bitcoin',
  cashAddrPrefix: 'bitcoincash',
  pubkeyhash: 0x00,
  privatekey: 0x80,
  scripthash: 0x05,
  xpubkey: 0x0488b21e,
  xprivkey: 0x0488ade4,
  networkMagic: networkMagic.livenet,
  port: 8333,
  dnsSeeds: dnsSeeds
};

// network magic, port, cashAddrPrefix, and dnsSeeds are overloaded by enableRegtest
var testNetwork = {
  name: 'testnet',
  prefix: TESTNET.PREFIX,
  cashAddrPrefix: TESTNET.CASHADDRPREFIX,
  pubkeyhash: 0x6f,
  privatekey: 0xef,
  scripthash: 0xc4,
  xpubkey: 0x043587cf,
  xprivkey: 0x04358394,
  networkMagic: TESTNET.NETWORK_MAGIC
};

var regtestNetwork = {
  name: 'regtest',
  prefix: REGTEST.PREFIX,
  cashAddrPrefix: REGTEST.CASHADDRPREFIX,
  pubkeyhash: 0x6f,
  privatekey: 0xef,
  scripthash: 0xc4,
  xpubkey: 0x043587cf,
  xprivkey: 0x04358394,
  networkMagic: REGTEST.NETWORK_MAGIC,
  port: REGTEST.PORT,
  dnsSeeds: [],
  indexBy: [
    'port',
    'name',
    'cashAddrPrefix',
    'networkMagic'
  ]
};
var stnNetwork = {
  name: 'stn',
  prefix: STN.PREFIX,
  cashAddrPrefix: STN.CASHADDRPREFIX,
  pubkeyhash: 0x6f,
  privatekey: 0xef,
  scripthash: 0xc4,
  xpubkey: 0x043587cf,
  xprivkey: 0x04358394,
  networkMagic: STN.NETWORK_MAGIC,
  indexBy: [
    'port',
    'name',
    'cashAddrPrefix',
    'networkMagic'
  ]
};
// Add configurable values for testnet/regtest

addNetwork(testNetwork);
addNetwork(stnNetwork);
addNetwork(regtestNetwork);
addNetwork(liveNetwork);

var livenet = get('livenet');
var regtest = get('regtest');
var testnet = get('testnet');
var stn = get('stn');

Object.defineProperty(testnet, 'port', {
  enumerable: true,
  configurable: false,
  get: function () {
    if (this.regtestEnabled) {
      return REGTEST.PORT
    } else if (this.stnEnabled) {
      return STN.PORT
    } else {
      return TESTNET.PORT
    }
  }
});

Object.defineProperty(testnet, 'networkMagic', {
  enumerable: true,
  configurable: false,
  get: function () {
    if (this.regtestEnabled) {
      return JSUtil$1.integerAsBuffer(REGTEST.NETWORK_MAGIC)
    } else if (this.stnEnabled) {
      return JSUtil$1.integerAsBuffer(STN.NETWORK_MAGIC)
    } else {
      return JSUtil$1.integerAsBuffer(TESTNET.NETWORK_MAGIC)
    }
  }
});

Object.defineProperty(testnet, 'dnsSeeds', {
  enumerable: true,
  configurable: false,
  get: function () {
    if (this.regtestEnabled) {
      return REGTEST.DNS_SEEDS
    } else if (this.stnEnabled) {
      return STN.DNS_SEEDS
    } else {
      return TESTNET.DNS_SEEDS
    }
  }
});

Object.defineProperty(testnet, 'cashAddrPrefix', {
  enumerable: true,
  configurable: false,
  get: function () {
    if (this.regtestEnabled) {
      return REGTEST.CASHADDRPREFIX
    } else if (this.stnEnabled) {
      return STN.CASHADDRPREFIX
    } else {
      return TESTNET.CASHADDRPREFIX
    }
  }
});

Object.defineProperty(testnet, 'cashAddrPrefixArray', {
  enumerable: true,
  configurable: false,
  get: function () {
    if (this.regtestEnabled) {
      return cashAddrPrefixToArray(REGTEST.CASHADDRPREFIX)
    } else if (this.stnEnabled) {
      return STN.cashAddrPrefixToArray(STN.CASHADDRPREFIX)
    } else {
      return cashAddrPrefixToArray(TESTNET.CASHADDRPREFIX)
    }
  }
});

/**
 * @function
 * @member Networks#enableRegtest
 * Will enable regtest features for testnet
 */
function enableRegtest () {
  testnet.regtestEnabled = true;
}

/**
 * @function
 * @member Networks#disableRegtest
 * Will disable regtest features for testnet
 */
function disableRegtest () {
  testnet.regtestEnabled = false;
}
/**
 * @function
 * @member Networks#enableStn
 * Will enable stn features for testnet
 */
function enableStn () {
  testnet.stnEnabled = true;
}

/**
 * @function
 * @member Networks#disableStn
 * Will disable stn features for testnet
 */
function disableStn () {
  testnet.stnEnabled = false;
}

/**
 * @namespace Networks
 */
var networks_1 = {
  add: addNetwork,
  remove: removeNetwork,
  defaultNetwork: livenet,
  livenet: livenet,
  mainnet: livenet,
  testnet: testnet,
  regtest: regtest,
  stn: stn,
  get: get,
  enableRegtest: enableRegtest,
  disableRegtest: disableRegtest,
  enableStn: enableStn,
  disableStn: disableStn
};

var safeBuffer = {exports: {}};

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */

(function (module, exports) {
	/* eslint-disable node/no-deprecated-api */
	var buffer = require$$2$1;
	var Buffer = buffer.Buffer;

	// alternative to using Object.keys for old browsers
	function copyProps (src, dst) {
	  for (var key in src) {
	    dst[key] = src[key];
	  }
	}
	if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
	  module.exports = buffer;
	} else {
	  // Copy properties from require('buffer')
	  copyProps(buffer, exports);
	  exports.Buffer = SafeBuffer;
	}

	function SafeBuffer (arg, encodingOrOffset, length) {
	  return Buffer(arg, encodingOrOffset, length)
	}

	SafeBuffer.prototype = Object.create(Buffer.prototype);

	// Copy static methods from Buffer
	copyProps(Buffer, SafeBuffer);

	SafeBuffer.from = function (arg, encodingOrOffset, length) {
	  if (typeof arg === 'number') {
	    throw new TypeError('Argument must not be a number')
	  }
	  return Buffer(arg, encodingOrOffset, length)
	};

	SafeBuffer.alloc = function (size, fill, encoding) {
	  if (typeof size !== 'number') {
	    throw new TypeError('Argument must be a number')
	  }
	  var buf = Buffer(size);
	  if (fill !== undefined) {
	    if (typeof encoding === 'string') {
	      buf.fill(fill, encoding);
	    } else {
	      buf.fill(fill);
	    }
	  } else {
	    buf.fill(0);
	  }
	  return buf
	};

	SafeBuffer.allocUnsafe = function (size) {
	  if (typeof size !== 'number') {
	    throw new TypeError('Argument must be a number')
	  }
	  return Buffer(size)
	};

	SafeBuffer.allocUnsafeSlow = function (size) {
	  if (typeof size !== 'number') {
	    throw new TypeError('Argument must be a number')
	  }
	  return buffer.SlowBuffer(size)
	}; 
} (safeBuffer, safeBuffer.exports));

var safeBufferExports = safeBuffer.exports;

// base-x encoding / decoding
// Copyright (c) 2018 base-x contributors
// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)
// Distributed under the MIT software license, see the accompanying
// file LICENSE or http://www.opensource.org/licenses/mit-license.php.
// @ts-ignore
var _Buffer = safeBufferExports.Buffer;
function base (ALPHABET) {
  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up
  var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up
  function encode (source) {
    if (Array.isArray(source) || source instanceof Uint8Array) { source = _Buffer.from(source); }
    if (!_Buffer.isBuffer(source)) { throw new TypeError('Expected Buffer') }
    if (source.length === 0) { return '' }
        // Skip & count leading zeroes.
    var zeroes = 0;
    var length = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
        // Allocate enough space in big-endian base58 representation.
    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;
    var b58 = new Uint8Array(size);
        // Process the bytes.
    while (pbegin !== pend) {
      var carry = source[pbegin];
            // Apply "b58 = b58 * 256 + ch".
      var i = 0;
      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {
        carry += (256 * b58[it1]) >>> 0;
        b58[it1] = (carry % BASE) >>> 0;
        carry = (carry / BASE) >>> 0;
      }
      if (carry !== 0) { throw new Error('Non-zero carry') }
      length = i;
      pbegin++;
    }
        // Skip leading zeroes in base58 result.
    var it2 = size - length;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
        // Translate the result into a string.
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]); }
    return str
  }
  function decodeUnsafe (source) {
    if (typeof source !== 'string') { throw new TypeError('Expected String') }
    if (source.length === 0) { return _Buffer.alloc(0) }
    var psz = 0;
        // Skip and count leading '1's.
    var zeroes = 0;
    var length = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
        // Allocate enough space in big-endian base256 representation.
    var size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.
    var b256 = new Uint8Array(size);
        // Process the characters.
    while (source[psz]) {
            // Decode character
      var carry = BASE_MAP[source.charCodeAt(psz)];
            // Invalid character
      if (carry === 255) { return }
      var i = 0;
      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {
        carry += (BASE * b256[it3]) >>> 0;
        b256[it3] = (carry % 256) >>> 0;
        carry = (carry / 256) >>> 0;
      }
      if (carry !== 0) { throw new Error('Non-zero carry') }
      length = i;
      psz++;
    }
        // Skip leading zeroes in b256.
    var it4 = size - length;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = _Buffer.allocUnsafe(zeroes + (size - it4));
    vch.fill(0x00, 0, zeroes);
    var j = zeroes;
    while (it4 !== size) {
      vch[j++] = b256[it4++];
    }
    return vch
  }
  function decode (string) {
    var buffer = decodeUnsafe(string);
    if (buffer) { return buffer }
    throw new Error('Non-base' + BASE + ' character')
  }
  return {
    encode: encode,
    decodeUnsafe: decodeUnsafe,
    decode: decode
  }
}
var src$2 = base;

var basex = src$2;
var ALPHABET$1 = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';

var bs58$1 = basex(ALPHABET$1);

var _$6 = __1;
var bs58 = bs58$1;
var buffer$1 = require$$2$1;

/**
 * The alphabet for the Bitcoin-specific Base 58 encoding distinguishes between
 * lower case L and upper case i - neither of those characters are allowed to
 * prevent accidentaly miscopying of letters.
 */
var ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'.split('');

/**
 * A Base58 object can encode/decoded Base 58, which is used primarily for
 * string-formatted Bitcoin addresses and private keys. Addresses and private
 * keys actually use an additional checksum, and so they actually use the
 * Base58Check class.
 *
 * @param {object} obj Can be a string or buffer.
 */
var Base58$1 = function Base58 (obj) {
  if (!(this instanceof Base58)) {
    return new Base58(obj)
  }
  if (isBuffer$2(obj)) {
    var buf = obj;
    this.fromBuffer(buf);
  } else if (typeof obj === 'string') {
    var str = obj;
    this.fromString(str);
  }
};

Base58$1.validCharacters = function validCharacters (chars) {
  if (buffer$1.Buffer.isBuffer(chars)) {
    chars = chars.toString();
  }
  return _$6.every(_$6.map(chars, function (char) { return _$6.includes(ALPHABET, char) }))
};

Base58$1.prototype.set = function (obj) {
  this.buf = obj.buf || this.buf || undefined;
  return this
};

/**
 * Encode a buffer to Bsae 58.
 *
 * @param {Buffer} buf Any buffer to be encoded.
 * @returns {string} A Base 58 encoded string.
 */
Base58$1.encode = function (buf) {
  if (!buffer$1.Buffer.isBuffer(buf)) {
    throw new Error('Input should be a buffer')
  }
  return bs58.encode(buf)
};

/**
 * Decode a Base 58 string to a buffer.
 *
 * @param {string} str A Base 58 encoded string.
 * @returns {Buffer} The decoded buffer.
 */
Base58$1.decode = function (str) {
  if (typeof str !== 'string') {
    throw new Error('Input should be a string')
  }
  return Buffer.from(bs58.decode(str))
};

Base58$1.prototype.fromBuffer = function (buf) {
  this.buf = buf;
  return this
};

Base58$1.fromBuffer = function (buf) {
  return new Base58$1().fromBuffer(buf)
};

Base58$1.fromHex = function (hex) {
  return Base58$1.fromBuffer(Buffer.from(hex, 'hex'))
};

Base58$1.prototype.fromString = function (str) {
  var buf = Base58$1.decode(str);
  this.buf = buf;
  return this
};

Base58$1.fromString = function (str) {
  return new Base58$1().fromString(str)
};

Base58$1.prototype.toBuffer = function () {
  return this.buf
};

Base58$1.prototype.toHex = function () {
  return this.toBuffer().toString('hex')
};

Base58$1.prototype.toString = function () {
  return Base58$1.encode(this.buf)
};

var base58 = Base58$1;

var _$5 = __1;
var Base58 = base58;
var buffer = require$$2$1;
var sha256sha256 = hashExports.sha256sha256;

/**
 * A Base58check object can encode/decodd Base 58, which is used primarily for
 * string-formatted Bitcoin addresses and private keys. This is the same as
 * Base58, except that it includes a checksum to prevent accidental mistypings.
 *
 * @param {object} obj Can be a string or buffer.
 */
var Base58Check = function Base58Check (obj) {
  if (!(this instanceof Base58Check)) { return new Base58Check(obj) }
  if (isBuffer$2(obj)) {
    var buf = obj;
    this.fromBuffer(buf);
  } else if (typeof obj === 'string') {
    var str = obj;
    this.fromString(str);
  }
};

Base58Check.prototype.set = function (obj) {
  this.buf = obj.buf || this.buf || undefined;
  return this
};

Base58Check.validChecksum = function validChecksum (data, checksum) {
  if (_$5.isString(data)) {
    data = buffer.Buffer.from(Base58.decode(data));
  }
  if (_$5.isString(checksum)) {
    checksum = buffer.Buffer.from(Base58.decode(checksum));
  }
  if (!checksum) {
    checksum = data.slice(-4);
    data = data.slice(0, -4);
  }
  return Base58Check.checksum(data).toString('hex') === checksum.toString('hex')
};

Base58Check.decode = function (s) {
  if (typeof s !== 'string') { throw new Error('Input must be a string') }

  var buf = Buffer.from(Base58.decode(s));

  if (buf.length < 4) { throw new Error('Input string too short') }

  var data = buf.slice(0, -4);
  var csum = buf.slice(-4);

  var hash = sha256sha256(data);
  var hash4 = hash.slice(0, 4);

  if (csum.toString('hex') !== hash4.toString('hex')) { throw new Error('Checksum mismatch') }

  return data
};

Base58Check.checksum = function (buffer) {
  return sha256sha256(buffer).slice(0, 4)
};

Base58Check.encode = function (buf) {
  if (!isBuffer$2(buf)) { throw new Error('Input must be a buffer') }
  var checkedBuf = Buffer.alloc(buf.length + 4);
  var hash = Base58Check.checksum(buf);
  buf.copy(checkedBuf);
  hash.copy(checkedBuf, buf.length);
  return Base58.encode(checkedBuf)
};

Base58Check.prototype.fromBuffer = function (buf) {
  this.buf = buf;
  return this
};

Base58Check.fromBuffer = function (buf) {
  return new Base58Check().fromBuffer(buf)
};

Base58Check.fromHex = function (hex) {
  return Base58Check.fromBuffer(Buffer.from(hex, 'hex'))
};

Base58Check.prototype.fromString = function (str) {
  var buf = Base58Check.decode(str);
  this.buf = buf;
  return this
};

Base58Check.fromString = function (str) {
  var buf = Base58Check.decode(str);
  return new Base58(buf)
};

Base58Check.prototype.toBuffer = function () {
  return this.buf
};

Base58Check.prototype.toHex = function () {
  return this.toBuffer().toString('hex')
};

Base58Check.prototype.toString = function () {
  return Base58Check.encode(this.buf)
};

var base58check = Base58Check;

var script$1 = {exports: {}};

var _$4 = __1;
var $$6 = preconditions;
var BN$3 = bn$1;

var BufferReader$4 = function BufferReader (buf) {
  if (!(this instanceof BufferReader)) {
    return new BufferReader(buf)
  }
  if (_$4.isUndefined(buf)) {
    return
  }
  if (isBuffer$2(buf)) {
    this.set({
      buf: buf
    });
  } else if (_$4.isString(buf)) {
    var b = Buffer.from(buf, 'hex');
    if (b.length * 2 !== buf.length) { throw new TypeError('Invalid hex string') }

    this.set({
      buf: b
    });
  } else if (_$4.isObject(buf)) {
    var obj = buf;
    this.set(obj);
  } else {
    throw new TypeError('Unrecognized argument for BufferReader')
  }
};

BufferReader$4.prototype.set = function (obj) {
  this.buf = obj.buf || this.buf || undefined;
  this.pos = obj.pos || this.pos || 0;
  return this
};

BufferReader$4.prototype.eof = function () {
  return this.pos >= this.buf.length
};

BufferReader$4.prototype.finished = BufferReader$4.prototype.eof;

BufferReader$4.prototype.read = function (len) {
  $$6.checkArgument(!_$4.isUndefined(len), 'Must specify a length');
  var buf = this.buf.slice(this.pos, this.pos + len);
  this.pos = this.pos + len;
  return buf
};

BufferReader$4.prototype.readAll = function () {
  var buf = this.buf.slice(this.pos, this.buf.length);
  this.pos = this.buf.length;
  return buf
};

BufferReader$4.prototype.readUInt8 = function () {
  var val = this.buf.readUInt8(this.pos);
  this.pos = this.pos + 1;
  return val
};

BufferReader$4.prototype.readUInt16BE = function () {
  var val = this.buf.readUInt16BE(this.pos);
  this.pos = this.pos + 2;
  return val
};

BufferReader$4.prototype.readUInt16LE = function () {
  var val = this.buf.readUInt16LE(this.pos);
  this.pos = this.pos + 2;
  return val
};

BufferReader$4.prototype.readUInt32BE = function () {
  var val = this.buf.readUInt32BE(this.pos);
  this.pos = this.pos + 4;
  return val
};

BufferReader$4.prototype.readUInt32LE = function () {
  var val = this.buf.readUInt32LE(this.pos);
  this.pos = this.pos + 4;
  return val
};

BufferReader$4.prototype.readInt32LE = function () {
  var val = this.buf.readInt32LE(this.pos);
  this.pos = this.pos + 4;
  return val
};

BufferReader$4.prototype.readUInt64BEBN = function () {
  var buf = this.buf.slice(this.pos, this.pos + 8);
  var bn = BN$3.fromBuffer(buf);
  this.pos = this.pos + 8;
  return bn
};

BufferReader$4.prototype.readUInt64LEBN = function () {
  var second = this.buf.readUInt32LE(this.pos);
  var first = this.buf.readUInt32LE(this.pos + 4);
  var combined = (first * 0x100000000) + second;
  // Instantiating an instance of BN with a number is faster than with an
  // array or string. However, the maximum safe number for a double precision
  // floating point is 2 ^ 52 - 1 (0x1fffffffffffff), thus we can safely use
  // non-floating point numbers less than this amount (52 bits). And in the case
  // that the number is larger, we can instatiate an instance of BN by passing
  // an array from the buffer (slower) and specifying the endianness.
  var bn;
  if (combined <= 0x1fffffffffffff) {
    bn = new BN$3(combined);
  } else {
    var data = Array.prototype.slice.call(this.buf, this.pos, this.pos + 8);
    bn = new BN$3(data, 10, 'le');
  }
  this.pos = this.pos + 8;
  return bn
};

BufferReader$4.prototype.readVarintNum = function () {
  var first = this.readUInt8();
  switch (first) {
    case 0xFD:
      return this.readUInt16LE()
    case 0xFE:
      return this.readUInt32LE()
    case 0xFF:
      var bn = this.readUInt64LEBN();
      var n = bn.toNumber();
      if (n <= Math.pow(2, 53)) {
        return n
      } else {
        throw new Error('number too large to retain precision - use readVarintBN')
      }
      // break // unreachable
    default:
      return first
  }
};

/**
 * reads a length prepended buffer
 */
BufferReader$4.prototype.readVarLengthBuffer = function () {
  var len = this.readVarintNum();
  var buf = this.read(len);
  $$6.checkState(buf.length === len, 'Invalid length while reading varlength buffer. ' +
    'Expected to read: ' + len + ' and read ' + buf.length);
  return buf
};

BufferReader$4.prototype.readVarintBuf = function () {
  var first = this.buf.readUInt8(this.pos);
  switch (first) {
    case 0xFD:
      return this.read(1 + 2)
    case 0xFE:
      return this.read(1 + 4)
    case 0xFF:
      return this.read(1 + 8)
    default:
      return this.read(1)
  }
};

BufferReader$4.prototype.readVarintBN = function () {
  var first = this.readUInt8();
  switch (first) {
    case 0xFD:
      return new BN$3(this.readUInt16LE())
    case 0xFE:
      return new BN$3(this.readUInt32LE())
    case 0xFF:
      return this.readUInt64LEBN()
    default:
      return new BN$3(first)
  }
};

BufferReader$4.prototype.reverse = function () {
  var buf = Buffer.alloc(this.buf.length);
  for (var i = 0; i < buf.length; i++) {
    buf[i] = this.buf[this.buf.length - 1 - i];
  }
  this.buf = buf;
  return this
};

BufferReader$4.prototype.readReverse = function (len) {
  if (_$4.isUndefined(len)) {
    len = this.buf.length;
  }
  var buf = this.buf.slice(this.pos, this.pos + len);
  this.pos = this.pos + len;
  return Buffer.from(buf).reverse()
};

var bufferreader = BufferReader$4;

var assert$1 = require$$0$4;

var BufferWriter$4 = function BufferWriter (obj) {
  if (!(this instanceof BufferWriter)) { return new BufferWriter(obj) }
  this.bufLen = 0;
  if (obj) { this.set(obj); } else { this.bufs = []; }
};

BufferWriter$4.prototype.set = function (obj) {
  this.bufs = obj.bufs || this.bufs || [];
  this.bufLen = this.bufs.reduce(function (prev, buf) { return prev + buf.length }, 0);
  return this
};

BufferWriter$4.prototype.toBuffer = function () {
  return this.concat()
};

BufferWriter$4.prototype.concat = function () {
  return Buffer.concat(this.bufs, this.bufLen)
};

BufferWriter$4.prototype.write = function (buf) {
  assert$1(isBuffer$2(buf));
  this.bufs.push(buf);
  this.bufLen += buf.length;
  return this
};

BufferWriter$4.prototype.writeReverse = function (buf) {
  assert$1(isBuffer$2(buf));
  this.bufs.push(Buffer.from(buf).reverse());
  this.bufLen += buf.length;
  return this
};

BufferWriter$4.prototype.writeUInt8 = function (n) {
  var buf = Buffer.alloc(1);
  buf.writeUInt8(n, 0);
  this.write(buf);
  return this
};

BufferWriter$4.prototype.writeUInt16BE = function (n) {
  var buf = Buffer.alloc(2);
  buf.writeUInt16BE(n, 0);
  this.write(buf);
  return this
};

BufferWriter$4.prototype.writeUInt16LE = function (n) {
  var buf = Buffer.alloc(2);
  buf.writeUInt16LE(n, 0);
  this.write(buf);
  return this
};

BufferWriter$4.prototype.writeUInt32BE = function (n) {
  var buf = Buffer.alloc(4);
  buf.writeUInt32BE(n, 0);
  this.write(buf);
  return this
};

BufferWriter$4.prototype.writeInt32LE = function (n) {
  var buf = Buffer.alloc(4);
  buf.writeInt32LE(n, 0);
  this.write(buf);
  return this
};

BufferWriter$4.prototype.writeUInt32LE = function (n) {
  var buf = Buffer.alloc(4);
  buf.writeUInt32LE(n, 0);
  this.write(buf);
  return this
};

BufferWriter$4.prototype.writeUInt64BEBN = function (bn) {
  var buf = bn.toBuffer({ size: 8 });
  this.write(buf);
  return this
};

BufferWriter$4.prototype.writeUInt64LEBN = function (bn) {
  var buf = bn.toBuffer({ size: 8 });
  this.writeReverse(buf);
  return this
};

BufferWriter$4.prototype.writeVarintNum = function (n) {
  var buf = BufferWriter$4.varintBufNum(n);
  this.write(buf);
  return this
};

BufferWriter$4.prototype.writeVarintBN = function (bn) {
  var buf = BufferWriter$4.varintBufBN(bn);
  this.write(buf);
  return this
};

BufferWriter$4.varintBufNum = function (n) {
  var buf;
  if (n < 253) {
    buf = Buffer.alloc(1);
    buf.writeUInt8(n, 0);
  } else if (n < 0x10000) {
    buf = Buffer.alloc(1 + 2);
    buf.writeUInt8(253, 0);
    buf.writeUInt16LE(n, 1);
  } else if (n < 0x100000000) {
    buf = Buffer.alloc(1 + 4);
    buf.writeUInt8(254, 0);
    buf.writeUInt32LE(n, 1);
  } else {
    buf = Buffer.alloc(1 + 8);
    buf.writeUInt8(255, 0);
    buf.writeInt32LE(n & -1, 1);
    buf.writeUInt32LE(Math.floor(n / 0x100000000), 5);
  }
  return buf
};

BufferWriter$4.varintBufBN = function (bn) {
  var buf;
  var n = bn.toNumber();
  if (n < 253) {
    buf = Buffer.alloc(1);
    buf.writeUInt8(n, 0);
  } else if (n < 0x10000) {
    buf = Buffer.alloc(1 + 2);
    buf.writeUInt8(253, 0);
    buf.writeUInt16LE(n, 1);
  } else if (n < 0x100000000) {
    buf = Buffer.alloc(1 + 4);
    buf.writeUInt8(254, 0);
    buf.writeUInt32LE(n, 1);
  } else {
    var bw = new BufferWriter$4();
    bw.writeUInt8(255);
    bw.writeUInt64LEBN(bn);
    buf = bw.concat();
  }
  return buf
};

var bufferwriter = BufferWriter$4;

var _$3 = __1;
var $$5 = preconditions;
var JSUtil = js;

function Opcode (num) {
  if (!(this instanceof Opcode)) {
    return new Opcode(num)
  }

  var value;

  if (_$3.isNumber(num)) {
    value = num;
  } else if (_$3.isString(num)) {
    value = Opcode.map[num];
  } else {
    throw new TypeError('Unrecognized num type: "' + typeof (num) + '" for Opcode')
  }

  JSUtil.defineImmutable(this, {
    num: value
  });

  return this
}

Opcode.fromBuffer = function (buf) {
  $$5.checkArgument(isBuffer$2(buf));
  return new Opcode(Number('0x' + buf.toString('hex')))
};

Opcode.fromNumber = function (num) {
  $$5.checkArgument(_$3.isNumber(num));
  return new Opcode(num)
};

Opcode.fromString = function (str) {
  $$5.checkArgument(_$3.isString(str));
  var value = Opcode.map[str];
  if (typeof value === 'undefined') {
    throw new TypeError('Invalid opcodestr')
  }
  return new Opcode(value)
};

Opcode.prototype.toHex = function () {
  return this.num.toString(16)
};

Opcode.prototype.toBuffer = function () {
  return Buffer.from(this.toHex(), 'hex')
};

Opcode.prototype.toNumber = function () {
  return this.num
};

Opcode.prototype.toString = function () {
  var str = Opcode.reverseMap[this.num];
  if (typeof str === 'undefined') {
    throw new Error('Opcode does not have a string representation')
  }
  return str
};

Opcode.prototype.toSafeString = function () {
  var str = Opcode.reverseMap[this.num];
  if (typeof str === 'undefined') {
    return this.toHex()
  }
  return str
};

Opcode.smallInt = function (n) {
  $$5.checkArgument(_$3.isNumber(n), 'Invalid Argument: n should be number');
  $$5.checkArgument(n >= 0 && n <= 16, 'Invalid Argument: n must be between 0 and 16');
  if (n === 0) {
    return Opcode('OP_0')
  }
  return new Opcode(Opcode.map.OP_1 + n - 1)
};

Opcode.map = {
  // push value
  OP_FALSE: 0,
  OP_0: 0,
  OP_PUSHDATA1: 76,
  OP_PUSHDATA2: 77,
  OP_PUSHDATA4: 78,
  OP_1NEGATE: 79,
  OP_RESERVED: 80,
  OP_TRUE: 81,
  OP_1: 81,
  OP_2: 82,
  OP_3: 83,
  OP_4: 84,
  OP_5: 85,
  OP_6: 86,
  OP_7: 87,
  OP_8: 88,
  OP_9: 89,
  OP_10: 90,
  OP_11: 91,
  OP_12: 92,
  OP_13: 93,
  OP_14: 94,
  OP_15: 95,
  OP_16: 96,

  // control
  OP_NOP: 97,
  OP_VER: 98,
  OP_IF: 99,
  OP_NOTIF: 100,
  OP_VERIF: 101,
  OP_VERNOTIF: 102,
  OP_ELSE: 103,
  OP_ENDIF: 104,
  OP_VERIFY: 105,
  OP_RETURN: 106,

  // stack ops
  OP_TOALTSTACK: 107,
  OP_FROMALTSTACK: 108,
  OP_2DROP: 109,
  OP_2DUP: 110,
  OP_3DUP: 111,
  OP_2OVER: 112,
  OP_2ROT: 113,
  OP_2SWAP: 114,
  OP_IFDUP: 115,
  OP_DEPTH: 116,
  OP_DROP: 117,
  OP_DUP: 118,
  OP_NIP: 119,
  OP_OVER: 120,
  OP_PICK: 121,
  OP_ROLL: 122,
  OP_ROT: 123,
  OP_SWAP: 124,
  OP_TUCK: 125,

  // splice ops
  OP_CAT: 126,
  OP_SPLIT: 127,
  OP_NUM2BIN: 128,
  OP_BIN2NUM: 129,
  OP_SIZE: 130,

  // bit logic
  OP_INVERT: 131,
  OP_AND: 132,
  OP_OR: 133,
  OP_XOR: 134,
  OP_EQUAL: 135,
  OP_EQUALVERIFY: 136,
  OP_RESERVED1: 137,
  OP_RESERVED2: 138,

  // numeric
  OP_1ADD: 139,
  OP_1SUB: 140,
  OP_2MUL: 141,
  OP_2DIV: 142,
  OP_NEGATE: 143,
  OP_ABS: 144,
  OP_NOT: 145,
  OP_0NOTEQUAL: 146,

  OP_ADD: 147,
  OP_SUB: 148,
  OP_MUL: 149,
  OP_DIV: 150,
  OP_MOD: 151,
  OP_LSHIFT: 152,
  OP_RSHIFT: 153,

  OP_BOOLAND: 154,
  OP_BOOLOR: 155,
  OP_NUMEQUAL: 156,
  OP_NUMEQUALVERIFY: 157,
  OP_NUMNOTEQUAL: 158,
  OP_LESSTHAN: 159,
  OP_GREATERTHAN: 160,
  OP_LESSTHANOREQUAL: 161,
  OP_GREATERTHANOREQUAL: 162,
  OP_MIN: 163,
  OP_MAX: 164,

  OP_WITHIN: 165,

  // crypto
  OP_RIPEMD160: 166,
  OP_SHA1: 167,
  OP_SHA256: 168,
  OP_HASH160: 169,
  OP_HASH256: 170,
  OP_CODESEPARATOR: 171,
  OP_CHECKSIG: 172,
  OP_CHECKSIGVERIFY: 173,
  OP_CHECKMULTISIG: 174,
  OP_CHECKMULTISIGVERIFY: 175,

  OP_CHECKLOCKTIMEVERIFY: 177,
  OP_CHECKSEQUENCEVERIFY: 178,

  // expansion
  OP_NOP1: 176,
  OP_NOP2: 177,
  OP_NOP3: 178,
  OP_NOP4: 179,
  OP_NOP5: 180,
  OP_NOP6: 181,
  OP_NOP7: 182,
  OP_NOP8: 183,
  OP_NOP9: 184,
  OP_NOP10: 185,

  // template matching params
  OP_PUBKEYHASH: 253,
  OP_PUBKEY: 254,
  OP_INVALIDOPCODE: 255
};

Opcode.reverseMap = [];

for (var k in Opcode.map) {
  Opcode.reverseMap[Opcode.map[k]] = k;
}

// Easier access to opcodes
_$3.extend(Opcode, Opcode.map);

/**
 * @returns true if opcode is one of OP_0, OP_1, ..., OP_16
 */
Opcode.isSmallIntOp = function (opcode) {
  if (opcode instanceof Opcode) {
    opcode = opcode.toNumber();
  }
  return ((opcode === Opcode.map.OP_0) ||
    ((opcode >= Opcode.map.OP_1) && (opcode <= Opcode.map.OP_16)))
};

/**
 * Will return a string formatted for the console
 *
 * @returns {string} Script opcode
 */
Opcode.prototype.inspect = function () {
  return '<Opcode: ' + this.toString() + ', hex: ' + this.toHex() + ', decimal: ' + this.num + '>'
};

var opcode = Opcode;

var script;
var hasRequiredScript$1;

function requireScript$1 () {
	if (hasRequiredScript$1) return script;
	hasRequiredScript$1 = 1;

	var Address = requireAddress();
	var BufferReader = bufferreader;
	var BufferWriter = bufferwriter;
	var Hash = hashExports;
	var Opcode = opcode;
	var PublicKey = requirePublickey();
	var Signature = signature$1;
	var Networks = networks_1;
	var $ = preconditions;
	var _ = __1;
	var errors = errorsExports;
	var buffer = require$$2$1;
	var JSUtil = js;

	/**
	 * A bitcoin transaction script. Each transaction's inputs and outputs
	 * has a script that is evaluated to validate it's spending.
	 *
	 * See https://en.bitcoin.it/wiki/Script
	 *
	 * @constructor
	 * @param {Object|string|Buffer=} from optional data to populate script
	 */
	var Script = function Script(from) {
	  if (!(this instanceof Script)) {
	    return new Script(from)
	  }
	  this.chunks = [];

	  if (isBuffer$2(from)) {
	    return Script.fromBuffer(from)
	  } else if (from instanceof Address) {
	    return Script.fromAddress(from)
	  } else if (from instanceof Script) {
	    return Script.fromBuffer(from.toBuffer())
	  } else if (_.isString(from)) {
	    return Script.fromString(from)
	  } else if (_.isObject(from) && _.isArray(from.chunks)) {
	    this.set(from);
	  }
	};

	Script.prototype.set = function (obj) {
	  $.checkArgument(_.isObject(obj));
	  $.checkArgument(_.isArray(obj.chunks));
	  this.chunks = obj.chunks;
	  return this
	};

	Script.fromBuffer = function (buffer) {
	  var script = new Script();
	  script.chunks = [];

	  var br = new BufferReader(buffer);
	  while (!br.finished()) {
	    try {
	      var opcodenum = br.readUInt8();

	      var len, buf;
	      if (opcodenum > 0 && opcodenum < Opcode.OP_PUSHDATA1) {
	        len = opcodenum;
	        script.chunks.push({
	          buf: br.read(len),
	          len: len,
	          opcodenum: opcodenum
	        });
	      } else if (opcodenum === Opcode.OP_PUSHDATA1) {
	        len = br.readUInt8();
	        buf = br.read(len);
	        script.chunks.push({
	          buf: buf,
	          len: len,
	          opcodenum: opcodenum
	        });
	      } else if (opcodenum === Opcode.OP_PUSHDATA2) {
	        len = br.readUInt16LE();
	        buf = br.read(len);
	        script.chunks.push({
	          buf: buf,
	          len: len,
	          opcodenum: opcodenum
	        });
	      } else if (opcodenum === Opcode.OP_PUSHDATA4) {
	        len = br.readUInt32LE();
	        buf = br.read(len);
	        script.chunks.push({
	          buf: buf,
	          len: len,
	          opcodenum: opcodenum
	        });
	      } else {
	        script.chunks.push({
	          opcodenum: opcodenum
	        });
	      }
	    } catch (e) {
	      if (e instanceof RangeError) {
	        throw new errors.Script.InvalidBuffer(buffer.toString('hex'))
	      }
	      throw e
	    }
	  }

	  return script
	};

	Script.prototype.toBuffer = function () {
	  var bw = new BufferWriter();

	  for (var i = 0; i < this.chunks.length; i++) {
	    var chunk = this.chunks[i];
	    var opcodenum = chunk.opcodenum;
	    bw.writeUInt8(chunk.opcodenum);
	    if (chunk.buf) {
	      if (opcodenum < Opcode.OP_PUSHDATA1) {
	        bw.write(chunk.buf);
	      } else if (opcodenum === Opcode.OP_PUSHDATA1) {
	        bw.writeUInt8(chunk.len);
	        bw.write(chunk.buf);
	      } else if (opcodenum === Opcode.OP_PUSHDATA2) {
	        bw.writeUInt16LE(chunk.len);
	        bw.write(chunk.buf);
	      } else if (opcodenum === Opcode.OP_PUSHDATA4) {
	        bw.writeUInt32LE(chunk.len);
	        bw.write(chunk.buf);
	      }
	    }
	  }

	  return bw.concat()
	};

	Script.fromASM = function (str) {
	  var script = new Script();
	  script.chunks = [];

	  var tokens = str.split(' ');
	  var i = 0;
	  while (i < tokens.length) {
	    var token = tokens[i];
	    var opcode = Opcode(token);
	    var opcodenum = opcode.toNumber();

	    // we start with two special cases, 0 and -1, which are handled specially in
	    // toASM. see _chunkToString.
	    if (token === '0') {
	      opcodenum = 0;
	      script.chunks.push({
	        opcodenum: opcodenum
	      });
	      i = i + 1;
	    } else if (token === '-1') {
	      opcodenum = Opcode.OP_1NEGATE;
	      script.chunks.push({
	        opcodenum: opcodenum
	      });
	      i = i + 1;
	    } else if (_.isUndefined(opcodenum)) {
	      var buf = Buffer.from(tokens[i], 'hex');
	      if (buf.toString('hex') !== tokens[i]) {
	        throw new Error('invalid hex string in script')
	      }
	      var len = buf.length;
	      if (len >= 0 && len < Opcode.OP_PUSHDATA1) {
	        opcodenum = len;
	      } else if (len < Math.pow(2, 8)) {
	        opcodenum = Opcode.OP_PUSHDATA1;
	      } else if (len < Math.pow(2, 16)) {
	        opcodenum = Opcode.OP_PUSHDATA2;
	      } else if (len < Math.pow(2, 32)) {
	        opcodenum = Opcode.OP_PUSHDATA4;
	      }
	      script.chunks.push({
	        buf: buf,
	        len: buf.length,
	        opcodenum: opcodenum
	      });
	      i = i + 1;
	    } else {
	      script.chunks.push({
	        opcodenum: opcodenum
	      });
	      i = i + 1;
	    }
	  }
	  return script
	};

	Script.fromHex = function (str) {
	  return new Script(buffer.Buffer.from(str, 'hex'))
	};

	Script.fromString = function (str) {
	  if (JSUtil.isHexa(str) || str.length === 0) {
	    return new Script(buffer.Buffer.from(str, 'hex'))
	  }
	  var script = new Script();
	  script.chunks = [];

	  var tokens = str.split(' ');
	  var i = 0;
	  while (i < tokens.length) {
	    var token = tokens[i];
	    var opcode = Opcode(token);
	    var opcodenum = opcode.toNumber();

	    if (_.isUndefined(opcodenum)) {
	      opcodenum = parseInt(token);
	      if (opcodenum > 0 && opcodenum < Opcode.OP_PUSHDATA1) {
	        script.chunks.push({
	          buf: Buffer.from(tokens[i + 1].slice(2), 'hex'),
	          len: opcodenum,
	          opcodenum: opcodenum
	        });
	        i = i + 2;
	      } else {
	        throw new Error('Invalid script: ' + JSON.stringify(str))
	      }
	    } else if (opcodenum === Opcode.OP_PUSHDATA1 ||
	      opcodenum === Opcode.OP_PUSHDATA2 ||
	      opcodenum === Opcode.OP_PUSHDATA4) {
	      if (tokens[i + 2].slice(0, 2) !== '0x') {
	        throw new Error('Pushdata data must start with 0x')
	      }
	      script.chunks.push({
	        buf: Buffer.from(tokens[i + 2].slice(2), 'hex'),
	        len: parseInt(tokens[i + 1]),
	        opcodenum: opcodenum
	      });
	      i = i + 3;
	    } else {
	      script.chunks.push({
	        opcodenum: opcodenum
	      });
	      i = i + 1;
	    }
	  }
	  return script
	};

	Script.prototype._chunkToString = function (chunk, type) {
	  var opcodenum = chunk.opcodenum;
	  var asm = (type === 'asm');
	  var str = '';
	  if (!chunk.buf) {
	    // no data chunk
	    if (typeof Opcode.reverseMap[opcodenum] !== 'undefined') {
	      if (asm) {
	        // A few cases where the opcode name differs from reverseMap
	        // aside from 1 to 16 data pushes.
	        if (opcodenum === 0) {
	          // OP_0 -> 0
	          str = str + ' 0';
	        } else if (opcodenum === 79) {
	          // OP_1NEGATE -> 1
	          str = str + ' -1';
	        } else {
	          str = str + ' ' + Opcode(opcodenum).toString();
	        }
	      } else {
	        str = str + ' ' + Opcode(opcodenum).toString();
	      }
	    } else {
	      var numstr = opcodenum.toString(16);
	      if (numstr.length % 2 !== 0) {
	        numstr = '0' + numstr;
	      }
	      if (asm) {
	        str = str + ' ' + numstr;
	      } else {
	        str = str + ' ' + '0x' + numstr;
	      }
	    }
	  } else {
	    // data chunk
	    if (!asm && (opcodenum === Opcode.OP_PUSHDATA1 ||
	      opcodenum === Opcode.OP_PUSHDATA2 ||
	      opcodenum === Opcode.OP_PUSHDATA4)) {
	      str = str + ' ' + Opcode(opcodenum).toString();
	    }
	    if (chunk.len > 0) {
	      if (asm) {
	        str = str + ' ' + chunk.buf.toString('hex');
	      } else {
	        str = str + ' ' + chunk.len + ' ' + '0x' + chunk.buf.toString('hex');
	      }
	    }
	  }
	  return str
	};

	Script.prototype.toASM = function () {
	  var str = '';
	  for (var i = 0; i < this.chunks.length; i++) {
	    var chunk = this.chunks[i];
	    str += this._chunkToString(chunk, 'asm');
	  }

	  return str.substr(1)
	};

	Script.prototype.toString = function () {
	  var str = '';
	  for (var i = 0; i < this.chunks.length; i++) {
	    var chunk = this.chunks[i];
	    str += this._chunkToString(chunk);
	  }

	  return str.substr(1)
	};

	Script.prototype.toHex = function () {
	  return this.toBuffer().toString('hex')
	};

	Script.prototype.inspect = function () {
	  return '<Script: ' + this.toString() + '>'
	};

	// script classification methods

	/**
	 * @returns {boolean} if this is a pay to pubkey hash output script
	 */
	Script.prototype.isPublicKeyHashOut = function () {
	  return !!(this.chunks.length === 5 &&
	    this.chunks[0].opcodenum === Opcode.OP_DUP &&
	    this.chunks[1].opcodenum === Opcode.OP_HASH160 &&
	    this.chunks[2].buf &&
	    this.chunks[2].buf.length === 20 &&
	    this.chunks[3].opcodenum === Opcode.OP_EQUALVERIFY &&
	    this.chunks[4].opcodenum === Opcode.OP_CHECKSIG)
	};

	/**
	 * @returns {boolean} if this is a pay to public key hash input script
	 */
	Script.prototype.isPublicKeyHashIn = function () {
	  if (this.chunks.length === 2) {
	    var signatureBuf = this.chunks[0].buf;
	    var pubkeyBuf = this.chunks[1].buf;
	    if (signatureBuf &&
	      signatureBuf.length &&
	      signatureBuf[0] === 0x30 &&
	      pubkeyBuf &&
	      pubkeyBuf.length
	    ) {
	      var version = pubkeyBuf[0];
	      if ((version === 0x04 ||
	        version === 0x06 ||
	        version === 0x07) && pubkeyBuf.length === 65) {
	        return true
	      } else if ((version === 0x03 || version === 0x02) && pubkeyBuf.length === 33) {
	        return true
	      }
	    }
	  }
	  return false
	};

	Script.prototype.getPublicKey = function () {
	  $.checkState(this.isPublicKeyOut(), 'Can\'t retrieve PublicKey from a non-PK output');
	  return this.chunks[0].buf
	};

	Script.prototype.getPublicKeyHash = function () {
	  $.checkState(this.isPublicKeyHashOut(), 'Can\'t retrieve PublicKeyHash from a non-PKH output');
	  return this.chunks[2].buf
	};

	/**
	 * @returns {boolean} if this is a public key output script
	 */
	Script.prototype.isPublicKeyOut = function () {
	  if (this.chunks.length === 2 &&
	    this.chunks[0].buf &&
	    this.chunks[0].buf.length &&
	    this.chunks[1].opcodenum === Opcode.OP_CHECKSIG) {
	    var pubkeyBuf = this.chunks[0].buf;
	    var version = pubkeyBuf[0];
	    var isVersion = false;
	    if ((version === 0x04 ||
	      version === 0x06 ||
	      version === 0x07) && pubkeyBuf.length === 65) {
	      isVersion = true;
	    } else if ((version === 0x03 || version === 0x02) && pubkeyBuf.length === 33) {
	      isVersion = true;
	    }
	    if (isVersion) {
	      return PublicKey.isValid(pubkeyBuf)
	    }
	  }
	  return false
	};

	/**
	 * @returns {boolean} if this is a pay to public key input script
	 */
	Script.prototype.isPublicKeyIn = function () {
	  if (this.chunks.length === 1) {
	    var signatureBuf = this.chunks[0].buf;
	    if (signatureBuf &&
	      signatureBuf.length &&
	      signatureBuf[0] === 0x30) {
	      return true
	    }
	  }
	  return false
	};

	/**
	 * @returns {boolean} if this is a p2sh output script
	 */
	Script.prototype.isScriptHashOut = function () {
	  var buf = this.toBuffer();
	  return (buf.length === 23 &&
	    buf[0] === Opcode.OP_HASH160 &&
	    buf[1] === 0x14 &&
	    buf[buf.length - 1] === Opcode.OP_EQUAL)
	};

	/**
	 * @returns {boolean} if this is a p2sh input script
	 * Note that these are frequently indistinguishable from pubkeyhashin
	 */
	Script.prototype.isScriptHashIn = function () {
	  if (this.chunks.length <= 1) {
	    return false
	  }
	  var redeemChunk = this.chunks[this.chunks.length - 1];
	  var redeemBuf = redeemChunk.buf;
	  if (!redeemBuf) {
	    return false
	  }

	  var redeemScript;
	  try {
	    redeemScript = Script.fromBuffer(redeemBuf);
	  } catch (e) {
	    if (e instanceof errors.Script.InvalidBuffer) {
	      return false
	    }
	    throw e
	  }
	  var type = redeemScript.classify();
	  return type !== Script.types.UNKNOWN
	};

	/**
	 * @returns {boolean} if this is a mutlsig output script
	 */
	Script.prototype.isMultisigOut = function () {
	  return (this.chunks.length > 3 &&
	    Opcode.isSmallIntOp(this.chunks[0].opcodenum) &&
	    this.chunks.slice(1, this.chunks.length - 2).every(function (obj) {
	      return obj.buf && isBuffer$2(obj.buf)
	    }) &&
	    Opcode.isSmallIntOp(this.chunks[this.chunks.length - 2].opcodenum) &&
	    this.chunks[this.chunks.length - 1].opcodenum === Opcode.OP_CHECKMULTISIG)
	};

	/**
	 * @returns {boolean} if this is a multisig input script
	 */
	Script.prototype.isMultisigIn = function () {
	  return this.chunks.length >= 2 &&
	    this.chunks[0].opcodenum === 0 &&
	    this.chunks.slice(1, this.chunks.length).every(function (obj) {
	      return obj.buf &&
	        isBuffer$2(obj.buf) &&
	        Signature.isTxDER(obj.buf)
	    })
	};

	/**
	 * @returns {boolean} true if this is a valid standard OP_RETURN output
	 */
	Script.prototype.isDataOut = function () {
	  var step1 = this.chunks.length >= 1 &&
	    this.chunks[0].opcodenum === Opcode.OP_RETURN;
	  if (!step1) return false
	  var chunks = this.chunks.slice(1);
	  var script2 = new Script({ chunks: chunks });
	  return script2.isPushOnly()
	};

	Script.prototype.isSafeDataOut = function () {
	  if (this.chunks.length < 2) {
	    return false
	  }
	  if (this.chunks[0].opcodenum !== Opcode.OP_FALSE) {
	    return false
	  }
	  var chunks = this.chunks.slice(1);
	  var script2 = new Script({ chunks });
	  return script2.isDataOut()
	};

	/**
	 * Retrieve the associated data for this script.
	 * In the case of a pay to public key hash or P2SH, return the hash.
	 * In the case of safe OP_RETURN data, return an array of buffers
	 * In the case of a standard deprecated OP_RETURN, return the data
	 * @returns {Buffer}
	 */
	Script.prototype.getData = function () {
	  if (this.isSafeDataOut()) {
	    var chunks = this.chunks.slice(2);
	    var buffers = chunks.map(chunk => chunk.buf);
	    return buffers
	  }
	  if (this.isDataOut() || this.isScriptHashOut()) {
	    if (_.isUndefined(this.chunks[1])) {
	      return Buffer.alloc(0)
	    } else {
	      return Buffer.from(this.chunks[1].buf)
	    }
	  }
	  if (this.isPublicKeyHashOut()) {
	    return Buffer.from(this.chunks[2].buf)
	  }
	  throw new Error('Unrecognized script type to get data from')
	};

	/**
	 * @returns {boolean} if the script is only composed of data pushing
	 * opcodes or small int opcodes (OP_0, OP_1, ..., OP_16)
	 */
	Script.prototype.isPushOnly = function () {
	  return _.every(this.chunks, function (chunk) {
	    return chunk.opcodenum <= Opcode.OP_16 ||
	      chunk.opcodenum === Opcode.OP_PUSHDATA1 ||
	      chunk.opcodenum === Opcode.OP_PUSHDATA2 ||
	      chunk.opcodenum === Opcode.OP_PUSHDATA4
	  })
	};

	Script.types = {};
	Script.types.UNKNOWN = 'Unknown';
	Script.types.PUBKEY_OUT = 'Pay to public key';
	Script.types.PUBKEY_IN = 'Spend from public key';
	Script.types.PUBKEYHASH_OUT = 'Pay to public key hash';
	Script.types.PUBKEYHASH_IN = 'Spend from public key hash';
	Script.types.SCRIPTHASH_OUT = 'Pay to script hash';
	Script.types.SCRIPTHASH_IN = 'Spend from script hash';
	Script.types.MULTISIG_OUT = 'Pay to multisig';
	Script.types.MULTISIG_IN = 'Spend from multisig';
	Script.types.DATA_OUT = 'Data push';
	Script.types.SAFE_DATA_OUT = 'Safe data push';

	Script.OP_RETURN_STANDARD_SIZE = 220;

	/**
	 * @returns {object} The Script type if it is a known form,
	 * or Script.UNKNOWN if it isn't
	 */
	Script.prototype.classify = function () {
	  if (this._isInput) {
	    return this.classifyInput()
	  } else if (this._isOutput) {
	    return this.classifyOutput()
	  } else {
	    var outputType = this.classifyOutput();
	    return outputType !== Script.types.UNKNOWN ? outputType : this.classifyInput()
	  }
	};

	Script.outputIdentifiers = {};
	Script.outputIdentifiers.PUBKEY_OUT = Script.prototype.isPublicKeyOut;
	Script.outputIdentifiers.PUBKEYHASH_OUT = Script.prototype.isPublicKeyHashOut;
	Script.outputIdentifiers.MULTISIG_OUT = Script.prototype.isMultisigOut;
	Script.outputIdentifiers.SCRIPTHASH_OUT = Script.prototype.isScriptHashOut;
	Script.outputIdentifiers.DATA_OUT = Script.prototype.isDataOut;
	Script.outputIdentifiers.SAFE_DATA_OUT = Script.prototype.isSafeDataOut;

	/**
	 * @returns {object} The Script type if it is a known form,
	 * or Script.UNKNOWN if it isn't
	 */
	Script.prototype.classifyOutput = function () {
	  for (var type in Script.outputIdentifiers) {
	    if (Script.outputIdentifiers[type].bind(this)()) {
	      return Script.types[type]
	    }
	  }
	  return Script.types.UNKNOWN
	};

	Script.inputIdentifiers = {};
	Script.inputIdentifiers.PUBKEY_IN = Script.prototype.isPublicKeyIn;
	Script.inputIdentifiers.PUBKEYHASH_IN = Script.prototype.isPublicKeyHashIn;
	Script.inputIdentifiers.MULTISIG_IN = Script.prototype.isMultisigIn;
	Script.inputIdentifiers.SCRIPTHASH_IN = Script.prototype.isScriptHashIn;

	/**
	 * @returns {object} The Script type if it is a known form,
	 * or Script.UNKNOWN if it isn't
	 */
	Script.prototype.classifyInput = function () {
	  for (var type in Script.inputIdentifiers) {
	    if (Script.inputIdentifiers[type].bind(this)()) {
	      return Script.types[type]
	    }
	  }
	  return Script.types.UNKNOWN
	};

	/**
	 * @returns {boolean} if script is one of the known types
	 */
	Script.prototype.isStandard = function () {
	  // TODO: Add BIP62 compliance
	  return this.classify() !== Script.types.UNKNOWN
	};

	// Script construction methods

	/**
	 * Adds a script element at the start of the script.
	 * @param {*} obj a string, number, Opcode, Buffer, or object to add
	 * @returns {Script} this script instance
	 */
	Script.prototype.prepend = function (obj) {
	  this._addByType(obj, true);
	  return this
	};

	/**
	 * Compares a script with another script
	 */
	Script.prototype.equals = function (script) {
	  $.checkState(script instanceof Script, 'Must provide another script');
	  if (this.chunks.length !== script.chunks.length) {
	    return false
	  }
	  var i;
	  for (i = 0; i < this.chunks.length; i++) {
	    if (isBuffer$2(this.chunks[i].buf) && !isBuffer$2(script.chunks[i].buf)) {
	      return false
	    }
	    if (isBuffer$2(this.chunks[i].buf) && !this.chunks[i].buf.equals(script.chunks[i].buf)) {
	      return false
	    } else if (this.chunks[i].opcodenum !== script.chunks[i].opcodenum) {
	      return false
	    }
	  }
	  return true
	};

	/**
	 * Adds a script element to the end of the script.
	 *
	 * @param {*} obj a string, number, Opcode, Buffer, or object to add
	 * @returns {Script} this script instance
	 *
	 */
	Script.prototype.add = function (obj) {
	  this._addByType(obj, false);
	  return this
	};

	Script.prototype._addByType = function (obj, prepend) {
	  if (typeof obj === 'string') {
	    this._addOpcode(obj, prepend);
	  } else if (typeof obj === 'number') {
	    this._addOpcode(obj, prepend);
	  } else if (obj instanceof Opcode) {
	    this._addOpcode(obj, prepend);
	  } else if (isBuffer$2(obj)) {
	    this._addBuffer(obj, prepend);
	  } else if (obj instanceof Script) {
	    this.chunks = this.chunks.concat(obj.chunks);
	  } else if (typeof obj === 'object') {
	    this._insertAtPosition(obj, prepend);
	  } else {
	    throw new Error('Invalid script chunk')
	  }
	};

	Script.prototype._insertAtPosition = function (op, prepend) {
	  if (prepend) {
	    this.chunks.unshift(op);
	  } else {
	    this.chunks.push(op);
	  }
	};

	Script.prototype._addOpcode = function (opcode, prepend) {
	  var op;
	  if (typeof opcode === 'number') {
	    op = opcode;
	  } else if (opcode instanceof Opcode) {
	    op = opcode.toNumber();
	  } else {
	    op = Opcode(opcode).toNumber();
	  }
	  this._insertAtPosition({
	    opcodenum: op
	  }, prepend);
	  return this
	};

	Script.prototype._addBuffer = function (buf, prepend) {
	  var opcodenum;
	  var len = buf.length;
	  if (len >= 0 && len < Opcode.OP_PUSHDATA1) {
	    opcodenum = len;
	  } else if (len < Math.pow(2, 8)) {
	    opcodenum = Opcode.OP_PUSHDATA1;
	  } else if (len < Math.pow(2, 16)) {
	    opcodenum = Opcode.OP_PUSHDATA2;
	  } else if (len < Math.pow(2, 32)) {
	    opcodenum = Opcode.OP_PUSHDATA4;
	  } else {
	    throw new Error('You can\'t push that much data')
	  }
	  this._insertAtPosition({
	    buf: buf,
	    len: len,
	    opcodenum: opcodenum
	  }, prepend);
	  return this
	};

	Script.prototype.removeCodeseparators = function () {
	  var chunks = [];
	  for (var i = 0; i < this.chunks.length; i++) {
	    if (this.chunks[i].opcodenum !== Opcode.OP_CODESEPARATOR) {
	      chunks.push(this.chunks[i]);
	    }
	  }
	  this.chunks = chunks;
	  return this
	};


	/**
	 * If the script does not contain any OP_CODESEPARATOR, Return all scripts
	 * If the script contains any OP_CODESEPARATOR, the scriptCode is the script but removing everything up to and including the last executed OP_CODESEPARATOR before the signature checking opcode being executed
	 * @param {n} The {n}th codeseparator in the script
	 *
	 * @returns {Script} Subset of script starting at the {n}th codeseparator
	 */
	 Script.prototype.subScript = function (n) {

	  var idx = 0;

	  for (var i = 0; i < this.chunks.length; i++) {
	    if (this.chunks[i].opcodenum === Opcode.OP_CODESEPARATOR) {
	      if (idx === n) {
	        return new Script().set({
	          chunks: this.chunks.slice(i + 1)
	        })
	      } else {
	        idx++;
	      }
	    }
	  }

	  return new Script().set({
	    chunks: this.chunks.slice(0)
	  })
	};


	// high level script builder methods

	/**
	 * @returns {Script} a new Multisig output script for given public keys,
	 * requiring m of those public keys to spend
	 * @param {PublicKey[]} publicKeys - list of all public keys controlling the output
	 * @param {number} threshold - amount of required signatures to spend the output
	 * @param {Object=} opts - Several options:
	 *        - noSorting: defaults to false, if true, don't sort the given
	 *                      public keys before creating the script
	 */
	Script.buildMultisigOut = function (publicKeys, threshold, opts) {
	  $.checkArgument(threshold <= publicKeys.length,
	    'Number of required signatures must be less than or equal to the number of public keys');
	  opts = opts || {};
	  var script = new Script();
	  script.add(Opcode.smallInt(threshold));
	  publicKeys = _.map(publicKeys, PublicKey);
	  var sorted = publicKeys;
	  if (!opts.noSorting) {
	    sorted = publicKeys.map(k => k.toString('hex')).sort().map(k => new PublicKey(k));
	  }
	  for (var i = 0; i < sorted.length; i++) {
	    var publicKey = sorted[i];
	    script.add(publicKey.toBuffer());
	  }
	  script.add(Opcode.smallInt(publicKeys.length));
	  script.add(Opcode.OP_CHECKMULTISIG);
	  return script
	};

	/**
	 * A new Multisig input script for the given public keys, requiring m of those public keys to spend
	 *
	 * @param {PublicKey[]} pubkeys list of all public keys controlling the output
	 * @param {number} threshold amount of required signatures to spend the output
	 * @param {Array} signatures and array of signature buffers to append to the script
	 * @param {Object=} opts
	 * @param {boolean=} opts.noSorting don't sort the given public keys before creating the script (false by default)
	 * @param {Script=} opts.cachedMultisig don't recalculate the redeemScript
	 *
	 * @returns {Script}
	 */
	Script.buildMultisigIn = function (pubkeys, threshold, signatures, opts) {
	  $.checkArgument(_.isArray(pubkeys));
	  $.checkArgument(_.isNumber(threshold));
	  $.checkArgument(_.isArray(signatures));
	  var s = new Script();
	  s.add(Opcode.OP_0);
	  _.each(signatures, function (signature) {
	    $.checkArgument(isBuffer$2(signature), 'Signatures must be an array of Buffers');
	    // TODO: allow signatures to be an array of Signature objects
	    s.add(signature);
	  });
	  return s
	};

	/**
	 * A new P2SH Multisig input script for the given public keys, requiring m of those public keys to spend
	 *
	 * @param {PublicKey[]} pubkeys list of all public keys controlling the output
	 * @param {number} threshold amount of required signatures to spend the output
	 * @param {Array} signatures and array of signature buffers to append to the script
	 * @param {Object=} opts
	 * @param {boolean=} opts.noSorting don't sort the given public keys before creating the script (false by default)
	 * @param {Script=} opts.cachedMultisig don't recalculate the redeemScript
	 *
	 * @returns {Script}
	 */
	Script.buildP2SHMultisigIn = function (pubkeys, threshold, signatures, opts) {
	  $.checkArgument(_.isArray(pubkeys));
	  $.checkArgument(_.isNumber(threshold));
	  $.checkArgument(_.isArray(signatures));
	  opts = opts || {};
	  var s = new Script();
	  s.add(Opcode.OP_0);
	  _.each(signatures, function (signature) {
	    $.checkArgument(isBuffer$2(signature), 'Signatures must be an array of Buffers');
	    // TODO: allow signatures to be an array of Signature objects
	    s.add(signature);
	  });
	  s.add((opts.cachedMultisig || Script.buildMultisigOut(pubkeys, threshold, opts)).toBuffer());
	  return s
	};

	/**
	 * @returns {Script} a new pay to public key hash output for the given
	 * address or public key
	 * @param {(Address|PublicKey)} to - destination address or public key
	 */
	Script.buildPublicKeyHashOut = function (to) {
	  $.checkArgument(!_.isUndefined(to));
	  $.checkArgument(to instanceof PublicKey || to instanceof Address || _.isString(to));
	  if (to instanceof PublicKey) {
	    to = to.toAddress();
	  } else if (_.isString(to)) {
	    to = new Address(to);
	  }
	  var s = new Script();
	  s.add(Opcode.OP_DUP)
	    .add(Opcode.OP_HASH160)
	    .add(to.hashBuffer)
	    .add(Opcode.OP_EQUALVERIFY)
	    .add(Opcode.OP_CHECKSIG);
	  s._network = to.network;
	  return s
	};

	/**
	 * @returns {Script} a new pay to public key output for the given
	 *  public key
	 */
	Script.buildPublicKeyOut = function (pubkey) {
	  $.checkArgument(pubkey instanceof PublicKey);
	  var s = new Script();
	  s.add(pubkey.toBuffer())
	    .add(Opcode.OP_CHECKSIG);
	  return s
	};

	/**
	 * @returns {Script} a new OP_RETURN script with data
	 * @param {(string|Buffer|Array)} data - the data to embed in the output - it is a string, buffer, or array of strings or buffers
	 * @param {(string)} encoding - the type of encoding of the string(s)
	 */
	Script.buildDataOut = function (data, encoding) {
	  $.checkArgument(_.isUndefined(data) || _.isString(data) || _.isArray(data) || isBuffer$2(data));
	  var datas = data;
	  if (!_.isArray(datas)) {
	    datas = [data];
	  }
	  var s = new Script();
	  s.add(Opcode.OP_RETURN);
	  for (let data of datas) {
	    $.checkArgument(_.isUndefined(data) || _.isString(data) || isBuffer$2(data));
	    if (_.isString(data)) {
	      data = Buffer.from(data, encoding);
	    }
	    if (!_.isUndefined(data)) {
	      s.add(data);
	    }
	  }
	  return s
	};

	/**
	 * @returns {Script} a new OP_RETURN script with data
	 * @param {(string|Buffer|Array)} data - the data to embed in the output - it is a string, buffer, or array of strings or buffers
	 * @param {(string)} encoding - the type of encoding of the string(s)
	 */
	Script.buildSafeDataOut = function (data, encoding) {
	  var s2 = Script.buildDataOut(data, encoding);
	  var s1 = new Script();
	  s1.add(Opcode.OP_FALSE);
	  s1.add(s2);
	  return s1
	};

	/**
	 * @param {Script|Address} script - the redeemScript for the new p2sh output.
	 *    It can also be a p2sh address
	 * @returns {Script} new pay to script hash script for given script
	 */
	Script.buildScriptHashOut = function (script) {
	  $.checkArgument(script instanceof Script ||
	    (script instanceof Address && script.isPayToScriptHash()));
	  var s = new Script();
	  s.add(Opcode.OP_HASH160)
	    .add(script instanceof Address ? script.hashBuffer : Hash.sha256ripemd160(script.toBuffer()))
	    .add(Opcode.OP_EQUAL);

	  s._network = script._network || script.network;
	  return s
	};

	/**
	 * Builds a scriptSig (a script for an input) that signs a public key output script.
	 *
	 * @param {Signature|Buffer} signature - a Signature object, or the signature in DER canonical encoding
	 * @param {number=} sigtype - the type of the signature (defaults to SIGHASH_ALL)
	 */
	Script.buildPublicKeyIn = function (signature, sigtype) {
	  $.checkArgument(signature instanceof Signature || isBuffer$2(signature));
	  $.checkArgument(_.isUndefined(sigtype) || _.isNumber(sigtype));
	  if (signature instanceof Signature) {
	    signature = signature.toBuffer();
	  }
	  var script = new Script();
	  script.add(Buffer.concat([
	    signature,
	    Buffer.from([(sigtype || Signature.SIGHASH_ALL) & 0xff])
	  ]));
	  return script
	};

	/**
	 * Builds a scriptSig (a script for an input) that signs a public key hash
	 * output script.
	 *
	 * @param {Buffer|string|PublicKey} publicKey
	 * @param {Signature|Buffer} signature - a Signature object, or the signature in DER canonical encoding
	 * @param {number=} sigtype - the type of the signature (defaults to SIGHASH_ALL)
	 */
	Script.buildPublicKeyHashIn = function (publicKey, signature, sigtype) {
	  $.checkArgument(signature instanceof Signature || isBuffer$2(signature));
	  $.checkArgument(_.isUndefined(sigtype) || _.isNumber(sigtype));
	  if (signature instanceof Signature) {
	    signature = signature.toBuffer();
	  }
	  var script = new Script()
	    .add(Buffer.concat([
	      signature,
	      Buffer.from([(sigtype || Signature.SIGHASH_ALL) & 0xff])
	    ]))
	    .add(new PublicKey(publicKey).toBuffer());
	  return script
	};

	/**
	 * @returns {Script} an empty script
	 */
	Script.empty = function () {
	  return new Script()
	};

	/**
	 * @returns {Script} a new pay to script hash script that pays to this script
	 */
	Script.prototype.toScriptHashOut = function () {
	  return Script.buildScriptHashOut(this)
	};

	/**
	 * @return {Script} an output script built from the address
	 */
	Script.fromAddress = function (address) {
	  address = Address(address);
	  if (address.isPayToScriptHash()) {
	    return Script.buildScriptHashOut(address)
	  } else if (address.isPayToPublicKeyHash()) {
	    return Script.buildPublicKeyHashOut(address)
	  }
	  throw new errors.Script.UnrecognizedAddress(address)
	};

	/**
	 * Will return the associated address information object
	 * @return {Address|boolean}
	 */
	Script.prototype.getAddressInfo = function (opts) {
	  if (this._isInput) {
	    return this._getInputAddressInfo()
	  } else if (this._isOutput) {
	    return this._getOutputAddressInfo()
	  } else {
	    var info = this._getOutputAddressInfo();
	    if (!info) {
	      return this._getInputAddressInfo()
	    }
	    return info
	  }
	};

	/**
	 * Will return the associated output scriptPubKey address information object
	 * @return {Address|boolean}
	 * @private
	 */
	Script.prototype._getOutputAddressInfo = function () {
	  var info = {};
	  if (this.isScriptHashOut()) {
	    info.hashBuffer = this.getData();
	    info.type = Address.PayToScriptHash;
	  } else if (this.isPublicKeyHashOut()) {
	    info.hashBuffer = this.getData();
	    info.type = Address.PayToPublicKeyHash;
	  } else {
	    return false
	  }
	  return info
	};

	/**
	 * Will return the associated input scriptSig address information object
	 * @return {Address|boolean}
	 * @private
	 */
	Script.prototype._getInputAddressInfo = function () {
	  var info = {};
	  if (this.isPublicKeyHashIn()) {
	    // hash the publickey found in the scriptSig
	    info.hashBuffer = Hash.sha256ripemd160(this.chunks[1].buf);
	    info.type = Address.PayToPublicKeyHash;
	  } else if (this.isScriptHashIn()) {
	    // hash the redeemscript found at the end of the scriptSig
	    info.hashBuffer = Hash.sha256ripemd160(this.chunks[this.chunks.length - 1].buf);
	    info.type = Address.PayToScriptHash;
	  } else {
	    return false
	  }
	  return info
	};

	/**
	 * @param {Network=} network
	 * @return {Address|boolean} the associated address for this script if possible, or false
	 */
	Script.prototype.toAddress = function (network) {
	  var info = this.getAddressInfo();
	  if (!info) {
	    return false
	  }
	  info.network = Networks.get(network) || this._network || Networks.defaultNetwork;
	  return new Address(info)
	};

	/**
	 * Analogous to bitcoind's FindAndDelete. Find and delete equivalent chunks,
	 * typically used with push data chunks.  Note that this will find and delete
	 * not just the same data, but the same data with the same push data op as
	 * produced by default. i.e., if a pushdata in a tx does not use the minimal
	 * pushdata op, then when you try to remove the data it is pushing, it will not
	 * be removed, because they do not use the same pushdata op.
	 */
	Script.prototype.findAndDelete = function (script) {
	  var buf = script.toBuffer();
	  var hex = buf.toString('hex');
	  for (var i = 0; i < this.chunks.length; i++) {
	    var script2 = Script({
	      chunks: [this.chunks[i]]
	    });
	    var buf2 = script2.toBuffer();
	    var hex2 = buf2.toString('hex');
	    if (hex === hex2) {
	      this.chunks.splice(i, 1);
	    }
	  }
	  return this
	};

	/**
	 * Comes from bitcoind's script interpreter CheckMinimalPush function
	 * @returns {boolean} if the chunk {i} is the smallest way to push that particular data.
	 */
	Script.prototype.checkMinimalPush = function (i) {
	  var chunk = this.chunks[i];
	  var buf = chunk.buf;
	  var opcodenum = chunk.opcodenum;
	  if (!buf) {
	    return true
	  }
	  if (buf.length === 0) {
	    // Could have used OP_0.
	    return opcodenum === Opcode.OP_0
	  } else if (buf.length === 1 && buf[0] >= 1 && buf[0] <= 16) {
	    // Could have used OP_1 .. OP_16.
	    return opcodenum === Opcode.OP_1 + (buf[0] - 1)
	  } else if (buf.length === 1 && buf[0] === 0x81) {
	    // Could have used OP_1NEGATE
	    return opcodenum === Opcode.OP_1NEGATE
	  } else if (buf.length <= 75) {
	    // Could have used a direct push (opcode indicating number of bytes pushed + those bytes).
	    return opcodenum === buf.length
	  } else if (buf.length <= 255) {
	    // Could have used OP_PUSHDATA.
	    return opcodenum === Opcode.OP_PUSHDATA1
	  } else if (buf.length <= 65535) {
	    // Could have used OP_PUSHDATA2.
	    return opcodenum === Opcode.OP_PUSHDATA2
	  }
	  return true
	};

	/**
	 * Comes from bitcoind's script DecodeOP_N function
	 * @param {number} opcode
	 * @returns {number} numeric value in range of 0 to 16
	 */
	Script.prototype._decodeOP_N = function (opcode) {
	  if (opcode === Opcode.OP_0) {
	    return 0
	  } else if (opcode >= Opcode.OP_1 && opcode <= Opcode.OP_16) {
	    return opcode - (Opcode.OP_1 - 1)
	  } else {
	    throw new Error('Invalid opcode: ' + JSON.stringify(opcode))
	  }
	};

	/**
	 * Comes from bitcoind's script GetSigOpCount(boolean) function
	 * @param {boolean} use current (true) or pre-version-0.6 (false) logic
	 * @returns {number} number of signature operations required by this script
	 */
	Script.prototype.getSignatureOperationsCount = function (accurate) {
	  accurate = (_.isUndefined(accurate) ? true : accurate);
	  var self = this;
	  var n = 0;
	  var lastOpcode = Opcode.OP_INVALIDOPCODE;
	  _.each(self.chunks, function getChunk(chunk) {
	    var opcode = chunk.opcodenum;
	    if (opcode === Opcode.OP_CHECKSIG || opcode === Opcode.OP_CHECKSIGVERIFY) {
	      n++;
	    } else if (opcode === Opcode.OP_CHECKMULTISIG || opcode === Opcode.OP_CHECKMULTISIGVERIFY) {
	      if (accurate && lastOpcode >= Opcode.OP_1 && lastOpcode <= Opcode.OP_16) {
	        n += self._decodeOP_N(lastOpcode);
	      } else {
	        n += 20;
	      }
	    }
	    lastOpcode = opcode;
	  });
	  return n
	};

	script = Script;
	return script;
}

var toString$1 = Object.prototype.toString;

var kindOf$1 = function kindOf(val) {
  if (val === void 0) return 'undefined';
  if (val === null) return 'null';

  var type = typeof val;
  if (type === 'boolean') return 'boolean';
  if (type === 'string') return 'string';
  if (type === 'number') return 'number';
  if (type === 'symbol') return 'symbol';
  if (type === 'function') {
    return isGeneratorFn(val) ? 'generatorfunction' : 'function';
  }

  if (isArray$1(val)) return 'array';
  if (isBuffer$1(val)) return 'buffer';
  if (isArguments(val)) return 'arguments';
  if (isDate$1(val)) return 'date';
  if (isError(val)) return 'error';
  if (isRegexp(val)) return 'regexp';

  switch (ctorName(val)) {
    case 'Symbol': return 'symbol';
    case 'Promise': return 'promise';

    // Set, Map, WeakSet, WeakMap
    case 'WeakMap': return 'weakmap';
    case 'WeakSet': return 'weakset';
    case 'Map': return 'map';
    case 'Set': return 'set';

    // 8-bit typed arrays
    case 'Int8Array': return 'int8array';
    case 'Uint8Array': return 'uint8array';
    case 'Uint8ClampedArray': return 'uint8clampedarray';

    // 16-bit typed arrays
    case 'Int16Array': return 'int16array';
    case 'Uint16Array': return 'uint16array';

    // 32-bit typed arrays
    case 'Int32Array': return 'int32array';
    case 'Uint32Array': return 'uint32array';
    case 'Float32Array': return 'float32array';
    case 'Float64Array': return 'float64array';
  }

  if (isGeneratorObj(val)) {
    return 'generator';
  }

  // Non-plain objects
  type = toString$1.call(val);
  switch (type) {
    case '[object Object]': return 'object';
    // iterators
    case '[object Map Iterator]': return 'mapiterator';
    case '[object Set Iterator]': return 'setiterator';
    case '[object String Iterator]': return 'stringiterator';
    case '[object Array Iterator]': return 'arrayiterator';
  }

  // other
  return type.slice(8, -1).toLowerCase().replace(/\s/g, '');
};

function ctorName(val) {
  return typeof val.constructor === 'function' ? val.constructor.name : null;
}

function isArray$1(val) {
  if (Array.isArray) return Array.isArray(val);
  return val instanceof Array;
}

function isError(val) {
  return val instanceof Error || (typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number');
}

function isDate$1(val) {
  if (val instanceof Date) return true;
  return typeof val.toDateString === 'function'
    && typeof val.getDate === 'function'
    && typeof val.setDate === 'function';
}

function isRegexp(val) {
  if (val instanceof RegExp) return true;
  return typeof val.flags === 'string'
    && typeof val.ignoreCase === 'boolean'
    && typeof val.multiline === 'boolean'
    && typeof val.global === 'boolean';
}

function isGeneratorFn(name, val) {
  return ctorName(name) === 'GeneratorFunction';
}

function isGeneratorObj(val) {
  return typeof val.throw === 'function'
    && typeof val.return === 'function'
    && typeof val.next === 'function';
}

function isArguments(val) {
  try {
    if (typeof val.length === 'number' && typeof val.callee === 'function') {
      return true;
    }
  } catch (err) {
    if (err.message.indexOf('callee') !== -1) {
      return true;
    }
  }
  return false;
}

/**
 * If you need to support Safari 5-7 (8-10 yr-old browser),
 * take a look at https://github.com/feross/is-buffer
 */

function isBuffer$1(val) {
  if (val.constructor && typeof val.constructor.isBuffer === 'function') {
    return val.constructor.isBuffer(val);
  }
  return false;
}

const valueOf = Symbol.prototype.valueOf;
const typeOf$1 = kindOf$1;

function clone$1(val, deep) {
  switch (typeOf$1(val)) {
    case 'array':
      return val.slice();
    case 'object':
      return Object.assign({}, val);
    case 'date':
      return new val.constructor(Number(val));
    case 'map':
      return new Map(val);
    case 'set':
      return new Set(val);
    case 'buffer':
      return cloneBuffer(val);
    case 'symbol':
      return cloneSymbol(val);
    case 'arraybuffer':
      return cloneArrayBuffer(val);
    case 'float32array':
    case 'float64array':
    case 'int16array':
    case 'int32array':
    case 'int8array':
    case 'uint16array':
    case 'uint32array':
    case 'uint8clampedarray':
    case 'uint8array':
      return cloneTypedArray(val);
    case 'regexp':
      return cloneRegExp(val);
    case 'error':
      return Object.create(val);
    default: {
      return val;
    }
  }
}

function cloneRegExp(val) {
  const flags = val.flags !== void 0 ? val.flags : (/\w+$/.exec(val) || void 0);
  const re = new val.constructor(val.source, flags);
  re.lastIndex = val.lastIndex;
  return re;
}

function cloneArrayBuffer(val) {
  const res = new val.constructor(val.byteLength);
  new Uint8Array(res).set(new Uint8Array(val));
  return res;
}

function cloneTypedArray(val, deep) {
  return new val.constructor(val.buffer, val.byteOffset, val.length);
}

function cloneBuffer(val) {
  const len = val.length;
  const buf = Buffer.allocUnsafe ? Buffer.allocUnsafe(len) : Buffer.from(len);
  val.copy(buf);
  return buf;
}

function cloneSymbol(val) {
  return valueOf ? Object(valueOf.call(val)) : {};
}

/**
 * Expose `clone`
 */

var shallowClone = clone$1;

/*!
 * isobject <https://github.com/jonschlinkert/isobject>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

var isobject = function isObject(val) {
  return val != null && typeof val === 'object' && Array.isArray(val) === false;
};

/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

var isObject$1 = isobject;

function isObjectObject(o) {
  return isObject$1(o) === true
    && Object.prototype.toString.call(o) === '[object Object]';
}

var isPlainObject$2 = function isPlainObject(o) {
  var ctor,prot;

  if (isObjectObject(o) === false) return false;

  // If has modified constructor
  ctor = o.constructor;
  if (typeof ctor !== 'function') return false;

  // If has modified prototype
  prot = ctor.prototype;
  if (isObjectObject(prot) === false) return false;

  // If constructor does not have an Object-specific method
  if (prot.hasOwnProperty('isPrototypeOf') === false) {
    return false;
  }

  // Most likely a plain Object
  return true;
};

/**
 * Module dependenices
 */

const clone = shallowClone;
const typeOf = kindOf$1;
const isPlainObject$1 = isPlainObject$2;

function cloneDeep(val, instanceClone) {
  switch (typeOf(val)) {
    case 'object':
      return cloneObjectDeep(val, instanceClone);
    case 'array':
      return cloneArrayDeep(val, instanceClone);
    default: {
      return clone(val);
    }
  }
}

function cloneObjectDeep(val, instanceClone) {
  if (typeof instanceClone === 'function') {
    return instanceClone(val);
  }
  if (instanceClone || isPlainObject$1(val)) {
    const res = new val.constructor();
    for (let key in val) {
      res[key] = cloneDeep(val[key], instanceClone);
    }
    return res;
  }
  return val;
}

function cloneArrayDeep(val, instanceClone) {
  const res = new val.constructor(val.length);
  for (let i = 0; i < val.length; i++) {
    res[i] = cloneDeep(val[i], instanceClone);
  }
  return res;
}

/**
 * Expose `cloneDeep`
 */

var cloneDeep_1 = cloneDeep;

var Stack = function Stack (rawstack, varStack) {
  this.stack = rawstack;
  this.varStack = varStack || [];
};

var stack = Stack;

Stack.prototype.pushVar = function (varName) {
  this.varStack.push(varName || '$tmp');
};

Stack.prototype.popVar = function () {
  this.varStack.pop();
};

Stack.prototype.push = function (n, varName) {
  this.pushVar(varName);
  this.stack.push(n);
  this.checkConsistency();
};

Stack.prototype.pop = function () {
  this.popVar();
  let top = this.stack.pop();
  this.checkConsistency();
  return top
};

Stack.prototype.updateTopVars = function (vars) {
  if (vars.length > this.varStack.length) {
    throw new Error(`updateTopVars fail, stack: ${this.stack.length},  varStack: ${this.varStack.length}, vars:${vars.length}`)
  }
  vars = vars.reverse();
  this.varStack.splice(this.varStack.length - vars.length, vars.length, ...vars);
};

Stack.prototype.stacktop = function (i) {
  return this.stack[this.stack.length + i]
};

Stack.prototype.vartop = function (i) {
  return this.varStack[this.varStack.length + i]
};

Stack.prototype.slice = function (start, end) {
  return this.stack.slice(start, end)
};

Stack.prototype.splice = function (start, deleteCount, ...items) {
  this.varStack.splice(start, deleteCount, ...items);
  return this.stack.splice(start, deleteCount, ...items)
};

Stack.prototype.write = function (i, value) {
  this.stack[this.stack.length + i] = value;
};

Stack.prototype.copy = function () {
  return new Stack(this.stack.slice() || [], this.varStack.slice() || [])
};


function bytesToHexString(bytearray ) {
  return bytearray.reduce(function (o, c) { return o += ('0' + (c & 0xFF).toString(16)).slice(-2); }, '');
}

Stack.prototype.printVarStack = function () {

  let array = this.varStack.map((v,i) => ({
    name: v,
    value: bytesToHexString(this.rawstack[i].data)
  }));
  console.log(JSON.stringify(array, null, 4));
};

Stack.prototype.checkConsistency = function () {
  if (this.stack.length !== this.varStack.length) {
    this.printVarStack();
    throw new Error(`checkConsistency fail, stack: ${this.stack.length}, varStack:${this.varStack.length}`)
  }
};

Stack.prototype.checkConsistencyWithVars = function (varStack) {
  if (this.stack.length < varStack.length) {
    this.printVarStack();
    throw new Error(`checkConsistencyWithVars fail, stack: ${this.stack.length}, varStack:${varStack.length}`)
  }
};

Object.defineProperty(Stack.prototype, 'length', {
  get: function () {
    return this.stack.length
  }
});

Object.defineProperty(Stack.prototype, 'rawstack', {
  get: function () {
    return this.stack
  }
});

var transaction$1 = {exports: {}};

var BufferWriter$3 = bufferwriter;
var BufferReader$3 = bufferreader;
var BN$2 = bn$1;

var Varint = function Varint (buf) {
  if (!(this instanceof Varint)) { return new Varint(buf) }
  if (isBuffer$2(buf)) {
    this.buf = buf;
  } else if (typeof buf === 'number') {
    var num = buf;
    this.fromNumber(num);
  } else if (buf instanceof BN$2) {
    var bn = buf;
    this.fromBN(bn);
  } else if (buf) {
    var obj = buf;
    this.set(obj);
  }
};

Varint.prototype.set = function (obj) {
  this.buf = obj.buf || this.buf;
  return this
};

Varint.prototype.fromString = function (str) {
  this.set({
    buf: Buffer.from(str, 'hex')
  });
  return this
};

Varint.prototype.toString = function () {
  return this.buf.toString('hex')
};

Varint.prototype.fromBuffer = function (buf) {
  this.buf = buf;
  return this
};

Varint.prototype.fromBufferReader = function (br) {
  this.buf = br.readVarintBuf();
  return this
};

Varint.prototype.fromBN = function (bn) {
  this.buf = BufferWriter$3().writeVarintBN(bn).concat();
  return this
};

Varint.prototype.fromNumber = function (num) {
  this.buf = BufferWriter$3().writeVarintNum(num).concat();
  return this
};

Varint.prototype.toBuffer = function () {
  return this.buf
};

Varint.prototype.toBN = function () {
  return BufferReader$3(this.buf).readVarintBN()
};

Varint.prototype.toNumber = function () {
  return BufferReader$3(this.buf).readVarintNum()
};

var varint = Varint;

var output$1;
var hasRequiredOutput;

function requireOutput () {
	if (hasRequiredOutput) return output$1;
	hasRequiredOutput = 1;

	var _ = __1;
	var BN = bn$1;
	var buffer = require$$2$1;
	var JSUtil = js;
	var BufferWriter = bufferwriter;
	var Varint = varint;
	var Script = requireScript();
	var $ = preconditions;
	var errors = errorsExports;

	var MAX_SAFE_INTEGER = 0x1fffffffffffff;

	function Output (args) {
	  if (!(this instanceof Output)) {
	    return new Output(args)
	  }
	  if (_.isObject(args)) {
	    this.satoshis = args.satoshis;
	    if (isBuffer$2(args.script)) {
	      this._scriptBuffer = args.script;
	    } else {
	      var script;
	      if (_.isString(args.script) && JSUtil.isHexa(args.script)) {
	        script = buffer.Buffer.from(args.script, 'hex');
	      } else {
	        script = args.script;
	      }
	      this.setScript(script);
	    }
	  } else {
	    throw new TypeError('Unrecognized argument for Output')
	  }
	}

	Object.defineProperty(Output.prototype, 'script', {
	  configurable: false,
	  enumerable: true,
	  get: function () {
	    if (this._script) {
	      return this._script
	    } else {
	      this.setScriptFromBuffer(this._scriptBuffer);
	      return this._script
	    }
	  }
	});

	Object.defineProperty(Output.prototype, 'satoshis', {
	  configurable: false,
	  enumerable: true,
	  get: function () {
	    return this._satoshis
	  },
	  set: function (num) {
	    if (num instanceof BN) {
	      this._satoshisBN = num;
	      this._satoshis = num.toNumber();
	    } else if (_.isString(num)) {
	      this._satoshis = parseInt(num);
	      this._satoshisBN = BN.fromNumber(this._satoshis);
	    } else {
	      $.checkArgument(
	        JSUtil.isNaturalNumber(num),
	        'Output satoshis is not a natural number'
	      );
	      this._satoshisBN = BN.fromNumber(num);
	      this._satoshis = num;
	    }
	    $.checkState(
	      JSUtil.isNaturalNumber(this._satoshis),
	      'Output satoshis is not a natural number'
	    );
	  }
	});

	Output.prototype.invalidSatoshis = function () {
	  if (this._satoshis > MAX_SAFE_INTEGER) {
	    return 'transaction txout satoshis greater than max safe integer'
	  }
	  if (this._satoshis !== this._satoshisBN.toNumber()) {
	    return 'transaction txout satoshis has corrupted value'
	  }
	  if (this._satoshis < 0) {
	    return 'transaction txout negative'
	  }
	  return false
	};

	Object.defineProperty(Output.prototype, 'satoshisBN', {
	  configurable: false,
	  enumerable: true,
	  get: function () {
	    return this._satoshisBN
	  },
	  set: function (num) {
	    this._satoshisBN = num;
	    this._satoshis = num.toNumber();
	    $.checkState(
	      JSUtil.isNaturalNumber(this._satoshis),
	      'Output satoshis is not a natural number'
	    );
	  }
	});

	Output.prototype.toObject = Output.prototype.toJSON = function toObject () {
	  var obj = {
	    satoshis: this.satoshis
	  };
	  obj.script = this._scriptBuffer.toString('hex');
	  return obj
	};

	Output.fromObject = function (data) {
	  return new Output(data)
	};

	Output.prototype.setScriptFromBuffer = function (buffer) {
	  this._scriptBuffer = buffer;
	  try {
	    this._script = Script.fromBuffer(this._scriptBuffer);
	    this._script._isOutput = true;
	  } catch (e) {
	    if (e instanceof errors.Script.InvalidBuffer) {
	      this._script = null;
	    } else {
	      throw e
	    }
	  }
	};

	Output.prototype.setScript = function (script) {
	  if (script instanceof Script) {
	    this._scriptBuffer = script.toBuffer();
	    this._script = script;
	    this._script._isOutput = true;
	  } else if (_.isString(script)) {
	    this._script = Script.fromString(script);
	    this._scriptBuffer = this._script.toBuffer();
	    this._script._isOutput = true;
	  } else if (isBuffer$2(script)) {
	    this.setScriptFromBuffer(script);
	  } else {
	    throw new TypeError('Invalid argument type: script')
	  }
	  return this
	};

	Output.prototype.inspect = function () {
	  var scriptStr;
	  if (this.script) {
	    scriptStr = this.script.inspect();
	  } else {
	    scriptStr = this._scriptBuffer.toString('hex');
	  }
	  return '<Output (' + this.satoshis + ' sats) ' + scriptStr + '>'
	};

	Output.fromBufferReader = function (br) {
	  var obj = {};
	  obj.satoshis = br.readUInt64LEBN();
	  var size = br.readVarintNum();
	  if (size !== 0) {
	    obj.script = br.read(size);
	  } else {
	    obj.script = buffer.Buffer.from([]);
	  }
	  return new Output(obj)
	};

	Output.prototype.toBufferWriter = function (writer) {
	  if (!writer) {
	    writer = new BufferWriter();
	  }
	  writer.writeUInt64LEBN(this._satoshisBN);
	  var script = this._scriptBuffer;
	  writer.writeVarintNum(script.length);
	  writer.write(script);
	  return writer
	};

	// 8    value
	// ???  script size (VARINT)
	// ???  script
	Output.prototype.getSize = function () {
	  var scriptSize = this.script.toBuffer().length;
	  var varintSize = Varint(scriptSize).toBuffer().length;
	  return 8 + varintSize + scriptSize
	};

	output$1 = Output;
	return output$1;
}

var input$1 = {exports: {}};

var input;
var hasRequiredInput$1;

function requireInput$1 () {
	if (hasRequiredInput$1) return input;
	hasRequiredInput$1 = 1;

	var _ = __1;
	var $ = preconditions;
	var errors = errorsExports;
	var BufferWriter = bufferwriter;
	var buffer = require$$2$1;
	var JSUtil = js;
	var Script = requireScript();
	var Sighash = requireSighash();
	var Output = requireOutput();

	var MAXINT = 0xffffffff; // Math.pow(2, 32) - 1;
	var DEFAULT_RBF_SEQNUMBER = MAXINT - 2;
	var DEFAULT_SEQNUMBER = MAXINT;
	var DEFAULT_LOCKTIME_SEQNUMBER = MAXINT - 1;

	function Input(params) {
	  if (!(this instanceof Input)) {
	    return new Input(params)
	  }
	  if (params) {
	    return this._fromObject(params)
	  }
	}

	Input.MAXINT = MAXINT;
	Input.DEFAULT_SEQNUMBER = DEFAULT_SEQNUMBER;
	Input.DEFAULT_LOCKTIME_SEQNUMBER = DEFAULT_LOCKTIME_SEQNUMBER;
	Input.DEFAULT_RBF_SEQNUMBER = DEFAULT_RBF_SEQNUMBER;
	// txid + output index + sequence number
	Input.BASE_SIZE = 32 + 4 + 4;

	Object.defineProperty(Input.prototype, 'script', {
	  configurable: false,
	  enumerable: true,
	  get: function () {
	    if (this.isNull()) {
	      return null
	    }
	    if (!this._script) {
	      this._script = new Script(this._scriptBuffer);
	      this._script._isInput = true;
	    }
	    return this._script
	  }
	});

	Input.fromObject = function (obj) {
	  $.checkArgument(_.isObject(obj));
	  var input = new Input();
	  return input._fromObject(obj)
	};

	Input.prototype._fromObject = function (params) {
	  var prevTxId;
	  if (_.isString(params.prevTxId) && JSUtil.isHexa(params.prevTxId)) {
	    prevTxId = buffer.Buffer.from(params.prevTxId, 'hex');
	  } else {
	    prevTxId = params.prevTxId;
	  }
	  this.output = params.output
	    ? (params.output instanceof Output ? params.output : new Output(params.output)) : undefined;
	  this.prevTxId = prevTxId || params.txidbuf;
	  this.outputIndex = _.isUndefined(params.outputIndex) ? params.txoutnum : params.outputIndex;
	  this.sequenceNumber = _.isUndefined(params.sequenceNumber)
	    ? (_.isUndefined(params.seqnum) ? DEFAULT_SEQNUMBER : params.seqnum) : params.sequenceNumber;
	  if (_.isUndefined(params.script) && _.isUndefined(params.scriptBuffer)) {
	    throw new errors.Transaction.Input.MissingScript()
	  }
	  this.setScript(params.scriptBuffer || params.script);
	  return this
	};

	Input.prototype.toObject = Input.prototype.toJSON = function toObject() {
	  var obj = {
	    prevTxId: this.prevTxId.toString('hex'),
	    outputIndex: this.outputIndex,
	    sequenceNumber: this.sequenceNumber,
	    script: this._scriptBuffer.toString('hex')
	  };
	  // add human readable form if input contains valid script
	  if (this.script) {
	    obj.scriptString = this.script.toString();
	  }
	  if (this.output) {
	    obj.output = this.output.toObject();
	  }
	  return obj
	};

	Input.fromBufferReader = function (br) {
	  var input = new Input();
	  input.prevTxId = br.readReverse(32);
	  input.outputIndex = br.readUInt32LE();
	  input._scriptBuffer = br.readVarLengthBuffer();
	  input.sequenceNumber = br.readUInt32LE();
	  // TODO: return different classes according to which input it is
	  // e.g: CoinbaseInput, PublicKeyHashInput, MultiSigScriptHashInput, etc.
	  return input
	};

	Input.prototype.toBufferWriter = function (writer) {
	  if (!writer) {
	    writer = new BufferWriter();
	  }
	  writer.writeReverse(this.prevTxId);
	  writer.writeUInt32LE(this.outputIndex);
	  var script = this._scriptBuffer;
	  writer.writeVarintNum(script.length);
	  writer.write(script);
	  writer.writeUInt32LE(this.sequenceNumber);
	  return writer
	};

	Input.prototype.setScript = function (script) {
	  this._script = null;
	  if (script instanceof Script) {
	    this._script = script;
	    this._script._isInput = true;
	    this._scriptBuffer = script.toBuffer();
	  } else if (script === null) {
	    this._script = Script.empty();
	    this._script._isInput = true;
	    this._scriptBuffer = this._script.toBuffer();
	  } else if (JSUtil.isHexa(script)) {
	    // hex string script
	    this._scriptBuffer = buffer.Buffer.from(script, 'hex');
	  } else if (_.isString(script)) {
	    // human readable string script
	    this._script = new Script(script);
	    this._script._isInput = true;
	    this._scriptBuffer = this._script.toBuffer();
	  } else if (isBuffer$2(script)) {
	    // buffer script
	    this._scriptBuffer = buffer.Buffer.from(script);
	  } else {
	    throw new TypeError('Invalid argument type: script')
	  }
	  return this
	};

	/**
	 * Retrieve signatures for the provided PrivateKey.
	 *
	 * @param {Transaction} transaction - the transaction to be signed
	 * @param {PrivateKey} privateKey - the private key to use when signing
	 * @param {number} inputIndex - the index of this input in the provided transaction
	 * @param {number} sigType - defaults to Signature.SIGHASH_ALL
	 * @param {Buffer} addressHash - if provided, don't calculate the hash of the
	 *     public key associated with the private key provided
	 * @abstract
	 */
	Input.prototype.getSignatures = function () {
	  // throw new errors.AbstractMethodInvoked(
	  //   'Trying to sign unsupported output type (only P2PKH and P2SH multisig inputs are supported)' +
	  //   ' for input: ' + JSON.stringify(this)
	  // )
	  return []
	};

	Input.prototype.isFullySigned = function () {
	  throw new errors.AbstractMethodInvoked('Input#isFullySigned')
	};

	Input.prototype.isFinal = function () {
	  return this.sequenceNumber === Input.MAXINT
	};

	Input.prototype.addSignature = function () {
	  // throw new errors.AbstractMethodInvoked('Input#addSignature')
	};

	Input.prototype.clearSignatures = function () {
	  // throw new errors.AbstractMethodInvoked('Input#clearSignatures')
	};

	Input.prototype.isValidSignature = function (transaction, signature) {
	  // FIXME: Refactor signature so this is not necessary
	  signature.signature.nhashtype = signature.sigtype;
	  return Sighash.verify(
	    transaction,
	    signature.signature,
	    signature.publicKey,
	    signature.inputIndex,
	    this.output.script,
	    this.output.satoshisBN
	  )
	};

	/**
	 * @returns true if this is a coinbase input (represents no input)
	 */
	Input.prototype.isNull = function () {
	  return this.prevTxId.toString('hex') === '0000000000000000000000000000000000000000000000000000000000000000' &&
	    this.outputIndex === 0xffffffff
	};

	Input.prototype._estimateSize = function () {
	  return this.toBufferWriter().toBuffer().length
	};

	input = Input;
	return input;
}

var inherits$1 = {exports: {}};

var inherits_browser = {exports: {}};

var hasRequiredInherits_browser;

function requireInherits_browser () {
	if (hasRequiredInherits_browser) return inherits_browser.exports;
	hasRequiredInherits_browser = 1;
	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  inherits_browser.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor;
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  inherits_browser.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor;
	    var TempCtor = function () {};
	    TempCtor.prototype = superCtor.prototype;
	    ctor.prototype = new TempCtor();
	    ctor.prototype.constructor = ctor;
	  };
	}
	return inherits_browser.exports;
}

try {
  var util = require('util');
  if (typeof util.inherits !== 'function') throw '';
  inherits$1.exports = util.inherits;
} catch (e) {
  inherits$1.exports = requireInherits_browser();
}

var inheritsExports = inherits$1.exports;

var signature;
var hasRequiredSignature;

function requireSignature () {
	if (hasRequiredSignature) return signature;
	hasRequiredSignature = 1;

	var _ = __1;
	var $ = preconditions;
	var inherits = inheritsExports;
	var JSUtil = js;

	var PublicKey = requirePublickey();
	var errors = errorsExports;
	var Signature = signature$1;

	/**
	 * @desc
	 * Wrapper around Signature with fields related to signing a transaction specifically
	 *
	 * @param {Object|string|TransactionSignature} arg
	 * @constructor
	 */
	function TransactionSignature (arg) {
	  if (!(this instanceof TransactionSignature)) {
	    return new TransactionSignature(arg)
	  }
	  if (arg instanceof TransactionSignature) {
	    return arg
	  }
	  if (_.isObject(arg)) {
	    return this._fromObject(arg)
	  }
	  throw new errors.InvalidArgument('TransactionSignatures must be instantiated from an object')
	}
	inherits(TransactionSignature, Signature);

	TransactionSignature.prototype._fromObject = function (arg) {
	  this._checkObjectArgs(arg);
	  this.publicKey = new PublicKey(arg.publicKey);
	  this.prevTxId = isBuffer$2(arg.prevTxId) ? arg.prevTxId : Buffer.from(arg.prevTxId, 'hex');
	  this.outputIndex = arg.outputIndex;
	  this.inputIndex = arg.inputIndex;
	  this.signature = (arg.signature instanceof Signature) ? arg.signature
	    : isBuffer$2(arg.signature) ? Signature.fromBuffer(arg.signature)
	      : Signature.fromString(arg.signature);
	  this.sigtype = arg.sigtype;
	  return this
	};

	TransactionSignature.prototype._checkObjectArgs = function (arg) {
	  $.checkArgument(PublicKey(arg.publicKey), 'publicKey');
	  $.checkArgument(!_.isUndefined(arg.inputIndex), 'inputIndex');
	  $.checkArgument(!_.isUndefined(arg.outputIndex), 'outputIndex');
	  $.checkState(_.isNumber(arg.inputIndex), 'inputIndex must be a number');
	  $.checkState(_.isNumber(arg.outputIndex), 'outputIndex must be a number');
	  $.checkArgument(arg.signature, 'signature');
	  $.checkArgument(arg.prevTxId, 'prevTxId');
	  $.checkState(arg.signature instanceof Signature ||
	               isBuffer$2(arg.signature) ||
	               JSUtil.isHexa(arg.signature), 'signature must be a buffer or hexa value');
	  $.checkState(isBuffer$2(arg.prevTxId) ||
	               JSUtil.isHexa(arg.prevTxId), 'prevTxId must be a buffer or hexa value');
	  $.checkArgument(arg.sigtype, 'sigtype');
	  $.checkState(_.isNumber(arg.sigtype), 'sigtype must be a number');
	};

	/**
	 * Serializes a transaction to a plain JS object
	 * @return {Object}
	 */
	TransactionSignature.prototype.toObject = TransactionSignature.prototype.toJSON = function toObject () {
	  return {
	    publicKey: this.publicKey.toString(),
	    prevTxId: this.prevTxId.toString('hex'),
	    outputIndex: this.outputIndex,
	    inputIndex: this.inputIndex,
	    signature: this.signature.toString(),
	    sigtype: this.sigtype
	  }
	};

	/**
	 * Builds a TransactionSignature from an object
	 * @param {Object} object
	 * @return {TransactionSignature}
	 */
	TransactionSignature.fromObject = function (object) {
	  $.checkArgument(object);
	  return new TransactionSignature(object)
	};

	signature = TransactionSignature;
	return signature;
}

var publickey$1;
var hasRequiredPublickey$1;

function requirePublickey$1 () {
	if (hasRequiredPublickey$1) return publickey$1;
	hasRequiredPublickey$1 = 1;

	var inherits = inheritsExports;

	var $ = preconditions;

	var Input = requireInput$1();
	var Output = requireOutput();
	var Sighash = requireSighash();
	var Script = requireScript();
	var Signature = signature$1;
	var TransactionSignature = requireSignature();

	/**
	 * Represents a special kind of input of PayToPublicKey kind.
	 * @constructor
	 */
	function PublicKeyInput () {
	  Input.apply(this, arguments);
	}
	inherits(PublicKeyInput, Input);

	/**
	 * @param {Transaction} transaction - the transaction to be signed
	 * @param {PrivateKey} privateKey - the private key with which to sign the transaction
	 * @param {number} index - the index of the input in the transaction input vector
	 * @param {number=} sigtype - the type of signature, defaults to Signature.SIGHASH_ALL
	 * @return {Array} of objects that can be
	 */
	PublicKeyInput.prototype.getSignatures = function (transaction, privateKey, index, sigtype) {
	  $.checkState(this.output instanceof Output);
	  sigtype = sigtype || (Signature.SIGHASH_ALL | Signature.SIGHASH_FORKID);
	  var publicKey = privateKey.toPublicKey();
	  if (publicKey.toString() === this.output.script.getPublicKey().toString('hex')) {
	    return [new TransactionSignature({
	      publicKey: publicKey,
	      prevTxId: this.prevTxId,
	      outputIndex: this.outputIndex,
	      inputIndex: index,
	      signature: Sighash.sign(transaction, privateKey, sigtype, index, this.output.script, this.output.satoshisBN),
	      sigtype: sigtype
	    })]
	  }
	  return []
	};

	/**
	 * Add the provided signature
	 *
	 * @param {Object} signature
	 * @param {PublicKey} signature.publicKey
	 * @param {Signature} signature.signature
	 * @param {number=} signature.sigtype
	 * @return {PublicKeyInput} this, for chaining
	 */
	PublicKeyInput.prototype.addSignature = function (transaction, signature) {
	  $.checkState(this.isValidSignature(transaction, signature), 'Signature is invalid');
	  this.setScript(Script.buildPublicKeyIn(
	    signature.signature.toDER(),
	    signature.sigtype
	  ));
	  return this
	};

	/**
	 * Clear the input's signature
	 * @return {PublicKeyHashInput} this, for chaining
	 */
	PublicKeyInput.prototype.clearSignatures = function () {
	  this.setScript(Script.empty());
	  return this
	};

	/**
	 * Query whether the input is signed
	 * @return {boolean}
	 */
	PublicKeyInput.prototype.isFullySigned = function () {
	  return this.script.isPublicKeyIn()
	};

	// 32   txid
	// 4    output index
	// ---
	// 1    script size (VARINT)
	// 1    signature size (OP_PUSHDATA)
	// <=72 signature (DER + SIGHASH type)
	// ---
	// 4    sequence number
	PublicKeyInput.SCRIPT_MAX_SIZE = 74;

	PublicKeyInput.prototype._estimateSize = function () {
	  return Input.BASE_SIZE + PublicKeyInput.SCRIPT_MAX_SIZE
	};

	publickey$1 = PublicKeyInput;
	return publickey$1;
}

var publickeyhash;
var hasRequiredPublickeyhash;

function requirePublickeyhash () {
	if (hasRequiredPublickeyhash) return publickeyhash;
	hasRequiredPublickeyhash = 1;

	var inherits = inheritsExports;

	var $ = preconditions;

	var Hash = hashExports;
	var Input = requireInput$1();
	var Output = requireOutput();
	var Sighash = requireSighash();
	var Script = requireScript();
	var Signature = signature$1;
	var TransactionSignature = requireSignature();

	/**
	 * Represents a special kind of input of PayToPublicKeyHash kind.
	 * @constructor
	 */
	function PublicKeyHashInput () {
	  Input.apply(this, arguments);
	}
	inherits(PublicKeyHashInput, Input);

	/**
	 * @param {Transaction} transaction - the transaction to be signed
	 * @param {PrivateKey} privateKey - the private key with which to sign the transaction
	 * @param {number} index - the index of the input in the transaction input vector
	 * @param {number=} sigtype - the type of signature, defaults to Signature.SIGHASH_ALL
	 * @param {Buffer=} hashData - the precalculated hash of the public key associated with the privateKey provided
	 * @return {Array} of objects that can be
	 */
	PublicKeyHashInput.prototype.getSignatures = function (transaction, privateKey, index, sigtype, hashData) {
	  $.checkState(this.output instanceof Output);
	  hashData = hashData || Hash.sha256ripemd160(privateKey.publicKey.toBuffer());
	  sigtype = sigtype || (Signature.SIGHASH_ALL | Signature.SIGHASH_FORKID);

	  if (hashData.equals(this.output.script.getPublicKeyHash())) {
	    return [new TransactionSignature({
	      publicKey: privateKey.publicKey,
	      prevTxId: this.prevTxId,
	      outputIndex: this.outputIndex,
	      inputIndex: index,
	      signature: Sighash.sign(transaction, privateKey, sigtype, index, this.output.script, this.output.satoshisBN),
	      sigtype: sigtype
	    })]
	  }
	  return []
	};

	/**
	 * Add the provided signature
	 *
	 * @param {Object} signature
	 * @param {PublicKey} signature.publicKey
	 * @param {Signature} signature.signature
	 * @param {number=} signature.sigtype
	 * @return {PublicKeyHashInput} this, for chaining
	 */
	PublicKeyHashInput.prototype.addSignature = function (transaction, signature) {
	  $.checkState(this.isValidSignature(transaction, signature), 'Signature is invalid');

	  this.setScript(Script.buildPublicKeyHashIn(
	    signature.publicKey,
	    signature.signature.toDER(),
	    signature.sigtype
	  ));
	  return this
	};

	/**
	 * Clear the input's signature
	 * @return {PublicKeyHashInput} this, for chaining
	 */
	PublicKeyHashInput.prototype.clearSignatures = function () {
	  this.setScript(Script.empty());
	  return this
	};

	/**
	 * Query whether the input is signed
	 * @return {boolean}
	 */
	PublicKeyHashInput.prototype.isFullySigned = function () {
	  return this.script.isPublicKeyHashIn()
	};

	// 32   txid
	// 4    output index
	// --- script ---
	// 1    script size (VARINT)
	// 1    signature size (OP_PUSHDATA)
	// <=72 signature (DER + SIGHASH type)
	// 1    public key size (OP_PUSHDATA)
	// 33   compressed public key
	//
	// 4    sequence number
	PublicKeyHashInput.SCRIPT_MAX_SIZE = 108;

	PublicKeyHashInput.prototype._estimateSize = function () {
	  return Input.BASE_SIZE + PublicKeyHashInput.SCRIPT_MAX_SIZE
	};

	publickeyhash = PublicKeyHashInput;
	return publickeyhash;
}

var multisig;
var hasRequiredMultisig;

function requireMultisig () {
	if (hasRequiredMultisig) return multisig;
	hasRequiredMultisig = 1;

	var _ = __1;
	var inherits = inheritsExports;
	var Input = requireInput$1();
	var Output = requireOutput();
	var $ = preconditions;

	var Script = requireScript();
	var Signature = signature$1;
	var Sighash = requireSighash();
	var TransactionSignature = requireSignature();
	var PublicKey = requirePublickey();
	var Varint = varint;

	/**
	 * @constructor
	 */
	function MultiSigInput (input, pubkeys, threshold, signatures) {
	  Input.apply(this, arguments);
	  var self = this;
	  pubkeys = pubkeys || input.publicKeys;
	  threshold = threshold || input.threshold;
	  signatures = signatures || input.signatures;
	  this.publicKeys = pubkeys.map(k => k.toString('hex')).sort().map(k => new PublicKey(k));
	  $.checkState(Script.buildMultisigOut(this.publicKeys, threshold).equals(this.output.script),
	    'Provided public keys don\'t match to the provided output script');
	  this.publicKeyIndex = {};
	  _.each(this.publicKeys, function (publicKey, index) {
	    self.publicKeyIndex[publicKey.toString()] = index;
	  });
	  this.threshold = threshold;
	  // Empty array of signatures
	  this.signatures = signatures ? this._deserializeSignatures(signatures) : new Array(this.publicKeys.length);
	}
	inherits(MultiSigInput, Input);

	MultiSigInput.prototype.toObject = function () {
	  var obj = Input.prototype.toObject.apply(this, arguments);
	  obj.threshold = this.threshold;
	  obj.publicKeys = _.map(this.publicKeys, function (publicKey) { return publicKey.toString() });
	  obj.signatures = this._serializeSignatures();
	  return obj
	};

	MultiSigInput.prototype._deserializeSignatures = function (signatures) {
	  return _.map(signatures, function (signature) {
	    if (!signature) {
	      return undefined
	    }
	    return new TransactionSignature(signature)
	  })
	};

	MultiSigInput.prototype._serializeSignatures = function () {
	  return _.map(this.signatures, function (signature) {
	    if (!signature) {
	      return undefined
	    }
	    return signature.toObject()
	  })
	};

	MultiSigInput.prototype.getSignatures = function (transaction, privateKey, index, sigtype) {
	  $.checkState(this.output instanceof Output);
	  sigtype = sigtype || (Signature.SIGHASH_ALL | Signature.SIGHASH_FORKID);

	  var self = this;
	  var results = [];
	  _.each(this.publicKeys, function (publicKey) {
	    if (publicKey.toString() === privateKey.publicKey.toString()) {
	      results.push(new TransactionSignature({
	        publicKey: privateKey.publicKey,
	        prevTxId: self.prevTxId,
	        outputIndex: self.outputIndex,
	        inputIndex: index,
	        signature: Sighash.sign(transaction, privateKey, sigtype, index, self.output.script, self.output.satoshisBN),
	        sigtype: sigtype
	      }));
	    }
	  });

	  return results
	};

	MultiSigInput.prototype.addSignature = function (transaction, signature) {
	  $.checkState(!this.isFullySigned(), 'All needed signatures have already been added');
	  $.checkArgument(!_.isUndefined(this.publicKeyIndex[signature.publicKey.toString()]),
	    'Signature has no matching public key');
	  $.checkState(this.isValidSignature(transaction, signature));
	  this.signatures[this.publicKeyIndex[signature.publicKey.toString()]] = signature;
	  this._updateScript();
	  return this
	};

	MultiSigInput.prototype._updateScript = function () {
	  this.setScript(Script.buildMultisigIn(
	    this.publicKeys,
	    this.threshold,
	    this._createSignatures()
	  ));
	  return this
	};

	MultiSigInput.prototype._createSignatures = function () {
	  return _.map(
	    _.filter(this.signatures, function (signature) { return !_.isUndefined(signature) }),
	    function (signature) {
	      return Buffer.concat([
	        signature.signature.toDER(),
	        Buffer.from([signature.sigtype & 0xff])
	      ])
	    }
	  )
	};

	MultiSigInput.prototype.clearSignatures = function () {
	  this.signatures = new Array(this.publicKeys.length);
	  this._updateScript();
	};

	MultiSigInput.prototype.isFullySigned = function () {
	  return this.countSignatures() === this.threshold
	};

	MultiSigInput.prototype.countMissingSignatures = function () {
	  return this.threshold - this.countSignatures()
	};

	MultiSigInput.prototype.countSignatures = function () {
	  return _.reduce(this.signatures, function (sum, signature) {
	    return sum + (!!signature)
	  }, 0)
	};

	MultiSigInput.prototype.publicKeysWithoutSignature = function () {
	  var self = this;
	  return _.filter(this.publicKeys, function (publicKey) {
	    return !(self.signatures[self.publicKeyIndex[publicKey.toString()]])
	  })
	};

	MultiSigInput.prototype.isValidSignature = function (transaction, signature) {
	  // FIXME: Refactor signature so this is not necessary
	  signature.signature.nhashtype = signature.sigtype;
	  return Sighash.verify(
	    transaction,
	    signature.signature,
	    signature.publicKey,
	    signature.inputIndex,
	    this.output.script,
	    this.output.satoshisBN
	  )
	};

	/**
	 *
	 * @param {Buffer[]} signatures
	 * @param {PublicKey[]} publicKeys
	 * @param {Transaction} transaction
	 * @param {Integer} inputIndex
	 * @param {Input} input
	 * @returns {TransactionSignature[]}
	 */
	MultiSigInput.normalizeSignatures = function (transaction, input, inputIndex, signatures, publicKeys) {
	  return publicKeys.map(function (pubKey) {
	    var signatureMatch = null;
	    signatures = signatures.filter(function (signatureBuffer) {
	      if (signatureMatch) {
	        return true
	      }

	      var signature = new TransactionSignature({
	        signature: Signature.fromTxFormat(signatureBuffer),
	        publicKey: pubKey,
	        prevTxId: input.prevTxId,
	        outputIndex: input.outputIndex,
	        inputIndex: inputIndex,
	        sigtype: Signature.SIGHASH_ALL
	      });

	      signature.signature.nhashtype = signature.sigtype;
	      var isMatch = Sighash.verify(
	        transaction,
	        signature.signature,
	        signature.publicKey,
	        signature.inputIndex,
	        input.output.script
	      );

	      if (isMatch) {
	        signatureMatch = signature;
	        return false
	      }

	      return true
	    });

	    return signatureMatch || null
	  })
	};

	// 32   txid
	// 4    output index
	// --- script ---
	// ??? script size (VARINT)
	// 1    OP_0
	// --- signature list ---
	//      1       signature size (OP_PUSHDATA)
	//      <=72    signature (DER + SIGHASH type)
	//
	// 4    sequence number
	MultiSigInput.SIGNATURE_SIZE = 73;

	MultiSigInput.prototype._estimateSize = function () {
	  var scriptSize = 1 + this.threshold * MultiSigInput.SIGNATURE_SIZE;
	  return Input.BASE_SIZE + Varint(scriptSize).toBuffer().length + scriptSize
	};

	multisig = MultiSigInput;
	return multisig;
}

var multisigscripthash;
var hasRequiredMultisigscripthash;

function requireMultisigscripthash () {
	if (hasRequiredMultisigscripthash) return multisigscripthash;
	hasRequiredMultisigscripthash = 1;

	var _ = __1;
	var inherits = inheritsExports;
	var Input = requireInput$1();
	var Output = requireOutput();
	var $ = preconditions;

	var Script = requireScript();
	var Signature = signature$1;
	var Sighash = requireSighash();
	var TransactionSignature = requireSignature();
	var PublicKey = requirePublickey();
	var Varint = varint;

	/**
	 * @constructor
	 */
	function MultiSigScriptHashInput (input, pubkeys, threshold, signatures) {
	  Input.apply(this, arguments);
	  var self = this;
	  pubkeys = pubkeys || input.publicKeys;
	  threshold = threshold || input.threshold;
	  signatures = signatures || input.signatures;
	  this.publicKeys = pubkeys.map(k => k.toString('hex')).sort().map(k => new PublicKey(k));
	  this.redeemScript = Script.buildMultisigOut(this.publicKeys, threshold);
	  $.checkState(Script.buildScriptHashOut(this.redeemScript).equals(this.output.script),
	    'Provided public keys don\'t hash to the provided output');
	  this.publicKeyIndex = {};
	  _.each(this.publicKeys, function (publicKey, index) {
	    self.publicKeyIndex[publicKey.toString()] = index;
	  });
	  this.threshold = threshold;
	  // Empty array of signatures
	  this.signatures = signatures ? this._deserializeSignatures(signatures) : new Array(this.publicKeys.length);
	}
	inherits(MultiSigScriptHashInput, Input);

	MultiSigScriptHashInput.prototype.toObject = function () {
	  var obj = Input.prototype.toObject.apply(this, arguments);
	  obj.threshold = this.threshold;
	  obj.publicKeys = _.map(this.publicKeys, function (publicKey) { return publicKey.toString() });
	  obj.signatures = this._serializeSignatures();
	  return obj
	};

	MultiSigScriptHashInput.prototype._deserializeSignatures = function (signatures) {
	  return _.map(signatures, function (signature) {
	    if (!signature) {
	      return undefined
	    }
	    return new TransactionSignature(signature)
	  })
	};

	MultiSigScriptHashInput.prototype._serializeSignatures = function () {
	  return _.map(this.signatures, function (signature) {
	    if (!signature) {
	      return undefined
	    }
	    return signature.toObject()
	  })
	};

	MultiSigScriptHashInput.prototype.getSignatures = function (transaction, privateKey, index, sigtype) {
	  $.checkState(this.output instanceof Output);
	  sigtype = sigtype || (Signature.SIGHASH_ALL | Signature.SIGHASH_FORKID);

	  var self = this;
	  var results = [];
	  _.each(this.publicKeys, function (publicKey) {
	    if (publicKey.toString() === privateKey.publicKey.toString()) {
	      results.push(new TransactionSignature({
	        publicKey: privateKey.publicKey,
	        prevTxId: self.prevTxId,
	        outputIndex: self.outputIndex,
	        inputIndex: index,
	        signature: Sighash.sign(transaction, privateKey, sigtype, index, self.redeemScript, self.output.satoshisBN),
	        sigtype: sigtype
	      }));
	    }
	  });
	  return results
	};

	MultiSigScriptHashInput.prototype.addSignature = function (transaction, signature) {
	  $.checkState(!this.isFullySigned(), 'All needed signatures have already been added');
	  $.checkArgument(!_.isUndefined(this.publicKeyIndex[signature.publicKey.toString()]),
	    'Signature has no matching public key');
	  $.checkState(this.isValidSignature(transaction, signature));
	  this.signatures[this.publicKeyIndex[signature.publicKey.toString()]] = signature;
	  this._updateScript();
	  return this
	};

	MultiSigScriptHashInput.prototype._updateScript = function () {
	  this.setScript(Script.buildP2SHMultisigIn(
	    this.publicKeys,
	    this.threshold,
	    this._createSignatures(),
	    { cachedMultisig: this.redeemScript }
	  ));
	  return this
	};

	MultiSigScriptHashInput.prototype._createSignatures = function () {
	  return _.map(
	    _.filter(this.signatures, function (signature) { return !_.isUndefined(signature) }),
	    function (signature) {
	      return Buffer.concat([
	        signature.signature.toDER(),
	        Buffer.from([signature.sigtype & 0xff])
	      ])
	    }
	  )
	};

	MultiSigScriptHashInput.prototype.clearSignatures = function () {
	  this.signatures = new Array(this.publicKeys.length);
	  this._updateScript();
	};

	MultiSigScriptHashInput.prototype.isFullySigned = function () {
	  return this.countSignatures() === this.threshold
	};

	MultiSigScriptHashInput.prototype.countMissingSignatures = function () {
	  return this.threshold - this.countSignatures()
	};

	MultiSigScriptHashInput.prototype.countSignatures = function () {
	  return _.reduce(this.signatures, function (sum, signature) {
	    return sum + (!!signature)
	  }, 0)
	};

	MultiSigScriptHashInput.prototype.publicKeysWithoutSignature = function () {
	  var self = this;
	  return _.filter(this.publicKeys, function (publicKey) {
	    return !(self.signatures[self.publicKeyIndex[publicKey.toString()]])
	  })
	};

	MultiSigScriptHashInput.prototype.isValidSignature = function (transaction, signature) {
	  // FIXME: Refactor signature so this is not necessary
	  signature.signature.nhashtype = signature.sigtype;
	  return Sighash.verify(
	    transaction,
	    signature.signature,
	    signature.publicKey,
	    signature.inputIndex,
	    this.redeemScript,
	    this.output.satoshisBN
	  )
	};

	// 32   txid
	// 4    output index
	// --- script ---
	// ???  script size (VARINT)
	// 1    OP_0
	// --- signature list ---
	//      1       signature size (OP_PUSHDATA)
	//      <=72    signature (DER + SIGHASH type)
	//
	// ???  redeem script size (OP_PUSHDATA)
	// --- redeem script ---
	//      1       OP_2
	//      --- public key list ---
	//      1       public key size (OP_PUSHDATA)
	//      33      compressed public key
	//
	//      1       OP_3
	//      1       OP_CHECKMULTISIG
	//
	// 4    sequence number
	MultiSigScriptHashInput.SIGNATURE_SIZE = 73;
	MultiSigScriptHashInput.PUBKEY_SIZE = 34;

	MultiSigScriptHashInput.prototype._estimateSize = function () {
	  var pubKeysSize = this.publicKeys.length * MultiSigScriptHashInput.PUBKEY_SIZE;
	  var sigsSize = this.threshold * MultiSigScriptHashInput.SIGNATURE_SIZE;
	  var redeemScriptSize = 3 + pubKeysSize;
	  var redeemScriptPushdataSize = redeemScriptSize <= 75 ? 1 : redeemScriptSize <= 255 ? 2 : 3;
	  var scriptLength = sigsSize + 1 + redeemScriptPushdataSize + redeemScriptSize;
	  return Input.BASE_SIZE + Varint(scriptLength).toBuffer().length + scriptLength
	};

	multisigscripthash = MultiSigScriptHashInput;
	return multisigscripthash;
}

var hasRequiredInput;

function requireInput () {
	if (hasRequiredInput) return input$1.exports;
	hasRequiredInput = 1;
	input$1.exports = requireInput$1();

	input$1.exports.PublicKey = requirePublickey$1();
	input$1.exports.PublicKeyHash = requirePublickeyhash();
	input$1.exports.MultiSig = requireMultisig();
	input$1.exports.MultiSigScriptHash = requireMultisigscripthash();
	return input$1.exports;
}

var sighash_1;
var hasRequiredSighash;

function requireSighash () {
	if (hasRequiredSighash) return sighash_1;
	hasRequiredSighash = 1;

	var buffer = require$$2$1;

	var Signature = signature$1;
	var Script = requireScript();
	var Output = requireOutput();
	var BufferReader = bufferreader;
	var BufferWriter = bufferwriter;
	var BN = bn$1;
	var Hash = hashExports;
	var ECDSA = requireEcdsa();
	var $ = preconditions;
	var Interpreter = requireInterpreter();
	var _ = __1;

	var SIGHASH_SINGLE_BUG = Buffer.from('0000000000000000000000000000000000000000000000000000000000000001', 'hex');
	var BITS_64_ON = 'ffffffffffffffff';

	// By default, we sign with sighash_forkid
	var DEFAULT_SIGN_FLAGS = Interpreter.SCRIPT_ENABLE_SIGHASH_FORKID;

	var sighashPreimageForForkId = function (transaction, sighashType, inputNumber, subscript, satoshisBN) {
	  var input = transaction.inputs[inputNumber];
	  $.checkArgument(
	    satoshisBN instanceof BN,
	    'For ForkId=0 signatures, satoshis or complete input must be provided'
	  );

	  function GetPrevoutHash (tx) {
	    var writer = new BufferWriter();

	    _.each(tx.inputs, function (input) {
	      writer.writeReverse(input.prevTxId);
	      writer.writeUInt32LE(input.outputIndex);
	    });

	    var buf = writer.toBuffer();
	    var ret = Hash.sha256sha256(buf);
	    return ret
	  }

	  function GetSequenceHash (tx) {
	    var writer = new BufferWriter();

	    _.each(tx.inputs, function (input) {
	      writer.writeUInt32LE(input.sequenceNumber);
	    });

	    var buf = writer.toBuffer();
	    var ret = Hash.sha256sha256(buf);
	    return ret
	  }

	  function GetOutputsHash (tx, n) {
	    var writer = new BufferWriter();

	    if (_.isUndefined(n)) {
	      _.each(tx.outputs, function (output) {
	        output.toBufferWriter(writer);
	      });
	    } else {
	      tx.outputs[n].toBufferWriter(writer);
	    }

	    var buf = writer.toBuffer();
	    var ret = Hash.sha256sha256(buf);
	    return ret
	  }

	  var hashPrevouts = Buffer.alloc(32);
	  var hashSequence = Buffer.alloc(32);
	  var hashOutputs = Buffer.alloc(32);

	  if (!(sighashType & Signature.SIGHASH_ANYONECANPAY)) {
	    hashPrevouts = GetPrevoutHash(transaction);
	  }

	  if (!(sighashType & Signature.SIGHASH_ANYONECANPAY) &&
	    (sighashType & 31) !== Signature.SIGHASH_SINGLE &&
	    (sighashType & 31) !== Signature.SIGHASH_NONE) {
	    hashSequence = GetSequenceHash(transaction);
	  }

	  if ((sighashType & 31) !== Signature.SIGHASH_SINGLE && (sighashType & 31) !== Signature.SIGHASH_NONE) {
	    hashOutputs = GetOutputsHash(transaction);
	  } else if ((sighashType & 31) === Signature.SIGHASH_SINGLE && inputNumber < transaction.outputs.length) {
	    hashOutputs = GetOutputsHash(transaction, inputNumber);
	  }

	  var writer = new BufferWriter();

	  // Version
	  writer.writeInt32LE(transaction.version);

	  // Input prevouts/nSequence (none/all, depending on flags)
	  writer.write(hashPrevouts);
	  writer.write(hashSequence);

	  //  outpoint (32-byte hash + 4-byte little endian)
	  writer.writeReverse(input.prevTxId);
	  writer.writeUInt32LE(input.outputIndex);

	  // scriptCode of the input (serialized as scripts inside CTxOuts)
	  writer.writeVarintNum(subscript.toBuffer().length);
	  writer.write(subscript.toBuffer());

	  // value of the output spent by this input (8-byte little endian)
	  writer.writeUInt64LEBN(satoshisBN);

	  // nSequence of the input (4-byte little endian)
	  var sequenceNumber = input.sequenceNumber;
	  writer.writeUInt32LE(sequenceNumber);

	  // Outputs (none/one/all, depending on flags)
	  writer.write(hashOutputs);

	  // Locktime
	  writer.writeUInt32LE(transaction.nLockTime);

	  // sighashType
	  writer.writeUInt32LE(sighashType >>> 0);

	  var buf = writer.toBuffer();
	  return buf
	};

	/**
	 * Returns a buffer with the which is hashed with sighash that needs to be signed
	 * for OP_CHECKSIG.
	 *
	 * @name Signing.sighash
	 * @param {Transaction} transaction the transaction to sign
	 * @param {number} sighashType the type of the hash
	 * @param {number} inputNumber the input index for the signature
	 * @param {Script} subscript the script that will be signed
	 * @param {satoshisBN} input's amount (for  ForkId signatures)
	 *
	 */
	var sighashPreimage = function sighashPreimage (transaction, sighashType, inputNumber, subscript, satoshisBN, flags) {
	  var Transaction = requireTransaction$1();
	  var Input = requireInput();

	  if (_.isUndefined(flags)) {
	    flags = DEFAULT_SIGN_FLAGS;
	  }

	  // Copy transaction
	  var txcopy = Transaction.shallowCopy(transaction);

	  // Copy script
	  subscript = new Script(subscript);

	  if (flags & Interpreter.SCRIPT_ENABLE_REPLAY_PROTECTION) {
	    // Legacy chain's value for fork id must be of the form 0xffxxxx.
	    // By xoring with 0xdead, we ensure that the value will be different
	    // from the original one, even if it already starts with 0xff.
	    var forkValue = sighashType >> 8;
	    var newForkValue = 0xff0000 | (forkValue ^ 0xdead);
	    sighashType = (newForkValue << 8) | (sighashType & 0xff);
	  }

	  if ((sighashType & Signature.SIGHASH_FORKID) && (flags & Interpreter.SCRIPT_ENABLE_SIGHASH_FORKID)) {
	    return sighashPreimageForForkId(txcopy, sighashType, inputNumber, subscript, satoshisBN)
	  }

	  // For no ForkId sighash, separators need to be removed.
	  subscript.removeCodeseparators();

	  var i;

	  for (i = 0; i < txcopy.inputs.length; i++) {
	    // Blank signatures for other inputs
	    txcopy.inputs[i] = new Input(txcopy.inputs[i]).setScript(Script.empty());
	  }

	  txcopy.inputs[inputNumber] = new Input(txcopy.inputs[inputNumber]).setScript(subscript);

	  if ((sighashType & 31) === Signature.SIGHASH_NONE ||
	    (sighashType & 31) === Signature.SIGHASH_SINGLE) {
	    // clear all sequenceNumbers
	    for (i = 0; i < txcopy.inputs.length; i++) {
	      if (i !== inputNumber) {
	        txcopy.inputs[i].sequenceNumber = 0;
	      }
	    }
	  }

	  if ((sighashType & 31) === Signature.SIGHASH_NONE) {
	    txcopy.outputs = [];
	  } else if ((sighashType & 31) === Signature.SIGHASH_SINGLE) {
	    // The SIGHASH_SINGLE bug.
	    // https://bitcointalk.org/index.php?topic=260595.0
	    if (inputNumber >= txcopy.outputs.length) {
	      return SIGHASH_SINGLE_BUG
	    }

	    txcopy.outputs.length = inputNumber + 1;

	    for (i = 0; i < inputNumber; i++) {
	      txcopy.outputs[i] = new Output({
	        satoshis: BN.fromBuffer(buffer.Buffer.from(BITS_64_ON, 'hex')),
	        script: Script.empty()
	      });
	    }
	  }

	  if (sighashType & Signature.SIGHASH_ANYONECANPAY) {
	    txcopy.inputs = [txcopy.inputs[inputNumber]];
	  }

	  var buf = new BufferWriter()
	    .write(txcopy.toBuffer())
	    .writeInt32LE(sighashType)
	    .toBuffer();
	  return buf
	};

	/**
	 * Returns a buffer of length 32 bytes with the hash that needs to be signed
	 * for OP_CHECKSIG.
	 *
	 * @name Signing.sighash
	 * @param {Transaction} transaction the transaction to sign
	 * @param {number} sighashType the type of the hash
	 * @param {number} inputNumber the input index for the signature
	 * @param {Script} subscript the script that will be signed
	 * @param {satoshisBN} input's amount (for  ForkId signatures)
	 *
	 */
	var sighash = function sighash (transaction, sighashType, inputNumber, subscript, satoshisBN, flags) {
	  var preimage = sighashPreimage(transaction, sighashType, inputNumber, subscript, satoshisBN, flags);
	  if (preimage.compare(SIGHASH_SINGLE_BUG) === 0) return preimage
	  var ret = Hash.sha256sha256(preimage);
	  ret = new BufferReader(ret).readReverse();
	  return ret
	};

	/**
	 * Create a signature
	 *
	 * @name Signing.sign
	 * @param {Transaction} transaction
	 * @param {PrivateKey} privateKey
	 * @param {number} sighash
	 * @param {number} inputIndex
	 * @param {Script} subscript
	 * @param {satoshisBN} input's amount
	 * @return {Signature}
	 */
	function sign (transaction, privateKey, sighashType, inputIndex, subscript, satoshisBN, flags) {
	  var hashbuf = sighash(transaction, sighashType, inputIndex, subscript, satoshisBN, flags);

	  var sig = ECDSA.sign(hashbuf, privateKey, 'little').set({
	    nhashtype: sighashType
	  });
	  return sig
	}

	/**
	 * Verify a signature
	 *
	 * @name Signing.verify
	 * @param {Transaction} transaction
	 * @param {Signature} signature
	 * @param {PublicKey} publicKey
	 * @param {number} inputIndex
	 * @param {Script} subscript
	 * @param {satoshisBN} input's amount
	 * @param {flags} verification flags
	 * @return {boolean}
	 */
	function verify (transaction, signature, publicKey, inputIndex, subscript, satoshisBN, flags) {
	  $.checkArgument(!_.isUndefined(transaction));
	  $.checkArgument(!_.isUndefined(signature) && !_.isUndefined(signature.nhashtype));
	  var hashbuf = sighash(transaction, signature.nhashtype, inputIndex, subscript, satoshisBN, flags);
	  return ECDSA.verify(hashbuf, signature, publicKey, 'little')
	}

	/**
	 * @namespace Signing
	 */
	sighash_1 = {
	  sighashPreimage: sighashPreimage,
	  sighash: sighash,
	  sign: sign,
	  verify: verify
	};
	return sighash_1;
}

var unspentoutput;
var hasRequiredUnspentoutput;

function requireUnspentoutput () {
	if (hasRequiredUnspentoutput) return unspentoutput;
	hasRequiredUnspentoutput = 1;

	var _ = __1;
	var $ = preconditions;
	var JSUtil = js;

	var Script = requireScript();
	var Address = requireAddress();

	/**
	 * Represents an unspent output information: its script, associated amount and address,
	 * transaction id and output index.
	 *
	 * @constructor
	 * @param {object} data
	 * @param {string} data.txid the previous transaction id
	 * @param {string=} data.txId alias for `txid`
	 * @param {number} data.vout the index in the transaction
	 * @param {number=} data.outputIndex alias for `vout`
	 * @param {string|Script} data.scriptPubKey the script that must be resolved to release the funds
	 * @param {string|Script=} data.script alias for `scriptPubKey`
	 * @param {number} data.amount amount of bitcoins associated
	 * @param {number=} data.satoshis alias for `amount`, but expressed in satoshis (1 space = 1e8 satoshis)
	 * @param {string|Address=} data.address the associated address to the script, if provided
	 */
	function UnspentOutput (data) {
	  if (!(this instanceof UnspentOutput)) {
	    return new UnspentOutput(data)
	  }
	  $.checkArgument(_.isObject(data), 'Must provide an object from where to extract data');
	  var address = data.address ? new Address(data.address) : undefined;
	  var txId = data.txid ? data.txid : data.txId;
	  if (!txId || !JSUtil.isHexaString(txId) || txId.length > 64) {
	    // TODO: Use the errors library
	    throw new Error('Invalid TXID in object', data)
	  }
	  var outputIndex = _.isUndefined(data.vout) ? data.outputIndex : data.vout;
	  if (!_.isNumber(outputIndex)) {
	    throw new Error('Invalid outputIndex, received ' + outputIndex)
	  }
	  $.checkArgument(!_.isUndefined(data.scriptPubKey) || !_.isUndefined(data.script),
	    'Must provide the scriptPubKey for that output!');
	  var script = new Script(data.scriptPubKey || data.script);
	  $.checkArgument(!_.isUndefined(data.amount) || !_.isUndefined(data.satoshis),
	    'Must provide an amount for the output');
	  var amount = !_.isUndefined(data.amount) ? Math.round(data.amount * 1e8) : data.satoshis;
	  $.checkArgument(_.isNumber(amount), 'Amount must be a number');
	  JSUtil.defineImmutable(this, {
	    address: address,
	    txId: txId,
	    outputIndex: outputIndex,
	    script: script,
	    satoshis: amount
	  });
	}

	/**
	 * Provide an informative output when displaying this object in the console
	 * @returns string
	 */
	UnspentOutput.prototype.inspect = function () {
	  return '<UnspentOutput: ' + this.txId + ':' + this.outputIndex +
	         ', satoshis: ' + this.satoshis + ', address: ' + this.address + '>'
	};

	/**
	 * String representation: just "txid:index"
	 * @returns string
	 */
	UnspentOutput.prototype.toString = function () {
	  return this.txId + ':' + this.outputIndex
	};

	/**
	 * Deserialize an UnspentOutput from an object
	 * @param {object|string} data
	 * @return UnspentOutput
	 */
	UnspentOutput.fromObject = function (data) {
	  return new UnspentOutput(data)
	};

	/**
	 * Returns a plain object (no prototype or methods) with the associated info for this output
	 * @return {object}
	 */
	UnspentOutput.prototype.toObject = UnspentOutput.prototype.toJSON = function toObject () {
	  return {
	    address: this.address ? this.address.toString() : undefined,
	    txid: this.txId,
	    vout: this.outputIndex,
	    scriptPubKey: this.script.toBuffer().toString('hex'),
	    amount: Number.parseFloat((this.satoshis / 1e8).toFixed(8))
	  }
	};

	unspentoutput = UnspentOutput;
	return unspentoutput;
}

var transaction;
var hasRequiredTransaction$1;

function requireTransaction$1 () {
	if (hasRequiredTransaction$1) return transaction;
	hasRequiredTransaction$1 = 1;

	var _ = __1;
	var $ = preconditions;
	var buffer = require$$2$1;

	var errors = errorsExports;
	var JSUtil = js;
	var BufferReader = bufferreader;
	var BufferWriter = bufferwriter;
	var Varint = varint;
	var Hash = hashExports;
	var Signature = signature$1;
	var Sighash = requireSighash();

	var Address = requireAddress();
	var UnspentOutput = requireUnspentoutput();
	var Input = requireInput();
	var PublicKeyHashInput = Input.PublicKeyHash;
	var PublicKeyInput = Input.PublicKey;
	var MultiSigScriptHashInput = Input.MultiSigScriptHash;
	var MultiSigInput = Input.MultiSig;
	var Output = requireOutput();
	var Script = requireScript();
	var PrivateKey = requirePrivatekey();
	var BN = bn$1;

	/**
	 * Represents a transaction, a set of inputs and outputs to change ownership of tokens
	 *
	 * @param {*} serialized
	 * @constructor
	 */
	function Transaction (serialized) {
	  if (!(this instanceof Transaction)) {
	    return new Transaction(serialized)
	  }
	  this.inputs = [];
	  this.outputs = [];
	  this._inputAmount = undefined;
	  this._outputAmount = undefined;
	  this.unlockScriptCallbackMap = new Map();
	  this.outputCallbackMap = new Map();
	  this._privateKey = undefined;
	  this._sigType = undefined;
	  this.isSeal = false;
	  if (serialized) {
	    if (serialized instanceof Transaction) {
	      return Transaction.shallowCopy(serialized)
	    } else if (JSUtil.isHexa(serialized)) {
	      this.fromString(serialized);
	    } else if (isBuffer$2(serialized)) {
	      this.fromBuffer(serialized);
	    } else if (_.isObject(serialized)) {
	      this.fromObject(serialized);
	    } else {
	      throw new errors.InvalidArgument('Must provide an object or string to deserialize a transaction')
	    }
	  } else {
	    this._newTransaction();
	  }
	}

	var CURRENT_VERSION = 1;
	var DEFAULT_NLOCKTIME = 0;
	var MAX_BLOCK_SIZE = 1000000;

	// Minimum amount for an output for it not to be considered a dust output
	Transaction.DUST_AMOUNT = 546;

	// Margin of error to allow fees in the vecinity of the expected value but doesn't allow a big difference
	Transaction.FEE_SECURITY_MARGIN = 150;

	// max amount of satoshis in circulation
	Transaction.MAX_MONEY = 21000000 * 1e8;

	// nlocktime limit to be considered block height rather than a timestamp
	Transaction.NLOCKTIME_BLOCKHEIGHT_LIMIT = 5e8;

	// Max value for an unsigned 32 bit value
	Transaction.NLOCKTIME_MAX_VALUE = 4294967295;

	// Value used for fee estimation (satoshis per kilobyte)
	Transaction.FEE_PER_KB = 500;

	// Safe upper bound for change address script size in bytes
	Transaction.CHANGE_OUTPUT_MAX_SIZE = 20 + 4 + 34 + 4;

	/* Constructors and Serialization */

	/**
	 * Create a 'shallow' copy of the transaction, by serializing and deserializing
	 * it dropping any additional information that inputs and outputs may have hold
	 *
	 * @param {Transaction} transaction
	 * @return {Transaction}
	 */
	Transaction.shallowCopy = function (transaction) {
	  var copy = new Transaction(transaction.toBuffer());
	  return copy
	};

	var hashProperty = {
	  configurable: false,
	  enumerable: true,
	  get: function () {
	    this._hash = new BufferReader(this._getHash()).readReverse().toString('hex');
	    return this._hash
	  }
	};
	Object.defineProperty(Transaction.prototype, 'hash', hashProperty);
	Object.defineProperty(Transaction.prototype, 'id', hashProperty);

	var ioProperty = {
	  configurable: false,
	  enumerable: true,
	  get: function () {
	    return this._getInputAmount()
	  }
	};
	Object.defineProperty(Transaction.prototype, 'inputAmount', ioProperty);
	ioProperty.get = function () {
	  return this._getOutputAmount()
	};
	Object.defineProperty(Transaction.prototype, 'outputAmount', ioProperty);

	/**
	 * Retrieve the little endian hash of the transaction (used for serialization)
	 * @return {Buffer}
	 */
	Transaction.prototype._getHash = function () {
	  if (this.version >= 10) {
	      return Hash.sha256sha256(this.newTxHeader().toBuffer())
	  }
	  return Hash.sha256sha256(this.toBuffer())
	};

	/**
	 * Retrieve a hexa string that can be used with bitcoind's CLI interface
	 * (decoderawtransaction, sendrawtransaction)
	 *
	 * @param {Object|boolean=} unsafe if true, skip all tests. if it's an object,
	 *   it's expected to contain a set of flags to skip certain tests:
	 * * `disableAll`: disable all checks
	 * * `disableLargeFees`: disable checking for fees that are too large
	 * * `disableIsFullySigned`: disable checking if all inputs are fully signed
	 * * `disableDustOutputs`: disable checking if there are no outputs that are dust amounts
	 * * `disableMoreOutputThanInput`: disable checking if the transaction spends more bitcoins than the sum of the input amounts
	 * @return {string}
	 */
	Transaction.prototype.serialize = function (unsafe) {
	  if (unsafe === true || (unsafe && unsafe.disableAll)) {
	    return this.uncheckedSerialize()
	  } else {
	    return this.checkedSerialize(unsafe)
	  }
	};

	Transaction.prototype.uncheckedSerialize = Transaction.prototype.toString = function () {
	  return this.toBuffer().toString('hex')
	};

	/**
	 * Retrieve a hexa string that can be used with bitcoind's CLI interface
	 * (decoderawtransaction, sendrawtransaction)
	 *
	 * @param {Object} opts allows to skip certain tests. {@see Transaction#serialize}
	 * @return {string}
	 */
	Transaction.prototype.checkedSerialize = function (opts) {
	  var serializationError = this.getSerializationError(opts);
	  if (serializationError) {
	    serializationError.message += ' - For more information please see: ' +
	      'https://bsv.io/api/lib/transaction#serialization-checks';
	    throw serializationError
	  }
	  return this.uncheckedSerialize()
	};

	Transaction.prototype.invalidSatoshis = function () {
	  var invalid = false;
	  for (var i = 0; i < this.outputs.length; i++) {
	    if (this.outputs[i].invalidSatoshis()) {
	      invalid = true;
	    }
	  }
	  return invalid
	};

	/**
	 * Retrieve a possible error that could appear when trying to serialize and
	 * broadcast this transaction.
	 *
	 * @param {Object} opts allows to skip certain tests. {@see Transaction#serialize}
	 * @return {bsv.Error}
	 */
	Transaction.prototype.getSerializationError = function (opts) {
	  opts = opts || {};

	  if (this.invalidSatoshis()) {
	    return new errors.Transaction.InvalidSatoshis()
	  }

	  var unspent = this._getUnspentValue();
	  var unspentError;
	  if (unspent < 0) {
	    if (!opts.disableMoreOutputThanInput) {
	      unspentError = new errors.Transaction.InvalidOutputAmountSum();
	    }
	  } else {
	    unspentError = this._hasFeeError(opts, unspent);
	  }

	  return unspentError ||
	    this._hasDustOutputs(opts) ||
	    this._isMissingSignatures(opts)
	};

	Transaction.prototype._hasFeeError = function (opts, unspent) {
	  if (!_.isUndefined(this._fee) && this._fee !== unspent) {
	    return new errors.Transaction.FeeError.Different(
	      'Unspent value is ' + unspent + ' but specified fee is ' + this._fee
	    )
	  }

	  if (!opts.disableLargeFees) {
	    var maximumFee = Math.floor(Transaction.FEE_SECURITY_MARGIN * this._estimateFee());
	    if (unspent > maximumFee) {
	      if (this._missingChange()) {
	        return new errors.Transaction.ChangeAddressMissing(
	          'Fee is too large and no change address was provided'
	        )
	      }
	      return new errors.Transaction.FeeError.TooLarge(
	        'expected less than ' + maximumFee + ' but got ' + unspent
	      )
	    }
	  }
	};

	Transaction.prototype._missingChange = function () {
	  return !this._changeScript
	};

	Transaction.prototype._hasDustOutputs = function (opts) {
	  if (opts.disableDustOutputs) {
	    return
	  }
	  var index, output;
	  for (index in this.outputs) {
	    output = this.outputs[index];
	    if (output.satoshis < Transaction.DUST_AMOUNT && !output.script.isDataOut() && !output.script.isSafeDataOut()) {
	      return new errors.Transaction.DustOutputs()
	    }
	  }
	};

	Transaction.prototype._isMissingSignatures = function (opts) {
	  if (opts.disableIsFullySigned) {
	    return
	  }
	  if (!this.isFullySigned()) {
	    return new errors.Transaction.MissingSignatures()
	  }
	};

	Transaction.prototype.inspect = function () {
	  return '<Transaction: ' + this.uncheckedSerialize() + '>'
	};

	Transaction.prototype.toBuffer = function () {
	  var writer = new BufferWriter();
	  return this.toBufferWriter(writer).toBuffer()
	};

	Transaction.prototype.toBufferWriter = function (writer) {
	  writer.writeInt32LE(this.version);
	  writer.writeVarintNum(this.inputs.length);
	  _.each(this.inputs, function (input) {
	    input.toBufferWriter(writer);
	  });
	  writer.writeVarintNum(this.outputs.length);
	  _.each(this.outputs, function (output) {
	    output.toBufferWriter(writer);
	  });
	  writer.writeUInt32LE(this.nLockTime);
	  return writer
	};

	Transaction.prototype.newTxHeader = function () {
	  var writer = new BufferWriter();
	  writer.writeUInt32LE(this.version);
	  writer.writeUInt32LE(this.nLockTime);
	  writer.writeInt32LE(this.inputs.length);
	  writer.writeInt32LE(this.outputs.length);

	  const inputWriter = new BufferWriter();
	  const inputWriter2 = new BufferWriter();
	  for (const input of this.inputs) {
	    inputWriter.writeReverse(input.prevTxId);
	    inputWriter.writeUInt32LE(input.outputIndex);
	    inputWriter.writeUInt32LE(input.sequenceNumber);

	    inputWriter2.write(Hash.sha256(input.script.toBuffer()));
	  }
	  writer.write(Hash.sha256(inputWriter.toBuffer()));
	  writer.write(Hash.sha256(inputWriter2.toBuffer()));

	  const outputWriter = new BufferWriter();
	  for (const output of this.outputs) {
	    outputWriter.writeUInt64LEBN(output.satoshisBN);
	    outputWriter.write(Hash.sha256(output.script.toBuffer()));
	  }
	  writer.write(Hash.sha256(outputWriter.toBuffer()));
	  return writer
	};

	Transaction.prototype.fromBuffer = function (buffer) {
	  var reader = new BufferReader(buffer);
	  return this.fromBufferReader(reader)
	};

	Transaction.prototype.fromBufferReader = function (reader) {
	  $.checkArgument(!reader.finished(), 'No transaction data received');
	  var i, sizeTxIns, sizeTxOuts;

	  this.version = reader.readInt32LE();
	  sizeTxIns = reader.readVarintNum();
	  for (i = 0; i < sizeTxIns; i++) {
	    var input = Input.fromBufferReader(reader);
	    this.inputs.push(input);
	  }
	  sizeTxOuts = reader.readVarintNum();
	  for (i = 0; i < sizeTxOuts; i++) {
	    this.outputs.push(Output.fromBufferReader(reader));
	  }
	  this.nLockTime = reader.readUInt32LE();
	  return this
	};

	Transaction.prototype.toObject = Transaction.prototype.toJSON = function toObject () {
	  var inputs = [];
	  this.inputs.forEach(function (input) {
	    inputs.push(input.toObject());
	  });
	  var outputs = [];
	  this.outputs.forEach(function (output) {
	    outputs.push(output.toObject());
	  });
	  var obj = {
	    hash: this.hash,
	    version: this.version,
	    inputs: inputs,
	    outputs: outputs,
	    nLockTime: this.nLockTime
	  };
	  if (this._changeScript) {
	    obj.changeScript = this._changeScript.toString();
	  }
	  if (!_.isUndefined(this._changeIndex)) {
	    obj.changeIndex = this._changeIndex;
	  }
	  if (!_.isUndefined(this._fee)) {
	    obj.fee = this._fee;
	  }
	  return obj
	};

	Transaction.prototype.fromObject = function fromObject (arg) {
	  $.checkArgument(_.isObject(arg) || arg instanceof Transaction);
	  var self = this;
	  var transaction;
	  if (arg instanceof Transaction) {
	    transaction = transaction.toObject();
	  } else {
	    transaction = arg;
	  }
	  _.each(transaction.inputs, function (input) {
	    if (!input.output || !input.output.script) {
	      self.uncheckedAddInput(new Input(input));
	      return
	    }
	    var script = new Script(input.output.script);
	    var txin;
	    if (script.isPublicKeyHashOut()) {
	      txin = new Input.PublicKeyHash(input);
	    } else if (script.isScriptHashOut() && input.publicKeys && input.threshold) {
	      txin = new Input.MultiSigScriptHash(
	        input, input.publicKeys, input.threshold, input.signatures
	      );
	    } else if (script.isPublicKeyOut()) {
	      txin = new Input.PublicKey(input);
	    } else {
	      throw new errors.Transaction.Input.UnsupportedScript(input.output.script)
	    }
	    self.addInput(txin);
	  });
	  _.each(transaction.outputs, function (output) {
	    self.addOutput(new Output(output));
	  });
	  if (transaction.changeIndex) {
	    this._changeIndex = transaction.changeIndex;
	  }
	  if (transaction.changeScript) {
	    this._changeScript = new Script(transaction.changeScript);
	  }
	  if (transaction.fee) {
	    this._fee = transaction.fee;
	  }
	  this.nLockTime = transaction.nLockTime;
	  this.version = transaction.version;
	  this._checkConsistency(arg);
	  return this
	};

	Transaction.prototype._checkConsistency = function (arg) {
	  if (!_.isUndefined(this._changeIndex)) {
	    $.checkState(this._changeScript, 'Change script is expected.');
	    $.checkState(this.outputs[this._changeIndex], 'Change index points to undefined output.');
	    $.checkState(this.outputs[this._changeIndex].script.toString() ===
	      this._changeScript.toString(), 'Change output has an unexpected script.');
	  }
	  if (arg && arg.hash) {
	    $.checkState(arg.hash === this.hash, 'Hash in object does not match transaction hash.');
	  }
	};

	/**
	 * Sets nLockTime so that transaction is not valid until the desired date(a
	 * timestamp in seconds since UNIX epoch is also accepted)
	 *
	 * @param {Date | Number} time
	 * @return {Transaction} this
	 */
	Transaction.prototype.lockUntilDate = function (time) {
	  $.checkArgument(time);
	  if (_.isNumber(time) && time < Transaction.NLOCKTIME_BLOCKHEIGHT_LIMIT) {
	    throw new errors.Transaction.LockTimeTooEarly()
	  }
	  if (_.isDate(time)) {
	    time = time.getTime() / 1000;
	  }

	  for (var i = 0; i < this.inputs.length; i++) {
	    if (this.inputs[i].sequenceNumber === Input.DEFAULT_SEQNUMBER) {
	      this.inputs[i].sequenceNumber = Input.DEFAULT_LOCKTIME_SEQNUMBER;
	    }
	  }

	  this.nLockTime = time;
	  return this
	};

	/**
	 * Sets nLockTime so that transaction is not valid until the desired block
	 * height.
	 *
	 * @param {Number} height
	 * @return {Transaction} this
	 */
	Transaction.prototype.lockUntilBlockHeight = function (height) {
	  $.checkArgument(_.isNumber(height));
	  if (height >= Transaction.NLOCKTIME_BLOCKHEIGHT_LIMIT) {
	    throw new errors.Transaction.BlockHeightTooHigh()
	  }
	  if (height < 0) {
	    throw new errors.Transaction.NLockTimeOutOfRange()
	  }

	  for (var i = 0; i < this.inputs.length; i++) {
	    if (this.inputs[i].sequenceNumber === Input.DEFAULT_SEQNUMBER) {
	      this.inputs[i].sequenceNumber = Input.DEFAULT_LOCKTIME_SEQNUMBER;
	    }
	  }

	  this.nLockTime = height;
	  return this
	};

	/**
	 *  Returns a semantic version of the transaction's nLockTime.
	 *  @return {Number|Date}
	 *  If nLockTime is 0, it returns null,
	 *  if it is < 500000000, it returns a block height (number)
	 *  else it returns a Date object.
	 */
	Transaction.prototype.getLockTime = function () {
	  if (!this.nLockTime) {
	    return null
	  }
	  if (this.nLockTime < Transaction.NLOCKTIME_BLOCKHEIGHT_LIMIT) {
	    return this.nLockTime
	  }
	  return new Date(1000 * this.nLockTime)
	};

	Transaction.prototype.fromString = function (string) {
	  this.fromBuffer(buffer.Buffer.from(string, 'hex'));
	};

	Transaction.prototype._newTransaction = function () {
	  this.version = CURRENT_VERSION;
	  this.nLockTime = DEFAULT_NLOCKTIME;
	};

	/* Transaction creation interface */

	/**
	 * @typedef {Object} Transaction~fromObject
	 * @property {string} prevTxId
	 * @property {number} outputIndex
	 * @property {(Buffer|string|Script)} script
	 * @property {number} satoshis
	 */

	/**
	 * Add an input to this transaction. This is a high level interface
	 * to add an input, for more control, use @{link Transaction#addInput}.
	 *
	 * Can receive, as output information, the output of bitcoind's `listunspent` command,
	 * and a slightly fancier format recognized by bsv:
	 *
	 * ```
	 * {
	 *  address: 'mszYqVnqKoQx4jcTdJXxwKAissE3Jbrrc1',
	 *  txId: 'a477af6b2667c29670467e4e0728b685ee07b240235771862318e29ddbe58458',
	 *  outputIndex: 0,
	 *  script: Script.empty(),
	 *  satoshis: 1020000
	 * }
	 * ```
	 * Where `address` can be either a string or a bsv Address object. The
	 * same is true for `script`, which can be a string or a bsv Script.
	 *
	 * Beware that this resets all the signatures for inputs (in further versions,
	 * SIGHASH_SINGLE or SIGHASH_NONE signatures will not be reset).
	 *
	 * @example
	 * ```javascript
	 * var transaction = new Transaction();
	 *
	 * // From a pay to public key hash output from bitcoind's listunspent
	 * transaction.from({'txid': '0000...', vout: 0, amount: 0.1, scriptPubKey: 'OP_DUP ...'});
	 *
	 * // From a pay to public key hash output
	 * transaction.from({'txId': '0000...', outputIndex: 0, satoshis: 1000, script: 'OP_DUP ...'});
	 *
	 * // From a multisig P2SH output
	 * transaction.from({'txId': '0000...', inputIndex: 0, satoshis: 1000, script: '... OP_HASH'},
	 *                  ['03000...', '02000...'], 2);
	 * ```
	 *
	 * @param {(Array.<Transaction~fromObject>|Transaction~fromObject)} utxo
	 * @param {Array=} pubkeys
	 * @param {number=} threshold
	 */
	Transaction.prototype.from = function (utxo, pubkeys, threshold) {
	  if (_.isArray(utxo)) {
	    var self = this;
	    _.each(utxo, function (utxo) {
	      self.from(utxo, pubkeys, threshold);
	    });
	    return this
	  }
	  var exists = _.some(this.inputs, function (input) {
	    // TODO: Maybe prevTxId should be a string? Or defined as read only property?
	    return input.prevTxId.toString('hex') === utxo.txId && input.outputIndex === utxo.outputIndex
	  });
	  if (exists) {
	    return this
	  }
	  if (pubkeys && threshold) {
	    this._fromMultisigUtxo(utxo, pubkeys, threshold);
	  } else {
	    this._fromNonP2SH(utxo);
	  }
	  return this
	};

	Transaction.prototype._fromNonP2SH = function (utxo) {
	  var Clazz;
	  utxo = new UnspentOutput(utxo);
	  if (utxo.script.isPublicKeyHashOut()) {
	    Clazz = PublicKeyHashInput;
	  } else if (utxo.script.isPublicKeyOut()) {
	    Clazz = PublicKeyInput;
	  } else {
	    Clazz = Input;
	  }
	  this.addInput(new Clazz({
	    output: new Output({
	      script: utxo.script,
	      satoshis: utxo.satoshis
	    }),
	    prevTxId: utxo.txId,
	    outputIndex: utxo.outputIndex,
	    script: Script.empty()
	  }));
	};

	Transaction.prototype._fromMultisigUtxo = function (utxo, pubkeys, threshold) {
	  $.checkArgument(threshold <= pubkeys.length,
	    'Number of required signatures must be greater than the number of public keys');
	  var Clazz;
	  utxo = new UnspentOutput(utxo);
	  if (utxo.script.isMultisigOut()) {
	    Clazz = MultiSigInput;
	  } else if (utxo.script.isScriptHashOut()) {
	    Clazz = MultiSigScriptHashInput;
	  } else {
	    throw new Error('@TODO')
	  }
	  this.addInput(new Clazz({
	    output: new Output({
	      script: utxo.script,
	      satoshis: utxo.satoshis
	    }),
	    prevTxId: utxo.txId,
	    outputIndex: utxo.outputIndex,
	    script: Script.empty()
	  }, pubkeys, threshold));
	};

	/**
	 * Add an input to this transaction. The input must be an instance of the `Input` class.
	 * It should have information about the Output that it's spending, but if it's not already
	 * set, two additional parameters, `outputScript` and `satoshis` can be provided.
	 *
	 * @param {Input} input
	 * @param {String|Script} outputScript
	 * @param {number} satoshis
	 * @return Transaction this, for chaining
	 */
	Transaction.prototype.addInput = function (input, outputScript, satoshis) {
	  $.checkArgumentType(input, Input, 'input');
	  if (!input.output && (_.isUndefined(outputScript) || _.isUndefined(satoshis))) {
	    throw new errors.Transaction.NeedMoreInfo('Need information about the UTXO script and satoshis')
	  }
	  if (!input.output && outputScript && !_.isUndefined(satoshis)) {
	    outputScript = outputScript instanceof Script ? outputScript : new Script(outputScript);
	    $.checkArgumentType(satoshis, 'number', 'satoshis');
	    input.output = new Output({
	      script: outputScript,
	      satoshis: satoshis
	    });
	  }
	  return this.uncheckedAddInput(input)
	};

	/**
	 * Add an input to this transaction, without checking that the input has information about
	 * the output that it's spending.
	 *
	 * @param {Input} input
	 * @return Transaction this, for chaining
	 */
	Transaction.prototype.uncheckedAddInput = function (input) {
	  $.checkArgumentType(input, Input, 'input');
	  this.inputs.push(input);
	  this._inputAmount = undefined;
	  this._updateChangeOutput();
	  return this
	};

	/**
	 * Returns true if the transaction has enough info on all inputs to be correctly validated
	 *
	 * @return {boolean}
	 */
	Transaction.prototype.hasAllUtxoInfo = function () {
	  return _.every(this.inputs.map(function (input) {
	    return !!input.output
	  }))
	};

	/**
	 * Manually set the fee for this transaction. Beware that this resets all the signatures
	 * for inputs (in further versions, SIGHASH_SINGLE or SIGHASH_NONE signatures will not
	 * be reset).
	 *
	 * @param {number} amount satoshis to be sent
	 * @return {Transaction} this, for chaining
	 */
	Transaction.prototype.fee = function (amount) {
	  $.checkArgument(_.isNumber(amount), 'amount must be a number');
	  this._fee = amount;
	  this._updateChangeOutput();
	  return this
	};

	/**
	 * Manually set the fee per KB for this transaction. Beware that this resets all the signatures
	 * for inputs (in further versions, SIGHASH_SINGLE or SIGHASH_NONE signatures will not
	 * be reset).
	 *
	 * @param {number} amount satoshis per KB to be sent
	 * @return {Transaction} this, for chaining
	 */
	Transaction.prototype.feePerKb = function (amount) {
	  $.checkArgument(_.isNumber(amount), 'amount must be a number');
	  this._feePerKb = amount;
	  this._updateChangeOutput();
	  return this
	};

	/* Output management */

	/**
	 * Set the change address for this transaction
	 *
	 * Beware that this resets all the signatures for inputs (in further versions,
	 * SIGHASH_SINGLE or SIGHASH_NONE signatures will not be reset).
	 *
	 * @param {Address} address An address for change to be sent to.
	 * @return {Transaction} this, for chaining
	 */
	Transaction.prototype.change = function (address) {
	  $.checkArgument(address, 'address is required');
	  this._changeScript = Script.fromAddress(address);
	  this._updateChangeOutput();
	  return this
	};

	/**
	 * @return {Output} change output, if it exists
	 */
	Transaction.prototype.getChangeOutput = function () {
	  if (!_.isUndefined(this._changeIndex)) {
	    return this.outputs[this._changeIndex]
	  }
	  return null
	};

	/**
	 * @typedef {Object} Transaction~toObject
	 * @property {(string|Address)} address
	 * @property {number} satoshis
	 */

	/**
	 * Add an output to the transaction.
	 *
	 * Beware that this resets all the signatures for inputs (in further versions,
	 * SIGHASH_SINGLE or SIGHASH_NONE signatures will not be reset).
	 *
	 * @param {(string|Address|Array.<Transaction~toObject>)} address
	 * @param {number} amount in satoshis
	 * @return {Transaction} this, for chaining
	 */
	Transaction.prototype.to = function (address, amount) {
	  if (_.isArray(address)) {
	    var self = this;
	    _.each(address, function (to) {
	      self.to(to.address, to.satoshis);
	    });
	    return this
	  }

	  $.checkArgument(
	    JSUtil.isNaturalNumber(amount),
	    'Amount is expected to be a positive integer'
	  );
	  this.addOutput(new Output({
	    script: Script(new Address(address)),
	    satoshis: amount
	  }));
	  return this
	};

	/**
	 * Add an OP_RETURN output to the transaction.
	 *
	 * Beware that this resets all the signatures for inputs (in further versions,
	 * SIGHASH_SINGLE or SIGHASH_NONE signatures will not be reset).
	 *
	 * @param {Buffer|string} value the data to be stored in the OP_RETURN output.
	 *    In case of a string, the UTF-8 representation will be stored
	 * @return {Transaction} this, for chaining
	 */
	Transaction.prototype.addData = function (value) {
	  this.addOutput(new Output({
	    script: Script.buildDataOut(value),
	    satoshis: 0
	  }));
	  return this
	};

	/**
	 * Add an OP_FALSE | OP_RETURN output to the transaction.
	 *
	 * Beware that this resets all the signatures for inputs (in further versions,
	 * SIGHASH_SINGLE or SIGHASH_NONE signatures will not be reset).
	 *
	 * @param {Buffer|string} value the data to be stored in the OP_RETURN output.
	 *    In case of a string, the UTF-8 representation will be stored
	 * @return {Transaction} this, for chaining
	 */
	Transaction.prototype.addSafeData = function (value) {
	  this.addOutput(new Output({
	    script: Script.buildSafeDataOut(value),
	    satoshis: 0
	  }));
	  return this
	};

	/**
	 * Add an output to the transaction.
	 *
	 * @param {Output} output the output to add.
	 * @return {Transaction} this, for chaining
	 */
	Transaction.prototype.addOutput = function (output) {
	  $.checkArgumentType(output, Output, 'output');
	  this._addOutput(output);
	  this._updateChangeOutput();
	  return this
	};

	/**
	 * Remove all outputs from the transaction.
	 *
	 * @return {Transaction} this, for chaining
	 */
	Transaction.prototype.clearOutputs = function () {
	  this.outputs = [];
	  this._clearSignatures();
	  this._outputAmount = undefined;
	  this._changeIndex = undefined;
	  this._updateChangeOutput();
	  return this
	};

	Transaction.prototype._addOutput = function (output) {
	  this.outputs.push(output);
	  this._outputAmount = undefined;
	};

	/**
	 * Calculates or gets the total output amount in satoshis
	 *
	 * @return {Number} the transaction total output amount
	 */
	Transaction.prototype._getOutputAmount = function () {
	  if (_.isUndefined(this._outputAmount)) {
	    var self = this;
	    this._outputAmount = 0;
	    _.each(this.outputs, function (output) {
	      self._outputAmount += output.satoshis;
	    });
	  }
	  return this._outputAmount
	};

	/**
	 * Calculates or gets the total input amount in satoshis
	 *
	 * @return {Number} the transaction total input amount
	 */
	Transaction.prototype._getInputAmount = function () {
	  if (_.isUndefined(this._inputAmount)) {
	    var self = this;
	    this._inputAmount = 0;
	    _.each(this.inputs, function (input) {
	      if (_.isUndefined(input.output)) {
	        throw new errors.Transaction.Input.MissingPreviousOutput()
	      }
	      self._inputAmount += input.output.satoshis;
	    });
	  }
	  return this._inputAmount
	};

	Transaction.prototype._updateChangeOutput = function () {

	  if(this.isSeal) {
	    throw new errors.Transaction.TransactionAlreadySealed()
	  }


	  if (!this._changeScript) {
	    return
	  }
	  this._clearSignatures();
	  if (!_.isUndefined(this._changeIndex)) {
	    this._removeOutput(this._changeIndex);
	  }
	  this._changeIndex = this.outputs.length;
	  this._addOutput(new Output({
	    script: this._changeScript,
	    satoshis: 0
	  }));
	  var available = this._getUnspentValue();
	  var fee = this.getFee();
	  var changeAmount = available - fee;
	  this._removeOutput(this._changeIndex);
	  this._changeIndex = undefined;
	  if (changeAmount >= Transaction.DUST_AMOUNT) {
	    this._changeIndex = this.outputs.length;
	    this._addOutput(new Output({
	      script: this._changeScript,
	      satoshis: changeAmount
	    }));
	  }
	};
	/**
	 * Calculates the fee of the transaction.
	 *
	 * If there's a fixed fee set, return that.
	 *
	 * If there is no change output set, the fee is the
	 * total value of the outputs minus inputs. Note that
	 * a serialized transaction only specifies the value
	 * of its outputs. (The value of inputs are recorded
	 * in the previous transaction outputs being spent.)
	 * This method therefore raises a "MissingPreviousOutput"
	 * error when called on a serialized transaction.
	 *
	 * If there's no fee set and no change address,
	 * estimate the fee based on size.
	 *
	 * @return {Number} fee of this transaction in satoshis
	 */
	Transaction.prototype.getFee = function () {
	  if (this.isCoinbase()) {
	    return 0
	  }
	  if (!_.isUndefined(this._fee)) {
	    return this._fee
	  }
	  // if no change output is set, fees should equal all the unspent amount
	  if (!this._changeScript) {
	    return this._getUnspentValue()
	  }
	  return this._estimateFee()
	};

	/**
	 * Estimates fee from serialized transaction size in bytes.
	 */
	Transaction.prototype._estimateFee = function () {
	  var estimatedSize = this._estimateSize();
	  return Math.ceil(estimatedSize / 1000 * (this._feePerKb || Transaction.FEE_PER_KB))
	};

	Transaction.prototype._getUnspentValue = function () {
	  return this._getInputAmount() - this._getOutputAmount()
	};

	Transaction.prototype._clearSignatures = function () {
	  _.each(this.inputs, function (input) {
	    input.clearSignatures();
	  });
	};

	// 4    version
	// ???  num inputs (VARINT)
	// --- input list ---
	//
	// ???  num outputs (VARINT)
	// --- output list ---
	//      8       value
	//      ???     script size (VARINT)
	//      ???     script
	//
	// 4    locktime
	Transaction.prototype._estimateSize = function () {
	  var result = 4 + 4; // size of version + size of locktime
	  result += Varint(this.inputs.length).toBuffer().length;
	  result += Varint(this.outputs.length).toBuffer().length;
	  _.each(this.inputs, function (input) {
	    result += input._estimateSize();
	  });
	  _.each(this.outputs, function (output) {
	    result += output.getSize();
	  });
	  return result
	};

	Transaction.prototype._removeOutput = function (index) {
	  var output = this.outputs[index];
	  this.outputs = _.without(this.outputs, output);
	  this._outputAmount = undefined;
	};

	Transaction.prototype.removeOutput = function (index) {
	  this._removeOutput(index);
	  this._updateChangeOutput();
	};

	/**
	 * Sort a transaction's inputs and outputs according to BIP69
	 *
	 * @see {https://github.com/bitcoin/bips/blob/master/bip-0069.mediawiki}
	 * @return {Transaction} this
	 */
	Transaction.prototype.sort = function () {
	  this.sortInputs(function (inputs) {
	    var copy = Array.prototype.concat.apply([], inputs);
	    copy.sort(function (first, second) {
	      return first.prevTxId.compare(second.prevTxId) ||
	        first.outputIndex - second.outputIndex
	    });
	    return copy
	  });
	  this.sortOutputs(function (outputs) {
	    var copy = Array.prototype.concat.apply([], outputs);
	    copy.sort(function (first, second) {
	      return first.satoshis - second.satoshis ||
	        first.script.toBuffer().compare(second.script.toBuffer())
	    });
	    return copy
	  });
	  return this
	};

	/**
	 * Randomize this transaction's outputs ordering. The shuffling algorithm is a
	 * version of the Fisher-Yates shuffle.
	 *
	 * @return {Transaction} this
	 */
	Transaction.prototype.shuffleOutputs = function () {
	  return this.sortOutputs(_.shuffle)
	};

	/**
	 * Sort this transaction's outputs, according to a given sorting function that
	 * takes an array as argument and returns a new array, with the same elements
	 * but with a different order. The argument function MUST NOT modify the order
	 * of the original array
	 *
	 * @param {Function} sortingFunction
	 * @return {Transaction} this
	 */
	Transaction.prototype.sortOutputs = function (sortingFunction) {
	  var outs = sortingFunction(this.outputs);
	  return this._newOutputOrder(outs)
	};

	/**
	 * Sort this transaction's inputs, according to a given sorting function that
	 * takes an array as argument and returns a new array, with the same elements
	 * but with a different order.
	 *
	 * @param {Function} sortingFunction
	 * @return {Transaction} this
	 */
	Transaction.prototype.sortInputs = function (sortingFunction) {
	  this.inputs = sortingFunction(this.inputs);
	  this._clearSignatures();
	  return this
	};

	Transaction.prototype._newOutputOrder = function (newOutputs) {
	  var isInvalidSorting = (this.outputs.length !== newOutputs.length ||
	                          _.difference(this.outputs, newOutputs).length !== 0);
	  if (isInvalidSorting) {
	    throw new errors.Transaction.InvalidSorting()
	  }

	  if (!_.isUndefined(this._changeIndex)) {
	    var changeOutput = this.outputs[this._changeIndex];
	    this._changeIndex = newOutputs.indexOf(changeOutput);
	  }

	  this.outputs = newOutputs;
	  return this
	};

	Transaction.prototype.removeInput = function (txId, outputIndex) {
	  var index;
	  if (!outputIndex && _.isNumber(txId)) {
	    index = txId;
	  } else {
	    index = _.findIndex(this.inputs, function (input) {
	      return input.prevTxId.toString('hex') === txId && input.outputIndex === outputIndex
	    });
	  }
	  if (index < 0 || index >= this.inputs.length) {
	    throw new errors.Transaction.InvalidIndex(index, this.inputs.length)
	  }
	  var input = this.inputs[index];
	  this.inputs = _.without(this.inputs, input);
	  this._inputAmount = undefined;
	  this._updateChangeOutput();
	};

	/* Signature handling */

	/**
	 * Sign the transaction using one or more private keys.
	 *
	 * It tries to sign each input, verifying that the signature will be valid
	 * (matches a public key).
	 *
	 * @param {Array|String|PrivateKey} privateKey
	 * @param {number} sigtype
	 * @return {Transaction} this, for chaining
	 */
	Transaction.prototype.sign = function (privateKey, sigtype) {
	  $.checkState(this.hasAllUtxoInfo(), 'Not all utxo information is available to sign the transaction.');
	  var self = this;
	  if (_.isArray(privateKey)) {
	    _.each(privateKey, function (privateKey) {
	      self.sign(privateKey, sigtype);
	    });
	    return this
	  }
	  _.each(this.getSignatures(privateKey, sigtype), function (signature) {
	    self.applySignature(signature);
	  });

	  this._privateKey = privateKey;
	  this._sigType = sigtype;
	  return this
	};

	Transaction.prototype.getSignatures = function (privKey, sigtype) {
	  privKey = new PrivateKey(privKey);
	  // By default, signs using ALL|FORKID
	  sigtype = sigtype || (Signature.SIGHASH_ALL | Signature.SIGHASH_FORKID);
	  var transaction = this;
	  var results = [];
	  var hashData = Hash.sha256ripemd160(privKey.publicKey.toBuffer());
	  _.each(this.inputs, function forEachInput (input, index) {
	    _.each(input.getSignatures(transaction, privKey, index, sigtype, hashData), function (signature) {
	      results.push(signature);
	    });
	  });
	  return results
	};

	/**
	 * Add a signature to the transaction
	 *
	 * @param {Object} signature
	 * @param {number} signature.inputIndex
	 * @param {number} signature.sigtype
	 * @param {PublicKey} signature.publicKey
	 * @param {Signature} signature.signature
	 * @return {Transaction} this, for chaining
	 */
	Transaction.prototype.applySignature = function (signature) {
	  this.inputs[signature.inputIndex].addSignature(this, signature);
	  return this
	};

	Transaction.prototype.isFullySigned = function () {
	  _.each(this.inputs, function (input) {
	    if (input.isFullySigned === Input.prototype.isFullySigned) {
	      throw new errors.Transaction.UnableToVerifySignature(
	        'Unrecognized script kind, or not enough information to execute script.' +
	        'This usually happens when creating a transaction from a serialized transaction'
	      )
	    }
	  });
	  return _.every(_.map(this.inputs, function (input) {
	    return input.isFullySigned()
	  }))
	};

	Transaction.prototype.isValidSignature = function (signature) {
	  var self = this;
	  if (this.inputs[signature.inputIndex].isValidSignature === Input.prototype.isValidSignature) {
	    throw new errors.Transaction.UnableToVerifySignature(
	      'Unrecognized script kind, or not enough information to execute script.' +
	      'This usually happens when creating a transaction from a serialized transaction'
	    )
	  }
	  return this.inputs[signature.inputIndex].isValidSignature(self, signature)
	};

	/**
	 * @returns {bool} whether the signature is valid for this transaction input
	 */
	Transaction.prototype.verifySignature = function (sig, pubkey, nin, subscript, satoshisBN, flags) {
	  return Sighash.verify(this, sig, pubkey, nin, subscript, satoshisBN, flags)
	};

	/**
	 * Check that a transaction passes basic sanity tests. If not, return a string
	 * describing the error. This function contains the same logic as
	 * CheckTransaction in bitcoin core.
	 */
	Transaction.prototype.verify = function () {
	  // Basic checks that don't depend on any context
	  if (this.inputs.length === 0) {
	    return 'transaction txins empty'
	  }

	  if (this.outputs.length === 0) {
	    return 'transaction txouts empty'
	  }

	  // Check for negative or overflow output values
	  var valueoutbn = new BN(0);
	  for (var i = 0; i < this.outputs.length; i++) {
	    var txout = this.outputs[i];

	    if (txout.invalidSatoshis()) {
	      return 'transaction txout ' + i + ' satoshis is invalid'
	    }
	    if (txout._satoshisBN.gt(new BN(Transaction.MAX_MONEY, 10))) {
	      return 'transaction txout ' + i + ' greater than MAX_MONEY'
	    }
	    valueoutbn = valueoutbn.add(txout._satoshisBN);
	    if (valueoutbn.gt(new BN(Transaction.MAX_MONEY))) {
	      return 'transaction txout ' + i + ' total output greater than MAX_MONEY'
	    }
	  }

	  // Size limits
	  if (this.toBuffer().length > MAX_BLOCK_SIZE) {
	    return 'transaction over the maximum block size'
	  }

	  // Check for duplicate inputs
	  var txinmap = {};
	  for (i = 0; i < this.inputs.length; i++) {
	    var txin = this.inputs[i];

	    var inputid = txin.prevTxId + ':' + txin.outputIndex;
	    if (!_.isUndefined(txinmap[inputid])) {
	      return 'transaction input ' + i + ' duplicate input'
	    }
	    txinmap[inputid] = true;
	  }

	  var isCoinbase = this.isCoinbase();
	  if (isCoinbase) {
	    var buf = this.inputs[0]._scriptBuffer;
	    if (buf.length < 2 || buf.length > 100) {
	      return 'coinbase transaction script size invalid'
	    }
	  } else {
	    for (i = 0; i < this.inputs.length; i++) {
	      if (this.inputs[i].isNull()) {
	        return 'transaction input ' + i + ' has null input'
	      }
	    }
	  }
	  return true
	};

	/**
	 * Analogous to bitcoind's IsCoinBase function in transaction.h
	 */
	Transaction.prototype.isCoinbase = function () {
	  return (this.inputs.length === 1 && this.inputs[0].isNull())
	};

	/**
	 * 
	 * @param {number} inputIndex 
	 * @param {Script|(tx, output) => Script} unlockScriptOrCallback  unlockScript or a callback returns unlockScript
	 * @returns unlockScript of the special input
	 */
	Transaction.prototype.setInputScript = function (inputIndex, unlockScriptOrCallback) {

	  if (unlockScriptOrCallback instanceof Function) {
	    this.unlockScriptCallbackMap.set(inputIndex, unlockScriptOrCallback);
	    this.inputs[inputIndex].setScript(unlockScriptOrCallback(this, this.inputs[inputIndex].output));

	  } else {
	    this.inputs[inputIndex].setScript(unlockScriptOrCallback);
	  }
	  
	  this._updateChangeOutput();
	  return this;
	};

	Transaction.prototype.setInputSequence = function (inputIndex, sequence) {
	  this.inputs[inputIndex].sequenceNumber = sequence;
	  return this;
	};

	/**
	 * 
	 * @param {number} outputIndex 
	 * @param {Output|(tx) => Output} outputOrcb  output or a callback returns output
	 * @returns output
	 */
	Transaction.prototype.setOutput = function (outputIndex, outputOrcb) {

	  if (outputOrcb instanceof Function) {
	    this.outputCallbackMap.set(outputIndex, outputOrcb);
	    this.outputs[outputIndex] = outputOrcb(this);

	  } else {
	    this.outputs[outputIndex] = outputOrcb;
	  }
	  
	  this._updateChangeOutput();
	  return this;
	};


	/**
	 * Seal a transaction. After the transaction is sealed, except for the unlock script entered, 
	 * other attributes of the transaction cannot be modified
	 */
	Transaction.prototype.seal = function () {

	  const self = this;

	  this.outputCallbackMap.forEach(function(outputCallback, key) {
	    self.outputs[key] = outputCallback(self);
	  });


	  this.unlockScriptCallbackMap.forEach(function(unlockScriptCallback, key) {
	    self.inputs[key].setScript(unlockScriptCallback(self, self.inputs[key].output));
	  });

	  if(this._privateKey) {
	    this.sign(this._privateKey, this._sigType);
	  }

	  this.isSeal = true;

	  return this;
	};

	Transaction.prototype.setLockTime = function (nLockTime) {
	  this.nLockTime = nLockTime;
	  return this;
	};

	/**
	 * 
	 * @returns satoshis of change output
	 */
	Transaction.prototype.getChangeAmount = function () {
	  if (_.isUndefined(this._changeIndex)) {
	    return 0
	  }

	  return this.outputs[this._changeIndex].satoshis
	};

	/**
	 * 
	 * @returns estimate fee by transaction size
	 */
	Transaction.prototype.getEstimateFee = function () {
	  return this._estimateFee();
	};


	/**
	 * 
	 * @param {number} feePerKb the fee per KB for this transaction 
	 * @returns true or false
	 */
	Transaction.prototype.checkFeeRate = function (feePerKb) {

	  const fee = this._getUnspentValue();

	  var estimatedSize = this._estimateSize();
	  var expectedFee = Math.ceil(estimatedSize / 1000 * (feePerKb || this._feePerKb || Transaction.FEE_PER_KB));

	  return fee >= expectedFee
	};


	/**
	 * 
	 * @returns the serialization of all input outpoints
	 */
	Transaction.prototype.prevouts = function () {

	  var writer = new BufferWriter();

	  _.each(this.inputs, function (input) {
	    writer.writeReverse(input.prevTxId);
	    writer.writeUInt32LE(input.outputIndex);
	  });

	  var buf = writer.toBuffer();
	  return buf.toString('hex');
	};


	transaction = Transaction;
	return transaction;
}

var hasRequiredTransaction;

function requireTransaction () {
	if (hasRequiredTransaction) return transaction$1.exports;
	hasRequiredTransaction = 1;
	transaction$1.exports = requireTransaction$1();

	transaction$1.exports.Input = requireInput();
	transaction$1.exports.Output = requireOutput();
	transaction$1.exports.UnspentOutput = requireUnspentoutput();
	transaction$1.exports.Signature = requireSignature();
	transaction$1.exports.Sighash = requireSighash();
	return transaction$1.exports;
}

var interpreter;
var hasRequiredInterpreter;

function requireInterpreter () {
	if (hasRequiredInterpreter) return interpreter;
	hasRequiredInterpreter = 1;

	var _ = __1;

	var Script = requireScript$1();
	var Opcode = opcode;
	var BN = bn$1;
	var Hash = hashExports;
	var Signature = signature$1;
	var PublicKey = requirePublickey();
	var cloneDeep = cloneDeep_1;
	var Stack = stack;
	/**
	 * Bitcoin transactions contain scripts. Each input has a script called the
	 * scriptSig, and each output has a script called the scriptPubkey. To validate
	 * an input, the input's script is concatenated with the referenced output script,
	 * and the result is executed. If at the end of execution the stack contains a
	 * "true" value, then the transaction is valid.
	 *
	 * The primary way to use this class is via the verify function.
	 * e.g., Interpreter().verify( ... );
	 */
	var Interpreter = function Interpreter (obj) {
	  if (!(this instanceof Interpreter)) {
	    return new Interpreter(obj)
	  }
	  if (obj) {
	    this.initialize();
	    this.set(obj);
	  } else {
	    this.initialize();
	  }
	};

	/**
	 * Verifies a Script by executing it and returns true if it is valid.
	 * This function needs to be provided with the scriptSig and the scriptPubkey
	 * separately.
	 * @param {Script} scriptSig - the script's first part (corresponding to the tx input)
	 * @param {Script} scriptPubkey - the script's last part (corresponding to the tx output)
	 * @param {Transaction=} tx - the Transaction containing the scriptSig in one input (used
	 *    to check signature validity for some opcodes like OP_CHECKSIG)
	 * @param {number} nin - index of the transaction input containing the scriptSig verified.
	 * @param {number} flags - evaluation flags. See Interpreter.SCRIPT_* constants
	 * @param {number} satoshisBN - amount in satoshis of the input to be verified (when FORKID signhash is used)
	 *
	 * Translated from bitcoind's VerifyScript
	 */
	Interpreter.prototype.verify = function (scriptSig, scriptPubkey, tx, nin, flags, satoshisBN, sighashScript) {
	  var Transaction = requireTransaction();

	  if (_.isUndefined(tx)) {
	    tx = new Transaction();
	  }
	  if (_.isUndefined(nin)) {
	    nin = 0;
	  }
	  if (_.isUndefined(flags)) {
	    flags = 0;
	  }

	  // If FORKID is enabled, we also ensure strict encoding.
	  if (flags & Interpreter.SCRIPT_ENABLE_SIGHASH_FORKID) {
	    flags |= Interpreter.SCRIPT_VERIFY_STRICTENC;

	    // If FORKID is enabled, we need the input amount.
	    if (!satoshisBN) {
	      throw new Error('internal error - need satoshisBN to verify FORKID transactions')
	    }
	  }

	  this.set({
	    script: scriptSig,
	    tx: tx,
	    nin: nin,
	    flags: flags,
	    satoshisBN: satoshisBN,
	    sighashScript: sighashScript
	  });
	  var stackCopy;

	  if ((flags & Interpreter.SCRIPT_VERIFY_SIGPUSHONLY) !== 0 && !scriptSig.isPushOnly()) {
	    this.errstr = 'SCRIPT_ERR_SIG_PUSHONLY';
	    return false
	  }

	  // evaluate scriptSig
	  if (!this.evaluate('scriptSig')) {
	    return false
	  }

	  if (flags & Interpreter.SCRIPT_VERIFY_P2SH) {
	    stackCopy = this.stack.copy();
	  }

	  var stack = this.stack;
	  this.initialize();
	  this.set({
	    script: scriptPubkey,
	    stack: stack,
	    tx: tx,
	    nin: nin,
	    flags: flags,
	    satoshisBN: satoshisBN,
	    sighashScript: sighashScript
	  });

	  // evaluate scriptPubkey
	  if (!this.evaluate('scriptPubkey')) {
	    return false
	  }

	  if (this.stack.length === 0) {
	    this.errstr = 'SCRIPT_ERR_EVAL_FALSE_NO_RESULT';
	    return false
	  }

	  var buf = this.stack.stacktop(-1);
	  if (!Interpreter.castToBool(buf)) {
	    this.errstr = 'SCRIPT_ERR_EVAL_FALSE_IN_STACK';
	    return false
	  }

	  // Additional validation for spend-to-script-hash transactions:
	  if ((flags & Interpreter.SCRIPT_VERIFY_P2SH) && scriptPubkey.isScriptHashOut()) {
	    // scriptSig must be literals-only or validation fails
	    if (!scriptSig.isPushOnly()) {
	      this.errstr = 'SCRIPT_ERR_SIG_PUSHONLY';
	      return false
	    }

	    // stackCopy cannot be empty here, because if it was the
	    // P2SH  HASH <> EQUAL  scriptPubKey would be evaluated with
	    // an empty stack and the EvalScript above would return false.
	    if (stackCopy.length === 0) {
	      throw new Error('internal error - stack copy empty')
	    }

	    var redeemScriptSerialized = stackCopy.stacktop(-1);
	    var redeemScript = Script.fromBuffer(redeemScriptSerialized);
	    stackCopy.pop();

	    this.initialize();
	    this.set({
	      script: redeemScript,
	      stack: stackCopy,
	      tx: tx,
	      nin: nin,
	      flags: flags,
	      satoshisBN: satoshisBN
	    });

	    // evaluate redeemScript
	    if (!this.evaluate()) {
	      return false
	    }

	    if (stackCopy.length === 0) {
	      this.errstr = 'SCRIPT_ERR_EVAL_FALSE_NO_P2SH_STACK';
	      return false
	    }

	    if (!Interpreter.castToBool(stackCopy.stacktop(-1))) {
	      this.errstr = 'SCRIPT_ERR_EVAL_FALSE_IN_P2SH_STACK';
	      return false
	    }
	  }

	  // The CLEANSTACK check is only performed after potential P2SH evaluation,
	  // as the non-P2SH evaluation of a P2SH script will obviously not result in
	  // a clean stack (the P2SH inputs remain). The same holds for witness
	  // evaluation.
	  if ((flags & Interpreter.SCRIPT_VERIFY_CLEANSTACK) !== 0) {
	    // Disallow CLEANSTACK without P2SH, as otherwise a switch
	    // CLEANSTACK->P2SH+CLEANSTACK would be possible, which is not a
	    // softfork (and P2SH should be one).
	    // if ((flags & Interpreter.SCRIPT_VERIFY_P2SH) === 0) {
	    //   throw new Error('internal error - CLEANSTACK without P2SH')
	    // }

	    if (this.stack.length !== 1) {
	      this.errstr = 'SCRIPT_ERR_CLEANSTACK';
	      return false
	    }
	  }

	  return true
	};

	interpreter = Interpreter;

	Interpreter.prototype.initialize = function (obj) {
	  this.stack = new Stack([]);
	  this.altstack = new Stack([]);
	  this.pc = 0;
	  this.pbegincodehash = 0;
	  this.nOpCount = 0;
	  this.vfExec = [];
	  this.errstr = '';
	  this.flags = 0;
	  // if OP_RETURN is found in executed branches after genesis is activated,
	  // we still have to check if the rest of the script is valid
	  this.nonTopLevelReturnAfterGenesis = false;
	};

	Interpreter.prototype.set = function (obj) {
	  this.script = obj.script || this.script;
	  this.tx = obj.tx || this.tx;
	  this.nin = typeof obj.nin !== 'undefined' ? obj.nin : this.nin;
	  this.satoshisBN = obj.satoshisBN || this.satoshisBN;
	  this.stack = obj.stack || this.stack;
	  this.altstack = obj.altstack || this.altstack;
	  this.pc = typeof obj.pc !== 'undefined' ? obj.pc : this.pc;
	  this.pbegincodehash = typeof obj.pbegincodehash !== 'undefined' ? obj.pbegincodehash : this.pbegincodehash;
	  this.nOpCount = typeof obj.nOpCount !== 'undefined' ? obj.nOpCount : this.nOpCount;
	  this.vfExec = obj.vfExec || this.vfExec;
	  this.errstr = obj.errstr || this.errstr;
	  this.flags = typeof obj.flags !== 'undefined' ? obj.flags : this.flags;
	  this.sighashScript = obj.sighashScript || this.sighashScript;
	};

	Interpreter.prototype.subscript = function () {
	  if (this.sighashScript) {
	    return new Script().set({
	      chunks: this.sighashScript.chunks
	    })
	  } else {
	    // Subset of script starting at the most recent codeseparator
	    // CScript scriptCode(pbegincodehash, pend);
	    return new Script().set({
	      chunks: this.script.chunks.slice(this.pbegincodehash)
	    })
	  }
	};

	Interpreter.getTrue = () => Buffer.from([1]);
	Interpreter.getFalse = () => Buffer.from([]);

	Interpreter.MAX_SCRIPT_ELEMENT_SIZE = 520;
	Interpreter.MAXIMUM_ELEMENT_SIZE = 4;

	Interpreter.LOCKTIME_THRESHOLD = 500000000;
	Interpreter.LOCKTIME_THRESHOLD_BN = new BN(Interpreter.LOCKTIME_THRESHOLD);

	// flags taken from bitcoind
	// bitcoind commit: b5d1b1092998bc95313856d535c632ea5a8f9104
	Interpreter.SCRIPT_VERIFY_NONE = 0;

	// Evaluate P2SH subscripts (softfork safe, BIP16).
	Interpreter.SCRIPT_VERIFY_P2SH = (1 << 0);

	// Passing a non-strict-DER signature or one with undefined hashtype to a checksig operation causes script failure.
	// Passing a pubkey that is not (0x04 + 64 bytes) or (0x02 or 0x03 + 32 bytes) to checksig causes that pubkey to be
	// skipped (not softfork safe: this flag can widen the validity of OP_CHECKSIG OP_NOT).
	Interpreter.SCRIPT_VERIFY_STRICTENC = (1 << 1);

	// Passing a non-strict-DER signature to a checksig operation causes script failure (softfork safe, BIP62 rule 1)
	Interpreter.SCRIPT_VERIFY_DERSIG = (1 << 2);

	// Passing a non-strict-DER signature or one with S > order/2 to a checksig operation causes script failure
	// (softfork safe, BIP62 rule 5).
	Interpreter.SCRIPT_VERIFY_LOW_S = (1 << 3);

	// verify dummy stack item consumed by CHECKMULTISIG is of zero-length (softfork safe, BIP62 rule 7).
	Interpreter.SCRIPT_VERIFY_NULLDUMMY = (1 << 4);

	// Using a non-push operator in the scriptSig causes script failure (softfork safe, BIP62 rule 2).
	Interpreter.SCRIPT_VERIFY_SIGPUSHONLY = (1 << 5);

	// Require minimal encodings for all push operations (OP_0... OP_16, OP_1NEGATE where possible, direct
	// pushes up to 75 bytes, OP_PUSHDATA up to 255 bytes, OP_PUSHDATA2 for anything larger). Evaluating
	// any other push causes the script to fail (BIP62 rule 3).
	// In addition, whenever a stack element is interpreted as a number, it must be of minimal length (BIP62 rule 4).
	// (softfork safe)
	Interpreter.SCRIPT_VERIFY_MINIMALDATA = (1 << 6);

	// Discourage use of NOPs reserved for upgrades (NOP1-10)
	//
	// Provided so that nodes can avoid accepting or mining transactions
	// containing executed NOP's whose meaning may change after a soft-fork,
	// thus rendering the script invalid; with this flag set executing
	// discouraged NOPs fails the script. This verification flag will never be
	// a mandatory flag applied to scripts in a block. NOPs that are not
	// executed, e.g.  within an unexecuted IF ENDIF block, are *not* rejected.
	Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS = (1 << 7);

	// Require that only a single stack element remains after evaluation. This
	// changes the success criterion from "At least one stack element must
	// remain, and when interpreted as a boolean, it must be true" to "Exactly
	// one stack element must remain, and when interpreted as a boolean, it must
	// be true".
	// (softfork safe, BIP62 rule 6)
	// Note: CLEANSTACK should never be used without P2SH or WITNESS.
	Interpreter.SCRIPT_VERIFY_CLEANSTACK = (1 << 8);

	// CLTV See BIP65 for details.
	Interpreter.SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY = (1 << 9);

	// support CHECKSEQUENCEVERIFY opcode
	//
	// See BIP112 for details
	Interpreter.SCRIPT_VERIFY_CHECKSEQUENCEVERIFY = (1 << 10);

	// Segwit script only: Require the argument of OP_IF/NOTIF to be exactly
	// 0x01 or empty vector
	//
	Interpreter.SCRIPT_VERIFY_MINIMALIF = (1 << 13);

	// Signature(s) must be empty vector if an CHECK(MULTI)SIG operation failed
	//
	Interpreter.SCRIPT_VERIFY_NULLFAIL = (1 << 14);

	// Public keys in scripts must be compressed
	Interpreter.SCRIPT_VERIFY_COMPRESSED_PUBKEYTYPE = (1 << 15);

	// Do we accept signature using SIGHASH_FORKID
	//
	Interpreter.SCRIPT_ENABLE_SIGHASH_FORKID = (1 << 16);

	// Do we accept activate replay protection using a different fork id.
	//
	Interpreter.SCRIPT_ENABLE_REPLAY_PROTECTION = (1 << 17);

	// Enable new opcodes.
	//
	Interpreter.SCRIPT_ENABLE_MONOLITH_OPCODES = (1 << 18);

	// Are the Magnetic upgrade opcodes enabled?
	//
	Interpreter.SCRIPT_ENABLE_MAGNETIC_OPCODES = (1 << 19);

	/* Below flags apply in the context of BIP 68 */
	/**
	 * If this flag set, CTxIn::nSequence is NOT interpreted as a relative
	 * lock-time.
	 */
	Interpreter.SEQUENCE_LOCKTIME_DISABLE_FLAG = (1 << 31);

	/**
	 * If CTxIn::nSequence encodes a relative lock-time and this flag is set,
	 * the relative lock-time has units of 512 seconds, otherwise it specifies
	 * blocks with a granularity of 1.
	 */
	Interpreter.SEQUENCE_LOCKTIME_TYPE_FLAG = (1 << 22);

	/**
	 * If CTxIn::nSequence encodes a relative lock-time, this mask is applied to
	 * extract that lock-time from the sequence field.
	 */
	Interpreter.SEQUENCE_LOCKTIME_MASK = 0x0000ffff;

	Interpreter.MAX_SCRIPT_SIZE = Number.MAX_SAFE_INTEGER;

	Interpreter.MAX_OPCODE_COUNT = Number.MAX_SAFE_INTEGER;

	Interpreter.castToBool = function (buf) {
	  for (var i = 0; i < buf.length; i++) {
	    if (buf[i] !== 0) {
	      // can be negative zero
	      if (i === buf.length - 1 && buf[i] === 0x80) {
	        return false
	      }
	      return true
	    }
	  }
	  return false
	};

	/**
	 * Translated from bitcoind's CheckSignatureEncoding
	 */
	Interpreter.prototype.checkSignatureEncoding = function (buf) {
	  var sig;

	  // Empty signature. Not strictly DER encoded, but allowed to provide a
	  // compact way to provide an invalid signature for use with CHECK(MULTI)SIG
	  if (buf.length === 0) {
	    return true
	  }

	  if ((this.flags & (Interpreter.SCRIPT_VERIFY_DERSIG | Interpreter.SCRIPT_VERIFY_LOW_S | Interpreter.SCRIPT_VERIFY_STRICTENC)) !== 0 && !Signature.isTxDER(buf)) {
	    this.errstr = 'SCRIPT_ERR_SIG_DER_INVALID_FORMAT';
	    return false
	  } else if ((this.flags & Interpreter.SCRIPT_VERIFY_LOW_S) !== 0) {
	    sig = Signature.fromTxFormat(buf);
	    if (!sig.hasLowS()) {
	      this.errstr = 'SCRIPT_ERR_SIG_DER_HIGH_S';
	      return false
	    }
	  } else if ((this.flags & Interpreter.SCRIPT_VERIFY_STRICTENC) !== 0) {
	    sig = Signature.fromTxFormat(buf);
	    if (!sig.hasDefinedHashtype()) {
	      this.errstr = 'SCRIPT_ERR_SIG_HASHTYPE';
	      return false
	    }

	    if (!(this.flags & Interpreter.SCRIPT_ENABLE_SIGHASH_FORKID) &&
	      (sig.nhashtype & Signature.SIGHASH_FORKID)) {
	      this.errstr = 'SCRIPT_ERR_ILLEGAL_FORKID';
	      return false
	    }

	    if ((this.flags & Interpreter.SCRIPT_ENABLE_SIGHASH_FORKID) &&
	      !(sig.nhashtype & Signature.SIGHASH_FORKID)) {
	      this.errstr = 'SCRIPT_ERR_MUST_USE_FORKID';
	      return false
	    }
	  }

	  return true
	};

	/**
	 * Translated from bitcoind's CheckPubKeyEncoding
	 */
	Interpreter.prototype.checkPubkeyEncoding = function (buf) {
	  if ((this.flags & Interpreter.SCRIPT_VERIFY_STRICTENC) !== 0 && !PublicKey.isValid(buf)) {
	    this.errstr = 'SCRIPT_ERR_PUBKEYTYPE';
	    return false
	  }
	  return true
	};

	/**
	  *
	  * Check the buffer is minimally encoded (see https://github.com/bitcoincashorg/spec/blob/master/may-2018-reenabled-opcodes.md#op_bin2num)
	  *
	  *
	  */

	Interpreter._isMinimallyEncoded = function (buf, nMaxNumSize) {
	  nMaxNumSize = nMaxNumSize || Interpreter.MAXIMUM_ELEMENT_SIZE;
	  if (buf.length > nMaxNumSize) {
	    return false
	  }

	  if (buf.length > 0) {
	    // Check that the number is encoded with the minimum possible number
	    // of bytes.
	    //
	    // If the most-significant-byte - excluding the sign bit - is zero
	    // then we're not minimal. Note how this test also rejects the
	    // negative-zero encoding, 0x80.
	    if ((buf[buf.length - 1] & 0x7f) === 0) {
	      // One exception: if there's more than one byte and the most
	      // significant bit of the second-most-significant-byte is set it
	      // would conflict with the sign bit. An example of this case is
	      // +-255, which encode to 0xff00 and 0xff80 respectively.
	      // (big-endian).
	      if (buf.length <= 1 || (buf[buf.length - 2] & 0x80) === 0) {
	        return false
	      }
	    }
	  }
	  return true
	};

	/**
	  *
	  * minimally encode the buffer content
	  *
	  * @param {number} nMaxNumSize (max allowed size)
	  */
	Interpreter._minimallyEncode = function (buf) {
	  if (buf.length === 0) {
	    return buf
	  }

	  // If the last byte is not 0x00 or 0x80, we are minimally encoded.
	  var last = buf[buf.length - 1];
	  if (last & 0x7f) {
	    return buf
	  }

	  // If the script is one byte long, then we have a zero, which encodes as an
	  // empty array.
	  if (buf.length === 1) {
	    return Buffer.from('')
	  }

	  // If the next byte has it sign bit set, then we are minimaly encoded.
	  if (buf[buf.length - 2] & 0x80) {
	    return buf
	  }

	  // We are not minimally encoded, we need to figure out how much to trim.
	  for (var i = buf.length - 1; i > 0; i--) {
	    // We found a non zero byte, time to encode.
	    if (buf[i - 1] !== 0) {
	      if (buf[i - 1] & 0x80) {
	        // We found a byte with it sign bit set so we need one more
	        // byte.
	        buf[i++] = last;
	      } else {
	        // the sign bit is clear, we can use it.
	        buf[i - 1] |= last;
	      }

	      return buf.slice(0, i)
	    }
	  }

	  // If we found the whole thing is zeros, then we have a zero.
	  return Buffer.from('')
	};

	/**
	 * Based on bitcoind's EvalScript function, with the inner loop moved to
	 * Interpreter.prototype.step()
	 * bitcoind commit: b5d1b1092998bc95313856d535c632ea5a8f9104
	 */
	Interpreter.prototype.evaluate = function (scriptType) {
	  // TODO: script size should be configurable. no magic numbers
	  if (this.script.toBuffer().length > Interpreter.MAX_SCRIPT_SIZE) {
	    this.errstr = 'SCRIPT_ERR_SCRIPT_SIZE';
	    return false
	  }

	  try {
	    while (this.pc < this.script.chunks.length) {
	      // fExec: if the opcode will be executed, i.e., not in a false branch
	      let thisStep = { pc: this.pc, fExec: (this.vfExec.indexOf(false) === -1), opcode: Opcode.fromNumber(this.script.chunks[this.pc].opcodenum) };

	      var fSuccess = this.step(scriptType);

	      this._callbackStep(thisStep);

	      if (!fSuccess) {
	        return false
	      }
	    }

	    // Size limits
	    if (this.stack.length + this.altstack.length > 1000) {
	      this.errstr = 'SCRIPT_ERR_STACK_SIZE';
	      return false
	    }
	  } catch (e) {
	    this.errstr = 'SCRIPT_ERR_UNKNOWN_ERROR: ' + e;
	    return false
	  }

	  if (this.vfExec.length > 0) {
	    this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';
	    return false
	  }

	  return true
	};

	Interpreter.prototype._callbackStep = function (thisStep) {
	  if (typeof this.stepListener === 'function') {
	    try {
	      this.stepListener(thisStep, cloneDeep(this.stack.rawstack, true), cloneDeep(this.altstack.rawstack, true), cloneDeep(this.stack.varStack, true));
	    } catch (err) {
	      console.log(`Error in Step callback:${err}`);
	    }
	  }
	};

	/**
	 * call to update stackvar
	 * @param {*} stack
	 */
	Interpreter.prototype._callbackStack = function (stack, pc, scriptType) {
	  if (typeof this.stackListener === 'function') {
	    try {
	      this.stackListener(stack, pc, scriptType);
	    } catch (err) {
	      var chunk = this.script.chunks[pc];
	      console.error(`Error: ${err} in _updateStack pc: ${pc}, opcode ${Opcode.fromNumber(chunk.opcodenum).toSafeString()}`);
	    }
	  }
	};

	/**
	 * Checks a locktime parameter with the transaction's locktime.
	 * There are two times of nLockTime: lock-by-blockheight and lock-by-blocktime,
	 * distinguished by whether nLockTime < LOCKTIME_THRESHOLD = 500000000
	 *
	 * See the corresponding code on bitcoin core:
	 * https://github.com/bitcoin/bitcoin/blob/ffd75adce01a78b3461b3ff05bcc2b530a9ce994/src/script/interpreter.cpp#L1129
	 *
	 * @param {BN} nLockTime the locktime read from the script
	 * @return {boolean} true if the transaction's locktime is less than or equal to
	 *                   the transaction's locktime
	 */
	Interpreter.prototype.checkLockTime = function (nLockTime) {
	  // We want to compare apples to apples, so fail the script
	  // unless the type of nLockTime being tested is the same as
	  // the nLockTime in the transaction.
	  if (!(
	    (this.tx.nLockTime < Interpreter.LOCKTIME_THRESHOLD && nLockTime.lt(Interpreter.LOCKTIME_THRESHOLD_BN)) ||
	    (this.tx.nLockTime >= Interpreter.LOCKTIME_THRESHOLD && nLockTime.gte(Interpreter.LOCKTIME_THRESHOLD_BN))
	  )) {
	    return false
	  }

	  // Now that we know we're comparing apples-to-apples, the
	  // comparison is a simple numeric one.
	  if (nLockTime.gt(new BN(this.tx.nLockTime))) {
	    return false
	  }

	  // Finally the nLockTime feature can be disabled and thus
	  // CHECKLOCKTIMEVERIFY bypassed if every txin has been
	  // finalized by setting nSequence to maxint. The
	  // transaction would be allowed into the blockchain, making
	  // the opcode ineffective.
	  //
	  // Testing if this vin is not final is sufficient to
	  // prevent this condition. Alternatively we could test all
	  // inputs, but testing just this input minimizes the data
	  // required to prove correct CHECKLOCKTIMEVERIFY execution.
	  if (this.tx.inputs[this.nin].isFinal()) {
	    return false
	  }

	  return true
	};

	/**
	 * Checks a sequence parameter with the transaction's sequence.
	 * @param {BN} nSequence the sequence read from the script
	 * @return {boolean} true if the transaction's sequence is less than or equal to
	 *                   the transaction's sequence
	 */
	Interpreter.prototype.checkSequence = function (nSequence) {
	  // Relative lock times are supported by comparing the passed in operand to
	  // the sequence number of the input.
	  var txToSequence = this.tx.inputs[this.nin].sequenceNumber;

	  // Fail if the transaction's version number is not set high enough to
	  // trigger BIP 68 rules.
	  if (this.tx.version < 2) {
	    return false
	  }

	  // Sequence numbers with their most significant bit set are not consensus
	  // constrained. Testing that the transaction's sequence number do not have
	  // this bit set prevents using this property to get around a
	  // CHECKSEQUENCEVERIFY check.
	  if (txToSequence & Interpreter.SEQUENCE_LOCKTIME_DISABLE_FLAG) {
	    return false
	  }

	  // Mask off any bits that do not have consensus-enforced meaning before
	  // doing the integer comparisons
	  var nLockTimeMask =
	    Interpreter.SEQUENCE_LOCKTIME_TYPE_FLAG | Interpreter.SEQUENCE_LOCKTIME_MASK;
	  var txToSequenceMasked = new BN(txToSequence & nLockTimeMask);
	  var nSequenceMasked = nSequence.and(nLockTimeMask);

	  // There are two kinds of nSequence: lock-by-blockheight and
	  // lock-by-blocktime, distinguished by whether nSequenceMasked <
	  // CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG.
	  //
	  // We want to compare apples to apples, so fail the script unless the type
	  // of nSequenceMasked being tested is the same as the nSequenceMasked in the
	  // transaction.
	  var SEQUENCE_LOCKTIME_TYPE_FLAG_BN = new BN(Interpreter.SEQUENCE_LOCKTIME_TYPE_FLAG);

	  if (!((txToSequenceMasked.lt(SEQUENCE_LOCKTIME_TYPE_FLAG_BN) &&
	    nSequenceMasked.lt(SEQUENCE_LOCKTIME_TYPE_FLAG_BN)) ||
	    (txToSequenceMasked.gte(SEQUENCE_LOCKTIME_TYPE_FLAG_BN) &&
	      nSequenceMasked.gte(SEQUENCE_LOCKTIME_TYPE_FLAG_BN)))) {
	    return false
	  }

	  // Now that we know we're comparing apples-to-apples, the comparison is a
	  // simple numeric one.
	  if (nSequenceMasked.gt(txToSequenceMasked)) {
	    return false
	  }
	  return true
	};

	function padBufferToSize (buf, len) {
	  let b = buf;
	  while (b.length < len) {
	    b = Buffer.concat([Buffer.from([0x00]), b]);
	  }
	  return b
	}

	/**
	 * Based on the inner loop of bitcoind's EvalScript function
	 * bitcoind commit: b5d1b1092998bc95313856d535c632ea5a8f9104
	 */
	Interpreter.prototype.step = function (scriptType) {
	  var self = this;

	  function stacktop (i) {
	    return self.stack.stacktop(i)
	  }

	  function vartop (i) {
	    return self.stack.vartop(i)
	  }

	  function isOpcodeDisabled (opcode) {
	    switch (opcode) {
	      case Opcode.OP_2MUL:
	      case Opcode.OP_2DIV:

	        // Disabled opcodes.
	        return true

	      case Opcode.OP_INVERT:
	      case Opcode.OP_MUL:
	      case Opcode.OP_LSHIFT:
	      case Opcode.OP_RSHIFT:
	        // Opcodes that have been reenabled.
	        if ((self.flags & Interpreter.SCRIPT_ENABLE_MAGNETIC_OPCODES) === 0) {
	          return true
	        }
	        break
	      case Opcode.OP_DIV:
	      case Opcode.OP_MOD:
	      case Opcode.OP_SPLIT:
	      case Opcode.OP_CAT:
	      case Opcode.OP_AND:
	      case Opcode.OP_OR:
	      case Opcode.OP_XOR:
	      case Opcode.OP_BIN2NUM:
	      case Opcode.OP_NUM2BIN:
	        // Opcodes that have been reenabled.
	        if ((self.flags & Interpreter.SCRIPT_ENABLE_MONOLITH_OPCODES) === 0) {
	          return true
	        }
	        break
	    }

	    return false
	  }

	  var fRequireMinimal = (this.flags & Interpreter.SCRIPT_VERIFY_MINIMALDATA) !== 0;

	  // bool fExec = !count(vfExec.begin(), vfExec.end(), false);

	  var buf, buf1, buf2, spliced, n, x1, x2, bn, bn1, bn2, bufSig, bufPubkey, subscript;
	  var sig, pubkey;
	  var fValue, fSuccess;
	  var var1, var2, var3;

	  // Read instruction
	  var chunk = this.script.chunks[this.pc];
	  this.pc++;
	  var opcodenum = chunk.opcodenum;
	  if (_.isUndefined(opcodenum)) {
	    this.errstr = 'SCRIPT_ERR_UNDEFINED_OPCODE';
	    return false
	  }
	  if (chunk.buf && chunk.buf.length > Interpreter.MAX_SCRIPT_ELEMENT_SIZE) {
	    this.errstr = 'SCRIPT_ERR_PUSH_SIZE';
	    return false
	  }

	  // Do not execute instructions if Genesis OP_RETURN was found in executed branches.
	  var fExec = (this.vfExec.indexOf(false) === -1) && (!this.nonTopLevelReturnAfterGenesis || opcodenum === Opcode.OP_RETURN);

	  // Note how Opcode.OP_RESERVED does not count towards the opcode limit.
	  if (opcodenum > Opcode.OP_16 && ++(this.nOpCount) > Interpreter.MAX_OPCODE_COUNT) {
	    this.errstr = 'SCRIPT_ERR_OP_COUNT';
	    return false
	  }

	  if (isOpcodeDisabled(opcodenum)) {
	    this.errstr = 'SCRIPT_ERR_DISABLED_OPCODE';
	    return false
	  }

	  if (fExec && opcodenum >= 0 && opcodenum <= Opcode.OP_PUSHDATA4) {
	    if (fRequireMinimal && !this.script.checkMinimalPush(this.pc - 1)) {
	      this.errstr = 'SCRIPT_ERR_MINIMALDATA';
	      return false
	    }
	    if (!chunk.buf) {
	      this.stack.push(Interpreter.getFalse());
	    } else if (chunk.len !== chunk.buf.length) {
	      throw new Error(`Length of push value not equal to length of data (${chunk.len},${chunk.buf.length})`)
	    } else {
	      this.stack.push(chunk.buf);
	    }
	  } else if (fExec || (Opcode.OP_IF <= opcodenum && opcodenum <= Opcode.OP_ENDIF)) {
	    switch (opcodenum) {
	      // Push value
	      case Opcode.OP_1NEGATE:
	      case Opcode.OP_1:
	      case Opcode.OP_2:
	      case Opcode.OP_3:
	      case Opcode.OP_4:
	      case Opcode.OP_5:
	      case Opcode.OP_6:
	      case Opcode.OP_7:
	      case Opcode.OP_8:
	      case Opcode.OP_9:
	      case Opcode.OP_10:
	      case Opcode.OP_11:
	      case Opcode.OP_12:
	      case Opcode.OP_13:
	      case Opcode.OP_14:
	      case Opcode.OP_15:
	      case Opcode.OP_16:
	        // ( -- value)
	        // ScriptNum bn((int)opcode - (int)(Opcode.OP_1 - 1));
	        n = opcodenum - (Opcode.OP_1 - 1);
	        buf = new BN(n).toScriptNumBuffer();
	        this.stack.push(buf);
	        // The result of these opcodes should always be the minimal way to push the data
	        // they push, so no need for a CheckMinimalPush here.
	        break

	      //
	      // Control
	      //
	      case Opcode.OP_NOP:
	        break

	      case Opcode.OP_NOP2:
	      case Opcode.OP_CHECKLOCKTIMEVERIFY:

	        if (!(this.flags & Interpreter.SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY)) {
	          // not enabled; treat as a NOP2
	          if (this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {
	            this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS';
	            return false
	          }
	          break
	        }

	        if (this.stack.length < 1) {
	          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	          return false
	        }

	        // Note that elsewhere numeric opcodes are limited to
	        // operands in the range -2**31+1 to 2**31-1, however it is
	        // legal for opcodes to produce results exceeding that
	        // range. This limitation is implemented by CScriptNum's
	        // default 4-byte limit.
	        //
	        // If we kept to that limit we'd have a year 2038 problem,
	        // even though the nLockTime field in transactions
	        // themselves is uint32 which only becomes meaningless
	        // after the year 2106.
	        //
	        // Thus as a special case we tell CScriptNum to accept up
	        // to 5-byte bignums, which are good until 2**39-1, well
	        // beyond the 2**32-1 limit of the nLockTime field itself.
	        var nLockTime = BN.fromScriptNumBuffer(this.stack.stacktop(-1), fRequireMinimal, 5);

	        // In the rare event that the argument may be < 0 due to
	        // some arithmetic being done first, you can always use
	        // 0 MAX CHECKLOCKTIMEVERIFY.
	        if (nLockTime.lt(new BN(0))) {
	          this.errstr = 'SCRIPT_ERR_NEGATIVE_LOCKTIME';
	          return false
	        }

	        // Actually compare the specified lock time with the transaction.
	        if (!this.checkLockTime(nLockTime)) {
	          this.errstr = 'SCRIPT_ERR_UNSATISFIED_LOCKTIME';
	          return false
	        }
	        break

	      case Opcode.OP_NOP3:
	      case Opcode.OP_CHECKSEQUENCEVERIFY:

	        if (!(this.flags & Interpreter.SCRIPT_VERIFY_CHECKSEQUENCEVERIFY)) {
	          // not enabled; treat as a NOP3
	          if (this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {
	            this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS';
	            return false
	          }
	          break
	        }

	        if (this.stack.length < 1) {
	          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	          return false
	        }

	        // nSequence, like nLockTime, is a 32-bit unsigned
	        // integer field. See the comment in CHECKLOCKTIMEVERIFY
	        // regarding 5-byte numeric operands.

	        var nSequence = BN.fromScriptNumBuffer(stacktop(-1), fRequireMinimal, 5);

	        // In the rare event that the argument may be < 0 due to
	        // some arithmetic being done first, you can always use
	        // 0 MAX CHECKSEQUENCEVERIFY.
	        if (nSequence.lt(new BN(0))) {
	          this.errstr = 'SCRIPT_ERR_NEGATIVE_LOCKTIME';
	          return false
	        }

	        // To provide for future soft-fork extensibility, if the
	        // operand has the disabled lock-time flag set,
	        // CHECKSEQUENCEVERIFY behaves as a NOP.
	        if ((nSequence &
	          Interpreter.SEQUENCE_LOCKTIME_DISABLE_FLAG) !== 0) {
	          break
	        }

	        // Actually compare the specified lock time with the transaction.
	        if (!this.checkSequence(nSequence)) {
	          this.errstr = 'SCRIPT_ERR_UNSATISFIED_LOCKTIME';
	          return false
	        }
	        break

	      case Opcode.OP_NOP1:
	      case Opcode.OP_NOP4:
	      case Opcode.OP_NOP5:
	      case Opcode.OP_NOP6:
	      case Opcode.OP_NOP7:
	      case Opcode.OP_NOP8:
	      case Opcode.OP_NOP9:
	      case Opcode.OP_NOP10:
	        if (this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {
	          this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS';
	          return false
	        }
	        break

	      case Opcode.OP_IF:
	      case Opcode.OP_NOTIF:
	        // <expression> if [statements] [else [statements]] endif
	        // bool fValue = false;
	        fValue = false;
	        if (fExec) {
	          if (this.stack.length < 1) {
	            this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';
	            return false
	          }
	          buf = stacktop(-1);

	          if (this.flags & Interpreter.SCRIPT_VERIFY_MINIMALIF) {
	            if (buf.length > 1) {
	              this.errstr = 'SCRIPT_ERR_MINIMALIF';
	              return false
	            }
	            if (buf.length === 1 && buf[0] !== 1) {
	              this.errstr = 'SCRIPT_ERR_MINIMALIF';
	              return false
	            }
	          }
	          fValue = Interpreter.castToBool(buf);
	          if (opcodenum === Opcode.OP_NOTIF) {
	            fValue = !fValue;
	          }
	          this.stack.pop();
	        }
	        this.vfExec.push(fValue);
	        break

	      case Opcode.OP_ELSE:
	        if (this.vfExec.length === 0) {
	          this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';
	          return false
	        }
	        this.vfExec[this.vfExec.length - 1] = !this.vfExec[this.vfExec.length - 1];
	        break

	      case Opcode.OP_ENDIF:
	        if (this.vfExec.length === 0) {
	          this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';
	          return false
	        }
	        this.vfExec.pop();
	        break

	      case Opcode.OP_VERIFY:
	        // (true -- ) or
	        // (false -- false) and return
	        if (this.stack.length < 1) {
	          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	          return false
	        }
	        buf = stacktop(-1);
	        fValue = Interpreter.castToBool(buf);
	        if (fValue) {
	          this.stack.pop();
	        } else {
	          this.errstr = 'SCRIPT_ERR_VERIFY';
	          return false
	        }
	        break

	      case Opcode.OP_RETURN:

	        if ((this.flags & Interpreter.SCRIPT_VERIFY_P2SH) === 0) { // utxo_after_genesis
	          if (this.vfExec.length === 0) {
	            // Terminate the execution as successful. The remaining of the script does not affect the validity (even in
	            // presence of unbalanced IFs, invalid opcodes etc)
	            this.pc = this.script.chunks.length;
	            return true
	          }
	          // op_return encountered inside if statement after genesis --> check for invalid grammar
	          this.nonTopLevelReturnAfterGenesis = true;
	        } else {
	          return false
	        }

	        break

	      //
	      // Stack ops
	      //
	      case Opcode.OP_TOALTSTACK:
	        if (this.stack.length < 1) {
	          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	          return false
	        }
	        var1 = vartop(-1);
	        this.altstack.push(this.stack.pop(), var1);
	        break

	      case Opcode.OP_FROMALTSTACK:
	        if (this.altstack.length < 1) {
	          this.errstr = 'SCRIPT_ERR_INVALID_ALTSTACK_OPERATION';
	          return false
	        }
	        const varAlt = this.altstack.vartop(-1);
	        this.stack.push(this.altstack.pop(), varAlt);
	        break

	      case Opcode.OP_2DROP:
	        // (x1 x2 -- )
	        if (this.stack.length < 2) {
	          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	          return false
	        }
	        this.stack.pop();
	        this.stack.pop();
	        break

	      case Opcode.OP_2DUP:
	        // (x1 x2 -- x1 x2 x1 x2)
	        if (this.stack.length < 2) {
	          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	          return false
	        }
	        buf1 = stacktop(-2);
	        buf2 = stacktop(-1);
	        var1 = vartop(-2);
	        var2 = vartop(-1);
	        this.stack.push(Buffer.from(buf1), `$${var1}`);
	        this.stack.push(Buffer.from(buf2), `$${var2}`);
	        break

	      case Opcode.OP_3DUP:
	        // (x1 x2 x3 -- x1 x2 x3 x1 x2 x3)
	        if (this.stack.length < 3) {
	          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	          return false
	        }
	        buf1 = stacktop(-3);
	        buf2 = stacktop(-2);
	        var buf3 = stacktop(-1);
	        var1 = vartop(-3);
	        var2 = vartop(-2);
	        var3 = vartop(-1);
	        this.stack.push(Buffer.from(buf1), `$${var1}`);
	        this.stack.push(Buffer.from(buf2), `$${var2}`);
	        this.stack.push(Buffer.from(buf3), `$${var3}`);
	        break

	      case Opcode.OP_2OVER:
	        // (x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2)
	        if (this.stack.length < 4) {
	          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	          return false
	        }
	        buf1 = stacktop(-4);
	        buf2 = stacktop(-3);
	        var1 = vartop(-4);
	        var2 = vartop(-3);
	        this.stack.push(Buffer.from(buf1), `$${var1}`);
	        this.stack.push(Buffer.from(buf2), `$${var2}`);
	        break

	      case Opcode.OP_2ROT:
	        // (x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2)
	        if (this.stack.length < 6) {
	          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	          return false
	        }

	        var1 = vartop(-6);
	        var2 = vartop(-5);

	        spliced = this.stack.splice(this.stack.length - 6, 2);
	        this.stack.push(spliced[0], var1);
	        this.stack.push(spliced[1], var2);
	        break

	      case Opcode.OP_2SWAP:
	        // (x1 x2 x3 x4 -- x3 x4 x1 x2)
	        if (this.stack.length < 4) {
	          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	          return false
	        }
	        var1 = vartop(-4);
	        var2 = vartop(-3);
	        spliced = this.stack.splice(this.stack.length - 4, 2);
	        this.stack.push(spliced[0], var1);
	        this.stack.push(spliced[1], var2);
	        break

	      case Opcode.OP_IFDUP:
	        // (x - 0 | x x)
	        if (this.stack.length < 1) {
	          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	          return false
	        }
	        buf = stacktop(-1);
	        fValue = Interpreter.castToBool(buf);
	        if (fValue) {
	          var1 = vartop(-1);
	          this.stack.push(Buffer.from(buf), `$${var1}`);
	        }
	        break

	      case Opcode.OP_DEPTH:
	        // -- stacksize
	        buf = new BN(this.stack.length).toScriptNumBuffer();
	        this.stack.push(buf, '$depth');
	        break

	      case Opcode.OP_DROP:
	        // (x -- )
	        if (this.stack.length < 1) {
	          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	          return false
	        }
	        this.stack.pop();
	        break

	      case Opcode.OP_DUP:
	        // (x -- x x)
	        if (this.stack.length < 1) {
	          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	          return false
	        }
	        var1 = vartop(-1);
	        this.stack.push(Buffer.from(stacktop(-1)), `$${var1}`);
	        break

	      case Opcode.OP_NIP:
	        // (x1 x2 -- x2)
	        if (this.stack.length < 2) {
	          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	          return false
	        }
	        this.stack.splice(this.stack.length - 2, 1);
	        break

	      case Opcode.OP_OVER:
	        // (x1 x2 -- x1 x2 x1)
	        if (this.stack.length < 2) {
	          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	          return false
	        }
	        var2 = vartop(-2);
	        this.stack.push(Buffer.from(stacktop(-2)), `$${var2}`);
	        break

	      case Opcode.OP_PICK:
	      case Opcode.OP_ROLL:
	        // (xn ... x2 x1 x0 n - xn ... x2 x1 x0 xn)
	        // (xn ... x2 x1 x0 n - ... x2 x1 x0 xn)
	        if (this.stack.length < 2) {
	          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	          return false
	        }
	        buf = stacktop(-1);
	        bn = BN.fromScriptNumBuffer(buf, fRequireMinimal, 4);
	        n = bn.toNumber();
	        this.stack.pop();
	        if (n < 0 || n >= this.stack.length) {
	          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	          return false
	        }
	        buf = stacktop(-n - 1);
	        var1 = vartop(-n - 1);
	        if (opcodenum === Opcode.OP_ROLL) {
	          this.stack.splice(this.stack.length - n - 1, 1);
	          this.stack.push(Buffer.from(buf), var1);
	        } else {
	          this.stack.push(Buffer.from(buf), `$${var1}`);
	        }

	        break

	      case Opcode.OP_ROT:
	        // (x1 x2 x3 -- x2 x3 x1)
	        //  x2 x1 x3  after first swap
	        //  x2 x3 x1  after second swap
	        if (this.stack.length < 3) {
	          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	          return false
	        }
	        x1 = stacktop(-3);
	        x2 = stacktop(-2);
	        var x3 = stacktop(-1);
	        var1 = vartop(-3);
	        var2 = vartop(-2);
	        var3 = vartop(-1);
	        this.stack.write(-3, x2);
	        this.stack.write(-2, x3);
	        this.stack.write(-1, x1);
	        this.stack.updateTopVars([var1, var3, var2]);
	        break

	      case Opcode.OP_SWAP:
	        // (x1 x2 -- x2 x1)
	        if (this.stack.length < 2) {
	          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	          return false
	        }
	        x1 = stacktop(-2);
	        x2 = stacktop(-1);
	        var1 = vartop(-2);
	        var2 = vartop(-1);
	        this.stack.write(-2, x2);
	        this.stack.write(-1, x1);
	        this.stack.updateTopVars([var1, var2]);
	        break

	      case Opcode.OP_TUCK:
	        // (x1 x2 -- x2 x1 x2)
	        if (this.stack.length < 2) {
	          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	          return false
	        }

	        var1 = vartop(-2);
	        var2 = vartop(-1);

	        this.stack.splice(this.stack.length - 2, 0, Buffer.from(stacktop(-1)));
	        this.stack.updateTopVars([var2, var1, `$${var2}`]);
	        break

	      case Opcode.OP_SIZE:
	        // (in -- in size)
	        if (this.stack.length < 1) {
	          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	          return false
	        }
	        bn = new BN(stacktop(-1).length);
	        this.stack.push(bn.toScriptNumBuffer(), `$size`);
	        break

	      //
	      // Bitwise logic
	      //
	      case Opcode.OP_AND:
	      case Opcode.OP_OR:
	      case Opcode.OP_XOR:
	        // (x1 x2 - out)
	        if (this.stack.length < 2) {
	          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	          return false
	        }
	        buf1 = stacktop(-2);
	        buf2 = stacktop(-1);

	        // Inputs must be the same size
	        if (buf1.length !== buf2.length) {
	          this.errstr = 'SCRIPT_ERR_INVALID_OPERAND_SIZE';
	          return false
	        }

	        // To avoid allocating, we modify vch1 in place.
	        switch (opcodenum) {
	          case Opcode.OP_AND:
	            for (let i = 0; i < buf1.length; i++) {
	              buf1[i] &= buf2[i];
	            }
	            break
	          case Opcode.OP_OR:
	            for (let i = 0; i < buf1.length; i++) {
	              buf1[i] |= buf2[i];
	            }
	            break
	          case Opcode.OP_XOR:
	            for (let i = 0; i < buf1.length; i++) {
	              buf1[i] ^= buf2[i];
	            }
	            break
	        }

	        // And pop vch2.
	        this.stack.pop();
	        break

	      case Opcode.OP_INVERT:
	        // (x -- out)
	        if (this.stack.length < 1) {
	          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	        }
	        buf = stacktop(-1);
	        for (let i = 0; i < buf.length; i++) {
	          buf[i] = ~buf[i];
	        }
	        break

	      case Opcode.OP_LSHIFT:
	      case Opcode.OP_RSHIFT:
	        // (x n -- out)
	        if (this.stack.length < 2) {
	          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	          return false
	        }
	        buf1 = stacktop(-2);
	        if (buf1.length === 0) {
	          this.stack.pop();
	        } else {
	          bn1 = new BN(buf1);
	          bn2 = BN.fromScriptNumBuffer(stacktop(-1), fRequireMinimal, 4);
	          n = bn2.toNumber();
	          if (n < 0) {
	            this.errstr = 'SCRIPT_ERR_INVALID_NUMBER_RANGE';
	            return false
	          }
	          this.stack.pop();
	          this.stack.pop();
	          let shifted;
	          if (opcodenum === Opcode.OP_LSHIFT) {
	            shifted = bn1.ushln(n);
	          }
	          if (opcodenum === Opcode.OP_RSHIFT) {
	            shifted = bn1.ushrn(n);
	          }
	          // bitcoin client implementation of l/rshift is unconventional, therefore this implementation is a bit unconventional
	          // bn library has shift functions however it expands the carried bits into a new byte
	          // in contrast to the bitcoin client implementation which drops off the carried bits
	          // in other words, if operand was 1 byte then we put 1 byte back on the stack instead of expanding to more shifted bytes
	          let bufShifted = padBufferToSize(Buffer.from(shifted.toArray().slice(buf1.length * -1)), buf1.length);
	          this.stack.push(bufShifted);
	        }
	        break

	      case Opcode.OP_EQUAL:
	      case Opcode.OP_EQUALVERIFY:
	        // case Opcode.OP_NOTEQUAL: // use Opcode.OP_NUMNOTEQUAL
	        // (x1 x2 - bool)
	        if (this.stack.length < 2) {
	          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	          return false
	        }
	        buf1 = stacktop(-2);
	        buf2 = stacktop(-1);
	        var fEqual = buf1.toString('hex') === buf2.toString('hex');
	        this.stack.pop();
	        this.stack.pop();
	        this.stack.push(fEqual ? Interpreter.getTrue() : Interpreter.getFalse());
	        if (opcodenum === Opcode.OP_EQUALVERIFY) {
	          if (fEqual) {
	            this.stack.pop();
	          } else {
	            this.errstr = 'SCRIPT_ERR_EQUALVERIFY';
	            return false
	          }
	        }
	        break

	      //
	      // Numeric
	      //
	      case Opcode.OP_1ADD:
	      case Opcode.OP_1SUB:
	      case Opcode.OP_NEGATE:
	      case Opcode.OP_ABS:
	      case Opcode.OP_NOT:
	      case Opcode.OP_0NOTEQUAL:
	        // (in -- out)
	        if (this.stack.length < 1) {
	          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	          return false
	        }
	        buf = stacktop(-1);
	        bn = BN.fromScriptNumBuffer(buf, fRequireMinimal);
	        switch (opcodenum) {
	          case Opcode.OP_1ADD:
	            bn = bn.add(BN.One);
	            break
	          case Opcode.OP_1SUB:
	            bn = bn.sub(BN.One);
	            break
	          case Opcode.OP_NEGATE:
	            bn = bn.neg();
	            break
	          case Opcode.OP_ABS:
	            if (bn.cmp(BN.Zero) < 0) {
	              bn = bn.neg();
	            }
	            break
	          case Opcode.OP_NOT:
	            bn = new BN((bn.cmp(BN.Zero) === 0) + 0);
	            break
	          case Opcode.OP_0NOTEQUAL:
	            bn = new BN((bn.cmp(BN.Zero) !== 0) + 0);
	            break
	          // default:      assert(!'invalid opcode'); break; // TODO: does this ever occur?
	        }
	        this.stack.pop();
	        this.stack.push(bn.toScriptNumBuffer());
	        break

	      case Opcode.OP_ADD:
	      case Opcode.OP_SUB:
	      case Opcode.OP_MUL:
	      case Opcode.OP_MOD:
	      case Opcode.OP_DIV:
	      case Opcode.OP_BOOLAND:
	      case Opcode.OP_BOOLOR:
	      case Opcode.OP_NUMEQUAL:
	      case Opcode.OP_NUMEQUALVERIFY:
	      case Opcode.OP_NUMNOTEQUAL:
	      case Opcode.OP_LESSTHAN:
	      case Opcode.OP_GREATERTHAN:
	      case Opcode.OP_LESSTHANOREQUAL:
	      case Opcode.OP_GREATERTHANOREQUAL:
	      case Opcode.OP_MIN:
	      case Opcode.OP_MAX:
	        // (x1 x2 -- out)
	        if (this.stack.length < 2) {
	          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	          return false
	        }
	        bn1 = BN.fromScriptNumBuffer(stacktop(-2), fRequireMinimal);
	        bn2 = BN.fromScriptNumBuffer(stacktop(-1), fRequireMinimal);
	        bn = new BN(0);

	        switch (opcodenum) {
	          case Opcode.OP_ADD:
	            bn = bn1.add(bn2);
	            break

	          case Opcode.OP_SUB:
	            bn = bn1.sub(bn2);
	            break

	          case Opcode.OP_MUL:
	            bn = bn1.mul(bn2);
	            break

	          case Opcode.OP_DIV:
	            // denominator must not be 0
	            if (bn2 === 0) {
	              this.errstr = 'SCRIPT_ERR_DIV_BY_ZERO';
	              return false
	            }
	            bn = bn1.div(bn2);
	            break

	          case Opcode.OP_MOD:
	            // divisor must not be 0
	            if (bn2 === 0) {
	              this.errstr = 'SCRIPT_ERR_DIV_BY_ZERO';
	              return false
	            }
	            bn = bn1.mod(bn2);
	            break

	          case Opcode.OP_BOOLAND:
	            bn = new BN(((bn1.cmp(BN.Zero) !== 0) && (bn2.cmp(BN.Zero) !== 0)) + 0);
	            break
	          // case Opcode.OP_BOOLOR:        bn = (bn1 !== bnZero || bn2 !== bnZero); break;
	          case Opcode.OP_BOOLOR:
	            bn = new BN(((bn1.cmp(BN.Zero) !== 0) || (bn2.cmp(BN.Zero) !== 0)) + 0);
	            break
	          // case Opcode.OP_NUMEQUAL:      bn = (bn1 === bn2); break;
	          case Opcode.OP_NUMEQUAL:
	            bn = new BN((bn1.cmp(bn2) === 0) + 0);
	            break
	          // case Opcode.OP_NUMEQUALVERIFY:    bn = (bn1 === bn2); break;
	          case Opcode.OP_NUMEQUALVERIFY:
	            bn = new BN((bn1.cmp(bn2) === 0) + 0);
	            break
	          // case Opcode.OP_NUMNOTEQUAL:     bn = (bn1 !== bn2); break;
	          case Opcode.OP_NUMNOTEQUAL:
	            bn = new BN((bn1.cmp(bn2) !== 0) + 0);
	            break
	          // case Opcode.OP_LESSTHAN:      bn = (bn1 < bn2); break;
	          case Opcode.OP_LESSTHAN:
	            bn = new BN((bn1.cmp(bn2) < 0) + 0);
	            break
	          // case Opcode.OP_GREATERTHAN:     bn = (bn1 > bn2); break;
	          case Opcode.OP_GREATERTHAN:
	            bn = new BN((bn1.cmp(bn2) > 0) + 0);
	            break
	          // case Opcode.OP_LESSTHANOREQUAL:   bn = (bn1 <= bn2); break;
	          case Opcode.OP_LESSTHANOREQUAL:
	            bn = new BN((bn1.cmp(bn2) <= 0) + 0);
	            break
	          // case Opcode.OP_GREATERTHANOREQUAL:  bn = (bn1 >= bn2); break;
	          case Opcode.OP_GREATERTHANOREQUAL:
	            bn = new BN((bn1.cmp(bn2) >= 0) + 0);
	            break
	          case Opcode.OP_MIN:
	            bn = (bn1.cmp(bn2) < 0 ? bn1 : bn2);
	            break
	          case Opcode.OP_MAX:
	            bn = (bn1.cmp(bn2) > 0 ? bn1 : bn2);
	            break
	          // default:           assert(!'invalid opcode'); break; //TODO: does this ever occur?
	        }
	        this.stack.pop();
	        this.stack.pop();
	        this.stack.push(bn.toScriptNumBuffer());

	        if (opcodenum === Opcode.OP_NUMEQUALVERIFY) {
	          // if (CastToBool(stacktop(-1)))
	          if (Interpreter.castToBool(stacktop(-1))) {
	            this.stack.pop();
	          } else {
	            this.errstr = 'SCRIPT_ERR_NUMEQUALVERIFY';
	            return false
	          }
	        }
	        break

	      case Opcode.OP_WITHIN:
	        // (x min max -- out)
	        if (this.stack.length < 3) {
	          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	          return false
	        }
	        bn1 = BN.fromScriptNumBuffer(stacktop(-3), fRequireMinimal);
	        bn2 = BN.fromScriptNumBuffer(stacktop(-2), fRequireMinimal);
	        var bn3 = BN.fromScriptNumBuffer(stacktop(-1), fRequireMinimal);
	        // bool fValue = (bn2 <= bn1 && bn1 < bn3);
	        fValue = (bn2.cmp(bn1) <= 0) && (bn1.cmp(bn3) < 0);
	        this.stack.pop();
	        this.stack.pop();
	        this.stack.pop();
	        this.stack.push(fValue ? Interpreter.getTrue() : Interpreter.getFalse());
	        break

	      //
	      // Crypto
	      //
	      case Opcode.OP_RIPEMD160:
	      case Opcode.OP_SHA1:
	      case Opcode.OP_SHA256:
	      case Opcode.OP_HASH160:
	      case Opcode.OP_HASH256:
	        // (in -- hash)
	        if (this.stack.length < 1) {
	          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	          return false
	        }
	        buf = stacktop(-1);
	        // valtype vchHash((opcode === Opcode.OP_RIPEMD160 ||
	        //                 opcode === Opcode.OP_SHA1 || opcode === Opcode.OP_HASH160) ? 20 : 32);
	        var bufHash;
	        if (opcodenum === Opcode.OP_RIPEMD160) {
	          bufHash = Hash.ripemd160(buf);
	        } else if (opcodenum === Opcode.OP_SHA1) {
	          bufHash = Hash.sha1(buf);
	        } else if (opcodenum === Opcode.OP_SHA256) {
	          bufHash = Hash.sha256(buf);
	        } else if (opcodenum === Opcode.OP_HASH160) {
	          bufHash = Hash.sha256ripemd160(buf);
	        } else if (opcodenum === Opcode.OP_HASH256) {
	          bufHash = Hash.sha256sha256(buf);
	        }
	        this.stack.pop();
	        this.stack.push(bufHash);
	        break

	      case Opcode.OP_CODESEPARATOR:
	        // Hash starts after the code separator
	        this.pbegincodehash = this.pc;
	        break

	      case Opcode.OP_CHECKSIG:
	      case Opcode.OP_CHECKSIGVERIFY:
	        // (sig pubkey -- bool)
	        if (this.stack.length < 2) {
	          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	          return false
	        }

	        bufSig = stacktop(-2);
	        bufPubkey = stacktop(-1);

	        if (!this.checkSignatureEncoding(bufSig) || !this.checkPubkeyEncoding(bufPubkey)) {
	          return false
	        }

	        // Subset of script starting at the most recent codeseparator
	        // CScript scriptCode(pbegincodehash, pend);
	        subscript = this.subscript();

	        // Drop the signature, since there's no way for a signature to sign itself
	        var tmpScript = new Script().add(bufSig);
	        subscript.findAndDelete(tmpScript);

	        try {
	          sig = Signature.fromTxFormat(bufSig);
	          pubkey = PublicKey.fromBuffer(bufPubkey, false);

	          fSuccess = this.tx.verifySignature(sig, pubkey, this.nin, subscript, this.satoshisBN, this.flags);
	        } catch (e) {
	          // invalid sig or pubkey
	          fSuccess = false;
	        }

	        if (!fSuccess && (this.flags & Interpreter.SCRIPT_VERIFY_NULLFAIL) &&
	          bufSig.length) {
	          this.errstr = 'SCRIPT_ERR_NULLFAIL';
	          return false
	        }

	        this.stack.pop();
	        this.stack.pop();

	        // stack.push_back(fSuccess ? vchTrue : vchFalse);
	        this.stack.push(fSuccess ? Interpreter.getTrue() : Interpreter.getFalse());
	        if (opcodenum === Opcode.OP_CHECKSIGVERIFY) {
	          if (fSuccess) {
	            this.stack.pop();
	          } else {
	            this.errstr = 'SCRIPT_ERR_CHECKSIGVERIFY';
	            return false
	          }
	        }
	        break

	      case Opcode.OP_CHECKMULTISIG:
	      case Opcode.OP_CHECKMULTISIGVERIFY:
	        // ([sig ...] num_of_signatures [pubkey ...] num_of_pubkeys -- bool)

	        var i = 1;
	        if (this.stack.length < i) {
	          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	          return false
	        }

	        var nKeysCount = BN.fromScriptNumBuffer(stacktop(-i), fRequireMinimal).toNumber();
	        // TODO: Keys and opcount are parameterized in client. No magic numbers!
	        if (nKeysCount < 0 || nKeysCount > 20) {
	          this.errstr = 'SCRIPT_ERR_PUBKEY_COUNT';
	          return false
	        }
	        this.nOpCount += nKeysCount;
	        if (this.nOpCount > Interpreter.MAX_OPCODE_COUNT) {
	          this.errstr = 'SCRIPT_ERR_OP_COUNT';
	          return false
	        }
	        // int ikey = ++i;
	        var ikey = ++i;
	        i += nKeysCount;

	        // ikey2 is the position of last non-signature item in
	        // the stack. Top stack item = 1. With
	        // SCRIPT_VERIFY_NULLFAIL, this is used for cleanup if
	        // operation fails.
	        var ikey2 = nKeysCount + 2;

	        if (this.stack.length < i) {
	          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	          return false
	        }

	        var nSigsCount = BN.fromScriptNumBuffer(stacktop(-i), fRequireMinimal).toNumber();
	        if (nSigsCount < 0 || nSigsCount > nKeysCount) {
	          this.errstr = 'SCRIPT_ERR_SIG_COUNT';
	          return false
	        }
	        // int isig = ++i;
	        var isig = ++i;
	        i += nSigsCount;
	        if (this.stack.length < i) {
	          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	          return false
	        }

	        // Subset of script starting at the most recent codeseparator
	        subscript = this.subscript();

	        // Drop the signatures, since there's no way for a signature to sign itself
	        for (var k = 0; k < nSigsCount; k++) {
	          bufSig = stacktop(-isig - k);
	          subscript.findAndDelete(new Script().add(bufSig));
	        }

	        fSuccess = true;
	        while (fSuccess && nSigsCount > 0) {
	          // valtype& vchSig  = stacktop(-isig);
	          bufSig = stacktop(-isig);
	          // valtype& vchPubKey = stacktop(-ikey);
	          bufPubkey = stacktop(-ikey);

	          if (!this.checkSignatureEncoding(bufSig) || !this.checkPubkeyEncoding(bufPubkey)) {
	            return false
	          }

	          var fOk;
	          try {
	            sig = Signature.fromTxFormat(bufSig);
	            pubkey = PublicKey.fromBuffer(bufPubkey, false);
	            fOk = this.tx.verifySignature(sig, pubkey, this.nin, subscript, this.satoshisBN, this.flags);
	          } catch (e) {
	            // invalid sig or pubkey
	            fOk = false;
	          }

	          if (fOk) {
	            isig++;
	            nSigsCount--;
	          }
	          ikey++;
	          nKeysCount--;

	          // If there are more signatures left than keys left,
	          // then too many signatures have failed
	          if (nSigsCount > nKeysCount) {
	            fSuccess = false;
	          }
	        }

	        // Clean up stack of actual arguments
	        while (i-- > 1) {
	          if (!fSuccess && (this.flags & Interpreter.SCRIPT_VERIFY_NULLFAIL) &&
	            !ikey2 && stacktop(-1).length) {
	            this.errstr = 'SCRIPT_ERR_NULLFAIL';
	            return false
	          }

	          if (ikey2 > 0) {
	            ikey2--;
	          }

	          this.stack.pop();
	        }

	        // A bug causes CHECKMULTISIG to consume one extra argument
	        // whose contents were not checked in any way.
	        //
	        // Unfortunately this is a potential source of mutability,
	        // so optionally verify it is exactly equal to zero prior
	        // to removing it from the stack.
	        if (this.stack.length < 1) {
	          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	          return false
	        }
	        if ((this.flags & Interpreter.SCRIPT_VERIFY_NULLDUMMY) && stacktop(-1).length) {
	          this.errstr = 'SCRIPT_ERR_SIG_NULLDUMMY';
	          return false
	        }
	        this.stack.pop();

	        this.stack.push(fSuccess ? Interpreter.getTrue() : Interpreter.getFalse());

	        if (opcodenum === Opcode.OP_CHECKMULTISIGVERIFY) {
	          if (fSuccess) {
	            this.stack.pop();
	          } else {
	            this.errstr = 'SCRIPT_ERR_CHECKMULTISIGVERIFY';
	            return false
	          }
	        }
	        break

	      //
	      // Byte string operations
	      //
	      case Opcode.OP_CAT:
	        if (this.stack.length < 2) {
	          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	          return false
	        }

	        buf1 = stacktop(-2);
	        buf2 = stacktop(-1);
	        if (buf1.length + buf2.length > Interpreter.MAX_SCRIPT_ELEMENT_SIZE) {
	          this.errstr = 'SCRIPT_ERR_PUSH_SIZE';
	          return false
	        }
	        this.stack.write(-2, Buffer.concat([buf1, buf2]));
	        this.stack.pop();
	        break

	      case Opcode.OP_SPLIT:
	        if (this.stack.length < 2) {
	          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	          return false
	        }
	        buf1 = stacktop(-2);

	        // Make sure the split point is apropriate.
	        var position = BN.fromScriptNumBuffer(stacktop(-1), fRequireMinimal).toNumber();
	        if (position < 0 || position > buf1.length) {
	          this.errstr = 'SCRIPT_ERR_INVALID_SPLIT_RANGE';
	          return false
	        }

	        // Prepare the results in their own buffer as `data`
	        // will be invalidated.
	        // Copy buffer data, to slice it before
	        var n1 = Buffer.from(buf1);

	        // Replace existing stack values by the new values.
	        this.stack.write(-2, n1.slice(0, position));
	        this.stack.write(-1, n1.slice(position));
	        break

	      //
	      // Conversion operations
	      //
	      case Opcode.OP_NUM2BIN:
	        // (in -- out)
	        if (this.stack.length < 2) {
	          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	          return false
	        }

	        var size = BN.fromScriptNumBuffer(stacktop(-1), fRequireMinimal).toNumber();
	        if (size > Interpreter.MAX_SCRIPT_ELEMENT_SIZE) {
	          this.errstr = 'SCRIPT_ERR_PUSH_SIZE';
	          return false
	        }

	        this.stack.pop();
	        var rawnum = stacktop(-1);

	        // Try to see if we can fit that number in the number of
	        // byte requested.
	        rawnum = Interpreter._minimallyEncode(rawnum);

	        if (rawnum.length > size) {
	          // We definitively cannot.
	          this.errstr = 'SCRIPT_ERR_IMPOSSIBLE_ENCODING';
	          return false
	        }

	        // We already have an element of the right size, we
	        // don't need to do anything.
	        if (rawnum.length === size) {
	          this.stack.write(-1, rawnum);
	          break
	        }

	        var signbit = 0x00;
	        if (rawnum.length > 0) {
	          signbit = rawnum[rawnum.length - 1] & 0x80;
	          rawnum[rawnum.length - 1] &= 0x7f;
	        }

	        var num = Buffer.alloc(size);
	        rawnum.copy(num, 0);

	        var l = rawnum.length - 1;
	        while (l++ < size - 2) {
	          num[l] = 0x00;
	        }

	        num[l] = signbit;

	        this.stack.write(-1, num);
	        break

	      case Opcode.OP_BIN2NUM:
	        // (in -- out)
	        if (this.stack.length < 1) {
	          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	          return false
	        }

	        buf1 = stacktop(-1);
	        buf2 = Interpreter._minimallyEncode(buf1);

	        this.stack.write(-1, buf2);

	        // The resulting number must be a valid number.
	        if (!Interpreter._isMinimallyEncoded(buf2)) {
	          this.errstr = 'SCRIPT_ERR_INVALID_NUMBER_RANGE';
	          return false
	        }
	        break

	      default:
	        this.errstr = 'SCRIPT_ERR_BAD_OPCODE';
	        return false
	    }
	  }

	  // only when next opcode is evaluate opcode, we update stack
	  if (this.vfExec.indexOf(false) === -1) {
	    this._callbackStack(this.stack, this.pc, scriptType);
	  }

	  return true
	};
	return interpreter;
}

var hasRequiredScript;

function requireScript () {
	if (hasRequiredScript) return script$1.exports;
	hasRequiredScript = 1;
	script$1.exports = requireScript$1();

	script$1.exports.Interpreter = requireInterpreter();

	script$1.exports.Stack = stack;
	return script$1.exports;
}

var address;
var hasRequiredAddress;

function requireAddress () {
	if (hasRequiredAddress) return address;
	hasRequiredAddress = 1;

	var _ = __1;
	var $ = preconditions;
	var errors = errorsExports;
	var Base58Check = base58check;
	var Networks = networks_1;
	var Hash = hashExports;
	var JSUtil = js;
	var PublicKey = requirePublickey();

	/**
	 * Instantiate an address from an address String or Buffer, a public key or script hash Buffer,
	 * or an instance of {@link PublicKey} or {@link Script}.
	 *
	 * This is an immutable class, and if the first parameter provided to this constructor is an
	 * `Address` instance, the same argument will be returned.
	 *
	 * An address has two key properties: `network` and `type`. The type is either
	 * `Address.PayToPublicKeyHash` (value is the `'pubkeyhash'` string)
	 * or `Address.PayToScriptHash` (the string `'scripthash'`). The network is an instance of {@link Network}.
	 * You can quickly check whether an address is of a given kind by using the methods
	 * `isPayToPublicKeyHash` and `isPayToScriptHash`
	 *
	 * @example
	 * ```javascript
	 * // validate that an input field is valid
	 * var error = Address.getValidationError(input, 'testnet');
	 * if (!error) {
	 *   var address = Address(input, 'testnet');
	 * } else {
	 *   // invalid network or checksum (typo?)
	 *   var message = error.messsage;
	 * }
	 *
	 * // get an address from a public key
	 * var address = Address(publicKey, 'testnet').toString();
	 * ```
	 *
	 * @param {*} data - The encoded data in various formats
	 * @param {Network|String|number=} network - The network: 'livenet' or 'testnet'
	 * @param {string=} type - The type of address: 'script' or 'pubkey'
	 * @returns {Address} A new valid and frozen instance of an Address
	 * @constructor
	 */
	function Address (data, network, type) {
	  if (!(this instanceof Address)) {
	    return new Address(data, network, type)
	  }

	  if (_.isArray(data) && _.isNumber(network)) {
	    return Address.createMultisig(data, network, type)
	  }

	  if (data instanceof Address) {
	    // Immutable instance
	    return data
	  }

	  $.checkArgument(data, 'First argument is required, please include address data.', 'guide/address.html');

	  if (network && !Networks.get(network)) {
	    throw new TypeError('Second argument must be "livenet", "testnet", or "regtest".')
	  }

	  if (type && (type !== Address.PayToPublicKeyHash && type !== Address.PayToScriptHash)) {
	    throw new TypeError('Third argument must be "pubkeyhash" or "scripthash".')
	  }

	  var info = this._classifyArguments(data, network, type);

	  // set defaults if not set
	  info.network = info.network || Networks.get(network) || Networks.defaultNetwork;
	  info.type = info.type || type || Address.PayToPublicKeyHash;

	  JSUtil.defineImmutable(this, {
	    hashBuffer: info.hashBuffer,
	    network: info.network,
	    type: info.type
	  });

	  return this
	}

	/**
	 * Internal function used to split different kinds of arguments of the constructor
	 * @param {*} data - The encoded data in various formats
	 * @param {Network|String|number=} network - The network: 'livenet' or 'testnet'
	 * @param {string=} type - The type of address: 'script' or 'pubkey'
	 * @returns {Object} An "info" object with "type", "network", and "hashBuffer"
	 */
	Address.prototype._classifyArguments = function (data, network, type) {
	  // transform and validate input data
	  if ((data instanceof Buffer || data instanceof Uint8Array) && data.length === 20) {
	    return Address._transformHash(data)
	  } else if ((data instanceof Buffer || data instanceof Uint8Array) && data.length === 21) {
	    return Address._transformBuffer(data, network, type)
	  } else if (data instanceof PublicKey) {
	    return Address._transformPublicKey(data)
	  } else if (data instanceof Script) {
	    return Address._transformScript(data, network)
	  } else if (typeof (data) === 'string') {
	    return Address._transformString(data, network, type)
	  } else if (_.isObject(data)) {
	    return Address._transformObject(data)
	  } else {
	    throw new TypeError('First argument is an unrecognized data format.')
	  }
	};

	/** @static */
	Address.PayToPublicKeyHash = 'pubkeyhash';
	/** @static */
	Address.PayToScriptHash = 'scripthash';

	/**
	 * @param {Buffer} hash - An instance of a hash Buffer
	 * @returns {Object} An object with keys: hashBuffer
	 * @private
	 */
	Address._transformHash = function (hash) {
	  var info = {};
	  if (!(hash instanceof Buffer) && !(hash instanceof Uint8Array)) {
	    throw new TypeError('Address supplied is not a buffer.')
	  }
	  if (hash.length !== 20) {
	    throw new TypeError('Address hashbuffers must be exactly 20 bytes.')
	  }
	  info.hashBuffer = hash;
	  return info
	};

	/**
	 * Deserializes an address serialized through `Address#toObject()`
	 * @param {Object} data
	 * @param {string} data.hash - the hash that this address encodes
	 * @param {string} data.type - either 'pubkeyhash' or 'scripthash'
	 * @param {Network=} data.network - the name of the network associated
	 * @return {Address}
	 */
	Address._transformObject = function (data) {
	  $.checkArgument(data.hash || data.hashBuffer, 'Must provide a `hash` or `hashBuffer` property');
	  $.checkArgument(data.type, 'Must provide a `type` property');
	  return {
	    hashBuffer: data.hash ? Buffer.from(data.hash, 'hex') : data.hashBuffer,
	    network: Networks.get(data.network) || Networks.defaultNetwork,
	    type: data.type
	  }
	};

	/**
	 * Internal function to discover the network and type based on the first data byte
	 *
	 * @param {Buffer} buffer - An instance of a hex encoded address Buffer
	 * @returns {Object} An object with keys: network and type
	 * @private
	 */
	Address._classifyFromVersion = function (buffer) {
	  var version = {};

	  var pubkeyhashNetwork = Networks.get(buffer[0], 'pubkeyhash');
	  var scripthashNetwork = Networks.get(buffer[0], 'scripthash');

	  if (pubkeyhashNetwork) {
	    version.network = pubkeyhashNetwork;
	    version.type = Address.PayToPublicKeyHash;
	  } else if (scripthashNetwork) {
	    version.network = scripthashNetwork;
	    version.type = Address.PayToScriptHash;
	  }

	  return version
	};

	/**
	 * Internal function to transform a bitcoin address buffer
	 *
	 * @param {Buffer} buffer - An instance of a hex encoded address Buffer
	 * @param {string=} network - The network: 'livenet' or 'testnet'
	 * @param {string=} type - The type: 'pubkeyhash' or 'scripthash'
	 * @returns {Object} An object with keys: hashBuffer, network and type
	 * @private
	 */
	Address._transformBuffer = function (buffer, network, type) {
	  var info = {};
	  if (!(buffer instanceof Buffer) && !(buffer instanceof Uint8Array)) {
	    throw new TypeError('Address supplied is not a buffer.')
	  }
	  if (buffer.length !== 1 + 20) {
	    throw new TypeError('Address buffers must be exactly 21 bytes.')
	  }

	  var networkObj = Networks.get(network);
	  var bufferVersion = Address._classifyFromVersion(buffer);

	  if (network && !networkObj) {
	    throw new TypeError('Unknown network')
	  }

	  if (!bufferVersion.network || (networkObj && networkObj !== bufferVersion.network)) {
	    // console.log(bufferVersion)
	    throw new TypeError('Address has mismatched network type.')
	  }

	  if (!bufferVersion.type || (type && type !== bufferVersion.type)) {
	    throw new TypeError('Address has mismatched type.')
	  }

	  info.hashBuffer = buffer.slice(1);
	  info.network = bufferVersion.network;
	  info.type = bufferVersion.type;
	  return info
	};

	/**
	 * Internal function to transform a {@link PublicKey}
	 *
	 * @param {PublicKey} pubkey - An instance of PublicKey
	 * @returns {Object} An object with keys: hashBuffer, type
	 * @private
	 */
	Address._transformPublicKey = function (pubkey) {
	  var info = {};
	  if (!(pubkey instanceof PublicKey)) {
	    throw new TypeError('Address must be an instance of PublicKey.')
	  }
	  info.hashBuffer = Hash.sha256ripemd160(pubkey.toBuffer());
	  info.type = Address.PayToPublicKeyHash;
	  return info
	};

	/**
	 * Internal function to transform a {@link Script} into a `info` object.
	 *
	 * @param {Script} script - An instance of Script
	 * @returns {Object} An object with keys: hashBuffer, type
	 * @private
	 */
	Address._transformScript = function (script, network) {
	  $.checkArgument(script instanceof Script, 'script must be a Script instance');
	  var info = script.getAddressInfo(network);
	  if (!info) {
	    throw new errors.Script.CantDeriveAddress(script)
	  }
	  return info
	};

	/**
	 * Creates a P2SH address from a set of public keys and a threshold.
	 *
	 * The addresses will be sorted lexicographically, as that is the trend in bitcoin.
	 * To create an address from unsorted public keys, use the {@link Script#buildMultisigOut}
	 * interface.
	 *
	 * @param {Array} publicKeys - a set of public keys to create an address
	 * @param {number} threshold - the number of signatures needed to release the funds
	 * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'
	 * @return {Address}
	 */
	Address.createMultisig = function (publicKeys, threshold, network) {
	  network = network || publicKeys[0].network || Networks.defaultNetwork;
	  return Address.payingTo(Script.buildMultisigOut(publicKeys, threshold), network)
	};

	/**
	 * Internal function to transform a bitcoin cash address string
	 *
	 * @param {string} data
	 * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'
	 * @param {string=} type - The type: 'pubkeyhash' or 'scripthash'
	 * @returns {Object} An object with keys: hashBuffer, network and type
	 * @private
	 */
	Address._transformString = function (data, network, type) {
	  if (typeof (data) !== 'string') {
	    throw new TypeError('data parameter supplied is not a string.')
	  }
	  if (data.length < 27) {
	    throw new Error('Invalid Address string provided')
	  }
	  data = data.trim();
	  var networkObj = Networks.get(network);

	  if (network && !networkObj) {
	    throw new TypeError('Unknown network')
	  }

	  var addressBuffer = Base58Check.decode(data);
	  return Address._transformBuffer(addressBuffer, network, type)
	};

	/**
	 * Instantiate an address from a PublicKey instance
	 *
	 * @param {PublicKey} data
	 * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'
	 * @returns {Address} A new valid and frozen instance of an Address
	 */
	Address.fromPublicKey = function (data, network) {
	  var info = Address._transformPublicKey(data);
	  network = network || Networks.defaultNetwork;
	  return new Address(info.hashBuffer, network, info.type)
	};

	/**
	 * Instantiate an address from a PrivateKey instance
	 *
	 * @param {PrivateKey} privateKey
	 * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'
	 * @returns {Address} A new valid and frozen instance of an Address
	 */
	Address.fromPrivateKey = function (privateKey, network) {
	  let publicKey = PublicKey.fromPrivateKey(privateKey);
	  network = network || privateKey.network || Networks.defaultNetwork;
	  return Address.fromPublicKey(publicKey, network)
	};

	/**
	 * Instantiate an address from a ripemd160 public key hash
	 *
	 * @param {Buffer} hash - An instance of buffer of the hash
	 * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'
	 * @returns {Address} A new valid and frozen instance of an Address
	 */
	Address.fromPublicKeyHash = function (hash, network) {
	  var info = Address._transformHash(hash);
	  return new Address(info.hashBuffer, network, Address.PayToPublicKeyHash)
	};

	/**
	 * Instantiate an address from a ripemd160 script hash
	 *
	 * @param {Buffer} hash - An instance of buffer of the hash
	 * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'
	 * @returns {Address} A new valid and frozen instance of an Address
	 */
	Address.fromScriptHash = function (hash, network) {
	  $.checkArgument(hash, 'hash parameter is required');
	  var info = Address._transformHash(hash);
	  return new Address(info.hashBuffer, network, Address.PayToScriptHash)
	};

	/**
	 * Builds a p2sh address paying to script. This will hash the script and
	 * use that to create the address.
	 * If you want to extract an address associated with a script instead,
	 * see {{Address#fromScript}}
	 *
	 * @param {Script} script - An instance of Script
	 * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'
	 * @returns {Address} A new valid and frozen instance of an Address
	 */
	Address.payingTo = function (script, network) {
	  $.checkArgument(script, 'script is required');
	  $.checkArgument(script instanceof Script, 'script must be instance of Script');

	  return Address.fromScriptHash(Hash.sha256ripemd160(script.toBuffer()), network)
	};

	/**
	 * Extract address from a Script. The script must be of one
	 * of the following types: p2pkh input, p2pkh output, p2sh input
	 * or p2sh output.
	 * This will analyze the script and extract address information from it.
	 * If you want to transform any script to a p2sh Address paying
	 * to that script's hash instead, use {{Address#payingTo}}
	 *
	 * @param {Script} script - An instance of Script
	 * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'
	 * @returns {Address} A new valid and frozen instance of an Address
	 */
	Address.fromScript = function (script, network) {
	  $.checkArgument(script instanceof Script, 'script must be a Script instance');
	  var info = Address._transformScript(script, network);
	  return new Address(info.hashBuffer, network, info.type)
	};

	/**
	 * Instantiate an address from a buffer of the address
	 *
	 * @param {Buffer} buffer - An instance of buffer of the address
	 * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'
	 * @param {string=} type - The type of address: 'script' or 'pubkey'
	 * @returns {Address} A new valid and frozen instance of an Address
	 */
	Address.fromBuffer = function (buffer, network, type) {
	  var info = Address._transformBuffer(buffer, network, type);
	  return new Address(info.hashBuffer, info.network, info.type)
	};

	Address.fromHex = function (hex, network, type) {
	  return Address.fromBuffer(Buffer.from(hex, 'hex'), network, type)
	};

	/**
	 * Instantiate an address from an address string
	 *
	 * @param {string} str - An string of the bitcoin address
	 * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'
	 * @param {string=} type - The type of address: 'script' or 'pubkey'
	 * @returns {Address} A new valid and frozen instance of an Address
	 */
	Address.fromString = function (str, network, type) {
	  var info = Address._transformString(str, network, type);
	  return new Address(info.hashBuffer, info.network, info.type)
	};

	/**
	 * Instantiate an address from an Object
	 *
	 * @param {string} json - An JSON string or Object with keys: hash, network and type
	 * @returns {Address} A new valid instance of an Address
	 */
	Address.fromObject = function fromObject (obj) {
	  $.checkState(
	    JSUtil.isHexa(obj.hash),
	    'Unexpected hash property, "' + obj.hash + '", expected to be hex.'
	  );
	  var hashBuffer = Buffer.from(obj.hash, 'hex');
	  return new Address(hashBuffer, obj.network, obj.type)
	};

	/**
	 * Will return a validation error if exists
	 *
	 * @example
	 * ```javascript
	 * // a network mismatch error
	 * var error = Address.getValidationError('15vkcKf7gB23wLAnZLmbVuMiiVDc1Nm4a2', 'testnet');
	 * ```
	 *
	 * @param {string} data - The encoded data
	 * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'
	 * @param {string} type - The type of address: 'script' or 'pubkey'
	 * @returns {null|Error} The corresponding error message
	 */
	Address.getValidationError = function (data, network, type) {
	  var error;
	  try {
	    new Address(data, network, type); // eslint-disable-line
	  } catch (e) {
	    error = e;
	  }
	  return error
	};

	/**
	 * Will return a boolean if an address is valid
	 *
	 * @example
	 * ```javascript
	 * assert(Address.isValid('15vkcKf7gB23wLAnZLmbVuMiiVDc1Nm4a2', 'livenet'));
	 * ```
	 *
	 * @param {string} data - The encoded data
	 * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'
	 * @param {string} type - The type of address: 'script' or 'pubkey'
	 * @returns {boolean} The corresponding error message
	 */
	Address.isValid = function (data, network, type) {
	  return !Address.getValidationError(data, network, type)
	};

	/**
	 * Returns true if an address is of pay to public key hash type
	 * @return boolean
	 */
	Address.prototype.isPayToPublicKeyHash = function () {
	  return this.type === Address.PayToPublicKeyHash
	};

	/**
	 * Returns true if an address is of pay to script hash type
	 * @return boolean
	 */
	Address.prototype.isPayToScriptHash = function () {
	  return this.type === Address.PayToScriptHash
	};

	/**
	 * Will return a buffer representation of the address
	 *
	 * @returns {Buffer} Bitcoin address buffer
	 */
	Address.prototype.toBuffer = function () {
	  var version = Buffer.from([this.network[this.type]]);
	  var buf = Buffer.concat([version, this.hashBuffer]);
	  return buf
	};

	Address.prototype.toHex = function () {
	  return this.toBuffer().toString('hex')
	};

	/**
	 * @returns {Object} A plain object with the address information
	 */
	Address.prototype.toObject = Address.prototype.toJSON = function toObject () {
	  return {
	    hash: this.hashBuffer.toString('hex'),
	    type: this.type,
	    network: this.network.toString()
	  }
	};

	/**
	 * Will return a string formatted for the console
	 *
	 * @returns {string} Bitcoin address
	 */
	Address.prototype.inspect = function () {
	  return '<Address: ' + this.toString() + ', type: ' + this.type + ', network: ' + this.network + '>'
	};

	/**
	 * Will return a the base58 string representation of the address
	 *
	 * @returns {string} Bitcoin address
	 */
	Address.prototype.toString = function () {
	  return Base58Check.encode(this.toBuffer())
	};

	address = Address;

	var Script = requireScript();
	return address;
}

function Random$1 () {
}

/* secure random bytes that sometimes throws an error due to lack of entropy */
Random$1.getRandomBuffer = function (size) {
  { return Random$1.getRandomBufferBrowser(size) }
};

Random$1.getRandomBufferNode = function (size) {
  var crypto = require$$0$5;
  return crypto.randomBytes(size)
};

Random$1.getRandomBufferBrowser = function (size) {
  if (!window.crypto && !window.msCrypto) {
    throw new Error('window.crypto not available')
  }
  var crypto;

  if (window.crypto && window.crypto.getRandomValues) {
    crypto = window.crypto;
  } else if (window.msCrypto && window.msCrypto.getRandomValues) { // internet explorer
    crypto = window.msCrypto;
  } else {
    throw new Error('window.crypto.getRandomValues not available')
  }

  var bbuf = new Uint8Array(size);
  crypto.getRandomValues(bbuf);
  var buf = Buffer.from(bbuf);

  return buf
};

var random = Random$1;

var privatekey;
var hasRequiredPrivatekey;

function requirePrivatekey () {
	if (hasRequiredPrivatekey) return privatekey;
	hasRequiredPrivatekey = 1;

	var _ = __1;
	var Address = requireAddress();
	var Base58Check = base58check;
	var BN = bn$1;
	var JSUtil = js;
	var Networks = networks_1;
	var Point = point;
	var PublicKey = requirePublickey();
	var Random = random;
	var $ = preconditions;

	/**
	 * Instantiate a PrivateKey from a BN, Buffer or WIF string.
	 *
	 * @param {string} data - The encoded data in various formats
	 * @param {Network|string=} network - a {@link Network} object, or a string with the network name
	 * @returns {PrivateKey} A new valid instance of an PrivateKey
	 * @constructor
	 */
	function PrivateKey (data, network) {
	  if (!(this instanceof PrivateKey)) {
	    return new PrivateKey(data, network)
	  }
	  if (data instanceof PrivateKey) {
	    return data
	  }

	  var info = this._classifyArguments(data, network);

	  // validation
	  if (!info.bn || info.bn.cmp(new BN(0)) === 0) {
	    throw new TypeError('Number can not be equal to zero, undefined, null or false')
	  }
	  if (!info.bn.lt(Point.getN())) {
	    throw new TypeError('Number must be less than N')
	  }
	  if (typeof (info.network) === 'undefined') {
	    throw new TypeError('Must specify the network ("livenet" or "testnet")')
	  }

	  JSUtil.defineImmutable(this, {
	    bn: info.bn,
	    compressed: info.compressed,
	    network: info.network
	  });

	  Object.defineProperty(this, 'publicKey', {
	    configurable: false,
	    enumerable: true,
	    get: this.toPublicKey.bind(this)
	  });

	  return this
	}
	/**
	 * Internal helper to instantiate PrivateKey internal `info` object from
	 * different kinds of arguments passed to the constructor.
	 *
	 * @param {*} data
	 * @param {Network|string=} network - a {@link Network} object, or a string with the network name
	 * @return {Object}
	 */
	PrivateKey.prototype._classifyArguments = function (data, network) {
	  var info = {
	    compressed: true,
	    network: network ? Networks.get(network) : Networks.defaultNetwork
	  };

	  // detect type of data
	  if (_.isUndefined(data) || _.isNull(data)) {
	    info.bn = PrivateKey._getRandomBN();
	  } else if (data instanceof BN) {
	    info.bn = data;
	  } else if (data instanceof Buffer || data instanceof Uint8Array) {
	    info = PrivateKey._transformBuffer(data, network);
	  } else if (data.bn && data.network) {
	    info = PrivateKey._transformObject(data);
	  } else if (!network && Networks.get(data)) {
	    info.bn = PrivateKey._getRandomBN();
	    info.network = Networks.get(data);
	  } else if (typeof (data) === 'string') {
	    if (JSUtil.isHexa(data)) {
	      info.bn = new BN(Buffer.from(data, 'hex'));
	    } else {
	      info = PrivateKey._transformWIF(data, network);
	    }
	  } else {
	    throw new TypeError('First argument is an unrecognized data type.')
	  }
	  return info
	};

	/**
	 * Internal function to get a random Big Number (BN)
	 *
	 * @returns {BN} A new randomly generated BN
	 * @private
	 */
	PrivateKey._getRandomBN = function () {
	  var condition;
	  var bn;
	  do {
	    var privbuf = Random.getRandomBuffer(32);
	    bn = BN.fromBuffer(privbuf);
	    condition = bn.lt(Point.getN());
	  } while (!condition)
	  return bn
	};

	/**
	 * Internal function to transform a WIF Buffer into a private key
	 *
	 * @param {Buffer} buf - An WIF string
	 * @param {Network|string=} network - a {@link Network} object, or a string with the network name
	 * @returns {Object} An object with keys: bn, network and compressed
	 * @private
	 */
	PrivateKey._transformBuffer = function (buf, network) {
	  var info = {};

	  if (buf.length === 32) {
	    return PrivateKey._transformBNBuffer(buf, network)
	  }

	  info.network = Networks.get(buf[0], 'privatekey');

	  if (!info.network) {
	    throw new Error('Invalid network')
	  }

	  if (network && info.network !== Networks.get(network)) {
	    throw new TypeError('Private key network mismatch')
	  }

	  if (buf.length === 1 + 32 + 1 && buf[1 + 32 + 1 - 1] === 1) {
	    info.compressed = true;
	  } else if (buf.length === 1 + 32) {
	    info.compressed = false;
	  } else {
	    throw new Error('Length of buffer must be 33 (uncompressed) or 34 (compressed)')
	  }

	  info.bn = BN.fromBuffer(buf.slice(1, 32 + 1));

	  return info
	};

	/**
	 * Internal function to transform a BN buffer into a private key
	 *
	 * @param {Buffer} buf
	 * @param {Network|string=} network - a {@link Network} object, or a string with the network name
	 * @returns {object} an Object with keys: bn, network, and compressed
	 * @private
	 */
	PrivateKey._transformBNBuffer = function (buf, network) {
	  var info = {};
	  info.network = Networks.get(network) || Networks.defaultNetwork;
	  info.bn = BN.fromBuffer(buf);
	  info.compressed = false;
	  return info
	};

	/**
	 * Internal function to transform a WIF string into a private key
	 *
	 * @param {string} buf - An WIF string
	 * @returns {Object} An object with keys: bn, network and compressed
	 * @private
	 */
	PrivateKey._transformWIF = function (str, network) {
	  return PrivateKey._transformBuffer(Base58Check.decode(str), network)
	};

	/**
	 * Instantiate a PrivateKey from a Buffer with the DER or WIF representation
	 *
	 * @param {Buffer} buf
	 * @param {Network} network
	 * @return {PrivateKey}
	 */
	PrivateKey.fromBuffer = function (buf, network) {
	  return new PrivateKey(buf, network)
	};

	PrivateKey.fromHex = function (hex, network) {
	  return PrivateKey.fromBuffer(Buffer.from(hex, 'hex'), network)
	};

	/**
	 * Internal function to transform a JSON string on plain object into a private key
	 * return this.
	 *
	 * @param {string} json - A JSON string or plain object
	 * @returns {Object} An object with keys: bn, network and compressed
	 * @private
	 */
	PrivateKey._transformObject = function (json) {
	  var bn = new BN(json.bn, 'hex');
	  var network = Networks.get(json.network);
	  return {
	    bn: bn,
	    network: network,
	    compressed: json.compressed
	  }
	};

	/**
	 * Instantiate a PrivateKey from a WIF string
	 *
	 * @param {string} str - The WIF encoded private key string
	 * @returns {PrivateKey} A new valid instance of PrivateKey
	 */
	PrivateKey.fromString = PrivateKey.fromWIF = function (str) {
	  $.checkArgument(_.isString(str), 'First argument is expected to be a string.');
	  return new PrivateKey(str)
	};

	/**
	 * Instantiate a PrivateKey from a plain JavaScript object
	 *
	 * @param {Object} obj - The output from privateKey.toObject()
	 */
	PrivateKey.fromObject = PrivateKey.fromJSON = function (obj) {
	  $.checkArgument(_.isObject(obj), 'First argument is expected to be an object.');
	  return new PrivateKey(obj)
	};

	/**
	 * Instantiate a PrivateKey from random bytes
	 *
	 * @param {string=} network - Either "livenet" or "testnet"
	 * @returns {PrivateKey} A new valid instance of PrivateKey
	 */
	PrivateKey.fromRandom = function (network) {
	  var bn = PrivateKey._getRandomBN();
	  return new PrivateKey(bn, network)
	};

	/**
	 * Check if there would be any errors when initializing a PrivateKey
	 *
	 * @param {string} data - The encoded data in various formats
	 * @param {string=} network - Either "livenet" or "testnet"
	 * @returns {null|Error} An error if exists
	 */

	PrivateKey.getValidationError = function (data, network) {
	  var error;
	  try {
	    new PrivateKey(data, network); // eslint-disable-line
	  } catch (e) {
	    error = e;
	  }
	  return error
	};

	/**
	 * Check if the parameters are valid
	 *
	 * @param {string} data - The encoded data in various formats
	 * @param {string=} network - Either "livenet" or "testnet"
	 * @returns {Boolean} If the private key is would be valid
	 */
	PrivateKey.isValid = function (data, network) {
	  if (!data) {
	    return false
	  }
	  return !PrivateKey.getValidationError(data, network)
	};

	/**
	 * Will output the PrivateKey in WIF
	 *
	 * @returns {string}
	 */
	PrivateKey.prototype.toString = function () {
	  return this.toWIF()
	};

	/**
	 * Will output the PrivateKey to a WIF string
	 *
	 * @returns {string} A WIP representation of the private key
	 */
	PrivateKey.prototype.toWIF = function () {
	  var network = this.network;
	  var compressed = this.compressed;

	  var buf;
	  if (compressed) {
	    buf = Buffer.concat([Buffer.from([network.privatekey]),
	      this.bn.toBuffer({ size: 32 }),
	      Buffer.from([0x01])]);
	  } else {
	    buf = Buffer.concat([Buffer.from([network.privatekey]),
	      this.bn.toBuffer({ size: 32 })]);
	  }

	  return Base58Check.encode(buf)
	};

	/**
	 * Will return the private key as a BN instance
	 *
	 * @returns {BN} A BN instance of the private key
	 */
	PrivateKey.prototype.toBigNumber = function () {
	  return this.bn
	};

	/**
	 * Will return the private key as a BN buffer
	 *
	 * @returns {Buffer} A buffer of the private key
	 */
	PrivateKey.prototype.toBuffer = function () {
	  return this.bn.toBuffer({ size: 32 })
	};

	PrivateKey.prototype.toHex = function () {
	  return this.toBuffer().toString('hex')
	};

	/**
	 * Will return the corresponding public key
	 *
	 * @returns {PublicKey} A public key generated from the private key
	 */
	PrivateKey.prototype.toPublicKey = function () {
	  if (!this._pubkey) {
	    this._pubkey = PublicKey.fromPrivateKey(this);
	  }
	  return this._pubkey
	};

	/**
	 * Will return an address for the private key
	 * @param {Network=} network - optional parameter specifying
	 * the desired network for the address
	 *
	 * @returns {Address} An address generated from the private key
	 */
	PrivateKey.prototype.toAddress = function (network) {
	  var pubkey = this.toPublicKey();
	  return Address.fromPublicKey(pubkey, network || this.network)
	};

	/**
	 * @returns {Object} A plain object representation
	 */
	PrivateKey.prototype.toObject = PrivateKey.prototype.toJSON = function toObject () {
	  return {
	    bn: this.bn.toString('hex'),
	    compressed: this.compressed,
	    network: this.network.toString()
	  }
	};

	/**
	 * Will return a string formatted for the console
	 *
	 * @returns {string} Private key
	 */
	PrivateKey.prototype.inspect = function () {
	  var uncompressed = !this.compressed ? ', uncompressed' : '';
	  return '<PrivateKey: ' + this.toHex() + ', network: ' + this.network + uncompressed + '>'
	};

	privatekey = PrivateKey;
	return privatekey;
}

var publickey;
var hasRequiredPublickey;

function requirePublickey () {
	if (hasRequiredPublickey) return publickey;
	hasRequiredPublickey = 1;

	var BN = bn$1;
	var Point = point;
	var Hash = hashExports;
	var JSUtil = js;
	var Network = networks_1;
	var _ = __1;
	var $ = preconditions;

	/**
	 * Instantiate a PublicKey from a {@link PrivateKey}, {@link Point}, `string`, or `Buffer`.
	 *
	 * There are two internal properties, `network` and `compressed`, that deal with importing
	 * a PublicKey from a PrivateKey in WIF format. More details described on {@link PrivateKey}
	 *
	 * @example
	 * ```javascript
	 * // instantiate from a private key
	 * var key = PublicKey(privateKey, true);
	 *
	 * // export to as a DER hex encoded string
	 * var exported = key.toString();
	 *
	 * // import the public key
	 * var imported = PublicKey.fromString(exported);
	 * ```
	 *
	 * @param {string} data - The encoded data in various formats
	 * @param {Object} extra - additional options
	 * @param {Network=} extra.network - Which network should the address for this public key be for
	 * @param {String=} extra.compressed - If the public key is compressed
	 * @returns {PublicKey} A new valid instance of an PublicKey
	 * @constructor
	 */
	function PublicKey (data, extra) {
	  if (!(this instanceof PublicKey)) {
	    return new PublicKey(data, extra)
	  }

	  $.checkArgument(data, 'First argument is required, please include public key data.');

	  if (data instanceof PublicKey) {
	    // Return copy, but as it's an immutable object, return same argument
	    return data
	  }
	  extra = extra || {};

	  var info = this._classifyArgs(data, extra);

	  // validation
	  info.point.validate();

	  JSUtil.defineImmutable(this, {
	    point: info.point,
	    compressed: info.compressed,
	    network: info.network || Network.defaultNetwork
	  });

	  return this
	}
	/**
	 * Internal function to differentiate between arguments passed to the constructor
	 * @param {*} data
	 * @param {Object} extra
	 */
	PublicKey.prototype._classifyArgs = function (data, extra) {
	  var info = {
	    compressed: _.isUndefined(extra.compressed) || extra.compressed
	  };

	  // detect type of data
	  if (data instanceof Point) {
	    info.point = data;
	  } else if (data.x && data.y) {
	    info = PublicKey._transformObject(data);
	  } else if (typeof (data) === 'string') {
	    info = PublicKey._transformDER(Buffer.from(data, 'hex'));
	  } else if (PublicKey._isBuffer(data)) {
	    info = PublicKey._transformDER(data);
	  } else if (PublicKey._isPrivateKey(data)) {
	    info = PublicKey._transformPrivateKey(data);
	  } else {
	    throw new TypeError('First argument is an unrecognized data format.')
	  }
	  if (!info.network) {
	    info.network = _.isUndefined(extra.network) ? undefined : Network.get(extra.network);
	  }
	  return info
	};

	/**
	 * Internal function to detect if an object is a {@link PrivateKey}
	 *
	 * @param {*} param - object to test
	 * @returns {boolean}
	 * @private
	 */
	PublicKey._isPrivateKey = function (param) {
	  var PrivateKey = requirePrivatekey();
	  return param instanceof PrivateKey
	};

	/**
	 * Internal function to detect if an object is a Buffer
	 *
	 * @param {*} param - object to test
	 * @returns {boolean}
	 * @private
	 */
	PublicKey._isBuffer = function (param) {
	  return (param instanceof Buffer) || (param instanceof Uint8Array)
	};

	/**
	 * Internal function to transform a private key into a public key point
	 *
	 * @param {PrivateKey} privkey - An instance of PrivateKey
	 * @returns {Object} An object with keys: point and compressed
	 * @private
	 */
	PublicKey._transformPrivateKey = function (privkey) {
	  $.checkArgument(PublicKey._isPrivateKey(privkey), 'Must be an instance of PrivateKey');
	  var info = {};
	  info.point = Point.getG().mul(privkey.bn);
	  info.compressed = privkey.compressed;
	  info.network = privkey.network;
	  return info
	};

	/**
	 * Internal function to transform DER into a public key point
	 *
	 * @param {Buffer} buf - An DER buffer
	 * @param {bool=} strict - if set to false, will loosen some conditions
	 * @returns {Object} An object with keys: point and compressed
	 * @private
	 */
	PublicKey._transformDER = function (buf, strict) {
	  $.checkArgument(PublicKey._isBuffer(buf), 'Must be a buffer of DER encoded public key');
	  var info = {};

	  strict = _.isUndefined(strict) ? true : strict;

	  var x;
	  var y;
	  var xbuf;
	  var ybuf;

	  if (buf[0] === 0x04 || (!strict && (buf[0] === 0x06 || buf[0] === 0x07))) {
	    xbuf = buf.slice(1, 33);
	    ybuf = buf.slice(33, 65);
	    if (xbuf.length !== 32 || ybuf.length !== 32 || buf.length !== 65) {
	      throw new TypeError('Length of x and y must be 32 bytes')
	    }
	    x = new BN(xbuf);
	    y = new BN(ybuf);
	    info.point = new Point(x, y);
	    info.compressed = false;
	  } else if (buf[0] === 0x03) {
	    xbuf = buf.slice(1);
	    x = new BN(xbuf);
	    info = PublicKey._transformX(true, x);
	    info.compressed = true;
	  } else if (buf[0] === 0x02) {
	    xbuf = buf.slice(1);
	    x = new BN(xbuf);
	    info = PublicKey._transformX(false, x);
	    info.compressed = true;
	  } else {
	    throw new TypeError('Invalid DER format public key')
	  }
	  return info
	};

	/**
	 * Internal function to transform X into a public key point
	 *
	 * @param {Boolean} odd - If the point is above or below the x axis
	 * @param {Point} x - The x point
	 * @returns {Object} An object with keys: point and compressed
	 * @private
	 */
	PublicKey._transformX = function (odd, x) {
	  $.checkArgument(typeof odd === 'boolean', 'Must specify whether y is odd or not (true or false)');
	  var info = {};
	  info.point = Point.fromX(odd, x);
	  return info
	};

	/**
	 * Internal function to transform a JSON into a public key point
	 *
	 * @param {String|Object} json - a JSON string or plain object
	 * @returns {Object} An object with keys: point and compressed
	 * @private
	 */
	PublicKey._transformObject = function (json) {
	  var x = new BN(json.x, 'hex');
	  var y = new BN(json.y, 'hex');
	  var point = new Point(x, y);
	  return new PublicKey(point, {
	    compressed: json.compressed
	  })
	};

	/**
	 * Instantiate a PublicKey from a PrivateKey
	 *
	 * @param {PrivateKey} privkey - An instance of PrivateKey
	 * @returns {PublicKey} A new valid instance of PublicKey
	 */
	PublicKey.fromPrivateKey = function (privkey) {
	  $.checkArgument(PublicKey._isPrivateKey(privkey), 'Must be an instance of PrivateKey');
	  var info = PublicKey._transformPrivateKey(privkey);
	  return new PublicKey(info.point, {
	    compressed: info.compressed,
	    network: info.network
	  })
	};

	/**
	 * Instantiate a PublicKey from a Buffer
	 * @param {Buffer} buf - A DER buffer
	 * @param {bool=} strict - if set to false, will loosen some conditions
	 * @returns {PublicKey} A new valid instance of PublicKey
	 */
	PublicKey.fromDER = PublicKey.fromBuffer = function (buf, strict) {
	  $.checkArgument(PublicKey._isBuffer(buf), 'Must be a buffer of DER encoded public key');
	  var info = PublicKey._transformDER(buf, strict);
	  return new PublicKey(info.point, {
	    compressed: info.compressed
	  })
	};

	/**
	 * Instantiate a PublicKey from a Point
	 *
	 * @param {Point} point - A Point instance
	 * @param {boolean=} compressed - whether to store this public key as compressed format
	 * @returns {PublicKey} A new valid instance of PublicKey
	 */
	PublicKey.fromPoint = function (point, compressed) {
	  $.checkArgument(point instanceof Point, 'First argument must be an instance of Point.');
	  return new PublicKey(point, {
	    compressed: compressed
	  })
	};

	/**
	 * Instantiate a PublicKey from a DER hex encoded string
	 *
	 * @param {string} str - A DER hex string
	 * @param {String=} encoding - The type of string encoding
	 * @returns {PublicKey} A new valid instance of PublicKey
	 */
	PublicKey.fromHex = PublicKey.fromString = function (str, encoding) {
	  var buf = Buffer.from(str, encoding || 'hex');
	  var info = PublicKey._transformDER(buf);
	  return new PublicKey(info.point, {
	    compressed: info.compressed
	  })
	};

	/**
	 * Instantiate a PublicKey from an X Point
	 *
	 * @param {Boolean} odd - If the point is above or below the x axis
	 * @param {Point} x - The x point
	 * @returns {PublicKey} A new valid instance of PublicKey
	 */
	PublicKey.fromX = function (odd, x) {
	  var info = PublicKey._transformX(odd, x);
	  return new PublicKey(info.point, {
	    compressed: info.compressed
	  })
	};

	/**
	 * Check if there would be any errors when initializing a PublicKey
	 *
	 * @param {string} data - The encoded data in various formats
	 * @returns {null|Error} An error if exists
	 */
	PublicKey.getValidationError = function (data) {
	  var error;
	  try {
	    new PublicKey(data); // eslint-disable-line
	  } catch (e) {
	    error = e;
	  }
	  return error
	};

	/**
	 * Check if the parameters are valid
	 *
	 * @param {string} data - The encoded data in various formats
	 * @returns {Boolean} If the public key would be valid
	 */
	PublicKey.isValid = function (data) {
	  return !PublicKey.getValidationError(data)
	};

	/**
	 * @returns {Object} A plain object of the PublicKey
	 */
	PublicKey.prototype.toObject = PublicKey.prototype.toJSON = function toObject () {
	  return {
	    x: this.point.getX().toString('hex', 2),
	    y: this.point.getY().toString('hex', 2),
	    compressed: this.compressed
	  }
	};

	/**
	 * Will output the PublicKey to a DER Buffer
	 *
	 * @returns {Buffer} A DER hex encoded buffer
	 */
	PublicKey.prototype.toBuffer = PublicKey.prototype.toDER = function () {
	  var x = this.point.getX();
	  var y = this.point.getY();

	  var xbuf = x.toBuffer({
	    size: 32
	  });
	  var ybuf = y.toBuffer({
	    size: 32
	  });

	  var prefix;
	  if (!this.compressed) {
	    prefix = Buffer.from([0x04]);
	    return Buffer.concat([prefix, xbuf, ybuf])
	  } else {
	    var odd = ybuf[ybuf.length - 1] % 2;
	    if (odd) {
	      prefix = Buffer.from([0x03]);
	    } else {
	      prefix = Buffer.from([0x02]);
	    }
	    return Buffer.concat([prefix, xbuf])
	  }
	};

	/**
	 * Will return a sha256 + ripemd160 hash of the serialized public key
	 * @see https://github.com/bitcoin/bitcoin/blob/master/src/pubkey.h#L141
	 * @returns {Buffer}
	 */
	PublicKey.prototype._getID = function _getID () {
	  return Hash.sha256ripemd160(this.toBuffer())
	};

	/**
	 * Will return an address for the public key
	 *
	 * @param {String|Network=} network - Which network should the address be for
	 * @returns {Address} An address generated from the public key
	 */
	PublicKey.prototype.toAddress = function (network) {
	  var Address = requireAddress();
	  return Address.fromPublicKey(this, network || this.network)
	};

	/**
	 * Will output the PublicKey to a DER encoded hex string
	 *
	 * @returns {string} A DER hex encoded string
	 */
	PublicKey.prototype.toString = PublicKey.prototype.toHex = function () {
	  return this.toDER().toString('hex')
	};

	/**
	 * Will return a string formatted for the console
	 *
	 * @returns {string} Public key
	 */
	PublicKey.prototype.inspect = function () {
	  return '<PublicKey: ' + this.toHex() +
	    (this.compressed ? '' : ', uncompressed') + '>'
	};

	publickey = PublicKey;
	return publickey;
}

var ecdsa;
var hasRequiredEcdsa;

function requireEcdsa () {
	if (hasRequiredEcdsa) return ecdsa;
	hasRequiredEcdsa = 1;

	var BN = bn$1;
	var Point = point;
	var Signature = signature$1;
	var PublicKey = requirePublickey();
	var Random = random;
	var Hash = hashExports;
	var _ = __1;
	var $ = preconditions;

	var ECDSA = function ECDSA(obj) {
	  if (!(this instanceof ECDSA)) {
	    return new ECDSA(obj)
	  }
	  if (obj) {
	    this.set(obj);
	  }
	};

	ECDSA.prototype.set = function (obj) {
	  this.hashbuf = obj.hashbuf || this.hashbuf;
	  this.endian = obj.endian || this.endian; // the endianness of hashbuf
	  this.privkey = obj.privkey || this.privkey;
	  this.pubkey = obj.pubkey || (this.privkey ? this.privkey.publicKey : this.pubkey);
	  this.sig = obj.sig || this.sig;
	  this.k = obj.k || this.k;
	  this.verified = obj.verified || this.verified;
	  return this
	};

	ECDSA.prototype.privkey2pubkey = function () {
	  this.pubkey = this.privkey.toPublicKey();
	};

	ECDSA.prototype.calci = function () {
	  for (var i = 0; i < 4; i++) {
	    this.sig.i = i;
	    var Qprime;
	    try {
	      Qprime = this.toPublicKey();
	    } catch (e) {
	      console.error(e);
	      continue
	    }

	    if (Qprime.point.eq(this.pubkey.point)) {
	      this.sig.compressed = this.pubkey.compressed;
	      return this
	    }
	  }

	  this.sig.i = undefined;
	  throw new Error('Unable to find valid recovery factor')
	};

	ECDSA.fromString = function (str) {
	  var obj = JSON.parse(str);
	  return new ECDSA(obj)
	};

	ECDSA.prototype.randomK = function () {
	  var N = Point.getN();
	  var k;
	  do {
	    k = BN.fromBuffer(Random.getRandomBuffer(32));
	  } while (!(k.lt(N) && k.gt(BN.Zero)))
	  this.k = k;
	  return this
	};

	// https://tools.ietf.org/html/rfc6979#section-3.2
	ECDSA.prototype.deterministicK = function (badrs) {
	  // if r or s were invalid when this function was used in signing,
	  // we do not want to actually compute r, s here for efficiency, so,
	  // we can increment badrs. explained at end of RFC 6979 section 3.2
	  if (_.isUndefined(badrs)) {
	    badrs = 0;
	  }
	  var v = Buffer.alloc(32);
	  v.fill(0x01);
	  var k = Buffer.alloc(32);
	  k.fill(0x00);
	  var x = this.privkey.bn.toBuffer({
	    size: 32
	  });
	  var hashbuf = this.endian === 'little' ? Buffer.from(this.hashbuf).reverse() : this.hashbuf;
	  k = Hash.sha256hmac(Buffer.concat([v, Buffer.from([0x00]), x, hashbuf]), k);
	  v = Hash.sha256hmac(v, k);
	  k = Hash.sha256hmac(Buffer.concat([v, Buffer.from([0x01]), x, hashbuf]), k);
	  v = Hash.sha256hmac(v, k);
	  v = Hash.sha256hmac(v, k);
	  var T = BN.fromBuffer(v);
	  var N = Point.getN();

	  // also explained in 3.2, we must ensure T is in the proper range (0, N)
	  for (var i = 0; i < badrs || !(T.lt(N) && T.gt(BN.Zero)); i++) {
	    k = Hash.sha256hmac(Buffer.concat([v, Buffer.from([0x00])]), k);
	    v = Hash.sha256hmac(v, k);
	    v = Hash.sha256hmac(v, k);
	    T = BN.fromBuffer(v);
	  }

	  this.k = T;
	  return this
	};

	// Information about public key recovery:
	// https://bitcointalk.org/index.php?topic=6430.0
	// http://stackoverflow.com/questions/19665491/how-do-i-get-an-ecdsa-public-key-from-just-a-bitcoin-signature-sec1-4-1-6-k
	ECDSA.prototype.toPublicKey = function () {
	  var i = this.sig.i;
	  $.checkArgument(i === 0 || i === 1 || i === 2 || i === 3, new Error('i must be equal to 0, 1, 2, or 3'));

	  var e = BN.fromBuffer(this.hashbuf);
	  var r = this.sig.r;
	  var s = this.sig.s;

	  // A set LSB signifies that the y-coordinate is odd
	  var isYOdd = i & 1;

	  // The more significant bit specifies whether we should use the
	  // first or second candidate key.
	  var isSecondKey = i >> 1;

	  var n = Point.getN();
	  var G = Point.getG();

	  // 1.1 Let x = r + jn
	  var x = isSecondKey ? r.add(n) : r;
	  var R = Point.fromX(isYOdd, x);

	  // 1.4 Check that nR is at infinity
	  var nR = R.mul(n);

	  if (!nR.isInfinity()) {
	    throw new Error('nR is not a valid curve point')
	  }

	  // Compute -e from e
	  var eNeg = e.neg().umod(n);

	  // 1.6.1 Compute Q = r^-1 (sR - eG)
	  // Q = r^-1 (sR + -eG)
	  var rInv = r.invm(n);

	  // var Q = R.multiplyTwo(s, G, eNeg).mul(rInv);
	  var Q = R.mul(s).add(G.mul(eNeg)).mul(rInv);

	  var pubkey = PublicKey.fromPoint(Q, this.sig.compressed);

	  return pubkey
	};

	ECDSA.prototype.sigError = function () {
	  if (!isBuffer$2(this.hashbuf) || this.hashbuf.length !== 32) {
	    return 'hashbuf must be a 32 byte buffer'
	  }

	  var r = this.sig.r;
	  var s = this.sig.s;
	  if (!(r.gt(BN.Zero) && r.lt(Point.getN())) || !(s.gt(BN.Zero) && s.lt(Point.getN()))) {
	    return 'r and s not in range'
	  }

	  var e = BN.fromBuffer(this.hashbuf, this.endian ? {
	    endian: this.endian
	  } : undefined);
	  var n = Point.getN();
	  var sinv = s.invm(n);
	  var u1 = sinv.mul(e).umod(n);
	  var u2 = sinv.mul(r).umod(n);

	  var p = Point.getG().mulAdd(u1, this.pubkey.point, u2);
	  if (p.isInfinity()) {
	    return 'p is infinity'
	  }

	  if (p.getX().umod(n).cmp(r) !== 0) {
	    return 'Invalid signature'
	  } else {
	    return false
	  }
	};

	ECDSA.toLowS = function (s) {
	  // enforce low s
	  // see BIP 62, "low S values in signatures"
	  if (s.gt(BN.fromBuffer(Buffer.from('7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0', 'hex')))) {
	    s = Point.getN().sub(s);
	  }
	  return s
	};

	ECDSA.prototype._findSignature = function (d, e) {
	  var N = Point.getN();
	  var G = Point.getG();
	  // try different values of k until r, s are valid
	  var badrs = 0;
	  var k, Q, r, s;
	  do {
	    if (!this.k || badrs > 0) {
	      this.deterministicK(badrs);
	    }
	    badrs++;
	    k = this.k;
	    Q = G.mul(k);
	    r = new BN(1).mul(Q.x.umod(N));
	    s = k.invm(N).mul(e.add(d.mul(r))).umod(N);
	  } while (r.cmp(BN.Zero) <= 0 || s.cmp(BN.Zero) <= 0)

	  s = ECDSA.toLowS(s);
	  return {
	    s: s,
	    r: r
	  }
	};

	ECDSA.prototype.sign = function () {
	  var hashbuf = this.hashbuf;
	  var privkey = this.privkey;
	  var d = privkey.bn;

	  $.checkState(hashbuf && privkey && d, new Error('invalid parameters'));
	  $.checkState(isBuffer$2(hashbuf) && hashbuf.length === 32, new Error('hashbuf must be a 32 byte buffer'));

	  var e = BN.fromBuffer(hashbuf, this.endian ? {
	    endian: this.endian
	  } : undefined);

	  var obj = this._findSignature(d, e);
	  obj.compressed = this.pubkey.compressed;

	  this.sig = new Signature(obj);
	  return this
	};

	ECDSA.prototype.signRandomK = function () {
	  this.randomK();
	  return this.sign()
	};

	ECDSA.prototype.toString = function () {
	  var obj = {};
	  if (this.hashbuf) {
	    obj.hashbuf = this.hashbuf.toString('hex');
	  }
	  if (this.privkey) {
	    obj.privkey = this.privkey.toString();
	  }
	  if (this.pubkey) {
	    obj.pubkey = this.pubkey.toString();
	  }
	  if (this.sig) {
	    obj.sig = this.sig.toString();
	  }
	  if (this.k) {
	    obj.k = this.k.toString();
	  }
	  return JSON.stringify(obj)
	};

	ECDSA.prototype.verify = function () {
	  if (!this.sigError()) {
	    this.verified = true;
	  } else {
	    this.verified = false;
	  }
	  return this
	};

	ECDSA.sign = function (hashbuf, privkey, endian) {
	  return ECDSA().set({
	    hashbuf: hashbuf,
	    endian: endian,
	    privkey: privkey
	  }).sign().sig
	};

	ECDSA.signWithCalcI = function (hashbuf, privkey, endian) {
	  return ECDSA().set({
	    hashbuf: hashbuf,
	    endian: endian,
	    privkey: privkey
	  }).sign().calci().sig
	};

	ECDSA.signRandomK = function (hashbuf, privkey, endian) {
	  return ECDSA().set({
	    hashbuf: hashbuf,
	    endian: endian,
	    privkey: privkey
	  }).signRandomK().sig
	};

	ECDSA.verify = function (hashbuf, sig, pubkey, endian) {
	  return ECDSA().set({
	    hashbuf: hashbuf,
	    endian: endian,
	    sig: sig,
	    pubkey: pubkey
	  }).verify().verified
	};

	ecdsa = ECDSA;
	return ecdsa;
}

var block$1 = {exports: {}};

var _$2 = __1;
var BN$1 = bn$1;
var BufferReader$2 = bufferreader;
var BufferWriter$2 = bufferwriter;
var Hash$4 = hashExports;
var $$4 = preconditions;

var GENESIS_BITS = 0x1d00ffff;

/**
 * Instantiate a BlockHeader from a Buffer, JSON object, or Object with
 * the properties of the BlockHeader
 *
 * @param {*} - A Buffer, JSON string, or Object
 * @returns {BlockHeader} - An instance of block header
 * @constructor
 */
var BlockHeader$2 = function BlockHeader (arg) {
  if (!(this instanceof BlockHeader)) {
    return new BlockHeader(arg)
  }
  var info = BlockHeader._from(arg);
  this.version = info.version;
  this.prevHash = info.prevHash;
  this.merkleRoot = info.merkleRoot;
  this.time = info.time;
  this.timestamp = info.time;
  this.bits = info.bits;
  this.nonce = info.nonce;

  if (info.hash) {
    $$4.checkState(
      this.hash === info.hash,
      'Argument object hash property does not match block hash.'
    );
  }

  return this
};

/**
 * @param {*} - A Buffer, JSON string or Object
 * @returns {Object} - An object representing block header data
 * @throws {TypeError} - If the argument was not recognized
 * @private
 */
BlockHeader$2._from = function _from (arg) {
  var info = {};
  if (isBuffer$2(arg)) {
    info = BlockHeader$2._fromBufferReader(BufferReader$2(arg));
  } else if (_$2.isObject(arg)) {
    info = BlockHeader$2._fromObject(arg);
  } else {
    throw new TypeError('Unrecognized argument for BlockHeader')
  }
  return info
};

/**
 * @param {Object} - A JSON string
 * @returns {Object} - An object representing block header data
 * @private
 */
BlockHeader$2._fromObject = function _fromObject (data) {
  $$4.checkArgument(data, 'data is required');
  var prevHash = data.prevHash;
  var merkleRoot = data.merkleRoot;
  if (_$2.isString(data.prevHash)) {
    prevHash = Buffer.from(data.prevHash, 'hex').reverse();
  }
  if (_$2.isString(data.merkleRoot)) {
    merkleRoot = Buffer.from(data.merkleRoot, 'hex').reverse();
  }
  var info = {
    hash: data.hash,
    version: data.version,
    prevHash: prevHash,
    merkleRoot: merkleRoot,
    time: data.time,
    timestamp: data.time,
    bits: data.bits,
    nonce: data.nonce
  };
  return info
};

/**
 * @param {Object} - A plain JavaScript object
 * @returns {BlockHeader} - An instance of block header
 */
BlockHeader$2.fromObject = function fromObject (obj) {
  var info = BlockHeader$2._fromObject(obj);
  return new BlockHeader$2(info)
};

/**
 * @param {Binary} - Raw block binary data or buffer
 * @returns {BlockHeader} - An instance of block header
 */
BlockHeader$2.fromRawBlock = function fromRawBlock (data) {
  if (!isBuffer$2(data)) {
    data = Buffer.from(data, 'binary');
  }
  var br = BufferReader$2(data);
  br.pos = BlockHeader$2.Constants.START_OF_HEADER;
  var info = BlockHeader$2._fromBufferReader(br);
  return new BlockHeader$2(info)
};

/**
 * @param {Buffer} - A buffer of the block header
 * @returns {BlockHeader} - An instance of block header
 */
BlockHeader$2.fromBuffer = function fromBuffer (buf) {
  var info = BlockHeader$2._fromBufferReader(BufferReader$2(buf));
  return new BlockHeader$2(info)
};

/**
 * @param {string} - A hex encoded buffer of the block header
 * @returns {BlockHeader} - An instance of block header
 */
BlockHeader$2.fromString = function fromString (str) {
  var buf = Buffer.from(str, 'hex');
  return BlockHeader$2.fromBuffer(buf)
};

/**
 * @param {BufferReader} - A BufferReader of the block header
 * @returns {Object} - An object representing block header data
 * @private
 */
BlockHeader$2._fromBufferReader = function _fromBufferReader (br) {
  var info = {};
  info.version = br.readInt32LE();
  info.prevHash = br.read(32);
  info.merkleRoot = br.read(32);
  info.time = br.readUInt32LE();
  info.bits = br.readUInt32LE();
  info.nonce = br.readUInt32LE();
  return info
};

/**
 * @param {BufferReader} - A BufferReader of the block header
 * @returns {BlockHeader} - An instance of block header
 */
BlockHeader$2.fromBufferReader = function fromBufferReader (br) {
  var info = BlockHeader$2._fromBufferReader(br);
  return new BlockHeader$2(info)
};

/**
 * @returns {Object} - A plain object of the BlockHeader
 */
BlockHeader$2.prototype.toObject = BlockHeader$2.prototype.toJSON = function toObject () {
  return {
    hash: this.hash,
    version: this.version,
    prevHash: Buffer.from(this.prevHash).reverse().toString('hex'),
    merkleRoot: Buffer.from(this.merkleRoot).reverse().toString('hex'),
    time: this.time,
    bits: this.bits,
    nonce: this.nonce
  }
};

/**
 * @returns {Buffer} - A Buffer of the BlockHeader
 */
BlockHeader$2.prototype.toBuffer = function toBuffer () {
  return this.toBufferWriter().concat()
};

/**
 * @returns {string} - A hex encoded string of the BlockHeader
 */
BlockHeader$2.prototype.toString = function toString () {
  return this.toBuffer().toString('hex')
};

/**
 * @param {BufferWriter} - An existing instance BufferWriter
 * @returns {BufferWriter} - An instance of BufferWriter representation of the BlockHeader
 */
BlockHeader$2.prototype.toBufferWriter = function toBufferWriter (bw) {
  if (!bw) {
    bw = new BufferWriter$2();
  }
  bw.writeInt32LE(this.version);
  bw.write(this.prevHash);
  bw.write(this.merkleRoot);
  bw.writeUInt32LE(this.time);
  bw.writeUInt32LE(this.bits);
  bw.writeUInt32LE(this.nonce);
  return bw
};

/**
 * Returns the target difficulty for this block
 * @param {Number} bits
 * @returns {BN} An instance of BN with the decoded difficulty bits
 */
BlockHeader$2.prototype.getTargetDifficulty = function getTargetDifficulty (bits) {
  bits = bits || this.bits;

  var target = new BN$1(bits & 0xffffff);
  var mov = 8 * ((bits >>> 24) - 3);
  while (mov-- > 0) {
    target = target.mul(new BN$1(2));
  }
  return target
};


BlockHeader$2.prototype.getDifficulty = function getDifficulty () {
  var difficulty1TargetBN = this.getTargetDifficulty(GENESIS_BITS).mul(new BN$1(Math.pow(10, 8)));
  var currentTargetBN = this.getTargetDifficulty();

  var difficultyString = difficulty1TargetBN.div(currentTargetBN).toString(10);
  var decimalPos = difficultyString.length - 8;
  difficultyString = difficultyString.slice(0, decimalPos) + '.' + difficultyString.slice(decimalPos);

  return parseFloat(difficultyString)
};

/**
 * @returns {Buffer} - The little endian hash buffer of the header
 */
BlockHeader$2.prototype._getHash = function hash () {
  var buf = this.toBuffer();
  return Hash$4.sha256sha256(buf)
};

var idProperty$1 = {
  configurable: false,
  enumerable: true,
  /**
   * @returns {string} - The big endian hash buffer of the header
   */
  get: function () {
    if (!this._id) {
      this._id = BufferReader$2(this._getHash()).readReverse().toString('hex');
    }
    return this._id
  },
  set: _$2.noop
};
Object.defineProperty(BlockHeader$2.prototype, 'id', idProperty$1);
Object.defineProperty(BlockHeader$2.prototype, 'hash', idProperty$1);

/**
 * @returns {Boolean} - If timestamp is not too far in the future
 */
BlockHeader$2.prototype.validTimestamp = function validTimestamp () {
  var currentTime = Math.round(new Date().getTime() / 1000);
  if (this.time > currentTime + BlockHeader$2.Constants.MAX_TIME_OFFSET) {
    return false
  }
  return true
};

/**
 * @returns {Boolean} - If the proof-of-work hash satisfies the target difficulty
 */
BlockHeader$2.prototype.validProofOfWork = function validProofOfWork () {
  var pow = new BN$1(this.id, 'hex');
  var target = this.getTargetDifficulty();

  if (pow.cmp(target) > 0) {
    return false
  }
  return true
};

/**
 * @returns {string} - A string formatted for the console
 */
BlockHeader$2.prototype.inspect = function inspect () {
  return '<BlockHeader ' + this.id + '>'
};

BlockHeader$2.Constants = {
  START_OF_HEADER: 8, // Start buffer position in raw block data
  MAX_TIME_OFFSET: 2 * 60 * 60, // The max a timestamp can be in the future
  LARGEST_HASH: new BN$1('10000000000000000000000000000000000000000000000000000000000000000', 'hex')
};

var blockheader = BlockHeader$2;

var _$1 = __1;
var BlockHeader$1 = blockheader;
var BN = bn$1;
var BufferReader$1 = bufferreader;
var BufferWriter$1 = bufferwriter;
var Hash$3 = hashExports;
var Transaction$1 = requireTransaction();
var $$3 = preconditions;

/**
 * Instantiate a Block from a Buffer, JSON object, or Object with
 * the properties of the Block
 *
 * @param {*} - A Buffer, JSON string, or Object
 * @returns {Block}
 * @constructor
 */
function Block (arg) {
  if (!(this instanceof Block)) {
    return new Block(arg)
  }
  _$1.extend(this, Block._from(arg));
  return this
}

Block.MAX_BLOCK_SIZE = 128000000;

/**
 * @param {*} - A Buffer, JSON string or Object
 * @returns {Object} - An object representing block data
 * @throws {TypeError} - If the argument was not recognized
 * @private
 */
Block._from = function _from (arg) {
  var info = {};
  if (isBuffer$2(arg)) {
    info = Block._fromBufferReader(BufferReader$1(arg));
  } else if (_$1.isObject(arg)) {
    info = Block._fromObject(arg);
  } else {
    throw new TypeError('Unrecognized argument for Block')
  }
  return info
};

/**
 * @param {Object} - A plain JavaScript object
 * @returns {Object} - An object representing block data
 * @private
 */
Block._fromObject = function _fromObject (data) {
  var transactions = [];
  data.transactions.forEach(function (tx) {
    if (tx instanceof Transaction$1) {
      transactions.push(tx);
    } else {
      transactions.push(Transaction$1().fromObject(tx));
    }
  });
  var info = {
    header: BlockHeader$1.fromObject(data.header),
    transactions: transactions
  };
  return info
};

/**
 * @param {Object} - A plain JavaScript object
 * @returns {Block} - An instance of block
 */
Block.fromObject = function fromObject (obj) {
  var info = Block._fromObject(obj);
  return new Block(info)
};

/**
 * @param {BufferReader} - Block data
 * @returns {Object} - An object representing the block data
 * @private
 */
Block._fromBufferReader = function _fromBufferReader (br) {
  var info = {};
  $$3.checkState(!br.finished(), 'No block data received');
  info.header = BlockHeader$1.fromBufferReader(br);
  var transactions = br.readVarintNum();
  info.transactions = [];
  for (var i = 0; i < transactions; i++) {
    info.transactions.push(Transaction$1().fromBufferReader(br));
  }
  return info
};

/**
 * @param {BufferReader} - A buffer reader of the block
 * @returns {Block} - An instance of block
 */
Block.fromBufferReader = function fromBufferReader (br) {
  $$3.checkArgument(br, 'br is required');
  var info = Block._fromBufferReader(br);
  return new Block(info)
};

/**
 * @param {Buffer} - A buffer of the block
 * @returns {Block} - An instance of block
 */
Block.fromBuffer = function fromBuffer (buf) {
  return Block.fromBufferReader(new BufferReader$1(buf))
};

/**
 * @param {string} - str - A hex encoded string of the block
 * @returns {Block} - A hex encoded string of the block
 */
Block.fromString = function fromString (str) {
  var buf = Buffer.from(str, 'hex');
  return Block.fromBuffer(buf)
};

/**
 * @param {Binary} - Raw block binary data or buffer
 * @returns {Block} - An instance of block
 */
Block.fromRawBlock = function fromRawBlock (data) {
  if (!isBuffer$2(data)) {
    data = Buffer.from(data, 'binary');
  }
  var br = BufferReader$1(data);
  br.pos = Block.Values.START_OF_BLOCK;
  var info = Block._fromBufferReader(br);
  return new Block(info)
};

/**
 * @returns {Object} - A plain object with the block properties
 */
Block.prototype.toObject = Block.prototype.toJSON = function toObject () {
  var transactions = [];
  this.transactions.forEach(function (tx) {
    transactions.push(tx.toObject());
  });
  return {
    header: this.header.toObject(),
    transactions: transactions
  }
};

/**
 * @returns {Buffer} - A buffer of the block
 */
Block.prototype.toBuffer = function toBuffer () {
  return this.toBufferWriter().concat()
};

/**
 * @returns {string} - A hex encoded string of the block
 */
Block.prototype.toString = function toString () {
  return this.toBuffer().toString('hex')
};

/**
 * @param {BufferWriter} - An existing instance of BufferWriter
 * @returns {BufferWriter} - An instance of BufferWriter representation of the Block
 */
Block.prototype.toBufferWriter = function toBufferWriter (bw) {
  if (!bw) {
    bw = new BufferWriter$1();
  }
  bw.write(this.header.toBuffer());
  bw.writeVarintNum(this.transactions.length);
  for (var i = 0; i < this.transactions.length; i++) {
    this.transactions[i].toBufferWriter(bw);
  }
  return bw
};

/**
 * Will iterate through each transaction and return an array of hashes
 * @returns {Array} - An array with transaction hashes
 */
Block.prototype.getTransactionHashes = function getTransactionHashes () {
  var hashes = [];
  if (this.transactions.length === 0) {
    return [Block.Values.NULL_HASH]
  }
  for (var t = 0; t < this.transactions.length; t++) {
    hashes.push(this.transactions[t]._getHash());
  }
  return hashes
};

Block.prototype.getMerkleTree = function getMerkleTree () {
  var tree = this.getTransactionHashes();

  var j = 0;
  for (var size = this.transactions.length; size > 1; size = Math.floor((size + 1) / 2)) {
    for (var i = 0; i < size; i += 2) {
      var i2 = Math.min(i + 1, size - 1);
      var buf = Buffer.concat([tree[j + i], tree[j + i2]]);
      tree.push(Hash$3.sha256sha256(buf));
    }
    j += size;
  }

  return tree
};

/**
 * Calculates the merkleRoot from the transactions.
 * @returns {Buffer} - A buffer of the merkle root hash
 */
Block.prototype.getMerkleRoot = function getMerkleRoot () {
  var tree = this.getMerkleTree();
  return tree[tree.length - 1]
};

/**
 * Verifies that the transactions in the block match the header merkle root
 * @returns {Boolean} - If the merkle roots match
 */
Block.prototype.validMerkleRoot = function validMerkleRoot () {
  var h = new BN(this.header.merkleRoot.toString('hex'), 'hex');
  var c = new BN(this.getMerkleRoot().toString('hex'), 'hex');

  if (h.cmp(c) !== 0) {
    return false
  }

  return true
};

/**
 * @returns {Buffer} - The little endian hash buffer of the header
 */
Block.prototype._getHash = function () {
  return this.header._getHash()
};

var idProperty = {
  configurable: false,
  enumerable: true,
  /**
   * @returns {string} - The big endian hash buffer of the header
   */
  get: function () {
    if (!this._id) {
      this._id = this.header.id;
    }
    return this._id
  },
  set: _$1.noop
};
Object.defineProperty(Block.prototype, 'id', idProperty);
Object.defineProperty(Block.prototype, 'hash', idProperty);

/**
 * @returns {string} - A string formatted for the console
 */
Block.prototype.inspect = function inspect () {
  return '<Block ' + this.id + '>'
};

Block.Values = {
  START_OF_BLOCK: 8, // Start of block in raw block data
  NULL_HASH: Buffer.from('0000000000000000000000000000000000000000000000000000000000000000', 'hex')
};

var block = Block;

var _ = __1;
var BlockHeader = blockheader;
var BufferReader = bufferreader;
var BufferWriter = bufferwriter;
var Hash$2 = hashExports;
var Transaction = requireTransaction();
var errors$2 = errorsExports;
var $$2 = preconditions;

/**
 * Instantiate a MerkleBlock from a Buffer, JSON object, or Object with
 * the properties of the Block
 *
 * @param {*} - A Buffer, JSON string, or Object representing a MerkleBlock
 * @returns {MerkleBlock}
 * @constructor
 */
function MerkleBlock (arg) {
  if (!(this instanceof MerkleBlock)) {
    return new MerkleBlock(arg)
  }

  var info = {};
  if (isBuffer$2(arg)) {
    info = MerkleBlock._fromBufferReader(BufferReader(arg));
  } else if (_.isObject(arg)) {
    var header;
    if (arg.header instanceof BlockHeader) {
      header = arg.header;
    } else {
      header = BlockHeader.fromObject(arg.header);
    }
    info = {
      /**
       * @name MerkleBlock#header
       * @type {BlockHeader}
       */
      header: header,
      /**
       * @name MerkleBlock#numTransactions
       * @type {Number}
       */
      numTransactions: arg.numTransactions,
      /**
       * @name MerkleBlock#hashes
       * @type {String[]}
       */
      hashes: arg.hashes,
      /**
       * @name MerkleBlock#flags
       * @type {Number[]}
       */
      flags: arg.flags
    };
  } else {
    throw new TypeError('Unrecognized argument for MerkleBlock')
  }
  _.extend(this, info);
  this._flagBitsUsed = 0;
  this._hashesUsed = 0;

  return this
}

/**
 * @param {Buffer} - MerkleBlock data in a Buffer object
 * @returns {MerkleBlock} - A MerkleBlock object
 */
MerkleBlock.fromBuffer = function fromBuffer (buf) {
  return MerkleBlock.fromBufferReader(BufferReader(buf))
};

/**
 * @param {BufferReader} - MerkleBlock data in a BufferReader object
 * @returns {MerkleBlock} - A MerkleBlock object
 */
MerkleBlock.fromBufferReader = function fromBufferReader (br) {
  return new MerkleBlock(MerkleBlock._fromBufferReader(br))
};

/**
 * @returns {Buffer} - A buffer of the block
 */
MerkleBlock.prototype.toBuffer = function toBuffer () {
  return this.toBufferWriter().concat()
};

/**
 * @param {BufferWriter} - An existing instance of BufferWriter
 * @returns {BufferWriter} - An instance of BufferWriter representation of the MerkleBlock
 */
MerkleBlock.prototype.toBufferWriter = function toBufferWriter (bw) {
  if (!bw) {
    bw = new BufferWriter();
  }
  bw.write(this.header.toBuffer());
  bw.writeUInt32LE(this.numTransactions);
  bw.writeVarintNum(this.hashes.length);
  for (var i = 0; i < this.hashes.length; i++) {
    bw.write(Buffer.from(this.hashes[i], 'hex'));
  }
  bw.writeVarintNum(this.flags.length);
  for (i = 0; i < this.flags.length; i++) {
    bw.writeUInt8(this.flags[i]);
  }
  return bw
};

/**
 * @returns {Object} - A plain object with the MerkleBlock properties
 */
MerkleBlock.prototype.toObject = MerkleBlock.prototype.toJSON = function toObject () {
  return {
    header: this.header.toObject(),
    numTransactions: this.numTransactions,
    hashes: this.hashes,
    flags: this.flags
  }
};

/**
 * Verify that the MerkleBlock is valid
 * @returns {Boolean} - True/False whether this MerkleBlock is Valid
 */
MerkleBlock.prototype.validMerkleTree = function validMerkleTree () {
  $$2.checkState(_.isArray(this.flags), 'MerkleBlock flags is not an array');
  $$2.checkState(_.isArray(this.hashes), 'MerkleBlock hashes is not an array');

  // Can't have more hashes than numTransactions
  if (this.hashes.length > this.numTransactions) {
    return false
  }

  // Can't have more flag bits than num hashes
  if (this.flags.length * 8 < this.hashes.length) {
    return false
  }

  var height = this._calcTreeHeight();
  var opts = { hashesUsed: 0, flagBitsUsed: 0 };
  var root = this._traverseMerkleTree(height, 0, opts);
  if (opts.hashesUsed !== this.hashes.length) {
    return false
  }
  return root.equals(this.header.merkleRoot)
};

/**
 * WARNING: This method is deprecated. Use filteredTxsHash instead.
 *
 * Return a list of all the txs hash that match the filter
 * @returns {Array} - txs hash that match the filter
 */
MerkleBlock.prototype.filterdTxsHash = function filterdTxsHash () {
  throw new Error('filterdTxsHash has been deprecated. use filteredTxsHash.')
};

/**
 * Return a list of all the txs hash that match the filter
 * @returns {Array} - txs hash that match the filter
 */
MerkleBlock.prototype.filteredTxsHash = function filteredTxsHash () {
  $$2.checkState(_.isArray(this.flags), 'MerkleBlock flags is not an array');
  $$2.checkState(_.isArray(this.hashes), 'MerkleBlock hashes is not an array');

  // Can't have more hashes than numTransactions
  if (this.hashes.length > this.numTransactions) {
    throw new errors$2.MerkleBlock.InvalidMerkleTree()
  }

  // Can't have more flag bits than num hashes
  if (this.flags.length * 8 < this.hashes.length) {
    throw new errors$2.MerkleBlock.InvalidMerkleTree()
  }

  // If there is only one hash the filter do not match any txs in the block
  if (this.hashes.length === 1) {
    return []
  }
  var height = this._calcTreeHeight();
  var opts = { hashesUsed: 0, flagBitsUsed: 0 };
  var txs = this._traverseMerkleTree(height, 0, opts, true);
  if (opts.hashesUsed !== this.hashes.length) {
    throw new errors$2.MerkleBlock.InvalidMerkleTree()
  }
  return txs
};


MerkleBlock.prototype._traverseMerkleTree = function traverseMerkleTree (depth, pos, opts, checkForTxs) {
  opts = opts || {};
  opts.txs = opts.txs || [];
  opts.flagBitsUsed = opts.flagBitsUsed || 0;
  opts.hashesUsed = opts.hashesUsed || 0;
  checkForTxs = checkForTxs || false;

  if (opts.flagBitsUsed > this.flags.length * 8) {
    return null
  }
  var isParentOfMatch = (this.flags[opts.flagBitsUsed >> 3] >>> (opts.flagBitsUsed++ & 7)) & 1;
  if (depth === 0 || !isParentOfMatch) {
    if (opts.hashesUsed >= this.hashes.length) {
      return null
    }
    var hash = this.hashes[opts.hashesUsed++];
    if (depth === 0 && isParentOfMatch) {
      opts.txs.push(hash);
    }
    return Buffer.from(hash, 'hex')
  } else {
    var left = this._traverseMerkleTree(depth - 1, pos * 2, opts);
    var right = left;
    if (pos * 2 + 1 < this._calcTreeWidth(depth - 1)) {
      right = this._traverseMerkleTree(depth - 1, pos * 2 + 1, opts);
    }
    if (checkForTxs) {
      return opts.txs
    } else {
      return Hash$2.sha256sha256(Buffer.concat([left, right]))
    }
  }
};


MerkleBlock.prototype._calcTreeWidth = function calcTreeWidth (height) {
  return (this.numTransactions + (1 << height) - 1) >> height
};

/** Calculates the height of the merkle tree in this MerkleBlock
 * @param {Number} - Height at which we want the tree width
 * @returns {Number} - Height of the merkle tree in this MerkleBlock
 * @private
 */
MerkleBlock.prototype._calcTreeHeight = function calcTreeHeight () {
  var height = 0;
  while (this._calcTreeWidth(height) > 1) {
    height++;
  }
  return height
};

/**
 * @param {Transaction|String} - Transaction or Transaction ID Hash
 * @returns {Boolean} - return true/false if this MerkleBlock has the TX or not
 * @private
 */
MerkleBlock.prototype.hasTransaction = function hasTransaction (tx) {
  $$2.checkArgument(!_.isUndefined(tx), 'tx cannot be undefined');
  $$2.checkArgument(tx instanceof Transaction || typeof tx === 'string',
    'Invalid tx given, tx must be a "string" or "Transaction"');

  var hash = tx;
  if (tx instanceof Transaction) {
    // We need to reverse the id hash for the lookup
    hash = Buffer.from(tx.id, 'hex').reverse().toString('hex');
  }

  var txs = [];
  var height = this._calcTreeHeight();
  this._traverseMerkleTree(height, 0, { txs: txs });
  return txs.indexOf(hash) !== -1
};

/**
 * @param {Buffer} - MerkleBlock data
 * @returns {Object} - An Object representing merkleblock data
 * @private
 */
MerkleBlock._fromBufferReader = function _fromBufferReader (br) {
  $$2.checkState(!br.finished(), 'No merkleblock data received');
  var info = {};
  info.header = BlockHeader.fromBufferReader(br);
  info.numTransactions = br.readUInt32LE();
  var numHashes = br.readVarintNum();
  info.hashes = [];
  for (var i = 0; i < numHashes; i++) {
    info.hashes.push(br.read(32).toString('hex'));
  }
  var numFlags = br.readVarintNum();
  info.flags = [];
  for (i = 0; i < numFlags; i++) {
    info.flags.push(br.readUInt8());
  }
  return info
};

/**
 * @param {Object} - A plain JavaScript object
 * @returns {Block} - An instance of block
 */
MerkleBlock.fromObject = function fromObject (obj) {
  return new MerkleBlock(obj)
};

var merkleblock = MerkleBlock;

block$1.exports = block;

block$1.exports.BlockHeader = blockheader;
block$1.exports.MerkleBlock = merkleblock;

var blockExports = block$1.exports;

var hdpublickey;
var hasRequiredHdpublickey;

function requireHdpublickey () {
	if (hasRequiredHdpublickey) return hdpublickey;
	hasRequiredHdpublickey = 1;

	var _ = __1;
	var $ = preconditions;

	var BN = bn$1;
	var Base58 = base58;
	var Base58Check = base58check;
	var Hash = hashExports;
	var HDPrivateKey = requireHdprivatekey();
	var Network = networks_1;
	var Point = point;
	var PublicKey = requirePublickey();

	var mvcErrors = errorsExports;
	var errors = mvcErrors;
	var hdErrors = mvcErrors.HDPublicKey;
	var assert = require$$0$4;

	var JSUtil = js;

	/**
	 * The representation of an hierarchically derived public key.
	 *
	 * See https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki
	 *
	 * @constructor
	 * @param {Object|string|Buffer} arg
	 */
	function HDPublicKey (arg) {
	  if (arg instanceof HDPublicKey) {
	    return arg
	  }
	  if (!(this instanceof HDPublicKey)) {
	    return new HDPublicKey(arg)
	  }
	  if (arg) {
	    if (_.isString(arg) || isBuffer$2(arg)) {
	      var error = HDPublicKey.getSerializedError(arg);
	      if (!error) {
	        return this._buildFromSerialized(arg)
	      } else if (isBuffer$2(arg) && !HDPublicKey.getSerializedError(arg.toString())) {
	        return this._buildFromSerialized(arg.toString())
	      } else {
	        if (error instanceof hdErrors.ArgumentIsPrivateExtended) {
	          return new HDPrivateKey(arg).hdPublicKey
	        }
	        throw error
	      }
	    } else {
	      if (_.isObject(arg)) {
	        if (arg instanceof HDPrivateKey) {
	          return this._buildFromPrivate(arg)
	        } else {
	          return this._buildFromObject(arg)
	        }
	      } else {
	        throw new hdErrors.UnrecognizedArgument(arg)
	      }
	    }
	  } else {
	    throw new hdErrors.MustSupplyArgument()
	  }
	}

	HDPublicKey.fromHDPrivateKey = function (hdPrivateKey) {
	  return new HDPublicKey(hdPrivateKey)
	};

	/**
	 * Verifies that a given path is valid.
	 *
	 * @param {string|number} arg
	 * @return {boolean}
	 */
	HDPublicKey.isValidPath = function (arg) {
	  if (_.isString(arg)) {
	    var indexes = HDPrivateKey._getDerivationIndexes(arg);
	    return indexes !== null && _.every(indexes, HDPublicKey.isValidPath)
	  }

	  if (_.isNumber(arg)) {
	    return arg >= 0 && arg < HDPublicKey.Hardened
	  }

	  return false
	};

	/**
	 * WARNING: This method is deprecated. Use deriveChild instead.
	 *
	 *
	 * Get a derivated child based on a string or number.
	 *
	 * If the first argument is a string, it's parsed as the full path of
	 * derivation. Valid values for this argument include "m" (which returns the
	 * same public key), "m/0/1/40/2/1000".
	 *
	 * Note that hardened keys can't be derived from a public extended key.
	 *
	 * If the first argument is a number, the child with that index will be
	 * derived. See the example usage for clarification.
	 *
	 * @example
	 * ```javascript
	 * var parent = new HDPublicKey('xpub...');
	 * var child_0_1_2 = parent.derive(0).derive(1).derive(2);
	 * var copy_of_child_0_1_2 = parent.derive("m/0/1/2");
	 * assert(child_0_1_2.xprivkey === copy_of_child_0_1_2);
	 * ```
	 *
	 * @param {string|number} arg
	 */
	HDPublicKey.prototype.derive = function () {
	  throw new Error('derive has been deprecated. use deriveChild or, for the old way, deriveNonCompliantChild.')
	};

	/**
	 * WARNING: This method will not be officially supported until v1.0.0.
	 *
	 *
	 * Get a derivated child based on a string or number.
	 *
	 * If the first argument is a string, it's parsed as the full path of
	 * derivation. Valid values for this argument include "m" (which returns the
	 * same public key), "m/0/1/40/2/1000".
	 *
	 * Note that hardened keys can't be derived from a public extended key.
	 *
	 * If the first argument is a number, the child with that index will be
	 * derived. See the example usage for clarification.
	 *
	 * @example
	 * ```javascript
	 * var parent = new HDPublicKey('xpub...');
	 * var child_0_1_2 = parent.deriveChild(0).deriveChild(1).deriveChild(2);
	 * var copy_of_child_0_1_2 = parent.deriveChild("m/0/1/2");
	 * assert(child_0_1_2.xprivkey === copy_of_child_0_1_2);
	 * ```
	 *
	 * @param {string|number} arg
	 */
	HDPublicKey.prototype.deriveChild = function (arg, hardened) {
	  if (_.isNumber(arg)) {
	    return this._deriveWithNumber(arg, hardened)
	  } else if (_.isString(arg)) {
	    return this._deriveFromString(arg)
	  } else {
	    throw new hdErrors.InvalidDerivationArgument(arg)
	  }
	};

	HDPublicKey.prototype._deriveWithNumber = function (index, hardened) {
	  if (index >= HDPublicKey.Hardened || hardened) {
	    throw new hdErrors.InvalidIndexCantDeriveHardened()
	  }
	  if (index < 0) {
	    throw new hdErrors.InvalidPath(index)
	  }

	  var indexBuffer = JSUtil.integerAsBuffer(index);
	  var data = Buffer.concat([this.publicKey.toBuffer(), indexBuffer]);
	  var hash = Hash.sha512hmac(data, this._buffers.chainCode);
	  var leftPart = BN.fromBuffer(hash.slice(0, 32), { size: 32 });
	  var chainCode = hash.slice(32, 64);

	  var publicKey;
	  try {
	    publicKey = PublicKey.fromPoint(Point.getG().mul(leftPart).add(this.publicKey.point));
	  } catch (e) {
	    return this._deriveWithNumber(index + 1)
	  }

	  var derived = new HDPublicKey({
	    network: this.network,
	    depth: this.depth + 1,
	    parentFingerPrint: this.fingerPrint,
	    childIndex: index,
	    chainCode: chainCode,
	    publicKey: publicKey
	  });

	  return derived
	};

	HDPublicKey.prototype._deriveFromString = function (path) {
	  if (_.includes(path, "'")) {
	    throw new hdErrors.InvalidIndexCantDeriveHardened()
	  } else if (!HDPublicKey.isValidPath(path)) {
	    throw new hdErrors.InvalidPath(path)
	  }

	  var indexes = HDPrivateKey._getDerivationIndexes(path);
	  var derived = indexes.reduce(function (prev, index) {
	    return prev._deriveWithNumber(index)
	  }, this);

	  return derived
	};

	/**
	 * Verifies that a given serialized public key in base58 with checksum format
	 * is valid.
	 *
	 * @param {string|Buffer} data - the serialized public key
	 * @param {string|Network=} network - optional, if present, checks that the
	 *     network provided matches the network serialized.
	 * @return {boolean}
	 */
	HDPublicKey.isValidSerialized = function (data, network) {
	  return _.isNull(HDPublicKey.getSerializedError(data, network))
	};

	/**
	 * Checks what's the error that causes the validation of a serialized public key
	 * in base58 with checksum to fail.
	 *
	 * @param {string|Buffer} data - the serialized public key
	 * @param {string|Network=} network - optional, if present, checks that the
	 *     network provided matches the network serialized.
	 * @return {errors|null}
	 */
	HDPublicKey.getSerializedError = function (data, network) {
	  if (!(_.isString(data) || isBuffer$2(data))) {
	    return new hdErrors.UnrecognizedArgument('expected buffer or string')
	  }
	  if (!Base58.validCharacters(data)) {
	    return new errors.InvalidB58Char('(unknown)', data)
	  }
	  try {
	    data = Base58Check.decode(data);
	  } catch (e) {
	    return new errors.InvalidB58Checksum(data)
	  }
	  if (data.length !== HDPublicKey.DataSize) {
	    return new hdErrors.InvalidLength(data)
	  }
	  if (!_.isUndefined(network)) {
	    var error = HDPublicKey._validateNetwork(data, network);
	    if (error) {
	      return error
	    }
	  }
	  var version = data.readUInt32BE(0);
	  if (version === Network.livenet.xprivkey || version === Network.testnet.xprivkey) {
	    return new hdErrors.ArgumentIsPrivateExtended()
	  }
	  return null
	};

	HDPublicKey._validateNetwork = function (data, networkArg) {
	  var network = Network.get(networkArg);
	  if (!network) {
	    return new errors.InvalidNetworkArgument(networkArg)
	  }
	  var version = data.slice(HDPublicKey.VersionStart, HDPublicKey.VersionEnd);
	  if (version.readUInt32BE(0) !== network.xpubkey) {
	    return new errors.InvalidNetwork(version)
	  }
	  return null
	};

	HDPublicKey.prototype._buildFromPrivate = function (arg) {
	  var args = _.clone(arg._buffers);
	  var point = Point.getG().mul(BN.fromBuffer(args.privateKey));
	  args.publicKey = Point.pointToCompressed(point);
	  args.version = JSUtil.integerAsBuffer(Network.get(args.version.readUInt32BE(0)).xpubkey);
	  args.privateKey = undefined;
	  args.checksum = undefined;
	  args.xprivkey = undefined;
	  return this._buildFromBuffers(args)
	};

	HDPublicKey.prototype._buildFromObject = function (arg) {
	  // TODO: Type validation
	  var buffers = {
	    version: arg.network ? JSUtil.integerAsBuffer(Network.get(arg.network).xpubkey) : arg.version,
	    depth: _.isNumber(arg.depth) ? Buffer.from([arg.depth & 0xff]) : arg.depth,
	    parentFingerPrint: _.isNumber(arg.parentFingerPrint) ? JSUtil.integerAsBuffer(arg.parentFingerPrint) : arg.parentFingerPrint,
	    childIndex: _.isNumber(arg.childIndex) ? JSUtil.integerAsBuffer(arg.childIndex) : arg.childIndex,
	    chainCode: _.isString(arg.chainCode) ? Buffer.from(arg.chainCode, 'hex') : arg.chainCode,
	    publicKey: _.isString(arg.publicKey) ? Buffer.from(arg.publicKey, 'hex')
	      : isBuffer$2(arg.publicKey) ? arg.publicKey : arg.publicKey.toBuffer(),
	    checksum: _.isNumber(arg.checksum) ? JSUtil.integerAsBuffer(arg.checksum) : arg.checksum
	  };
	  return this._buildFromBuffers(buffers)
	};

	HDPublicKey.prototype._buildFromSerialized = function (arg) {
	  var decoded = Base58Check.decode(arg);
	  var buffers = {
	    version: decoded.slice(HDPublicKey.VersionStart, HDPublicKey.VersionEnd),
	    depth: decoded.slice(HDPublicKey.DepthStart, HDPublicKey.DepthEnd),
	    parentFingerPrint: decoded.slice(HDPublicKey.ParentFingerPrintStart,
	      HDPublicKey.ParentFingerPrintEnd),
	    childIndex: decoded.slice(HDPublicKey.ChildIndexStart, HDPublicKey.ChildIndexEnd),
	    chainCode: decoded.slice(HDPublicKey.ChainCodeStart, HDPublicKey.ChainCodeEnd),
	    publicKey: decoded.slice(HDPublicKey.PublicKeyStart, HDPublicKey.PublicKeyEnd),
	    checksum: decoded.slice(HDPublicKey.ChecksumStart, HDPublicKey.ChecksumEnd),
	    xpubkey: arg
	  };
	  return this._buildFromBuffers(buffers)
	};

	/**
	 * Receives a object with buffers in all the properties and populates the
	 * internal structure
	 *
	 * @param {Object} arg
	 * @param {buffer.Buffer} arg.version
	 * @param {buffer.Buffer} arg.depth
	 * @param {buffer.Buffer} arg.parentFingerPrint
	 * @param {buffer.Buffer} arg.childIndex
	 * @param {buffer.Buffer} arg.chainCode
	 * @param {buffer.Buffer} arg.publicKey
	 * @param {buffer.Buffer} arg.checksum
	 * @param {string=} arg.xpubkey - if set, don't recalculate the base58
	 *      representation
	 * @return {HDPublicKey} this
	 */
	HDPublicKey.prototype._buildFromBuffers = function (arg) {
	  HDPublicKey._validateBufferArguments(arg);

	  JSUtil.defineImmutable(this, {
	    _buffers: arg
	  });

	  var sequence = [
	    arg.version, arg.depth, arg.parentFingerPrint, arg.childIndex, arg.chainCode,
	    arg.publicKey
	  ];
	  var concat = Buffer.concat(sequence);
	  var checksum = Base58Check.checksum(concat);
	  if (!arg.checksum || !arg.checksum.length) {
	    arg.checksum = checksum;
	  } else {
	    if (arg.checksum.toString('hex') !== checksum.toString('hex')) {
	      throw new errors.InvalidB58Checksum(concat, checksum)
	    }
	  }
	  var network = Network.get(arg.version.readUInt32BE(0));

	  var xpubkey;
	  xpubkey = Base58Check.encode(Buffer.concat(sequence));
	  arg.xpubkey = Buffer.from(xpubkey);

	  var publicKey = new PublicKey(arg.publicKey, { network: network });
	  var size = HDPublicKey.ParentFingerPrintSize;
	  var fingerPrint = Hash.sha256ripemd160(publicKey.toBuffer()).slice(0, size);

	  JSUtil.defineImmutable(this, {
	    xpubkey: xpubkey,
	    network: network,
	    depth: arg.depth[0],
	    publicKey: publicKey,
	    fingerPrint: fingerPrint
	  });

	  return this
	};

	HDPublicKey._validateBufferArguments = function (arg) {
	  var checkBuffer = function (name, size) {
	    var buff = arg[name];
	    assert(isBuffer$2(buff), name + ' argument is not a buffer, it\'s ' + typeof buff);
	    assert(
	      buff.length === size,
	      name + ' has not the expected size: found ' + buff.length + ', expected ' + size
	    );
	  };
	  checkBuffer('version', HDPublicKey.VersionSize);
	  checkBuffer('depth', HDPublicKey.DepthSize);
	  checkBuffer('parentFingerPrint', HDPublicKey.ParentFingerPrintSize);
	  checkBuffer('childIndex', HDPublicKey.ChildIndexSize);
	  checkBuffer('chainCode', HDPublicKey.ChainCodeSize);
	  checkBuffer('publicKey', HDPublicKey.PublicKeySize);
	  if (arg.checksum && arg.checksum.length) {
	    checkBuffer('checksum', HDPublicKey.CheckSumSize);
	  }
	};

	HDPublicKey.fromString = function (arg) {
	  $.checkArgument(_.isString(arg), 'No valid string was provided');
	  return new HDPublicKey(arg)
	};

	HDPublicKey.fromObject = function (arg) {
	  $.checkArgument(_.isObject(arg), 'No valid argument was provided');
	  return new HDPublicKey(arg)
	};

	/**
	 * Returns the base58 checked representation of the public key
	 * @return {string} a string starting with "xpub..." in livenet
	 */
	HDPublicKey.prototype.toString = function () {
	  return this.xpubkey
	};

	/**
	 * Returns the console representation of this extended public key.
	 * @return string
	 */
	HDPublicKey.prototype.inspect = function () {
	  return '<HDPublicKey: ' + this.xpubkey + '>'
	};

	/**
	 * Returns a plain JavaScript object with information to reconstruct a key.
	 *
	 * Fields are: <ul>
	 *  <li> network: 'livenet' or 'testnet'
	 *  <li> depth: a number from 0 to 255, the depth to the master extended key
	 *  <li> fingerPrint: a number of 32 bits taken from the hash of the public key
	 *  <li> fingerPrint: a number of 32 bits taken from the hash of this key's
	 *  <li>     parent's public key
	 *  <li> childIndex: index with which this key was derived
	 *  <li> chainCode: string in hexa encoding used for derivation
	 *  <li> publicKey: string, hexa encoded, in compressed key format
	 *  <li> checksum: this._buffers.checksum.readUInt32BE(0),
	 *  <li> xpubkey: the string with the base58 representation of this extended key
	 *  <li> checksum: the base58 checksum of xpubkey
	 * </ul>
	 */
	HDPublicKey.prototype.toObject = HDPublicKey.prototype.toJSON = function toObject () {
	  return {
	    network: Network.get(this._buffers.version.readUInt32BE(0)).name,
	    depth: this._buffers.depth[0],
	    fingerPrint: this.fingerPrint.readUInt32BE(0),
	    parentFingerPrint: this._buffers.parentFingerPrint.readUInt32BE(0),
	    childIndex: this._buffers.childIndex.readUInt32BE(0),
	    chainCode: this._buffers.chainCode.toString('hex'),
	    publicKey: this.publicKey.toString(),
	    checksum: this._buffers.checksum.readUInt32BE(0),
	    xpubkey: this.xpubkey
	  }
	};

	/**
	 * Create a HDPublicKey from a buffer argument
	 *
	 * @param {Buffer} arg
	 * @return {HDPublicKey}
	 */
	HDPublicKey.fromBuffer = function (arg) {
	  return new HDPublicKey(arg)
	};

	/**
	 * Create a HDPublicKey from a hex string argument
	 *
	 * @param {Buffer} arg
	 * @return {HDPublicKey}
	 */
	HDPublicKey.fromHex = function (hex) {
	  return HDPublicKey.fromBuffer(Buffer.from(hex, 'hex'))
	};

	/**
	 * Return a buffer representation of the xpubkey
	 *
	 * @return {Buffer}
	 */
	HDPublicKey.prototype.toBuffer = function () {
	  return Buffer.from(this._buffers.xpubkey)
	};

	/**
	 * Return a hex string representation of the xpubkey
	 *
	 * @return {Buffer}
	 */
	HDPublicKey.prototype.toHex = function () {
	  return this.toBuffer().toString('hex')
	};

	HDPublicKey.Hardened = 0x80000000;
	HDPublicKey.RootElementAlias = ['m', 'M'];

	HDPublicKey.VersionSize = 4;
	HDPublicKey.DepthSize = 1;
	HDPublicKey.ParentFingerPrintSize = 4;
	HDPublicKey.ChildIndexSize = 4;
	HDPublicKey.ChainCodeSize = 32;
	HDPublicKey.PublicKeySize = 33;
	HDPublicKey.CheckSumSize = 4;

	HDPublicKey.DataSize = 78;
	HDPublicKey.SerializedByteSize = 82;

	HDPublicKey.VersionStart = 0;
	HDPublicKey.VersionEnd = HDPublicKey.VersionStart + HDPublicKey.VersionSize;
	HDPublicKey.DepthStart = HDPublicKey.VersionEnd;
	HDPublicKey.DepthEnd = HDPublicKey.DepthStart + HDPublicKey.DepthSize;
	HDPublicKey.ParentFingerPrintStart = HDPublicKey.DepthEnd;
	HDPublicKey.ParentFingerPrintEnd = HDPublicKey.ParentFingerPrintStart + HDPublicKey.ParentFingerPrintSize;
	HDPublicKey.ChildIndexStart = HDPublicKey.ParentFingerPrintEnd;
	HDPublicKey.ChildIndexEnd = HDPublicKey.ChildIndexStart + HDPublicKey.ChildIndexSize;
	HDPublicKey.ChainCodeStart = HDPublicKey.ChildIndexEnd;
	HDPublicKey.ChainCodeEnd = HDPublicKey.ChainCodeStart + HDPublicKey.ChainCodeSize;
	HDPublicKey.PublicKeyStart = HDPublicKey.ChainCodeEnd;
	HDPublicKey.PublicKeyEnd = HDPublicKey.PublicKeyStart + HDPublicKey.PublicKeySize;
	HDPublicKey.ChecksumStart = HDPublicKey.PublicKeyEnd;
	HDPublicKey.ChecksumEnd = HDPublicKey.ChecksumStart + HDPublicKey.CheckSumSize;

	assert(HDPublicKey.PublicKeyEnd === HDPublicKey.DataSize);
	assert(HDPublicKey.ChecksumEnd === HDPublicKey.SerializedByteSize);

	hdpublickey = HDPublicKey;
	return hdpublickey;
}

var hdprivatekey;
var hasRequiredHdprivatekey;

function requireHdprivatekey () {
	if (hasRequiredHdprivatekey) return hdprivatekey;
	hasRequiredHdprivatekey = 1;

	var assert = require$$0$4;
	var buffer = require$$2$1;
	var _ = __1;
	var $ = preconditions;

	var BN = bn$1;
	var Base58 = base58;
	var Base58Check = base58check;
	var Hash = hashExports;
	var Network = networks_1;
	var Point = point;
	var PrivateKey = requirePrivatekey();
	var Random = random;

	var errors = errorsExports;
	var hdErrors = errors.HDPrivateKey;
	var JSUtil = js;

	var MINIMUM_ENTROPY_BITS = 128;
	var BITS_TO_BYTES = 1 / 8;
	var MAXIMUM_ENTROPY_BITS = 512;

	/**
	 * Represents an instance of an hierarchically derived private key.
	 *
	 * More info on https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki
	 *
	 * @constructor
	 * @param {string|Buffer|Object} arg
	 */
	function HDPrivateKey (arg) {
	  if (arg instanceof HDPrivateKey) {
	    return arg
	  }
	  if (!(this instanceof HDPrivateKey)) {
	    return new HDPrivateKey(arg)
	  }
	  if (!arg) {
	    return this._generateRandomly()
	  }

	  if (Network.get(arg)) {
	    return this._generateRandomly(arg)
	  } else if (_.isString(arg) || isBuffer$2(arg)) {
	    if (HDPrivateKey.isValidSerialized(arg)) {
	      this._buildFromSerialized(arg);
	    } else if (JSUtil.isValidJSON(arg)) {
	      this._buildFromJSON(arg);
	    } else if (isBuffer$2(arg) && HDPrivateKey.isValidSerialized(arg.toString())) {
	      this._buildFromSerialized(arg.toString());
	    } else {
	      throw HDPrivateKey.getSerializedError(arg)
	    }
	  } else if (_.isObject(arg)) {
	    this._buildFromObject(arg);
	  } else {
	    throw new hdErrors.UnrecognizedArgument(arg)
	  }
	}

	HDPrivateKey.fromRandom = function () {
	  return new HDPrivateKey()
	};

	/**
	 * Verifies that a given path is valid.
	 *
	 * @param {string|number} arg
	 * @param {boolean?} hardened
	 * @return {boolean}
	 */
	HDPrivateKey.isValidPath = function (arg, hardened) {
	  if (_.isString(arg)) {
	    var indexes = HDPrivateKey._getDerivationIndexes(arg);
	    return indexes !== null && _.every(indexes, HDPrivateKey.isValidPath)
	  }

	  if (_.isNumber(arg)) {
	    if (arg < HDPrivateKey.Hardened && hardened === true) {
	      arg += HDPrivateKey.Hardened;
	    }
	    return arg >= 0 && arg < HDPrivateKey.MaxIndex
	  }

	  return false
	};

	/**
	 * Internal function that splits a string path into a derivation index array.
	 * It will return null if the string path is malformed.
	 * It does not validate if indexes are in bounds.
	 *
	 * @param {string} path
	 * @return {Array}
	 */
	HDPrivateKey._getDerivationIndexes = function (path) {
	  var steps = path.split('/');

	  // Special cases:
	  if (_.includes(HDPrivateKey.RootElementAlias, path)) {
	    return []
	  }

	  if (!_.includes(HDPrivateKey.RootElementAlias, steps[0])) {
	    return null
	  }

	  var indexes = steps.slice(1).map(function (step) {
	    var isHardened = step.slice(-1) === '\'';
	    if (isHardened) {
	      step = step.slice(0, -1);
	    }
	    if (!step || step[0] === '-') {
	      return NaN
	    }
	    var index = +step; // cast to number
	    if (isHardened) {
	      index += HDPrivateKey.Hardened;
	    }

	    return index
	  });

	  return _.some(indexes, isNaN) ? null : indexes
	};

	/**
	 * WARNING: This method is deprecated. Use deriveChild or deriveNonCompliantChild instead. This is not BIP32 compliant
	 *
	 *
	 * Get a derived child based on a string or number.
	 *
	 * If the first argument is a string, it's parsed as the full path of
	 * derivation. Valid values for this argument include "m" (which returns the
	 * same private key), "m/0/1/40/2'/1000", where the ' quote means a hardened
	 * derivation.
	 *
	 * If the first argument is a number, the child with that index will be
	 * derived. If the second argument is truthy, the hardened version will be
	 * derived. See the example usage for clarification.
	 *
	 * @example
	 * ```javascript
	 * var parent = new HDPrivateKey('xprv...');
	 * var child_0_1_2h = parent.derive(0).derive(1).derive(2, true);
	 * var copy_of_child_0_1_2h = parent.derive("m/0/1/2'");
	 * assert(child_0_1_2h.xprivkey === copy_of_child_0_1_2h);
	 * ```
	 *
	 * @param {string|number} arg
	 * @param {boolean?} hardened
	 */
	HDPrivateKey.prototype.derive = function () {
	  throw new Error('derive has been deprecated. use deriveChild or, for the old way, deriveNonCompliantChild.')
	};

	/**
	 * WARNING: This method will not be officially supported until v1.0.0.
	 *
	 *
	 * Get a derived child based on a string or number.
	 *
	 * If the first argument is a string, it's parsed as the full path of
	 * derivation. Valid values for this argument include "m" (which returns the
	 * same private key), "m/0/1/40/2'/1000", where the ' quote means a hardened
	 * derivation.
	 *
	 * If the first argument is a number, the child with that index will be
	 * derived. If the second argument is truthy, the hardened version will be
	 * derived. See the example usage for clarification.
	 *
	 * WARNING: The `nonCompliant` option should NOT be used, except for older implementation
	 * that used a derivation strategy that used a non-zero padded private key.
	 *
	 * @example
	 * ```javascript
	 * var parent = new HDPrivateKey('xprv...');
	 * var child_0_1_2h = parent.deriveChild(0).deriveChild(1).deriveChild(2, true);
	 * var copy_of_child_0_1_2h = parent.deriveChild("m/0/1/2'");
	 * assert(child_0_1_2h.xprivkey === copy_of_child_0_1_2h);
	 * ```
	 *
	 * @param {string|number} arg
	 * @param {boolean?} hardened
	 */
	HDPrivateKey.prototype.deriveChild = function (arg, hardened) {
	  if (_.isNumber(arg)) {
	    return this._deriveWithNumber(arg, hardened)
	  } else if (_.isString(arg)) {
	    return this._deriveFromString(arg)
	  } else {
	    throw new hdErrors.InvalidDerivationArgument(arg)
	  }
	};

	/**
	 * WARNING: This method will not be officially supported until v1.0.0
	 *
	 *
	 * WARNING: If this is a new implementation you should NOT use this method, you should be using
	 * `derive` instead.
	 *
	 * This method is explicitly for use and compatibility with an implementation that
	 * was not compliant with BIP32 regarding the derivation algorithm. The private key
	 * must be 32 bytes hashing, and this implementation will use the non-zero padded
	 * serialization of a private key, such that it's still possible to derive the privateKey
	 * to recover those funds.
	 *
	 * @param {string|number} arg
	 * @param {boolean?} hardened
	 */
	HDPrivateKey.prototype.deriveNonCompliantChild = function (arg, hardened) {
	  if (_.isNumber(arg)) {
	    return this._deriveWithNumber(arg, hardened, true)
	  } else if (_.isString(arg)) {
	    return this._deriveFromString(arg, true)
	  } else {
	    throw new hdErrors.InvalidDerivationArgument(arg)
	  }
	};

	HDPrivateKey.prototype._deriveWithNumber = function (index, hardened, nonCompliant) {
	  if (!HDPrivateKey.isValidPath(index, hardened)) {
	    throw new hdErrors.InvalidPath(index)
	  }

	  hardened = index >= HDPrivateKey.Hardened ? true : hardened;
	  if (index < HDPrivateKey.Hardened && hardened === true) {
	    index += HDPrivateKey.Hardened;
	  }

	  var indexBuffer = JSUtil.integerAsBuffer(index);
	  var data;
	  if (hardened && nonCompliant) {
	    // The private key serialization in this case will not be exactly 32 bytes and can be
	    // any value less, and the value is not zero-padded.
	    var nonZeroPadded = this.privateKey.bn.toBuffer();
	    data = Buffer.concat([buffer.Buffer.from([0]), nonZeroPadded, indexBuffer]);
	  } else if (hardened) {
	    // This will use a 32 byte zero padded serialization of the private key
	    var privateKeyBuffer = this.privateKey.bn.toBuffer({ size: 32 });
	    assert(privateKeyBuffer.length === 32, 'length of private key buffer is expected to be 32 bytes');
	    data = Buffer.concat([buffer.Buffer.from([0]), privateKeyBuffer, indexBuffer]);
	  } else {
	    data = Buffer.concat([this.publicKey.toBuffer(), indexBuffer]);
	  }
	  var hash = Hash.sha512hmac(data, this._buffers.chainCode);
	  var leftPart = BN.fromBuffer(hash.slice(0, 32), {
	    size: 32
	  });
	  var chainCode = hash.slice(32, 64);

	  var privateKey = leftPart.add(this.privateKey.toBigNumber()).umod(Point.getN()).toBuffer({
	    size: 32
	  });

	  if (!PrivateKey.isValid(privateKey)) {
	    // Index at this point is already hardened, we can pass null as the hardened arg
	    return this._deriveWithNumber(index + 1, null, nonCompliant)
	  }

	  var derived = new HDPrivateKey({
	    network: this.network,
	    depth: this.depth + 1,
	    parentFingerPrint: this.fingerPrint,
	    childIndex: index,
	    chainCode: chainCode,
	    privateKey: privateKey
	  });

	  return derived
	};

	HDPrivateKey.prototype._deriveFromString = function (path, nonCompliant) {
	  if (!HDPrivateKey.isValidPath(path)) {
	    throw new hdErrors.InvalidPath(path)
	  }

	  var indexes = HDPrivateKey._getDerivationIndexes(path);
	  var derived = indexes.reduce(function (prev, index) {
	    return prev._deriveWithNumber(index, null, nonCompliant)
	  }, this);

	  return derived
	};

	/**
	 * Verifies that a given serialized private key in base58 with checksum format
	 * is valid.
	 *
	 * @param {string|Buffer} data - the serialized private key
	 * @param {string|Network=} network - optional, if present, checks that the
	 *     network provided matches the network serialized.
	 * @return {boolean}
	 */
	HDPrivateKey.isValidSerialized = function (data, network) {
	  return !HDPrivateKey.getSerializedError(data, network)
	};

	/**
	 * Checks what's the error that causes the validation of a serialized private key
	 * in base58 with checksum to fail.
	 *
	 * @param {string|Buffer} data - the serialized private key
	 * @param {string|Network=} network - optional, if present, checks that the
	 *     network provided matches the network serialized.
	 * @return {errors.InvalidArgument|null}
	 */
	HDPrivateKey.getSerializedError = function (data, network) {
	  if (!(_.isString(data) || isBuffer$2(data))) {
	    return new hdErrors.UnrecognizedArgument('Expected string or buffer')
	  }
	  if (!Base58.validCharacters(data)) {
	    return new errors.InvalidB58Char('(unknown)', data)
	  }
	  try {
	    data = Base58Check.decode(data);
	  } catch (e) {
	    return new errors.InvalidB58Checksum(data)
	  }
	  if (data.length !== HDPrivateKey.DataLength) {
	    return new hdErrors.InvalidLength(data)
	  }
	  if (!_.isUndefined(network)) {
	    var error = HDPrivateKey._validateNetwork(data, network);
	    if (error) {
	      return error
	    }
	  }
	  return null
	};

	HDPrivateKey._validateNetwork = function (data, networkArg) {
	  var network = Network.get(networkArg);
	  if (!network) {
	    return new errors.InvalidNetworkArgument(networkArg)
	  }
	  var version = data.slice(0, 4);
	  if (version.readUInt32BE(0) !== network.xprivkey) {
	    return new errors.InvalidNetwork(version)
	  }
	  return null
	};

	HDPrivateKey.fromString = function (arg) {
	  $.checkArgument(_.isString(arg), 'No valid string was provided');
	  return new HDPrivateKey(arg)
	};

	HDPrivateKey.fromObject = function (arg) {
	  $.checkArgument(_.isObject(arg), 'No valid argument was provided');
	  return new HDPrivateKey(arg)
	};

	HDPrivateKey.prototype._buildFromJSON = function (arg) {
	  return this._buildFromObject(JSON.parse(arg))
	};

	HDPrivateKey.prototype._buildFromObject = function (arg) {
	  // TODO: Type validation
	  var buffers = {
	    version: arg.network ? JSUtil.integerAsBuffer(Network.get(arg.network).xprivkey) : arg.version,
	    depth: _.isNumber(arg.depth) ? Buffer.from([arg.depth & 0xff]) : arg.depth,
	    parentFingerPrint: _.isNumber(arg.parentFingerPrint) ? JSUtil.integerAsBuffer(arg.parentFingerPrint) : arg.parentFingerPrint,
	    childIndex: _.isNumber(arg.childIndex) ? JSUtil.integerAsBuffer(arg.childIndex) : arg.childIndex,
	    chainCode: _.isString(arg.chainCode) ? Buffer.from(arg.chainCode, 'hex') : arg.chainCode,
	    privateKey: (_.isString(arg.privateKey) && JSUtil.isHexa(arg.privateKey)) ? Buffer.from(arg.privateKey, 'hex') : arg.privateKey,
	    checksum: arg.checksum ? (arg.checksum.length ? arg.checksum : JSUtil.integerAsBuffer(arg.checksum)) : undefined
	  };
	  return this._buildFromBuffers(buffers)
	};

	HDPrivateKey.prototype._buildFromSerialized = function (arg) {
	  var decoded = Base58Check.decode(arg);
	  var buffers = {
	    version: decoded.slice(HDPrivateKey.VersionStart, HDPrivateKey.VersionEnd),
	    depth: decoded.slice(HDPrivateKey.DepthStart, HDPrivateKey.DepthEnd),
	    parentFingerPrint: decoded.slice(HDPrivateKey.ParentFingerPrintStart,
	      HDPrivateKey.ParentFingerPrintEnd),
	    childIndex: decoded.slice(HDPrivateKey.ChildIndexStart, HDPrivateKey.ChildIndexEnd),
	    chainCode: decoded.slice(HDPrivateKey.ChainCodeStart, HDPrivateKey.ChainCodeEnd),
	    privateKey: decoded.slice(HDPrivateKey.PrivateKeyStart, HDPrivateKey.PrivateKeyEnd),
	    checksum: decoded.slice(HDPrivateKey.ChecksumStart, HDPrivateKey.ChecksumEnd),
	    xprivkey: arg
	  };
	  return this._buildFromBuffers(buffers)
	};

	HDPrivateKey.prototype._generateRandomly = function (network) {
	  return HDPrivateKey.fromSeed(Random.getRandomBuffer(64), network)
	};

	/**
	 * Generate a private key from a seed, as described in BIP32
	 *
	 * @param {string|Buffer} hexa
	 * @param {*} network
	 * @return HDPrivateKey
	 */
	HDPrivateKey.fromSeed = function (hexa, network) {
	  if (JSUtil.isHexaString(hexa)) {
	    hexa = Buffer.from(hexa, 'hex');
	  }
	  if (!isBuffer$2(hexa)) {
	    throw new hdErrors.InvalidEntropyArgument(hexa)
	  }
	  if (hexa.length < MINIMUM_ENTROPY_BITS * BITS_TO_BYTES) {
	    throw new hdErrors.InvalidEntropyArgument.NotEnoughEntropy(hexa)
	  }
	  if (hexa.length > MAXIMUM_ENTROPY_BITS * BITS_TO_BYTES) {
	    throw new hdErrors.InvalidEntropyArgument.TooMuchEntropy(hexa)
	  }
	  var hash = Hash.sha512hmac(hexa, buffer.Buffer.from('Bitcoin seed'));

	  return new HDPrivateKey({
	    network: Network.get(network) || Network.defaultNetwork,
	    depth: 0,
	    parentFingerPrint: 0,
	    childIndex: 0,
	    privateKey: hash.slice(0, 32),
	    chainCode: hash.slice(32, 64)
	  })
	};

	HDPrivateKey.prototype._calcHDPublicKey = function () {
	  if (!this._hdPublicKey) {
	    var HDPublicKey = requireHdpublickey();
	    this._hdPublicKey = new HDPublicKey(this);
	  }
	};

	/**
	 * Receives a object with buffers in all the properties and populates the
	 * internal structure
	 *
	 * @param {Object} arg
	 * @param {buffer.Buffer} arg.version
	 * @param {buffer.Buffer} arg.depth
	 * @param {buffer.Buffer} arg.parentFingerPrint
	 * @param {buffer.Buffer} arg.childIndex
	 * @param {buffer.Buffer} arg.chainCode
	 * @param {buffer.Buffer} arg.privateKey
	 * @param {buffer.Buffer} arg.checksum
	 * @param {string=} arg.xprivkey - if set, don't recalculate the base58
	 *      representation
	 * @return {HDPrivateKey} this
	 */
	HDPrivateKey.prototype._buildFromBuffers = function (arg) {
	  HDPrivateKey._validateBufferArguments(arg);

	  JSUtil.defineImmutable(this, {
	    _buffers: arg
	  });

	  var sequence = [
	    arg.version, arg.depth, arg.parentFingerPrint, arg.childIndex, arg.chainCode,
	    Buffer.alloc(1), arg.privateKey
	  ];
	  var concat = buffer.Buffer.concat(sequence);
	  if (!arg.checksum || !arg.checksum.length) {
	    arg.checksum = Base58Check.checksum(concat);
	  } else {
	    if (arg.checksum.toString() !== Base58Check.checksum(concat).toString()) {
	      throw new errors.InvalidB58Checksum(concat)
	    }
	  }

	  var network = Network.get(arg.version.readUInt32BE(0));
	  var xprivkey;
	  xprivkey = Base58Check.encode(buffer.Buffer.concat(sequence));
	  arg.xprivkey = Buffer.from(xprivkey);

	  var privateKey = new PrivateKey(BN.fromBuffer(arg.privateKey), network);
	  var publicKey = privateKey.toPublicKey();
	  var size = HDPrivateKey.ParentFingerPrintSize;
	  var fingerPrint = Hash.sha256ripemd160(publicKey.toBuffer()).slice(0, size);

	  JSUtil.defineImmutable(this, {
	    xprivkey: xprivkey,
	    network: network,
	    depth: arg.depth[0],
	    privateKey: privateKey,
	    publicKey: publicKey,
	    fingerPrint: fingerPrint
	  });

	  this._hdPublicKey = null;

	  Object.defineProperty(this, 'hdPublicKey', {
	    configurable: false,
	    enumerable: true,
	    get: function () {
	      this._calcHDPublicKey();
	      return this._hdPublicKey
	    }
	  });
	  Object.defineProperty(this, 'xpubkey', {
	    configurable: false,
	    enumerable: true,
	    get: function () {
	      this._calcHDPublicKey();
	      return this._hdPublicKey.xpubkey
	    }
	  });
	  return this
	};

	HDPrivateKey._validateBufferArguments = function (arg) {
	  var checkBuffer = function (name, size) {
	    var buff = arg[name];
	    assert(isBuffer$2(buff), name + ' argument is not a buffer');
	    assert(
	      buff.length === size,
	      name + ' has not the expected size: found ' + buff.length + ', expected ' + size
	    );
	  };
	  checkBuffer('version', HDPrivateKey.VersionSize);
	  checkBuffer('depth', HDPrivateKey.DepthSize);
	  checkBuffer('parentFingerPrint', HDPrivateKey.ParentFingerPrintSize);
	  checkBuffer('childIndex', HDPrivateKey.ChildIndexSize);
	  checkBuffer('chainCode', HDPrivateKey.ChainCodeSize);
	  checkBuffer('privateKey', HDPrivateKey.PrivateKeySize);
	  if (arg.checksum && arg.checksum.length) {
	    checkBuffer('checksum', HDPrivateKey.CheckSumSize);
	  }
	};

	/**
	 * Returns the string representation of this private key (a string starting
	 * with "xprv..."
	 *
	 * @return string
	 */
	HDPrivateKey.prototype.toString = function () {
	  return this.xprivkey
	};

	/**
	 * Returns the console representation of this extended private key.
	 * @return string
	 */
	HDPrivateKey.prototype.inspect = function () {
	  return '<HDPrivateKey: ' + this.xprivkey + '>'
	};

	/**
	 * Returns a plain object with a representation of this private key.
	 *
	 * Fields include:<ul>
	 * <li> network: either 'livenet' or 'testnet'
	 * <li> depth: a number ranging from 0 to 255
	 * <li> fingerPrint: a number ranging from 0 to 2^32-1, taken from the hash of the
	 * <li>     associated public key
	 * <li> parentFingerPrint: a number ranging from 0 to 2^32-1, taken from the hash
	 * <li>     of this parent's associated public key or zero.
	 * <li> childIndex: the index from which this child was derived (or zero)
	 * <li> chainCode: an hexa string representing a number used in the derivation
	 * <li> privateKey: the private key associated, in hexa representation
	 * <li> xprivkey: the representation of this extended private key in checksum
	 * <li>     base58 format
	 * <li> checksum: the base58 checksum of xprivkey
	 * </ul>
	 *  @return {Object}
	 */
	HDPrivateKey.prototype.toObject = HDPrivateKey.prototype.toJSON = function toObject () {
	  return {
	    network: Network.get(this._buffers.version.readUInt32BE(0), 'xprivkey').name,
	    depth: this._buffers.depth[0],
	    fingerPrint: this.fingerPrint.readUInt32BE(0),
	    parentFingerPrint: this._buffers.parentFingerPrint.readUInt32BE(0),
	    childIndex: this._buffers.childIndex.readUInt32BE(0),
	    chainCode: this._buffers.chainCode.toString('hex'),
	    privateKey: this.privateKey.toBuffer().toString('hex'),
	    checksum: this._buffers.checksum.readUInt32BE(0),
	    xprivkey: this.xprivkey
	  }
	};

	/**
	 * Build a HDPrivateKey from a buffer
	 *
	 * @param {Buffer} arg
	 * @return {HDPrivateKey}
	 */
	HDPrivateKey.fromBuffer = function (buf) {
	  return new HDPrivateKey(buf.toString())
	};

	/**
	 * Build a HDPrivateKey from a hex string
	 *
	 * @param {string} hex
	 * @return {HDPrivateKey}
	 */
	HDPrivateKey.fromHex = function (hex) {
	  return HDPrivateKey.fromBuffer(Buffer.from(hex, 'hex'))
	};

	/**
	 * Returns a buffer representation of the HDPrivateKey
	 *
	 * @return {string}
	 */
	HDPrivateKey.prototype.toBuffer = function () {
	  return Buffer.from(this.toString())
	};

	/**
	 * Returns a hex string representation of the HDPrivateKey
	 *
	 * @return {string}
	 */
	HDPrivateKey.prototype.toHex = function () {
	  return this.toBuffer().toString('hex')
	};

	HDPrivateKey.DefaultDepth = 0;
	HDPrivateKey.DefaultFingerprint = 0;
	HDPrivateKey.DefaultChildIndex = 0;
	HDPrivateKey.Hardened = 0x80000000;
	HDPrivateKey.MaxIndex = 2 * HDPrivateKey.Hardened;

	HDPrivateKey.RootElementAlias = ['m', 'M', 'm\'', 'M\''];

	HDPrivateKey.VersionSize = 4;
	HDPrivateKey.DepthSize = 1;
	HDPrivateKey.ParentFingerPrintSize = 4;
	HDPrivateKey.ChildIndexSize = 4;
	HDPrivateKey.ChainCodeSize = 32;
	HDPrivateKey.PrivateKeySize = 32;
	HDPrivateKey.CheckSumSize = 4;

	HDPrivateKey.DataLength = 78;
	HDPrivateKey.SerializedByteSize = 82;

	HDPrivateKey.VersionStart = 0;
	HDPrivateKey.VersionEnd = HDPrivateKey.VersionStart + HDPrivateKey.VersionSize;
	HDPrivateKey.DepthStart = HDPrivateKey.VersionEnd;
	HDPrivateKey.DepthEnd = HDPrivateKey.DepthStart + HDPrivateKey.DepthSize;
	HDPrivateKey.ParentFingerPrintStart = HDPrivateKey.DepthEnd;
	HDPrivateKey.ParentFingerPrintEnd = HDPrivateKey.ParentFingerPrintStart + HDPrivateKey.ParentFingerPrintSize;
	HDPrivateKey.ChildIndexStart = HDPrivateKey.ParentFingerPrintEnd;
	HDPrivateKey.ChildIndexEnd = HDPrivateKey.ChildIndexStart + HDPrivateKey.ChildIndexSize;
	HDPrivateKey.ChainCodeStart = HDPrivateKey.ChildIndexEnd;
	HDPrivateKey.ChainCodeEnd = HDPrivateKey.ChainCodeStart + HDPrivateKey.ChainCodeSize;
	HDPrivateKey.PrivateKeyStart = HDPrivateKey.ChainCodeEnd + 1;
	HDPrivateKey.PrivateKeyEnd = HDPrivateKey.PrivateKeyStart + HDPrivateKey.PrivateKeySize;
	HDPrivateKey.ChecksumStart = HDPrivateKey.PrivateKeyEnd;
	HDPrivateKey.ChecksumEnd = HDPrivateKey.ChecksumStart + HDPrivateKey.CheckSumSize;

	assert(HDPrivateKey.ChecksumEnd === HDPrivateKey.SerializedByteSize);

	hdprivatekey = HDPrivateKey;
	return hdprivatekey;
}

(function (module) {

	var mvc = module.exports;

	// module information
	mvc.version = 'v' + require$$0$3.version;
	mvc.versionGuard = function (version) {
	  if (version !== undefined) {
	    var message = `
      More than one instance of mvc found.
      Please make sure to require mvc and check that submodules do
      not also include their own mvc dependency.`;
	    console.warn(message);
	  }
	};
	mvc.versionGuard(commonjsGlobal._mvc);
	commonjsGlobal._mvc = mvc.version;

	// crypto
	mvc.crypto = {};
	mvc.crypto.BN = bn$1;
	mvc.crypto.ECDSA = requireEcdsa();
	mvc.crypto.Hash = hashExports;
	mvc.crypto.Random = random;
	mvc.crypto.Point = point;
	mvc.crypto.Signature = signature$1;

	// encoding
	mvc.encoding = {};
	mvc.encoding.Base58 = base58;
	mvc.encoding.Base58Check = base58check;
	mvc.encoding.BufferReader = bufferreader;
	mvc.encoding.BufferWriter = bufferwriter;
	mvc.encoding.Varint = varint;

	// utilities
	mvc.util = {};
	mvc.util.js = js;
	mvc.util.preconditions = preconditions;

	// errors thrown by the library
	mvc.errors = errorsExports;

	// main bitcoin library
	mvc.Address = requireAddress();
	mvc.Block = blockExports;
	mvc.MerkleBlock = merkleblock;
	mvc.BlockHeader = blockheader;
	mvc.HDPrivateKey = requireHdprivatekey();
	mvc.HDPublicKey = requireHdpublickey();
	mvc.Networks = networks_1;
	mvc.Opcode = opcode;
	mvc.PrivateKey = requirePrivatekey();
	mvc.PublicKey = requirePublickey();
	mvc.Script = requireScript();
	mvc.Transaction = requireTransaction();

	// dependencies, subject to change
	mvc.deps = {};
	mvc.deps.bnjs = bnExports$1;
	mvc.deps.bs58 = bs58$1;
	mvc.deps.Buffer = Buffer;
	mvc.deps.elliptic = elliptic;
	mvc.deps._ = __1;

	// Internal usage, exposed for testing/advanced tweaking
	mvc.Transaction.sighash = requireSighash(); 
} (mvcLib));

var mvcLibExports = mvcLib.exports;

/* eslint-disable no-use-before-define */

/**
 * Base class for inheritance.
 */
class Base {
  /**
   * Extends this object and runs the init method.
   * Arguments to create() will be passed to init().
   *
   * @return {Object} The new object.
   *
   * @static
   *
   * @example
   *
   *     var instance = MyType.create();
   */
  static create(...args) {
    return new this(...args);
  }

  /**
   * Copies properties into this object.
   *
   * @param {Object} properties The properties to mix in.
   *
   * @example
   *
   *     MyType.mixIn({
   *         field: 'value'
   *     });
   */
  mixIn(properties) {
    return Object.assign(this, properties);
  }

  /**
   * Creates a copy of this object.
   *
   * @return {Object} The clone.
   *
   * @example
   *
   *     var clone = instance.clone();
   */
  clone() {
    const clone = new this.constructor();
    Object.assign(clone, this);
    return clone;
  }
}

/**
 * An array of 32-bit words.
 *
 * @property {Array} words The array of 32-bit words.
 * @property {number} sigBytes The number of significant bytes in this word array.
 */
class WordArray extends Base {
  /**
   * Initializes a newly created word array.
   *
   * @param {Array} words (Optional) An array of 32-bit words.
   * @param {number} sigBytes (Optional) The number of significant bytes in the words.
   *
   * @example
   *
   *     var wordArray = CryptoJS.lib.WordArray.create();
   *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
   *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
   */
  constructor(words = [], sigBytes = words.length * 4) {
    super();

    let typedArray = words;
    // Convert buffers to uint8
    if (typedArray instanceof ArrayBuffer) {
      typedArray = new Uint8Array(typedArray);
    }

    // Convert other array views to uint8
    if (
      typedArray instanceof Int8Array
      || typedArray instanceof Uint8ClampedArray
      || typedArray instanceof Int16Array
      || typedArray instanceof Uint16Array
      || typedArray instanceof Int32Array
      || typedArray instanceof Uint32Array
      || typedArray instanceof Float32Array
      || typedArray instanceof Float64Array
    ) {
      typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
    }

    // Handle Uint8Array
    if (typedArray instanceof Uint8Array) {
      // Shortcut
      const typedArrayByteLength = typedArray.byteLength;

      // Extract bytes
      const _words = [];
      for (let i = 0; i < typedArrayByteLength; i += 1) {
        _words[i >>> 2] |= typedArray[i] << (24 - (i % 4) * 8);
      }

      // Initialize this word array
      this.words = _words;
      this.sigBytes = typedArrayByteLength;
    } else {
      // Else call normal init
      this.words = words;
      this.sigBytes = sigBytes;
    }
  }

  /**
   * Creates a word array filled with random bytes.
   *
   * @param {number} nBytes The number of random bytes to generate.
   *
   * @return {WordArray} The random word array.
   *
   * @static
   *
   * @example
   *
   *     var wordArray = CryptoJS.lib.WordArray.random(16);
   */
  static random(nBytes) {
    const words = [];

    const r = (m_w) => {
      let _m_w = m_w;
      let _m_z = 0x3ade68b1;
      const mask = 0xffffffff;

      return () => {
        _m_z = (0x9069 * (_m_z & 0xFFFF) + (_m_z >> 0x10)) & mask;
        _m_w = (0x4650 * (_m_w & 0xFFFF) + (_m_w >> 0x10)) & mask;
        let result = ((_m_z << 0x10) + _m_w) & mask;
        result /= 0x100000000;
        result += 0.5;
        return result * (Math.random() > 0.5 ? 1 : -1);
      };
    };

    for (let i = 0, rcache; i < nBytes; i += 4) {
      const _r = r((rcache || Math.random()) * 0x100000000);

      rcache = _r() * 0x3ade67b7;
      words.push((_r() * 0x100000000) | 0);
    }

    return new WordArray(words, nBytes);
  }

  /**
   * Converts this word array to a string.
   *
   * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
   *
   * @return {string} The stringified word array.
   *
   * @example
   *
   *     var string = wordArray + '';
   *     var string = wordArray.toString();
   *     var string = wordArray.toString(CryptoJS.enc.Utf8);
   */
  toString(encoder = Hex) {
    return encoder.stringify(this);
  }

  /**
   * Concatenates a word array to this word array.
   *
   * @param {WordArray} wordArray The word array to append.
   *
   * @return {WordArray} This word array.
   *
   * @example
   *
   *     wordArray1.concat(wordArray2);
   */
  concat(wordArray) {
    // Shortcuts
    const thisWords = this.words;
    const thatWords = wordArray.words;
    const thisSigBytes = this.sigBytes;
    const thatSigBytes = wordArray.sigBytes;

    // Clamp excess bits
    this.clamp();

    // Concat
    if (thisSigBytes % 4) {
      // Copy one byte at a time
      for (let i = 0; i < thatSigBytes; i += 1) {
        const thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
        thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
      }
    } else {
      // Copy one word at a time
      for (let i = 0; i < thatSigBytes; i += 4) {
        thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
      }
    }
    this.sigBytes += thatSigBytes;

    // Chainable
    return this;
  }

  /**
   * Removes insignificant bits.
   *
   * @example
   *
   *     wordArray.clamp();
   */
  clamp() {
    // Shortcuts
    const { words, sigBytes } = this;

    // Clamp
    words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
    words.length = Math.ceil(sigBytes / 4);
  }

  /**
   * Creates a copy of this word array.
   *
   * @return {WordArray} The clone.
   *
   * @example
   *
   *     var clone = wordArray.clone();
   */
  clone() {
    const clone = super.clone.call(this);
    clone.words = this.words.slice(0);

    return clone;
  }
}

/**
 * Hex encoding strategy.
 */
const Hex = {
  /**
   * Converts a word array to a hex string.
   *
   * @param {WordArray} wordArray The word array.
   *
   * @return {string} The hex string.
   *
   * @static
   *
   * @example
   *
   *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
   */
  stringify(wordArray) {
    // Shortcuts
    const { words, sigBytes } = wordArray;

    // Convert
    const hexChars = [];
    for (let i = 0; i < sigBytes; i += 1) {
      const bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
      hexChars.push((bite >>> 4).toString(16));
      hexChars.push((bite & 0x0f).toString(16));
    }

    return hexChars.join('');
  },

  /**
   * Converts a hex string to a word array.
   *
   * @param {string} hexStr The hex string.
   *
   * @return {WordArray} The word array.
   *
   * @static
   *
   * @example
   *
   *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
   */
  parse(hexStr) {
    // Shortcut
    const hexStrLength = hexStr.length;

    // Convert
    const words = [];
    for (let i = 0; i < hexStrLength; i += 2) {
      words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
    }

    return new WordArray(words, hexStrLength / 2);
  },
};

/**
 * Latin1 encoding strategy.
 */
const Latin1 = {
  /**
   * Converts a word array to a Latin1 string.
   *
   * @param {WordArray} wordArray The word array.
   *
   * @return {string} The Latin1 string.
   *
   * @static
   *
   * @example
   *
   *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
   */
  stringify(wordArray) {
    // Shortcuts
    const { words, sigBytes } = wordArray;

    // Convert
    const latin1Chars = [];
    for (let i = 0; i < sigBytes; i += 1) {
      const bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
      latin1Chars.push(String.fromCharCode(bite));
    }

    return latin1Chars.join('');
  },

  /**
   * Converts a Latin1 string to a word array.
   *
   * @param {string} latin1Str The Latin1 string.
   *
   * @return {WordArray} The word array.
   *
   * @static
   *
   * @example
   *
   *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
   */
  parse(latin1Str) {
    // Shortcut
    const latin1StrLength = latin1Str.length;

    // Convert
    const words = [];
    for (let i = 0; i < latin1StrLength; i += 1) {
      words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
    }

    return new WordArray(words, latin1StrLength);
  },
};

/**
 * UTF-8 encoding strategy.
 */
const Utf8 = {
  /**
   * Converts a word array to a UTF-8 string.
   *
   * @param {WordArray} wordArray The word array.
   *
   * @return {string} The UTF-8 string.
   *
   * @static
   *
   * @example
   *
   *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
   */
  stringify(wordArray) {
    try {
      return decodeURIComponent(escape(Latin1.stringify(wordArray)));
    } catch (e) {
      throw new Error('Malformed UTF-8 data');
    }
  },

  /**
   * Converts a UTF-8 string to a word array.
   *
   * @param {string} utf8Str The UTF-8 string.
   *
   * @return {WordArray} The word array.
   *
   * @static
   *
   * @example
   *
   *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
   */
  parse(utf8Str) {
    return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
  },
};

/**
 * Abstract buffered block algorithm template.
 *
 * The property blockSize must be implemented in a concrete subtype.
 *
 * @property {number} _minBufferSize
 *
 *     The number of blocks that should be kept unprocessed in the buffer. Default: 0
 */
class BufferedBlockAlgorithm extends Base {
  constructor() {
    super();
    this._minBufferSize = 0;
  }

  /**
   * Resets this block algorithm's data buffer to its initial state.
   *
   * @example
   *
   *     bufferedBlockAlgorithm.reset();
   */
  reset() {
    // Initial values
    this._data = new WordArray();
    this._nDataBytes = 0;
  }

  /**
   * Adds new data to this block algorithm's buffer.
   *
   * @param {WordArray|string} data
   *
   *     The data to append. Strings are converted to a WordArray using UTF-8.
   *
   * @example
   *
   *     bufferedBlockAlgorithm._append('data');
   *     bufferedBlockAlgorithm._append(wordArray);
   */
  _append(data) {
    let m_data = data;

    // Convert string to WordArray, else assume WordArray already
    if (typeof m_data === 'string') {
      m_data = Utf8.parse(m_data);
    }

    // Append
    this._data.concat(m_data);
    this._nDataBytes += m_data.sigBytes;
  }

  /**
   * Processes available data blocks.
   *
   * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
   *
   * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
   *
   * @return {WordArray} The processed data.
   *
   * @example
   *
   *     var processedData = bufferedBlockAlgorithm._process();
   *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
   */
  _process(doFlush) {
    let processedWords;

    // Shortcuts
    const { _data: data, blockSize } = this;
    const dataWords = data.words;
    const dataSigBytes = data.sigBytes;
    const blockSizeBytes = blockSize * 4;

    // Count blocks ready
    let nBlocksReady = dataSigBytes / blockSizeBytes;
    if (doFlush) {
      // Round up to include partial blocks
      nBlocksReady = Math.ceil(nBlocksReady);
    } else {
      // Round down to include only full blocks,
      // less the number of blocks that must remain in the buffer
      nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
    }

    // Count words ready
    const nWordsReady = nBlocksReady * blockSize;

    // Count bytes ready
    const nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

    // Process blocks
    if (nWordsReady) {
      for (let offset = 0; offset < nWordsReady; offset += blockSize) {
        // Perform concrete-algorithm logic
        this._doProcessBlock(dataWords, offset);
      }

      // Remove processed words
      processedWords = dataWords.splice(0, nWordsReady);
      data.sigBytes -= nBytesReady;
    }

    // Return processed words
    return new WordArray(processedWords, nBytesReady);
  }

  /**
   * Creates a copy of this object.
   *
   * @return {Object} The clone.
   *
   * @example
   *
   *     var clone = bufferedBlockAlgorithm.clone();
   */
  clone() {
    const clone = super.clone.call(this);
    clone._data = this._data.clone();

    return clone;
  }
}

/**
 * Abstract hasher template.
 *
 * @property {number} blockSize
 *
 *     The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
 */
class Hasher extends BufferedBlockAlgorithm {
  constructor(cfg) {
    super();

    this.blockSize = 512 / 32;

    /**
     * Configuration options.
     */
    this.cfg = Object.assign(new Base(), cfg);

    // Set initial values
    this.reset();
  }

  /**
   * Creates a shortcut function to a hasher's object interface.
   *
   * @param {Hasher} SubHasher The hasher to create a helper for.
   *
   * @return {Function} The shortcut function.
   *
   * @static
   *
   * @example
   *
   *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
   */
  static _createHelper(SubHasher) {
    return (message, cfg) => new SubHasher(cfg).finalize(message);
  }

  /**
   * Creates a shortcut function to the HMAC's object interface.
   *
   * @param {Hasher} SubHasher The hasher to use in this HMAC helper.
   *
   * @return {Function} The shortcut function.
   *
   * @static
   *
   * @example
   *
   *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
   */
  static _createHmacHelper(SubHasher) {
    return (message, key) => new HMAC(SubHasher, key).finalize(message);
  }

  /**
   * Resets this hasher to its initial state.
   *
   * @example
   *
   *     hasher.reset();
   */
  reset() {
    // Reset data buffer
    super.reset.call(this);

    // Perform concrete-hasher logic
    this._doReset();
  }

  /**
   * Updates this hasher with a message.
   *
   * @param {WordArray|string} messageUpdate The message to append.
   *
   * @return {Hasher} This hasher.
   *
   * @example
   *
   *     hasher.update('message');
   *     hasher.update(wordArray);
   */
  update(messageUpdate) {
    // Append
    this._append(messageUpdate);

    // Update the hash
    this._process();

    // Chainable
    return this;
  }

  /**
   * Finalizes the hash computation.
   * Note that the finalize operation is effectively a destructive, read-once operation.
   *
   * @param {WordArray|string} messageUpdate (Optional) A final message update.
   *
   * @return {WordArray} The hash.
   *
   * @example
   *
   *     var hash = hasher.finalize();
   *     var hash = hasher.finalize('message');
   *     var hash = hasher.finalize(wordArray);
   */
  finalize(messageUpdate) {
    // Final message update
    if (messageUpdate) {
      this._append(messageUpdate);
    }

    // Perform concrete-hasher logic
    const hash = this._doFinalize();

    return hash;
  }
}

/**
 * HMAC algorithm.
 */
class HMAC extends Base {
  /**
   * Initializes a newly created HMAC.
   *
   * @param {Hasher} SubHasher The hash algorithm to use.
   * @param {WordArray|string} key The secret key.
   *
   * @example
   *
   *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
   */
  constructor(SubHasher, key) {
    super();

    const hasher = new SubHasher();
    this._hasher = hasher;

    // Convert string to WordArray, else assume WordArray already
    let _key = key;
    if (typeof _key === 'string') {
      _key = Utf8.parse(_key);
    }

    // Shortcuts
    const hasherBlockSize = hasher.blockSize;
    const hasherBlockSizeBytes = hasherBlockSize * 4;

    // Allow arbitrary length keys
    if (_key.sigBytes > hasherBlockSizeBytes) {
      _key = hasher.finalize(key);
    }

    // Clamp excess bits
    _key.clamp();

    // Clone key for inner and outer pads
    const oKey = _key.clone();
    this._oKey = oKey;
    const iKey = _key.clone();
    this._iKey = iKey;

    // Shortcuts
    const oKeyWords = oKey.words;
    const iKeyWords = iKey.words;

    // XOR keys with pad constants
    for (let i = 0; i < hasherBlockSize; i += 1) {
      oKeyWords[i] ^= 0x5c5c5c5c;
      iKeyWords[i] ^= 0x36363636;
    }
    oKey.sigBytes = hasherBlockSizeBytes;
    iKey.sigBytes = hasherBlockSizeBytes;

    // Set initial values
    this.reset();
  }

  /**
   * Resets this HMAC to its initial state.
   *
   * @example
   *
   *     hmacHasher.reset();
   */
  reset() {
    // Shortcut
    const hasher = this._hasher;

    // Reset
    hasher.reset();
    hasher.update(this._iKey);
  }

  /**
   * Updates this HMAC with a message.
   *
   * @param {WordArray|string} messageUpdate The message to append.
   *
   * @return {HMAC} This HMAC instance.
   *
   * @example
   *
   *     hmacHasher.update('message');
   *     hmacHasher.update(wordArray);
   */
  update(messageUpdate) {
    this._hasher.update(messageUpdate);

    // Chainable
    return this;
  }

  /**
   * Finalizes the HMAC computation.
   * Note that the finalize operation is effectively a destructive, read-once operation.
   *
   * @param {WordArray|string} messageUpdate (Optional) A final message update.
   *
   * @return {WordArray} The HMAC.
   *
   * @example
   *
   *     var hmac = hmacHasher.finalize();
   *     var hmac = hmacHasher.finalize('message');
   *     var hmac = hmacHasher.finalize(wordArray);
   */
  finalize(messageUpdate) {
    // Shortcut
    const hasher = this._hasher;

    // Compute HMAC
    const innerHash = hasher.finalize(messageUpdate);
    hasher.reset();
    const hmac = hasher.finalize(this._oKey.clone().concat(innerHash));

    return hmac;
  }
}

const parseLoop = (base64Str, base64StrLength, reverseMap) => {
  const words = [];
  let nBytes = 0;
  for (let i = 0; i < base64StrLength; i += 1) {
    if (i % 4) {
      const bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);
      const bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);
      const bitsCombined = bits1 | bits2;
      words[nBytes >>> 2] |= bitsCombined << (24 - (nBytes % 4) * 8);
      nBytes += 1;
    }
  }
  return WordArray.create(words, nBytes);
};

/**
 * Base64 encoding strategy.
 */
const Base64 = {
  /**
   * Converts a word array to a Base64 string.
   *
   * @param {WordArray} wordArray The word array.
   *
   * @return {string} The Base64 string.
   *
   * @static
   *
   * @example
   *
   *     const base64String = CryptoJS.enc.Base64.stringify(wordArray);
   */
  stringify(wordArray) {
    // Shortcuts
    const { words, sigBytes } = wordArray;
    const map = this._map;

    // Clamp excess bits
    wordArray.clamp();

    // Convert
    const base64Chars = [];
    for (let i = 0; i < sigBytes; i += 3) {
      const byte1 = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
      const byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
      const byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;

      const triplet = (byte1 << 16) | (byte2 << 8) | byte3;

      for (let j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j += 1) {
        base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
      }
    }

    // Add padding
    const paddingChar = map.charAt(64);
    if (paddingChar) {
      while (base64Chars.length % 4) {
        base64Chars.push(paddingChar);
      }
    }

    return base64Chars.join('');
  },

  /**
   * Converts a Base64 string to a word array.
   *
   * @param {string} base64Str The Base64 string.
   *
   * @return {WordArray} The word array.
   *
   * @static
   *
   * @example
   *
   *     const wordArray = CryptoJS.enc.Base64.parse(base64String);
   */
  parse(base64Str) {
    // Shortcuts
    let base64StrLength = base64Str.length;
    const map = this._map;
    let reverseMap = this._reverseMap;

    if (!reverseMap) {
      this._reverseMap = [];
      reverseMap = this._reverseMap;
      for (let j = 0; j < map.length; j += 1) {
        reverseMap[map.charCodeAt(j)] = j;
      }
    }

    // Ignore padding
    const paddingChar = map.charAt(64);
    if (paddingChar) {
      const paddingIndex = base64Str.indexOf(paddingChar);
      if (paddingIndex !== -1) {
        base64StrLength = paddingIndex;
      }
    }

    // Convert
    return parseLoop(base64Str, base64StrLength, reverseMap);
  },

  _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
};

// Constants table
const T = [];

// Compute constants
for (let i = 0; i < 64; i += 1) {
  T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
}

const FF = (a, b, c, d, x, s, t) => {
  const n = a + ((b & c) | (~b & d)) + x + t;
  return ((n << s) | (n >>> (32 - s))) + b;
};

const GG = (a, b, c, d, x, s, t) => {
  const n = a + ((b & d) | (c & ~d)) + x + t;
  return ((n << s) | (n >>> (32 - s))) + b;
};

const HH = (a, b, c, d, x, s, t) => {
  const n = a + (b ^ c ^ d) + x + t;
  return ((n << s) | (n >>> (32 - s))) + b;
};

const II = (a, b, c, d, x, s, t) => {
  const n = a + (c ^ (b | ~d)) + x + t;
  return ((n << s) | (n >>> (32 - s))) + b;
};

/**
 * MD5 hash algorithm.
 */
class MD5Algo extends Hasher {
  _doReset() {
    this._hash = new WordArray([
      0x67452301,
      0xefcdab89,
      0x98badcfe,
      0x10325476,
    ]);
  }

  _doProcessBlock(M, offset) {
    const _M = M;

    // Swap endian
    for (let i = 0; i < 16; i += 1) {
      // Shortcuts
      const offset_i = offset + i;
      const M_offset_i = M[offset_i];

      _M[offset_i] = (
        (((M_offset_i << 8) | (M_offset_i >>> 24)) & 0x00ff00ff)
          | (((M_offset_i << 24) | (M_offset_i >>> 8)) & 0xff00ff00)
      );
    }

    // Shortcuts
    const H = this._hash.words;

    const M_offset_0 = _M[offset + 0];
    const M_offset_1 = _M[offset + 1];
    const M_offset_2 = _M[offset + 2];
    const M_offset_3 = _M[offset + 3];
    const M_offset_4 = _M[offset + 4];
    const M_offset_5 = _M[offset + 5];
    const M_offset_6 = _M[offset + 6];
    const M_offset_7 = _M[offset + 7];
    const M_offset_8 = _M[offset + 8];
    const M_offset_9 = _M[offset + 9];
    const M_offset_10 = _M[offset + 10];
    const M_offset_11 = _M[offset + 11];
    const M_offset_12 = _M[offset + 12];
    const M_offset_13 = _M[offset + 13];
    const M_offset_14 = _M[offset + 14];
    const M_offset_15 = _M[offset + 15];

    // Working varialbes
    let a = H[0];
    let b = H[1];
    let c = H[2];
    let d = H[3];

    // Computation
    a = FF(a, b, c, d, M_offset_0, 7, T[0]);
    d = FF(d, a, b, c, M_offset_1, 12, T[1]);
    c = FF(c, d, a, b, M_offset_2, 17, T[2]);
    b = FF(b, c, d, a, M_offset_3, 22, T[3]);
    a = FF(a, b, c, d, M_offset_4, 7, T[4]);
    d = FF(d, a, b, c, M_offset_5, 12, T[5]);
    c = FF(c, d, a, b, M_offset_6, 17, T[6]);
    b = FF(b, c, d, a, M_offset_7, 22, T[7]);
    a = FF(a, b, c, d, M_offset_8, 7, T[8]);
    d = FF(d, a, b, c, M_offset_9, 12, T[9]);
    c = FF(c, d, a, b, M_offset_10, 17, T[10]);
    b = FF(b, c, d, a, M_offset_11, 22, T[11]);
    a = FF(a, b, c, d, M_offset_12, 7, T[12]);
    d = FF(d, a, b, c, M_offset_13, 12, T[13]);
    c = FF(c, d, a, b, M_offset_14, 17, T[14]);
    b = FF(b, c, d, a, M_offset_15, 22, T[15]);

    a = GG(a, b, c, d, M_offset_1, 5, T[16]);
    d = GG(d, a, b, c, M_offset_6, 9, T[17]);
    c = GG(c, d, a, b, M_offset_11, 14, T[18]);
    b = GG(b, c, d, a, M_offset_0, 20, T[19]);
    a = GG(a, b, c, d, M_offset_5, 5, T[20]);
    d = GG(d, a, b, c, M_offset_10, 9, T[21]);
    c = GG(c, d, a, b, M_offset_15, 14, T[22]);
    b = GG(b, c, d, a, M_offset_4, 20, T[23]);
    a = GG(a, b, c, d, M_offset_9, 5, T[24]);
    d = GG(d, a, b, c, M_offset_14, 9, T[25]);
    c = GG(c, d, a, b, M_offset_3, 14, T[26]);
    b = GG(b, c, d, a, M_offset_8, 20, T[27]);
    a = GG(a, b, c, d, M_offset_13, 5, T[28]);
    d = GG(d, a, b, c, M_offset_2, 9, T[29]);
    c = GG(c, d, a, b, M_offset_7, 14, T[30]);
    b = GG(b, c, d, a, M_offset_12, 20, T[31]);

    a = HH(a, b, c, d, M_offset_5, 4, T[32]);
    d = HH(d, a, b, c, M_offset_8, 11, T[33]);
    c = HH(c, d, a, b, M_offset_11, 16, T[34]);
    b = HH(b, c, d, a, M_offset_14, 23, T[35]);
    a = HH(a, b, c, d, M_offset_1, 4, T[36]);
    d = HH(d, a, b, c, M_offset_4, 11, T[37]);
    c = HH(c, d, a, b, M_offset_7, 16, T[38]);
    b = HH(b, c, d, a, M_offset_10, 23, T[39]);
    a = HH(a, b, c, d, M_offset_13, 4, T[40]);
    d = HH(d, a, b, c, M_offset_0, 11, T[41]);
    c = HH(c, d, a, b, M_offset_3, 16, T[42]);
    b = HH(b, c, d, a, M_offset_6, 23, T[43]);
    a = HH(a, b, c, d, M_offset_9, 4, T[44]);
    d = HH(d, a, b, c, M_offset_12, 11, T[45]);
    c = HH(c, d, a, b, M_offset_15, 16, T[46]);
    b = HH(b, c, d, a, M_offset_2, 23, T[47]);

    a = II(a, b, c, d, M_offset_0, 6, T[48]);
    d = II(d, a, b, c, M_offset_7, 10, T[49]);
    c = II(c, d, a, b, M_offset_14, 15, T[50]);
    b = II(b, c, d, a, M_offset_5, 21, T[51]);
    a = II(a, b, c, d, M_offset_12, 6, T[52]);
    d = II(d, a, b, c, M_offset_3, 10, T[53]);
    c = II(c, d, a, b, M_offset_10, 15, T[54]);
    b = II(b, c, d, a, M_offset_1, 21, T[55]);
    a = II(a, b, c, d, M_offset_8, 6, T[56]);
    d = II(d, a, b, c, M_offset_15, 10, T[57]);
    c = II(c, d, a, b, M_offset_6, 15, T[58]);
    b = II(b, c, d, a, M_offset_13, 21, T[59]);
    a = II(a, b, c, d, M_offset_4, 6, T[60]);
    d = II(d, a, b, c, M_offset_11, 10, T[61]);
    c = II(c, d, a, b, M_offset_2, 15, T[62]);
    b = II(b, c, d, a, M_offset_9, 21, T[63]);

    // Intermediate hash value
    H[0] = (H[0] + a) | 0;
    H[1] = (H[1] + b) | 0;
    H[2] = (H[2] + c) | 0;
    H[3] = (H[3] + d) | 0;
  }
  /* eslint-ensable no-param-reassign */

  _doFinalize() {
    // Shortcuts
    const data = this._data;
    const dataWords = data.words;

    const nBitsTotal = this._nDataBytes * 8;
    const nBitsLeft = data.sigBytes * 8;

    // Add padding
    dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - (nBitsLeft % 32));

    const nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
    const nBitsTotalL = nBitsTotal;
    dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (
      (((nBitsTotalH << 8) | (nBitsTotalH >>> 24)) & 0x00ff00ff)
        | (((nBitsTotalH << 24) | (nBitsTotalH >>> 8)) & 0xff00ff00)
    );
    dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
      (((nBitsTotalL << 8) | (nBitsTotalL >>> 24)) & 0x00ff00ff)
        | (((nBitsTotalL << 24) | (nBitsTotalL >>> 8)) & 0xff00ff00)
    );

    data.sigBytes = (dataWords.length + 1) * 4;

    // Hash final blocks
    this._process();

    // Shortcuts
    const hash = this._hash;
    const H = hash.words;

    // Swap endian
    for (let i = 0; i < 4; i += 1) {
      // Shortcut
      const H_i = H[i];

      H[i] = (((H_i << 8) | (H_i >>> 24)) & 0x00ff00ff)
        | (((H_i << 24) | (H_i >>> 8)) & 0xff00ff00);
    }

    // Return final computed hash
    return hash;
  }

  clone() {
    const clone = super.clone.call(this);
    clone._hash = this._hash.clone();

    return clone;
  }
}

/**
 * This key derivation function is meant to conform with EVP_BytesToKey.
 * www.openssl.org/docs/crypto/EVP_BytesToKey.html
 */
class EvpKDFAlgo extends Base {
  /**
   * Initializes a newly created key derivation function.
   *
   * @param {Object} cfg (Optional) The configuration options to use for the derivation.
   *
   * @example
   *
   *     const kdf = CryptoJS.algo.EvpKDF.create();
   *     const kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
   *     const kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
   */
  constructor(cfg) {
    super();

    /**
     * Configuration options.
     *
     * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
     * @property {Hasher} hasher The hash algorithm to use. Default: MD5
     * @property {number} iterations The number of iterations to perform. Default: 1
     */
    this.cfg = Object.assign(
      new Base(),
      {
        keySize: 128 / 32,
        hasher: MD5Algo,
        iterations: 1,
      },
      cfg,
    );
  }

  /**
   * Derives a key from a password.
   *
   * @param {WordArray|string} password The password.
   * @param {WordArray|string} salt A salt.
   *
   * @return {WordArray} The derived key.
   *
   * @example
   *
   *     const key = kdf.compute(password, salt);
   */
  compute(password, salt) {
    let block;

    // Shortcut
    const { cfg } = this;

    // Init hasher
    const hasher = cfg.hasher.create();

    // Initial values
    const derivedKey = WordArray.create();

    // Shortcuts
    const derivedKeyWords = derivedKey.words;
    const { keySize, iterations } = cfg;

    // Generate key
    while (derivedKeyWords.length < keySize) {
      if (block) {
        hasher.update(block);
      }
      block = hasher.update(password).finalize(salt);
      hasher.reset();

      // Iterations
      for (let i = 1; i < iterations; i += 1) {
        block = hasher.finalize(block);
        hasher.reset();
      }

      derivedKey.concat(block);
    }
    derivedKey.sigBytes = keySize * 4;

    return derivedKey;
  }
}

/* eslint-disable no-use-before-define */


/**
 * Abstract base cipher template.
 *
 * @property {number} keySize This cipher's key size. Default: 4 (128 bits)
 * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)
 * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.
 * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.
 */
class Cipher extends BufferedBlockAlgorithm {
  /**
   * Initializes a newly created cipher.
   *
   * @param {number} xformMode Either the encryption or decryption transormation mode constant.
   * @param {WordArray} key The key.
   * @param {Object} cfg (Optional) The configuration options to use for this operation.
   *
   * @example
   *
   *     const cipher = CryptoJS.algo.AES.create(
   *       CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray }
   *     );
   */
  constructor(xformMode, key, cfg) {
    super();

    /**
     * Configuration options.
     *
     * @property {WordArray} iv The IV to use for this operation.
     */
    this.cfg = Object.assign(new Base(), cfg);

    // Store transform mode and key
    this._xformMode = xformMode;
    this._key = key;

    // Set initial values
    this.reset();
  }

  /**
   * Creates this cipher in encryption mode.
   *
   * @param {WordArray} key The key.
   * @param {Object} cfg (Optional) The configuration options to use for this operation.
   *
   * @return {Cipher} A cipher instance.
   *
   * @static
   *
   * @example
   *
   *     const cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
   */
  static createEncryptor(key, cfg) {
    return this.create(this._ENC_XFORM_MODE, key, cfg);
  }

  /**
   * Creates this cipher in decryption mode.
   *
   * @param {WordArray} key The key.
   * @param {Object} cfg (Optional) The configuration options to use for this operation.
   *
   * @return {Cipher} A cipher instance.
   *
   * @static
   *
   * @example
   *
   *     const cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
   */
  static createDecryptor(key, cfg) {
    return this.create(this._DEC_XFORM_MODE, key, cfg);
  }

  /**
   * Creates shortcut functions to a cipher's object interface.
   *
   * @param {Cipher} cipher The cipher to create a helper for.
   *
   * @return {Object} An object with encrypt and decrypt shortcut functions.
   *
   * @static
   *
   * @example
   *
   *     const AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
   */
  static _createHelper(SubCipher) {
    const selectCipherStrategy = (key) => {
      if (typeof key === 'string') {
        return PasswordBasedCipher;
      }
      return SerializableCipher;
    };

    return {
      encrypt(message, key, cfg) {
        return selectCipherStrategy(key).encrypt(SubCipher, message, key, cfg);
      },

      decrypt(ciphertext, key, cfg) {
        return selectCipherStrategy(key).decrypt(SubCipher, ciphertext, key, cfg);
      },
    };
  }

  /**
   * Resets this cipher to its initial state.
   *
   * @example
   *
   *     cipher.reset();
   */
  reset() {
    // Reset data buffer
    super.reset.call(this);

    // Perform concrete-cipher logic
    this._doReset();
  }

  /**
   * Adds data to be encrypted or decrypted.
   *
   * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
   *
   * @return {WordArray} The data after processing.
   *
   * @example
   *
   *     const encrypted = cipher.process('data');
   *     const encrypted = cipher.process(wordArray);
   */
  process(dataUpdate) {
    // Append
    this._append(dataUpdate);

    // Process available blocks
    return this._process();
  }

  /**
   * Finalizes the encryption or decryption process.
   * Note that the finalize operation is effectively a destructive, read-once operation.
   *
   * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
   *
   * @return {WordArray} The data after final processing.
   *
   * @example
   *
   *     const encrypted = cipher.finalize();
   *     const encrypted = cipher.finalize('data');
   *     const encrypted = cipher.finalize(wordArray);
   */
  finalize(dataUpdate) {
    // Final data update
    if (dataUpdate) {
      this._append(dataUpdate);
    }

    // Perform concrete-cipher logic
    const finalProcessedData = this._doFinalize();

    return finalProcessedData;
  }
}
Cipher._ENC_XFORM_MODE = 1;
Cipher._DEC_XFORM_MODE = 2;
Cipher.keySize = 128 / 32;
Cipher.ivSize = 128 / 32;

/**
 * Abstract base block cipher mode template.
 */
class BlockCipherMode extends Base {
  /**
   * Initializes a newly created mode.
   *
   * @param {Cipher} cipher A block cipher instance.
   * @param {Array} iv The IV words.
   *
   * @example
   *
   *     const mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
   */
  constructor(cipher, iv) {
    super();

    this._cipher = cipher;
    this._iv = iv;
  }

  /**
   * Creates this mode for encryption.
   *
   * @param {Cipher} cipher A block cipher instance.
   * @param {Array} iv The IV words.
   *
   * @static
   *
   * @example
   *
   *     const mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
   */
  static createEncryptor(cipher, iv) {
    return this.Encryptor.create(cipher, iv);
  }

  /**
   * Creates this mode for decryption.
   *
   * @param {Cipher} cipher A block cipher instance.
   * @param {Array} iv The IV words.
   *
   * @static
   *
   * @example
   *
   *     const mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
   */
  static createDecryptor(cipher, iv) {
    return this.Decryptor.create(cipher, iv);
  }
}

function xorBlock(words, offset, blockSize) {
  const _words = words;
  let block;

  // Shortcut
  const iv = this._iv;

  // Choose mixing block
  if (iv) {
    block = iv;

    // Remove IV for subsequent blocks
    this._iv = undefined;
  } else {
    block = this._prevBlock;
  }

  // XOR blocks
  for (let i = 0; i < blockSize; i += 1) {
    _words[offset + i] ^= block[i];
  }
}

/**
 * Cipher Block Chaining mode.
 */

/**
 * Abstract base CBC mode.
 */
let CBC$2 = class CBC extends BlockCipherMode {
};
/**
 * CBC encryptor.
 */
CBC$2.Encryptor = class extends CBC$2 {
  /**
   * Processes the data block at offset.
   *
   * @param {Array} words The data words to operate on.
   * @param {number} offset The offset where the block starts.
   *
   * @example
   *
   *     mode.processBlock(data.words, offset);
   */
  processBlock(words, offset) {
    // Shortcuts
    const cipher = this._cipher;
    const { blockSize } = cipher;

    // XOR and encrypt
    xorBlock.call(this, words, offset, blockSize);
    cipher.encryptBlock(words, offset);

    // Remember this block to use with next block
    this._prevBlock = words.slice(offset, offset + blockSize);
  }
};
/**
 * CBC decryptor.
 */
CBC$2.Decryptor = class extends CBC$2 {
  /**
   * Processes the data block at offset.
   *
   * @param {Array} words The data words to operate on.
   * @param {number} offset The offset where the block starts.
   *
   * @example
   *
   *     mode.processBlock(data.words, offset);
   */
  processBlock(words, offset) {
    // Shortcuts
    const cipher = this._cipher;
    const { blockSize } = cipher;

    // Remember this block to use with next block
    const thisBlock = words.slice(offset, offset + blockSize);

    // Decrypt and XOR
    cipher.decryptBlock(words, offset);
    xorBlock.call(this, words, offset, blockSize);

    // This block becomes the previous block
    this._prevBlock = thisBlock;
  }
};

/**
 * PKCS #5/7 padding strategy.
 */
const Pkcs7 = {
  /**
   * Pads data using the algorithm defined in PKCS #5/7.
   *
   * @param {WordArray} data The data to pad.
   * @param {number} blockSize The multiple that the data should be padded to.
   *
   * @static
   *
   * @example
   *
   *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
   */
  pad(data, blockSize) {
    // Shortcut
    const blockSizeBytes = blockSize * 4;

    // Count padding bytes
    const nPaddingBytes = blockSizeBytes - (data.sigBytes % blockSizeBytes);

    // Create padding word
    const paddingWord = (nPaddingBytes << 24)
      | (nPaddingBytes << 16)
      | (nPaddingBytes << 8)
      | nPaddingBytes;

    // Create padding
    const paddingWords = [];
    for (let i = 0; i < nPaddingBytes; i += 4) {
      paddingWords.push(paddingWord);
    }
    const padding = WordArray.create(paddingWords, nPaddingBytes);

    // Add padding
    data.concat(padding);
  },

  /**
   * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
   *
   * @param {WordArray} data The data to unpad.
   *
   * @static
   *
   * @example
   *
   *     CryptoJS.pad.Pkcs7.unpad(wordArray);
   */
  unpad(data) {
    const _data = data;

    // Get number of padding bytes from last byte
    const nPaddingBytes = _data.words[(_data.sigBytes - 1) >>> 2] & 0xff;

    // Remove padding
    _data.sigBytes -= nPaddingBytes;
  },
};

/**
 * Abstract base block cipher template.
 *
 * @property {number} blockSize
 *
 *    The number of 32-bit words this cipher operates on. Default: 4 (128 bits)
 */
class BlockCipher extends Cipher {
  constructor(xformMode, key, cfg) {
    /**
     * Configuration options.
     *
     * @property {Mode} mode The block mode to use. Default: CBC
     * @property {Padding} padding The padding strategy to use. Default: Pkcs7
     */
    super(xformMode, key, Object.assign(
      {
        mode: CBC$2,
        padding: Pkcs7,
      },
      cfg,
    ));

    this.blockSize = 128 / 32;
  }

  reset() {
    let modeCreator;

    // Reset cipher
    super.reset.call(this);

    // Shortcuts
    const { cfg } = this;
    const { iv, mode } = cfg;

    // Reset block mode
    if (this._xformMode === this.constructor._ENC_XFORM_MODE) {
      modeCreator = mode.createEncryptor;
    } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
      modeCreator = mode.createDecryptor;
      // Keep at least one block in the buffer for unpadding
      this._minBufferSize = 1;
    }

    this._mode = modeCreator.call(mode, this, iv && iv.words);
    this._mode.__creator = modeCreator;
  }

  _doProcessBlock(words, offset) {
    this._mode.processBlock(words, offset);
  }

  _doFinalize() {
    let finalProcessedBlocks;

    // Shortcut
    const { padding } = this.cfg;

    // Finalize
    if (this._xformMode === this.constructor._ENC_XFORM_MODE) {
      // Pad data
      padding.pad(this._data, this.blockSize);

      // Process final blocks
      finalProcessedBlocks = this._process(!!'flush');
    } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
      // Process final blocks
      finalProcessedBlocks = this._process(!!'flush');

      // Unpad data
      padding.unpad(finalProcessedBlocks);
    }

    return finalProcessedBlocks;
  }
}

/**
 * A collection of cipher parameters.
 *
 * @property {WordArray} ciphertext The raw ciphertext.
 * @property {WordArray} key The key to this ciphertext.
 * @property {WordArray} iv The IV used in the ciphering operation.
 * @property {WordArray} salt The salt used with a key derivation function.
 * @property {Cipher} algorithm The cipher algorithm.
 * @property {Mode} mode The block mode used in the ciphering operation.
 * @property {Padding} padding The padding scheme used in the ciphering operation.
 * @property {number} blockSize The block size of the cipher.
 * @property {Format} formatter
 *    The default formatting strategy to convert this cipher params object to a string.
 */
class CipherParams extends Base {
  /**
   * Initializes a newly created cipher params object.
   *
   * @param {Object} cipherParams An object with any of the possible cipher parameters.
   *
   * @example
   *
   *     var cipherParams = CryptoJS.lib.CipherParams.create({
   *         ciphertext: ciphertextWordArray,
   *         key: keyWordArray,
   *         iv: ivWordArray,
   *         salt: saltWordArray,
   *         algorithm: CryptoJS.algo.AES,
   *         mode: CryptoJS.mode.CBC,
   *         padding: CryptoJS.pad.PKCS7,
   *         blockSize: 4,
   *         formatter: CryptoJS.format.OpenSSL
   *     });
   */
  constructor(cipherParams) {
    super();

    this.mixIn(cipherParams);
  }

  /**
   * Converts this cipher params object to a string.
   *
   * @param {Format} formatter (Optional) The formatting strategy to use.
   *
   * @return {string} The stringified cipher params.
   *
   * @throws Error If neither the formatter nor the default formatter is set.
   *
   * @example
   *
   *     var string = cipherParams + '';
   *     var string = cipherParams.toString();
   *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
   */
  toString(formatter) {
    return (formatter || this.formatter).stringify(this);
  }
}

/**
 * OpenSSL formatting strategy.
 */
const OpenSSLFormatter = {
  /**
   * Converts a cipher params object to an OpenSSL-compatible string.
   *
   * @param {CipherParams} cipherParams The cipher params object.
   *
   * @return {string} The OpenSSL-compatible string.
   *
   * @static
   *
   * @example
   *
   *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
   */
  stringify(cipherParams) {
    let wordArray;

    // Shortcuts
    const { ciphertext, salt } = cipherParams;

    // Format
    if (salt) {
      wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);
    } else {
      wordArray = ciphertext;
    }

    return wordArray.toString(Base64);
  },

  /**
   * Converts an OpenSSL-compatible string to a cipher params object.
   *
   * @param {string} openSSLStr The OpenSSL-compatible string.
   *
   * @return {CipherParams} The cipher params object.
   *
   * @static
   *
   * @example
   *
   *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
   */
  parse(openSSLStr) {
    let salt;

    // Parse base64
    const ciphertext = Base64.parse(openSSLStr);

    // Shortcut
    const ciphertextWords = ciphertext.words;

    // Test for salt
    if (ciphertextWords[0] === 0x53616c74 && ciphertextWords[1] === 0x65645f5f) {
      // Extract salt
      salt = WordArray.create(ciphertextWords.slice(2, 4));

      // Remove salt from ciphertext
      ciphertextWords.splice(0, 4);
      ciphertext.sigBytes -= 16;
    }

    return CipherParams.create({ ciphertext, salt });
  },
};

/**
 * A cipher wrapper that returns ciphertext as a serializable cipher params object.
 */
class SerializableCipher extends Base {
  /**
   * Encrypts a message.
   *
   * @param {Cipher} cipher The cipher algorithm to use.
   * @param {WordArray|string} message The message to encrypt.
   * @param {WordArray} key The key.
   * @param {Object} cfg (Optional) The configuration options to use for this operation.
   *
   * @return {CipherParams} A cipher params object.
   *
   * @static
   *
   * @example
   *
   *     var ciphertextParams = CryptoJS.lib.SerializableCipher
   *       .encrypt(CryptoJS.algo.AES, message, key);
   *     var ciphertextParams = CryptoJS.lib.SerializableCipher
   *       .encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
   *     var ciphertextParams = CryptoJS.lib.SerializableCipher
   *       .encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
   */
  static encrypt(cipher, message, key, cfg) {
    // Apply config defaults
    const _cfg = Object.assign(new Base(), this.cfg, cfg);

    // Encrypt
    const encryptor = cipher.createEncryptor(key, _cfg);
    const ciphertext = encryptor.finalize(message);

    // Shortcut
    const cipherCfg = encryptor.cfg;

    // Create and return serializable cipher params
    return CipherParams.create({
      ciphertext,
      key,
      iv: cipherCfg.iv,
      algorithm: cipher,
      mode: cipherCfg.mode,
      padding: cipherCfg.padding,
      blockSize: encryptor.blockSize,
      formatter: _cfg.format,
    });
  }

  /**
   * Decrypts serialized ciphertext.
   *
   * @param {Cipher} cipher The cipher algorithm to use.
   * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
   * @param {WordArray} key The key.
   * @param {Object} cfg (Optional) The configuration options to use for this operation.
   *
   * @return {WordArray} The plaintext.
   *
   * @static
   *
   * @example
   *
   *     var plaintext = CryptoJS.lib.SerializableCipher
   *       .decrypt(CryptoJS.algo.AES, formattedCiphertext, key,
   *         { iv: iv, format: CryptoJS.format.OpenSSL });
   *     var plaintext = CryptoJS.lib.SerializableCipher
   *       .decrypt(CryptoJS.algo.AES, ciphertextParams, key,
   *         { iv: iv, format: CryptoJS.format.OpenSSL });
   */
  static decrypt(cipher, ciphertext, key, cfg) {
    let _ciphertext = ciphertext;

    // Apply config defaults
    const _cfg = Object.assign(new Base(), this.cfg, cfg);

    // Convert string to CipherParams
    _ciphertext = this._parse(_ciphertext, _cfg.format);

    // Decrypt
    const plaintext = cipher.createDecryptor(key, _cfg).finalize(_ciphertext.ciphertext);

    return plaintext;
  }

  /**
   * Converts serialized ciphertext to CipherParams,
   * else assumed CipherParams already and returns ciphertext unchanged.
   *
   * @param {CipherParams|string} ciphertext The ciphertext.
   * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
   *
   * @return {CipherParams} The unserialized ciphertext.
   *
   * @static
   *
   * @example
   *
   *     var ciphertextParams = CryptoJS.lib.SerializableCipher
   *       ._parse(ciphertextStringOrParams, format);
   */
  static _parse(ciphertext, format) {
    if (typeof ciphertext === 'string') {
      return format.parse(ciphertext, this);
    }
    return ciphertext;
  }
}
/**
 * Configuration options.
 *
 * @property {Formatter} format
 *
 *    The formatting strategy to convert cipher param objects to and from a string.
 *    Default: OpenSSL
 */
SerializableCipher.cfg = Object.assign(
  new Base(),
  { format: OpenSSLFormatter },
);

/**
 * OpenSSL key derivation function.
 */
const OpenSSLKdf = {
  /**
   * Derives a key and IV from a password.
   *
   * @param {string} password The password to derive from.
   * @param {number} keySize The size in words of the key to generate.
   * @param {number} ivSize The size in words of the IV to generate.
   * @param {WordArray|string} salt
   *     (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
   *
   * @return {CipherParams} A cipher params object with the key, IV, and salt.
   *
   * @static
   *
   * @example
   *
   *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
   *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
   */
  execute(password, keySize, ivSize, salt) {
    let _salt = salt;

    // Generate random salt
    if (!_salt) {
      _salt = WordArray.random(64 / 8);
    }

    // Derive key and IV
    const key = EvpKDFAlgo.create({ keySize: keySize + ivSize }).compute(password, _salt);

    // Separate key and IV
    const iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
    key.sigBytes = keySize * 4;

    // Return params
    return CipherParams.create({ key, iv, salt: _salt });
  },
};

/**
 * A serializable cipher wrapper that derives the key from a password,
 * and returns ciphertext as a serializable cipher params object.
 */
class PasswordBasedCipher extends SerializableCipher {
  /**
   * Encrypts a message using a password.
   *
   * @param {Cipher} cipher The cipher algorithm to use.
   * @param {WordArray|string} message The message to encrypt.
   * @param {string} password The password.
   * @param {Object} cfg (Optional) The configuration options to use for this operation.
   *
   * @return {CipherParams} A cipher params object.
   *
   * @static
   *
   * @example
   *
   *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher
   *       .encrypt(CryptoJS.algo.AES, message, 'password');
   *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher
   *       .encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
   */
  static encrypt(cipher, message, password, cfg) {
    // Apply config defaults
    const _cfg = Object.assign(new Base(), this.cfg, cfg);

    // Derive key and other params
    const derivedParams = _cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);

    // Add IV to config
    _cfg.iv = derivedParams.iv;

    // Encrypt
    const ciphertext = SerializableCipher.encrypt
      .call(this, cipher, message, derivedParams.key, _cfg);

    // Mix in derived params
    ciphertext.mixIn(derivedParams);

    return ciphertext;
  }

  /**
   * Decrypts serialized ciphertext using a password.
   *
   * @param {Cipher} cipher The cipher algorithm to use.
   * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
   * @param {string} password The password.
   * @param {Object} cfg (Optional) The configuration options to use for this operation.
   *
   * @return {WordArray} The plaintext.
   *
   * @static
   *
   * @example
   *
   *     var plaintext = CryptoJS.lib.PasswordBasedCipher
   *       .decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password',
   *         { format: CryptoJS.format.OpenSSL });
   *     var plaintext = CryptoJS.lib.PasswordBasedCipher
   *       .decrypt(CryptoJS.algo.AES, ciphertextParams, 'password',
   *         { format: CryptoJS.format.OpenSSL });
   */
  static decrypt(cipher, ciphertext, password, cfg) {
    let _ciphertext = ciphertext;

    // Apply config defaults
    const _cfg = Object.assign(new Base(), this.cfg, cfg);

    // Convert string to CipherParams
    _ciphertext = this._parse(_ciphertext, _cfg.format);

    // Derive key and other params
    const derivedParams = _cfg.kdf
      .execute(password, cipher.keySize, cipher.ivSize, _ciphertext.salt);

    // Add IV to config
    _cfg.iv = derivedParams.iv;

    // Decrypt
    const plaintext = SerializableCipher.decrypt
      .call(this, cipher, _ciphertext, derivedParams.key, _cfg);

    return plaintext;
  }
}
/**
 * Configuration options.
 *
 * @property {KDF} kdf
 *     The key derivation function to use to generate a key and IV from a password.
 *     Default: OpenSSL
 */
PasswordBasedCipher.cfg = Object.assign(SerializableCipher.cfg, { kdf: OpenSSLKdf });

// Lookup tables
const _SBOX = [];
const INV_SBOX = [];
const _SUB_MIX_0 = [];
const _SUB_MIX_1 = [];
const _SUB_MIX_2 = [];
const _SUB_MIX_3 = [];
const INV_SUB_MIX_0 = [];
const INV_SUB_MIX_1 = [];
const INV_SUB_MIX_2 = [];
const INV_SUB_MIX_3 = [];

// Compute lookup tables

// Compute double table
const d = [];
for (let i = 0; i < 256; i += 1) {
  if (i < 128) {
    d[i] = i << 1;
  } else {
    d[i] = (i << 1) ^ 0x11b;
  }
}

// Walk GF(2^8)
let x = 0;
let xi = 0;
for (let i = 0; i < 256; i += 1) {
  // Compute sbox
  let sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
  sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
  _SBOX[x] = sx;
  INV_SBOX[sx] = x;

  // Compute multiplication
  const x2 = d[x];
  const x4 = d[x2];
  const x8 = d[x4];

  // Compute sub bytes, mix columns tables
  let t = (d[sx] * 0x101) ^ (sx * 0x1010100);
  _SUB_MIX_0[x] = (t << 24) | (t >>> 8);
  _SUB_MIX_1[x] = (t << 16) | (t >>> 16);
  _SUB_MIX_2[x] = (t << 8) | (t >>> 24);
  _SUB_MIX_3[x] = t;

  // Compute inv sub bytes, inv mix columns tables
  t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
  INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);
  INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);
  INV_SUB_MIX_2[sx] = (t << 8) | (t >>> 24);
  INV_SUB_MIX_3[sx] = t;

  // Compute next counter
  if (!x) {
    xi = 1;
    x = xi;
  } else {
    x = x2 ^ d[d[d[x8 ^ x2]]];
    xi ^= d[d[xi]];
  }
}

// Precomputed Rcon lookup
const RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];

/**
 * AES block cipher algorithm.
 */
class AESAlgo extends BlockCipher {
  _doReset() {
    let t;

    // Skip reset of nRounds has been set before and key did not change
    if (this._nRounds && this._keyPriorReset === this._key) {
      return;
    }

    // Shortcuts
    this._keyPriorReset = this._key;
    const key = this._keyPriorReset;
    const keyWords = key.words;
    const keySize = key.sigBytes / 4;

    // Compute number of rounds
    this._nRounds = keySize + 6;
    const nRounds = this._nRounds;

    // Compute number of key schedule rows
    const ksRows = (nRounds + 1) * 4;

    // Compute key schedule
    this._keySchedule = [];
    const keySchedule = this._keySchedule;
    for (let ksRow = 0; ksRow < ksRows; ksRow += 1) {
      if (ksRow < keySize) {
        keySchedule[ksRow] = keyWords[ksRow];
      } else {
        t = keySchedule[ksRow - 1];

        if (!(ksRow % keySize)) {
          // Rot word
          t = (t << 8) | (t >>> 24);

          // Sub word
          t = (_SBOX[t >>> 24] << 24)
            | (_SBOX[(t >>> 16) & 0xff] << 16)
            | (_SBOX[(t >>> 8) & 0xff] << 8)
            | _SBOX[t & 0xff];

          // Mix Rcon
          t ^= RCON[(ksRow / keySize) | 0] << 24;
        } else if (keySize > 6 && ksRow % keySize === 4) {
          // Sub word
          t = (_SBOX[t >>> 24] << 24)
            | (_SBOX[(t >>> 16) & 0xff] << 16)
            | (_SBOX[(t >>> 8) & 0xff] << 8)
            | _SBOX[t & 0xff];
        }

        keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
      }
    }

    // Compute inv key schedule
    this._invKeySchedule = [];
    const invKeySchedule = this._invKeySchedule;
    for (let invKsRow = 0; invKsRow < ksRows; invKsRow += 1) {
      const ksRow = ksRows - invKsRow;

      if (invKsRow % 4) {
        t = keySchedule[ksRow];
      } else {
        t = keySchedule[ksRow - 4];
      }

      if (invKsRow < 4 || ksRow <= 4) {
        invKeySchedule[invKsRow] = t;
      } else {
        invKeySchedule[invKsRow] = INV_SUB_MIX_0[_SBOX[t >>> 24]]
          ^ INV_SUB_MIX_1[_SBOX[(t >>> 16) & 0xff]]
          ^ INV_SUB_MIX_2[_SBOX[(t >>> 8) & 0xff]]
          ^ INV_SUB_MIX_3[_SBOX[t & 0xff]];
      }
    }
  }

  encryptBlock(M, offset) {
    this._doCryptBlock(
      M, offset, this._keySchedule, _SUB_MIX_0, _SUB_MIX_1, _SUB_MIX_2, _SUB_MIX_3, _SBOX,
    );
  }

  decryptBlock(M, offset) {
    const _M = M;

    // Swap 2nd and 4th rows
    let t = _M[offset + 1];
    _M[offset + 1] = _M[offset + 3];
    _M[offset + 3] = t;

    this._doCryptBlock(
      _M,
      offset,
      this._invKeySchedule,
      INV_SUB_MIX_0,
      INV_SUB_MIX_1,
      INV_SUB_MIX_2,
      INV_SUB_MIX_3,
      INV_SBOX,
    );

    // Inv swap 2nd and 4th rows
    t = _M[offset + 1];
    _M[offset + 1] = _M[offset + 3];
    _M[offset + 3] = t;
  }

  _doCryptBlock(M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
    const _M = M;

    // Shortcut
    const nRounds = this._nRounds;

    // Get input, add round key
    let s0 = _M[offset] ^ keySchedule[0];
    let s1 = _M[offset + 1] ^ keySchedule[1];
    let s2 = _M[offset + 2] ^ keySchedule[2];
    let s3 = _M[offset + 3] ^ keySchedule[3];

    // Key schedule row counter
    let ksRow = 4;

    // Rounds
    for (let round = 1; round < nRounds; round += 1) {
      // Shift rows, sub bytes, mix columns, add round key
      const t0 = SUB_MIX_0[s0 >>> 24]
        ^ SUB_MIX_1[(s1 >>> 16) & 0xff]
        ^ SUB_MIX_2[(s2 >>> 8) & 0xff]
        ^ SUB_MIX_3[s3 & 0xff]
        ^ keySchedule[ksRow];
      ksRow += 1;
      const t1 = SUB_MIX_0[s1 >>> 24]
        ^ SUB_MIX_1[(s2 >>> 16) & 0xff]
        ^ SUB_MIX_2[(s3 >>> 8) & 0xff]
        ^ SUB_MIX_3[s0 & 0xff]
        ^ keySchedule[ksRow];
      ksRow += 1;
      const t2 = SUB_MIX_0[s2 >>> 24]
        ^ SUB_MIX_1[(s3 >>> 16) & 0xff]
        ^ SUB_MIX_2[(s0 >>> 8) & 0xff]
        ^ SUB_MIX_3[s1 & 0xff]
        ^ keySchedule[ksRow];
      ksRow += 1;
      const t3 = SUB_MIX_0[s3 >>> 24]
        ^ SUB_MIX_1[(s0 >>> 16) & 0xff]
        ^ SUB_MIX_2[(s1 >>> 8) & 0xff]
        ^ SUB_MIX_3[s2 & 0xff]
        ^ keySchedule[ksRow];
      ksRow += 1;

      // Update state
      s0 = t0;
      s1 = t1;
      s2 = t2;
      s3 = t3;
    }

    // Shift rows, sub bytes, add round key
    const t0 = (
      (SBOX[s0 >>> 24] << 24)
        | (SBOX[(s1 >>> 16) & 0xff] << 16)
        | (SBOX[(s2 >>> 8) & 0xff] << 8)
        | SBOX[s3 & 0xff]
    ) ^ keySchedule[ksRow];
    ksRow += 1;
    const t1 = (
      (SBOX[s1 >>> 24] << 24)
        | (SBOX[(s2 >>> 16) & 0xff] << 16)
        | (SBOX[(s3 >>> 8) & 0xff] << 8)
        | SBOX[s0 & 0xff]
    ) ^ keySchedule[ksRow];
    ksRow += 1;
    const t2 = (
      (SBOX[s2 >>> 24] << 24)
        | (SBOX[(s3 >>> 16) & 0xff] << 16)
        | (SBOX[(s0 >>> 8) & 0xff] << 8)
        | SBOX[s1 & 0xff]
    ) ^ keySchedule[ksRow];
    ksRow += 1;
    const t3 = (
      (SBOX[s3 >>> 24] << 24)
        | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]
    ) ^ keySchedule[ksRow];
    ksRow += 1;

    // Set output
    _M[offset] = t0;
    _M[offset + 1] = t1;
    _M[offset + 2] = t2;
    _M[offset + 3] = t3;
  }
}
AESAlgo.keySize = 256 / 32;

// Initialization and round constants tables
const H = [];
const K = [];

// Compute constants
const isPrime = (n) => {
  const sqrtN = Math.sqrt(n);
  for (let factor = 2; factor <= sqrtN; factor += 1) {
    if (!(n % factor)) {
      return false;
    }
  }

  return true;
};

const getFractionalBits = n => ((n - (n | 0)) * 0x100000000) | 0;

let n = 2;
let nPrime = 0;
while (nPrime < 64) {
  if (isPrime(n)) {
    if (nPrime < 8) {
      H[nPrime] = getFractionalBits(n ** (1 / 2));
    }
    K[nPrime] = getFractionalBits(n ** (1 / 3));

    nPrime += 1;
  }

  n += 1;
}

var ripemd128 = {exports: {}};

var core$1 = {exports: {}};

var hasRequiredCore$1;

function requireCore$1 () {
	if (hasRequiredCore$1) return core$1.exports;
	hasRequiredCore$1 = 1;
	(function (module, exports) {
(function (root, factory) {
			{
				// CommonJS
				module.exports = factory();
			}
		}(commonjsGlobal, function () {

			/**
			 * CryptoJS core components.
			 */
			var CryptoJS = CryptoJS || (function (Math, undefined$1) {
			    /*
			     * Local polyfil of Object.create
			     */
			    var create = Object.create || (function () {
			        function F() {}
			        return function (obj) {
			            var subtype;

			            F.prototype = obj;

			            subtype = new F();

			            F.prototype = null;

			            return subtype;
			        };
			    }());

			    /**
			     * CryptoJS namespace.
			     */
			    var C = {};

			    /**
			     * Library namespace.
			     */
			    var C_lib = C.lib = {};

			    /**
			     * Base object for prototypal inheritance.
			     */
			    var Base = C_lib.Base = (function () {


			        return {
			            /**
			             * Creates a new object that inherits from this object.
			             *
			             * @param {Object} overrides Properties to copy into the new object.
			             *
			             * @return {Object} The new object.
			             *
			             * @static
			             *
			             * @example
			             *
			             *     var MyType = CryptoJS.lib.Base.extend({
			             *         field: 'value',
			             *
			             *         method: function () {
			             *         }
			             *     });
			             */
			            extend: function (overrides) {
			                // Spawn
			                var subtype = create(this);

			                // Augment
			                if (overrides) {
			                    subtype.mixIn(overrides);
			                }

			                // Create default initializer
			                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
			                    subtype.init = function () {
			                        subtype.$super.init.apply(this, arguments);
			                    };
			                }

			                // Initializer's prototype is the subtype object
			                subtype.init.prototype = subtype;

			                // Reference supertype
			                subtype.$super = this;

			                return subtype;
			            },

			            /**
			             * Extends this object and runs the init method.
			             * Arguments to create() will be passed to init().
			             *
			             * @return {Object} The new object.
			             *
			             * @static
			             *
			             * @example
			             *
			             *     var instance = MyType.create();
			             */
			            create: function () {
			                var instance = this.extend();
			                instance.init.apply(instance, arguments);

			                return instance;
			            },

			            /**
			             * Initializes a newly created object.
			             * Override this method to add some logic when your objects are created.
			             *
			             * @example
			             *
			             *     var MyType = CryptoJS.lib.Base.extend({
			             *         init: function () {
			             *             // ...
			             *         }
			             *     });
			             */
			            init: function () {
			            },

			            /**
			             * Copies properties into this object.
			             *
			             * @param {Object} properties The properties to mix in.
			             *
			             * @example
			             *
			             *     MyType.mixIn({
			             *         field: 'value'
			             *     });
			             */
			            mixIn: function (properties) {
			                for (var propertyName in properties) {
			                    if (properties.hasOwnProperty(propertyName)) {
			                        this[propertyName] = properties[propertyName];
			                    }
			                }

			                // IE won't copy toString using the loop above
			                if (properties.hasOwnProperty('toString')) {
			                    this.toString = properties.toString;
			                }
			            },

			            /**
			             * Creates a copy of this object.
			             *
			             * @return {Object} The clone.
			             *
			             * @example
			             *
			             *     var clone = instance.clone();
			             */
			            clone: function () {
			                return this.init.prototype.extend(this);
			            }
			        };
			    }());

			    /**
			     * An array of 32-bit words.
			     *
			     * @property {Array} words The array of 32-bit words.
			     * @property {number} sigBytes The number of significant bytes in this word array.
			     */
			    var WordArray = C_lib.WordArray = Base.extend({
			        /**
			         * Initializes a newly created word array.
			         *
			         * @param {Array} words (Optional) An array of 32-bit words.
			         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
			         *
			         * @example
			         *
			         *     var wordArray = CryptoJS.lib.WordArray.create();
			         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
			         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
			         */
			        init: function (words, sigBytes) {
			            words = this.words = words || [];

			            if (sigBytes != undefined$1) {
			                this.sigBytes = sigBytes;
			            } else {
			                this.sigBytes = words.length * 4;
			            }
			        },

			        /**
			         * Converts this word array to a string.
			         *
			         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
			         *
			         * @return {string} The stringified word array.
			         *
			         * @example
			         *
			         *     var string = wordArray + '';
			         *     var string = wordArray.toString();
			         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
			         */
			        toString: function (encoder) {
			            return (encoder || Hex).stringify(this);
			        },

			        /**
			         * Concatenates a word array to this word array.
			         *
			         * @param {WordArray} wordArray The word array to append.
			         *
			         * @return {WordArray} This word array.
			         *
			         * @example
			         *
			         *     wordArray1.concat(wordArray2);
			         */
			        concat: function (wordArray) {
			            // Shortcuts
			            var thisWords = this.words;
			            var thatWords = wordArray.words;
			            var thisSigBytes = this.sigBytes;
			            var thatSigBytes = wordArray.sigBytes;

			            // Clamp excess bits
			            this.clamp();

			            // Concat
			            if (thisSigBytes % 4) {
			                // Copy one byte at a time
			                for (var i = 0; i < thatSigBytes; i++) {
			                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
			                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
			                }
			            } else {
			                // Copy one word at a time
			                for (var i = 0; i < thatSigBytes; i += 4) {
			                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
			                }
			            }
			            this.sigBytes += thatSigBytes;

			            // Chainable
			            return this;
			        },

			        /**
			         * Removes insignificant bits.
			         *
			         * @example
			         *
			         *     wordArray.clamp();
			         */
			        clamp: function () {
			            // Shortcuts
			            var words = this.words;
			            var sigBytes = this.sigBytes;

			            // Clamp
			            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
			            words.length = Math.ceil(sigBytes / 4);
			        },

			        /**
			         * Creates a copy of this word array.
			         *
			         * @return {WordArray} The clone.
			         *
			         * @example
			         *
			         *     var clone = wordArray.clone();
			         */
			        clone: function () {
			            var clone = Base.clone.call(this);
			            clone.words = this.words.slice(0);

			            return clone;
			        },

			        /**
			         * Creates a word array filled with random bytes.
			         *
			         * @param {number} nBytes The number of random bytes to generate.
			         *
			         * @return {WordArray} The random word array.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var wordArray = CryptoJS.lib.WordArray.random(16);
			         */
			        random: function (nBytes) {
			            var words = [];

			            var r = (function (m_w) {
			                var m_w = m_w;
			                var m_z = 0x3ade68b1;
			                var mask = 0xffffffff;

			                return function () {
			                    m_z = (0x9069 * (m_z & 0xFFFF) + (m_z >> 0x10)) & mask;
			                    m_w = (0x4650 * (m_w & 0xFFFF) + (m_w >> 0x10)) & mask;
			                    var result = ((m_z << 0x10) + m_w) & mask;
			                    result /= 0x100000000;
			                    result += 0.5;
			                    return result * (Math.random() > .5 ? 1 : -1);
			                }
			            });

			            for (var i = 0, rcache; i < nBytes; i += 4) {
			                var _r = r((rcache || Math.random()) * 0x100000000);

			                rcache = _r() * 0x3ade67b7;
			                words.push((_r() * 0x100000000) | 0);
			            }

			            return new WordArray.init(words, nBytes);
			        }
			    });

			    /**
			     * Encoder namespace.
			     */
			    var C_enc = C.enc = {};

			    /**
			     * Hex encoding strategy.
			     */
			    var Hex = C_enc.Hex = {
			        /**
			         * Converts a word array to a hex string.
			         *
			         * @param {WordArray} wordArray The word array.
			         *
			         * @return {string} The hex string.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
			         */
			        stringify: function (wordArray) {
			            // Shortcuts
			            var words = wordArray.words;
			            var sigBytes = wordArray.sigBytes;

			            // Convert
			            var hexChars = [];
			            for (var i = 0; i < sigBytes; i++) {
			                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
			                hexChars.push((bite >>> 4).toString(16));
			                hexChars.push((bite & 0x0f).toString(16));
			            }

			            return hexChars.join('');
			        },

			        /**
			         * Converts a hex string to a word array.
			         *
			         * @param {string} hexStr The hex string.
			         *
			         * @return {WordArray} The word array.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
			         */
			        parse: function (hexStr) {
			            // Shortcut
			            var hexStrLength = hexStr.length;

			            // Convert
			            var words = [];
			            for (var i = 0; i < hexStrLength; i += 2) {
			                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
			            }

			            return new WordArray.init(words, hexStrLength / 2);
			        }
			    };

			    /**
			     * Latin1 encoding strategy.
			     */
			    var Latin1 = C_enc.Latin1 = {
			        /**
			         * Converts a word array to a Latin1 string.
			         *
			         * @param {WordArray} wordArray The word array.
			         *
			         * @return {string} The Latin1 string.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
			         */
			        stringify: function (wordArray) {
			            // Shortcuts
			            var words = wordArray.words;
			            var sigBytes = wordArray.sigBytes;

			            // Convert
			            var latin1Chars = [];
			            for (var i = 0; i < sigBytes; i++) {
			                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
			                latin1Chars.push(String.fromCharCode(bite));
			            }

			            return latin1Chars.join('');
			        },

			        /**
			         * Converts a Latin1 string to a word array.
			         *
			         * @param {string} latin1Str The Latin1 string.
			         *
			         * @return {WordArray} The word array.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
			         */
			        parse: function (latin1Str) {
			            // Shortcut
			            var latin1StrLength = latin1Str.length;

			            // Convert
			            var words = [];
			            for (var i = 0; i < latin1StrLength; i++) {
			                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
			            }

			            return new WordArray.init(words, latin1StrLength);
			        }
			    };

			    /**
			     * UTF-8 encoding strategy.
			     */
			    var Utf8 = C_enc.Utf8 = {
			        /**
			         * Converts a word array to a UTF-8 string.
			         *
			         * @param {WordArray} wordArray The word array.
			         *
			         * @return {string} The UTF-8 string.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
			         */
			        stringify: function (wordArray) {
			            try {
			                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
			            } catch (e) {
			                throw new Error('Malformed UTF-8 data');
			            }
			        },

			        /**
			         * Converts a UTF-8 string to a word array.
			         *
			         * @param {string} utf8Str The UTF-8 string.
			         *
			         * @return {WordArray} The word array.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
			         */
			        parse: function (utf8Str) {
			            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
			        }
			    };

			    /**
			     * Abstract buffered block algorithm template.
			     *
			     * The property blockSize must be implemented in a concrete subtype.
			     *
			     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
			     */
			    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
			        /**
			         * Resets this block algorithm's data buffer to its initial state.
			         *
			         * @example
			         *
			         *     bufferedBlockAlgorithm.reset();
			         */
			        reset: function () {
			            // Initial values
			            this._data = new WordArray.init();
			            this._nDataBytes = 0;
			        },

			        /**
			         * Adds new data to this block algorithm's buffer.
			         *
			         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
			         *
			         * @example
			         *
			         *     bufferedBlockAlgorithm._append('data');
			         *     bufferedBlockAlgorithm._append(wordArray);
			         */
			        _append: function (data) {
			            // Convert string to WordArray, else assume WordArray already
			            if (typeof data == 'string') {
			                data = Utf8.parse(data);
			            }

			            // Append
			            this._data.concat(data);
			            this._nDataBytes += data.sigBytes;
			        },

			        /**
			         * Processes available data blocks.
			         *
			         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
			         *
			         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
			         *
			         * @return {WordArray} The processed data.
			         *
			         * @example
			         *
			         *     var processedData = bufferedBlockAlgorithm._process();
			         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
			         */
			        _process: function (doFlush) {
			            // Shortcuts
			            var data = this._data;
			            var dataWords = data.words;
			            var dataSigBytes = data.sigBytes;
			            var blockSize = this.blockSize;
			            var blockSizeBytes = blockSize * 4;

			            // Count blocks ready
			            var nBlocksReady = dataSigBytes / blockSizeBytes;
			            if (doFlush) {
			                // Round up to include partial blocks
			                nBlocksReady = Math.ceil(nBlocksReady);
			            } else {
			                // Round down to include only full blocks,
			                // less the number of blocks that must remain in the buffer
			                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
			            }

			            // Count words ready
			            var nWordsReady = nBlocksReady * blockSize;

			            // Count bytes ready
			            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

			            // Process blocks
			            if (nWordsReady) {
			                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
			                    // Perform concrete-algorithm logic
			                    this._doProcessBlock(dataWords, offset);
			                }

			                // Remove processed words
			                var processedWords = dataWords.splice(0, nWordsReady);
			                data.sigBytes -= nBytesReady;
			            }

			            // Return processed words
			            return new WordArray.init(processedWords, nBytesReady);
			        },

			        /**
			         * Creates a copy of this object.
			         *
			         * @return {Object} The clone.
			         *
			         * @example
			         *
			         *     var clone = bufferedBlockAlgorithm.clone();
			         */
			        clone: function () {
			            var clone = Base.clone.call(this);
			            clone._data = this._data.clone();

			            return clone;
			        },

			        _minBufferSize: 0
			    });

			    /**
			     * Abstract hasher template.
			     *
			     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
			     */
			    C_lib.Hasher = BufferedBlockAlgorithm.extend({
			        /**
			         * Configuration options.
			         */
			        cfg: Base.extend(),

			        /**
			         * Initializes a newly created hasher.
			         *
			         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
			         *
			         * @example
			         *
			         *     var hasher = CryptoJS.algo.SHA256.create();
			         */
			        init: function (cfg) {
			            // Apply config defaults
			            this.cfg = this.cfg.extend(cfg);

			            // Set initial values
			            this.reset();
			        },

			        /**
			         * Resets this hasher to its initial state.
			         *
			         * @example
			         *
			         *     hasher.reset();
			         */
			        reset: function () {
			            // Reset data buffer
			            BufferedBlockAlgorithm.reset.call(this);

			            // Perform concrete-hasher logic
			            this._doReset();
			        },

			        /**
			         * Updates this hasher with a message.
			         *
			         * @param {WordArray|string} messageUpdate The message to append.
			         *
			         * @return {Hasher} This hasher.
			         *
			         * @example
			         *
			         *     hasher.update('message');
			         *     hasher.update(wordArray);
			         */
			        update: function (messageUpdate) {
			            // Append
			            this._append(messageUpdate);

			            // Update the hash
			            this._process();

			            // Chainable
			            return this;
			        },

			        /**
			         * Finalizes the hash computation.
			         * Note that the finalize operation is effectively a destructive, read-once operation.
			         *
			         * @param {WordArray|string} messageUpdate (Optional) A final message update.
			         *
			         * @return {WordArray} The hash.
			         *
			         * @example
			         *
			         *     var hash = hasher.finalize();
			         *     var hash = hasher.finalize('message');
			         *     var hash = hasher.finalize(wordArray);
			         */
			        finalize: function (messageUpdate) {
			            // Final message update
			            if (messageUpdate) {
			                this._append(messageUpdate);
			            }

			            // Perform concrete-hasher logic
			            var hash = this._doFinalize();

			            return hash;
			        },

			        blockSize: 512/32,

			        /**
			         * Creates a shortcut function to a hasher's object interface.
			         *
			         * @param {Hasher} hasher The hasher to create a helper for.
			         *
			         * @return {Function} The shortcut function.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
			         */
			        _createHelper: function (hasher) {
			            return function (message, cfg) {
			                return new hasher.init(cfg).finalize(message);
			            };
			        },

			        /**
			         * Creates a shortcut function to the HMAC's object interface.
			         *
			         * @param {Hasher} hasher The hasher to use in this HMAC helper.
			         *
			         * @return {Function} The shortcut function.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
			         */
			        _createHmacHelper: function (hasher) {
			            return function (message, key) {
			                return new C_algo.HMAC.init(hasher, key).finalize(message);
			            };
			        }
			    });

			    /**
			     * Algorithm namespace.
			     */
			    var C_algo = C.algo = {};

			    return C;
			}(Math));


			return CryptoJS;

		})); 
	} (core$1));
	return core$1.exports;
}

(function (module, exports) {
(function (root, factory) {
		{
			// CommonJS
			module.exports = factory(requireCore$1());
		}
	}(commonjsGlobal, function (CryptoJS) {

			  (function (Math) {
			    // Shortcuts
			    const C = CryptoJS;
			    const C_lib = C.lib;
			    const WordArray = C_lib.WordArray;
			    const Hasher = C_lib.Hasher;
			    const C_algo = C.algo;

			    // Constants table
			    const _zl = WordArray.create([
			      0,
			      1,
			      2,
			      3,
			      4,
			      5,
			      6,
			      7,
			      8,
			      9,
			      10,
			      11,
			      12,
			      13,
			      14,
			      15,
			      7,
			      4,
			      13,
			      1,
			      10,
			      6,
			      15,
			      3,
			      12,
			      0,
			      9,
			      5,
			      2,
			      14,
			      11,
			      8,
			      3,
			      10,
			      14,
			      4,
			      9,
			      15,
			      8,
			      1,
			      2,
			      7,
			      0,
			      6,
			      13,
			      11,
			      5,
			      12,
			      1,
			      9,
			      11,
			      10,
			      0,
			      8,
			      12,
			      4,
			      13,
			      3,
			      7,
			      15,
			      14,
			      5,
			      6,
			      2,
			    ]);
			    const _zr = WordArray.create([
			      5,
			      14,
			      7,
			      0,
			      9,
			      2,
			      11,
			      4,
			      13,
			      6,
			      15,
			      8,
			      1,
			      10,
			      3,
			      12,
			      6,
			      11,
			      3,
			      7,
			      0,
			      13,
			      5,
			      10,
			      14,
			      15,
			      8,
			      12,
			      4,
			      9,
			      1,
			      2,
			      15,
			      5,
			      1,
			      3,
			      7,
			      14,
			      6,
			      9,
			      11,
			      8,
			      12,
			      2,
			      10,
			      0,
			      4,
			      13,
			      8,
			      6,
			      4,
			      1,
			      3,
			      11,
			      15,
			      0,
			      5,
			      12,
			      2,
			      13,
			      9,
			      7,
			      10,
			      14,
			    ]);
			    const _sl = WordArray.create([
			      11,
			      14,
			      15,
			      12,
			      5,
			      8,
			      7,
			      9,
			      11,
			      13,
			      14,
			      15,
			      6,
			      7,
			      9,
			      8,
			      7,
			      6,
			      8,
			      13,
			      11,
			      9,
			      7,
			      15,
			      7,
			      12,
			      15,
			      9,
			      11,
			      7,
			      13,
			      12,
			      11,
			      13,
			      6,
			      7,
			      14,
			      9,
			      13,
			      15,
			      14,
			      8,
			      13,
			      6,
			      5,
			      12,
			      7,
			      5,
			      11,
			      12,
			      14,
			      15,
			      14,
			      15,
			      9,
			      8,
			      9,
			      14,
			      5,
			      6,
			      8,
			      6,
			      5,
			      12,
			    ]);
			    const _sr = WordArray.create([
			      8,
			      9,
			      9,
			      11,
			      13,
			      15,
			      15,
			      5,
			      7,
			      7,
			      8,
			      11,
			      14,
			      14,
			      12,
			      6,
			      9,
			      13,
			      15,
			      7,
			      12,
			      8,
			      9,
			      11,
			      7,
			      7,
			      12,
			      7,
			      6,
			      15,
			      13,
			      11,
			      9,
			      7,
			      15,
			      11,
			      8,
			      6,
			      6,
			      14,
			      12,
			      13,
			      5,
			      14,
			      13,
			      13,
			      7,
			      5,
			      15,
			      5,
			      8,
			      11,
			      14,
			      14,
			      6,
			      14,
			      6,
			      9,
			      12,
			      9,
			      12,
			      5,
			      15,
			      8,
			    ]);

			    const _hl = WordArray.create([0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc]);
			    const _hr = WordArray.create([0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x00000000]);

			    /**
			     * RIPEMD128 hash algorithm.
			     */
			    const RIPEMD128 = (C_algo.RIPEMD128 = Hasher.extend({
			      _doReset() {
			        this._hash = WordArray.create([0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476]);
			      },

			      _doProcessBlock(M, offset) {
			        // Swap endian
			        for (var i = 0; i < 16; i++) {
			          // Shortcuts
			          const offset_i = offset + i;
			          const M_offset_i = M[offset_i];

			          // Swap
			          M[offset_i] =
			            (((M_offset_i << 8) | (M_offset_i >>> 24)) & 0x00ff00ff) |
			            (((M_offset_i << 24) | (M_offset_i >>> 8)) & 0xff00ff00);
			        }
			        // Shortcut
			        const H = this._hash.words;
			        const hl = _hl.words;
			        const hr = _hr.words;
			        const zl = _zl.words;
			        const zr = _zr.words;
			        const sl = _sl.words;
			        const sr = _sr.words;

			        // Working variables
			        let al,
			          bl,
			          cl,
			          dl;
			        let ar,
			          br,
			          cr,
			          dr;

			        ar = al = H[0];
			        br = bl = H[1];
			        cr = cl = H[2];
			        dr = dl = H[3];
			        // Computation
			        let t;
			        for (var i = 0; i < 64; i += 1) {
			          t = (al + M[offset + zl[i]]) | 0;
			          if (i < 16) {
			            t += f1(bl, cl, dl) + hl[0];
			          } else if (i < 32) {
			            t += f2(bl, cl, dl) + hl[1];
			          } else if (i < 48) {
			            t += f3(bl, cl, dl) + hl[2];
			          } else if (i < 64) {
			            t += f4(bl, cl, dl) + hl[3];
			          }
			          t |= 0;
			          t = rotl(t, sl[i]);
			          al = dl;
			          dl = cl;
			          cl = bl;
			          bl = t;

			          t = (ar + M[offset + zr[i]]) | 0;
			          if (i < 16) {
			            t += f4(br, cr, dr) + hr[0];
			          } else if (i < 32) {
			            t += f3(br, cr, dr) + hr[1];
			          } else if (i < 48) {
			            t += f2(br, cr, dr) + hr[2];
			          } else if (i < 64) {
			            t += f1(br, cr, dr) + hr[3];
			          }
			          t |= 0;
			          t = rotl(t, sr[i]);
			          ar = dr;
			          dr = cr;
			          cr = br;
			          br = t;
			        }
			        // Intermediate hash value
			        t = (H[1] + cl + dr) | 0;
			        H[1] = (H[2] + dl + ar) | 0;
			        H[2] = (H[3] + al + br) | 0;
			        H[3] = (H[0] + bl + cr) | 0;
			        H[0] = t;
			      },

			      _doFinalize() {
			        // Shortcuts
			        const data = this._data;
			        const dataWords = data.words;

			        const nBitsTotal = this._nDataBytes * 8;
			        const nBitsLeft = data.sigBytes * 8;

			        // Add padding
			        dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
			        dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] =
			          (((nBitsTotal << 8) | (nBitsTotal >>> 24)) & 0x00ff00ff) |
			          (((nBitsTotal << 24) | (nBitsTotal >>> 8)) & 0xff00ff00);
			        data.sigBytes = (dataWords.length + 1) * 4;

			        // Hash final blocks
			        this._process();

			        // Shortcuts
			        const hash = this._hash;
			        const H = hash.words;

			        // Swap endian
			        for (let i = 0; i < 4; i++) {
			          // Shortcut
			          const H_i = H[i];

			          // Swap
			          H[i] =
			            (((H_i << 8) | (H_i >>> 24)) & 0x00ff00ff) | (((H_i << 24) | (H_i >>> 8)) & 0xff00ff00);
			        }

			        // Return final computed hash
			        return hash;
			      },

			      clone() {
			        const clone = Hasher.clone.call(this);
			        clone._hash = this._hash.clone();

			        return clone;
			      },
			    }));

			    function f1(x, y, z) {
			      return x ^ y ^ z;
			    }

			    function f2(x, y, z) {
			      return (x & y) | (~x & z);
			    }

			    function f3(x, y, z) {
			      return (x | ~y) ^ z;
			    }

			    function f4(x, y, z) {
			      return (x & z) | (y & ~z);
			    }

			    function rotl(x, n) {
			      return (x << n) | (x >>> (32 - n));
			    }

			    /**
			     * Shortcut function to the hasher's object interface.
			     *
			     * @param {WordArray|string} message The message to hash.
			     *
			     * @return {WordArray} The hash.
			     *
			     * @static
			     *
			     * @example
			     *
			     *     var hash = CryptoJS.RIPEMD128('message');
			     *     var hash = CryptoJS.RIPEMD128(wordArray);
			     */
			    C.RIPEMD128 = Hasher._createHelper(RIPEMD128);

			    /**
			     * Shortcut function to the HMAC's object interface.
			     *
			     * @param {WordArray|string} message The message to hash.
			     * @param {WordArray|string} key The secret key.
			     *
			     * @return {WordArray} The HMAC.
			     *
			     * @static
			     *
			     * @example
			     *
			     *     var hmac = CryptoJS.HmacRIPEMD128(message, key);
			     */
			    C.HmacRIPEMD128 = Hasher._createHmacHelper(RIPEMD128);
			  }());

		return CryptoJS.RIPEMD128;

	})); 
} (ripemd128));

var src$1 = {};

var sha256$1 = {};

var _sha2 = {};

var _assert = {};

Object.defineProperty(_assert, "__esModule", { value: true });
_assert.output = _assert.exists = _assert.hash = _assert.bytes = _assert.bool = _assert.number = void 0;
function number(n) {
    if (!Number.isSafeInteger(n) || n < 0)
        throw new Error(`Wrong positive integer: ${n}`);
}
_assert.number = number;
function bool(b) {
    if (typeof b !== 'boolean')
        throw new Error(`Expected boolean, not ${b}`);
}
_assert.bool = bool;
function bytes(b, ...lengths) {
    if (!(b instanceof Uint8Array))
        throw new TypeError('Expected Uint8Array');
    if (lengths.length > 0 && !lengths.includes(b.length))
        throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
_assert.bytes = bytes;
function hash(hash) {
    if (typeof hash !== 'function' || typeof hash.create !== 'function')
        throw new Error('Hash should be wrapped by utils.wrapConstructor');
    number(hash.outputLen);
    number(hash.blockLen);
}
_assert.hash = hash;
function exists(instance, checkFinished = true) {
    if (instance.destroyed)
        throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished)
        throw new Error('Hash#digest() has already been called');
}
_assert.exists = exists;
function output(out, instance) {
    bytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
}
_assert.output = output;
const assert = {
    number,
    bool,
    bytes,
    hash,
    exists,
    output,
};
_assert.default = assert;

var utils$a = {};

var crypto = {};

Object.defineProperty(crypto, "__esModule", { value: true });
crypto.crypto = void 0;
crypto.crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;

(function (exports) {
	/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.randomBytes = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
	// We use `globalThis.crypto`, but node.js versions earlier than v19 don't
	// declare it in global scope. For node.js, package.json#exports field mapping
	// rewrites import from `crypto` to `cryptoNode`, which imports native module.
	// Makes the utils un-importable in browsers without a bundler.
	// Once node.js 18 is deprecated, we can just drop the import.
	const crypto_1 = crypto;
	// Cast array to different type
	const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
	exports.u8 = u8;
	const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
	exports.u32 = u32;
	// Cast array to view
	const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
	exports.createView = createView;
	// The rotate right (circular right shift) operation for uint32
	const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);
	exports.rotr = rotr;
	// big-endian hardware is rare. Just in case someone still decides to run hashes:
	// early-throw an error because we don't support BE yet.
	exports.isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;
	if (!exports.isLE)
	    throw new Error('Non little-endian hardware is not supported');
	const hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));
	/**
	 * @example bytesToHex(Uint8Array.from([0xde, 0xad, 0xbe, 0xef])) // 'deadbeef'
	 */
	function bytesToHex(uint8a) {
	    // pre-caching improves the speed 6x
	    if (!(uint8a instanceof Uint8Array))
	        throw new Error('Uint8Array expected');
	    let hex = '';
	    for (let i = 0; i < uint8a.length; i++) {
	        hex += hexes[uint8a[i]];
	    }
	    return hex;
	}
	exports.bytesToHex = bytesToHex;
	/**
	 * @example hexToBytes('deadbeef') // Uint8Array.from([0xde, 0xad, 0xbe, 0xef])
	 */
	function hexToBytes(hex) {
	    if (typeof hex !== 'string') {
	        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);
	    }
	    if (hex.length % 2)
	        throw new Error('hexToBytes: received invalid unpadded hex');
	    const array = new Uint8Array(hex.length / 2);
	    for (let i = 0; i < array.length; i++) {
	        const j = i * 2;
	        const hexByte = hex.slice(j, j + 2);
	        const byte = Number.parseInt(hexByte, 16);
	        if (Number.isNaN(byte) || byte < 0)
	            throw new Error('Invalid byte sequence');
	        array[i] = byte;
	    }
	    return array;
	}
	exports.hexToBytes = hexToBytes;
	// There is no setImmediate in browser and setTimeout is slow.
	// call of async fn will return Promise, which will be fullfiled only on
	// next scheduler queue processing step and this is exactly what we need.
	const nextTick = async () => { };
	exports.nextTick = nextTick;
	// Returns control to thread each 'tick' ms to avoid blocking
	async function asyncLoop(iters, tick, cb) {
	    let ts = Date.now();
	    for (let i = 0; i < iters; i++) {
	        cb(i);
	        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
	        const diff = Date.now() - ts;
	        if (diff >= 0 && diff < tick)
	            continue;
	        await (0, exports.nextTick)();
	        ts += diff;
	    }
	}
	exports.asyncLoop = asyncLoop;
	function utf8ToBytes(str) {
	    if (typeof str !== 'string') {
	        throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);
	    }
	    return new TextEncoder().encode(str);
	}
	exports.utf8ToBytes = utf8ToBytes;
	function toBytes(data) {
	    if (typeof data === 'string')
	        data = utf8ToBytes(data);
	    if (!(data instanceof Uint8Array))
	        throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);
	    return data;
	}
	exports.toBytes = toBytes;
	/**
	 * Concats Uint8Array-s into one; like `Buffer.concat([buf1, buf2])`
	 * @example concatBytes(buf1, buf2)
	 */
	function concatBytes(...arrays) {
	    if (!arrays.every((a) => a instanceof Uint8Array))
	        throw new Error('Uint8Array list expected');
	    if (arrays.length === 1)
	        return arrays[0];
	    const length = arrays.reduce((a, arr) => a + arr.length, 0);
	    const result = new Uint8Array(length);
	    for (let i = 0, pad = 0; i < arrays.length; i++) {
	        const arr = arrays[i];
	        result.set(arr, pad);
	        pad += arr.length;
	    }
	    return result;
	}
	exports.concatBytes = concatBytes;
	// For runtime check if class implements interface
	class Hash {
	    // Safe version that clones internal state
	    clone() {
	        return this._cloneInto();
	    }
	}
	exports.Hash = Hash;
	// Check if object doens't have custom constructor (like Uint8Array/Array)
	const isPlainObject = (obj) => Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;
	function checkOpts(defaults, opts) {
	    if (opts !== undefined && (typeof opts !== 'object' || !isPlainObject(opts)))
	        throw new TypeError('Options should be object or undefined');
	    const merged = Object.assign(defaults, opts);
	    return merged;
	}
	exports.checkOpts = checkOpts;
	function wrapConstructor(hashConstructor) {
	    const hashC = (message) => hashConstructor().update(toBytes(message)).digest();
	    const tmp = hashConstructor();
	    hashC.outputLen = tmp.outputLen;
	    hashC.blockLen = tmp.blockLen;
	    hashC.create = () => hashConstructor();
	    return hashC;
	}
	exports.wrapConstructor = wrapConstructor;
	function wrapConstructorWithOpts(hashCons) {
	    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
	    const tmp = hashCons({});
	    hashC.outputLen = tmp.outputLen;
	    hashC.blockLen = tmp.blockLen;
	    hashC.create = (opts) => hashCons(opts);
	    return hashC;
	}
	exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
	/**
	 * Secure PRNG. Uses `globalThis.crypto` or node.js crypto module.
	 */
	function randomBytes(bytesLength = 32) {
	    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {
	        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
	    }
	    throw new Error('crypto.getRandomValues must be defined');
	}
	exports.randomBytes = randomBytes;
	
} (utils$a));

Object.defineProperty(_sha2, "__esModule", { value: true });
_sha2.SHA2 = void 0;
const _assert_js_1$1 = _assert;
const utils_js_1$3 = utils$a;
// Polyfill for Safari 14
function setBigUint64(view, byteOffset, value, isLE) {
    if (typeof view.setBigUint64 === 'function')
        return view.setBigUint64(byteOffset, value, isLE);
    const _32n = BigInt(32);
    const _u32_max = BigInt(0xffffffff);
    const wh = Number((value >> _32n) & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE ? 4 : 0;
    const l = isLE ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE);
    view.setUint32(byteOffset + l, wl, isLE);
}
// Base SHA2 class (RFC 6234)
class SHA2 extends utils_js_1$3.Hash {
    constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_js_1$3.createView)(this.buffer);
    }
    update(data) {
        _assert_js_1$1.default.exists(this);
        const { view, buffer, blockLen } = this;
        data = (0, utils_js_1$3.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            // Fast path: we have at least one block in input, cast it to view and process
            if (take === blockLen) {
                const dataView = (0, utils_js_1$3.createView)(data);
                for (; blockLen <= len - pos; pos += blockLen)
                    this.process(dataView, pos);
                continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
                this.process(view, 0);
                this.pos = 0;
            }
        }
        this.length += data.length;
        this.roundClean();
        return this;
    }
    digestInto(out) {
        _assert_js_1$1.default.exists(this);
        _assert_js_1$1.default.output(out, this);
        this.finished = true;
        // Padding
        // We can avoid allocation of buffer for padding completely if it
        // was previously not allocated here. But it won't change performance.
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        // append the bit '1' to the message
        buffer[pos++] = 0b10000000;
        this.buffer.subarray(pos).fill(0);
        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again
        if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
        }
        // Pad until full block byte with zeros
        for (let i = pos; i < blockLen; i++)
            buffer[i] = 0;
        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
        // So we just write lowest 64 bits of that value.
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_js_1$3.createView)(out);
        const len = this.outputLen;
        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT
        if (len % 4)
            throw new Error('_sha2: outputLen should be aligned to 32bit');
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
            throw new Error('_sha2: outputLen bigger than state');
        for (let i = 0; i < outLen; i++)
            oview.setUint32(4 * i, state[i], isLE);
    }
    digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
    }
    _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen)
            to.buffer.set(buffer);
        return to;
    }
}
_sha2.SHA2 = SHA2;

Object.defineProperty(sha256$1, "__esModule", { value: true });
sha256$1.sha224 = sha256$1.sha256 = void 0;
const _sha2_js_1$1 = _sha2;
const utils_js_1$2 = utils$a;
// Choice: a ? b : c
const Chi = (a, b, c) => (a & b) ^ (~a & c);
// Majority function, true if any two inpust is true
const Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);
// Round constants:
// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)
// prettier-ignore
const SHA256_K = new Uint32Array([
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
]);
// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):
// prettier-ignore
const IV = new Uint32Array([
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
]);
// Temporary buffer, not used to store anything between runs
// Named this way because it matches specification.
const SHA256_W = new Uint32Array(64);
class SHA256 extends _sha2_js_1$1.SHA2 {
    constructor() {
        super(64, 32, 8, false);
        // We cannot use array here since array allows indexing by variable
        // which means optimizer/compiler cannot use registers.
        this.A = IV[0] | 0;
        this.B = IV[1] | 0;
        this.C = IV[2] | 0;
        this.D = IV[3] | 0;
        this.E = IV[4] | 0;
        this.F = IV[5] | 0;
        this.G = IV[6] | 0;
        this.H = IV[7] | 0;
    }
    get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
        for (let i = 0; i < 16; i++, offset += 4)
            SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
            const W15 = SHA256_W[i - 15];
            const W2 = SHA256_W[i - 2];
            const s0 = (0, utils_js_1$2.rotr)(W15, 7) ^ (0, utils_js_1$2.rotr)(W15, 18) ^ (W15 >>> 3);
            const s1 = (0, utils_js_1$2.rotr)(W2, 17) ^ (0, utils_js_1$2.rotr)(W2, 19) ^ (W2 >>> 10);
            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;
        }
        // Compression function main loop, 64 rounds
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
            const sigma1 = (0, utils_js_1$2.rotr)(E, 6) ^ (0, utils_js_1$2.rotr)(E, 11) ^ (0, utils_js_1$2.rotr)(E, 25);
            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
            const sigma0 = (0, utils_js_1$2.rotr)(A, 2) ^ (0, utils_js_1$2.rotr)(A, 13) ^ (0, utils_js_1$2.rotr)(A, 22);
            const T2 = (sigma0 + Maj(A, B, C)) | 0;
            H = G;
            G = F;
            F = E;
            E = (D + T1) | 0;
            D = C;
            C = B;
            B = A;
            A = (T1 + T2) | 0;
        }
        // Add the compressed chunk to the current hash value
        A = (A + this.A) | 0;
        B = (B + this.B) | 0;
        C = (C + this.C) | 0;
        D = (D + this.D) | 0;
        E = (E + this.E) | 0;
        F = (F + this.F) | 0;
        G = (G + this.G) | 0;
        H = (H + this.H) | 0;
        this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
        SHA256_W.fill(0);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
    }
}
// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf
class SHA224 extends SHA256 {
    constructor() {
        super();
        this.A = 0xc1059ed8 | 0;
        this.B = 0x367cd507 | 0;
        this.C = 0x3070dd17 | 0;
        this.D = 0xf70e5939 | 0;
        this.E = 0xffc00b31 | 0;
        this.F = 0x68581511 | 0;
        this.G = 0x64f98fa7 | 0;
        this.H = 0xbefa4fa4 | 0;
        this.outputLen = 28;
    }
}
/**
 * SHA2-256 hash function
 * @param message - data that would be hashed
 */
sha256$1.sha256 = (0, utils_js_1$2.wrapConstructor)(() => new SHA256());
sha256$1.sha224 = (0, utils_js_1$2.wrapConstructor)(() => new SHA224());

var sha512$1 = {};

var _u64 = {};

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.add = exports.toBig = exports.split = exports.fromBig = void 0;
	const U32_MASK64 = BigInt(2 ** 32 - 1);
	const _32n = BigInt(32);
	// We are not using BigUint64Array, because they are extremely slow as per 2022
	function fromBig(n, le = false) {
	    if (le)
	        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };
	    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
	}
	exports.fromBig = fromBig;
	function split(lst, le = false) {
	    let Ah = new Uint32Array(lst.length);
	    let Al = new Uint32Array(lst.length);
	    for (let i = 0; i < lst.length; i++) {
	        const { h, l } = fromBig(lst[i], le);
	        [Ah[i], Al[i]] = [h, l];
	    }
	    return [Ah, Al];
	}
	exports.split = split;
	const toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);
	exports.toBig = toBig;
	// for Shift in [0, 32)
	const shrSH = (h, l, s) => h >>> s;
	const shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
	// Right rotate for Shift in [1, 32)
	const rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));
	const rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
	// Right rotate for Shift in (32, 64), NOTE: 32 is special case.
	const rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));
	const rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));
	// Right rotate for shift===32 (just swaps l&h)
	const rotr32H = (h, l) => l;
	const rotr32L = (h, l) => h;
	// Left rotate for Shift in [1, 32)
	const rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));
	const rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));
	// Left rotate for Shift in (32, 64), NOTE: 32 is special case.
	const rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));
	const rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));
	// JS uses 32-bit signed integers for bitwise operations which means we cannot
	// simple take carry out of low bit sum by shift, we need to use division.
	// Removing "export" has 5% perf penalty -_-
	function add(Ah, Al, Bh, Bl) {
	    const l = (Al >>> 0) + (Bl >>> 0);
	    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };
	}
	exports.add = add;
	// Addition with more than 2 elements
	const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
	const add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;
	const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
	const add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;
	const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
	const add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;
	// prettier-ignore
	const u64 = {
	    fromBig, split, toBig: exports.toBig,
	    shrSH, shrSL,
	    rotrSH, rotrSL, rotrBH, rotrBL,
	    rotr32H, rotr32L,
	    rotlSH, rotlSL, rotlBH, rotlBL,
	    add, add3L, add3H, add4L, add4H, add5H, add5L,
	};
	exports.default = u64;
	
} (_u64));

Object.defineProperty(sha512$1, "__esModule", { value: true });
sha512$1.sha384 = sha512$1.sha512_256 = sha512$1.sha512_224 = sha512$1.sha512 = sha512$1.SHA512 = void 0;
const _sha2_js_1 = _sha2;
const _u64_js_1 = _u64;
const utils_js_1$1 = utils$a;
// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):
// prettier-ignore
const [SHA512_Kh, SHA512_Kl] = _u64_js_1.default.split([
    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',
    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',
    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',
    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',
    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',
    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',
    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',
    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',
    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',
    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',
    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',
    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',
    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',
    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',
    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',
    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',
    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',
    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',
    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',
    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'
].map(n => BigInt(n)));
// Temporary buffer, not used to store anything between runs
const SHA512_W_H = new Uint32Array(80);
const SHA512_W_L = new Uint32Array(80);
class SHA512 extends _sha2_js_1.SHA2 {
    constructor() {
        super(128, 64, 16, false);
        // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.
        // Also looks cleaner and easier to verify with spec.
        // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = 0x6a09e667 | 0;
        this.Al = 0xf3bcc908 | 0;
        this.Bh = 0xbb67ae85 | 0;
        this.Bl = 0x84caa73b | 0;
        this.Ch = 0x3c6ef372 | 0;
        this.Cl = 0xfe94f82b | 0;
        this.Dh = 0xa54ff53a | 0;
        this.Dl = 0x5f1d36f1 | 0;
        this.Eh = 0x510e527f | 0;
        this.El = 0xade682d1 | 0;
        this.Fh = 0x9b05688c | 0;
        this.Fl = 0x2b3e6c1f | 0;
        this.Gh = 0x1f83d9ab | 0;
        this.Gl = 0xfb41bd6b | 0;
        this.Hh = 0x5be0cd19 | 0;
        this.Hl = 0x137e2179 | 0;
    }
    // prettier-ignore
    get() {
        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
    }
    // prettier-ignore
    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = Ah | 0;
        this.Al = Al | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl | 0;
        this.Eh = Eh | 0;
        this.El = El | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array
        for (let i = 0; i < 16; i++, offset += 4) {
            SHA512_W_H[i] = view.getUint32(offset);
            SHA512_W_L[i] = view.getUint32((offset += 4));
        }
        for (let i = 16; i < 80; i++) {
            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)
            const W15h = SHA512_W_H[i - 15] | 0;
            const W15l = SHA512_W_L[i - 15] | 0;
            const s0h = _u64_js_1.default.rotrSH(W15h, W15l, 1) ^ _u64_js_1.default.rotrSH(W15h, W15l, 8) ^ _u64_js_1.default.shrSH(W15h, W15l, 7);
            const s0l = _u64_js_1.default.rotrSL(W15h, W15l, 1) ^ _u64_js_1.default.rotrSL(W15h, W15l, 8) ^ _u64_js_1.default.shrSL(W15h, W15l, 7);
            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)
            const W2h = SHA512_W_H[i - 2] | 0;
            const W2l = SHA512_W_L[i - 2] | 0;
            const s1h = _u64_js_1.default.rotrSH(W2h, W2l, 19) ^ _u64_js_1.default.rotrBH(W2h, W2l, 61) ^ _u64_js_1.default.shrSH(W2h, W2l, 6);
            const s1l = _u64_js_1.default.rotrSL(W2h, W2l, 19) ^ _u64_js_1.default.rotrBL(W2h, W2l, 61) ^ _u64_js_1.default.shrSL(W2h, W2l, 6);
            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];
            const SUMl = _u64_js_1.default.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
            const SUMh = _u64_js_1.default.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
            SHA512_W_H[i] = SUMh | 0;
            SHA512_W_L[i] = SUMl | 0;
        }
        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        // Compression function main loop, 80 rounds
        for (let i = 0; i < 80; i++) {
            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)
            const sigma1h = _u64_js_1.default.rotrSH(Eh, El, 14) ^ _u64_js_1.default.rotrSH(Eh, El, 18) ^ _u64_js_1.default.rotrBH(Eh, El, 41);
            const sigma1l = _u64_js_1.default.rotrSL(Eh, El, 14) ^ _u64_js_1.default.rotrSL(Eh, El, 18) ^ _u64_js_1.default.rotrBL(Eh, El, 41);
            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
            const CHIh = (Eh & Fh) ^ (~Eh & Gh);
            const CHIl = (El & Fl) ^ (~El & Gl);
            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]
            // prettier-ignore
            const T1ll = _u64_js_1.default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
            const T1h = _u64_js_1.default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
            const T1l = T1ll | 0;
            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)
            const sigma0h = _u64_js_1.default.rotrSH(Ah, Al, 28) ^ _u64_js_1.default.rotrBH(Ah, Al, 34) ^ _u64_js_1.default.rotrBH(Ah, Al, 39);
            const sigma0l = _u64_js_1.default.rotrSL(Ah, Al, 28) ^ _u64_js_1.default.rotrBL(Ah, Al, 34) ^ _u64_js_1.default.rotrBL(Ah, Al, 39);
            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);
            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);
            Hh = Gh | 0;
            Hl = Gl | 0;
            Gh = Fh | 0;
            Gl = Fl | 0;
            Fh = Eh | 0;
            Fl = El | 0;
            ({ h: Eh, l: El } = _u64_js_1.default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
            Dh = Ch | 0;
            Dl = Cl | 0;
            Ch = Bh | 0;
            Cl = Bl | 0;
            Bh = Ah | 0;
            Bl = Al | 0;
            const All = _u64_js_1.default.add3L(T1l, sigma0l, MAJl);
            Ah = _u64_js_1.default.add3H(All, T1h, sigma0h, MAJh);
            Al = All | 0;
        }
        // Add the compressed chunk to the current hash value
        ({ h: Ah, l: Al } = _u64_js_1.default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
        ({ h: Bh, l: Bl } = _u64_js_1.default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
        ({ h: Ch, l: Cl } = _u64_js_1.default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
        ({ h: Dh, l: Dl } = _u64_js_1.default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
        ({ h: Eh, l: El } = _u64_js_1.default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
        ({ h: Fh, l: Fl } = _u64_js_1.default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
        ({ h: Gh, l: Gl } = _u64_js_1.default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
        ({ h: Hh, l: Hl } = _u64_js_1.default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
    }
    roundClean() {
        SHA512_W_H.fill(0);
        SHA512_W_L.fill(0);
    }
    destroy() {
        this.buffer.fill(0);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
}
sha512$1.SHA512 = SHA512;
class SHA512_224 extends SHA512 {
    constructor() {
        super();
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = 0x8c3d37c8 | 0;
        this.Al = 0x19544da2 | 0;
        this.Bh = 0x73e19966 | 0;
        this.Bl = 0x89dcd4d6 | 0;
        this.Ch = 0x1dfab7ae | 0;
        this.Cl = 0x32ff9c82 | 0;
        this.Dh = 0x679dd514 | 0;
        this.Dl = 0x582f9fcf | 0;
        this.Eh = 0x0f6d2b69 | 0;
        this.El = 0x7bd44da8 | 0;
        this.Fh = 0x77e36f73 | 0;
        this.Fl = 0x04c48942 | 0;
        this.Gh = 0x3f9d85a8 | 0;
        this.Gl = 0x6a1d36c8 | 0;
        this.Hh = 0x1112e6ad | 0;
        this.Hl = 0x91d692a1 | 0;
        this.outputLen = 28;
    }
}
class SHA512_256 extends SHA512 {
    constructor() {
        super();
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = 0x22312194 | 0;
        this.Al = 0xfc2bf72c | 0;
        this.Bh = 0x9f555fa3 | 0;
        this.Bl = 0xc84c64c2 | 0;
        this.Ch = 0x2393b86b | 0;
        this.Cl = 0x6f53b151 | 0;
        this.Dh = 0x96387719 | 0;
        this.Dl = 0x5940eabd | 0;
        this.Eh = 0x96283ee2 | 0;
        this.El = 0xa88effe3 | 0;
        this.Fh = 0xbe5e1e25 | 0;
        this.Fl = 0x53863992 | 0;
        this.Gh = 0x2b0199fc | 0;
        this.Gl = 0x2c85b8aa | 0;
        this.Hh = 0x0eb72ddc | 0;
        this.Hl = 0x81c52ca2 | 0;
        this.outputLen = 32;
    }
}
class SHA384 extends SHA512 {
    constructor() {
        super();
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = 0xcbbb9d5d | 0;
        this.Al = 0xc1059ed8 | 0;
        this.Bh = 0x629a292a | 0;
        this.Bl = 0x367cd507 | 0;
        this.Ch = 0x9159015a | 0;
        this.Cl = 0x3070dd17 | 0;
        this.Dh = 0x152fecd8 | 0;
        this.Dl = 0xf70e5939 | 0;
        this.Eh = 0x67332667 | 0;
        this.El = 0xffc00b31 | 0;
        this.Fh = 0x8eb44a87 | 0;
        this.Fl = 0x68581511 | 0;
        this.Gh = 0xdb0c2e0d | 0;
        this.Gl = 0x64f98fa7 | 0;
        this.Hh = 0x47b5481d | 0;
        this.Hl = 0xbefa4fa4 | 0;
        this.outputLen = 48;
    }
}
sha512$1.sha512 = (0, utils_js_1$1.wrapConstructor)(() => new SHA512());
sha512$1.sha512_224 = (0, utils_js_1$1.wrapConstructor)(() => new SHA512_224());
sha512$1.sha512_256 = (0, utils_js_1$1.wrapConstructor)(() => new SHA512_256());
sha512$1.sha384 = (0, utils_js_1$1.wrapConstructor)(() => new SHA384());

var pbkdf2$2 = {};

var hmac$1 = {};

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.hmac = void 0;
	const _assert_js_1 = _assert;
	const utils_js_1 = utils$a;
	// HMAC (RFC 2104)
	class HMAC extends utils_js_1.Hash {
	    constructor(hash, _key) {
	        super();
	        this.finished = false;
	        this.destroyed = false;
	        _assert_js_1.default.hash(hash);
	        const key = (0, utils_js_1.toBytes)(_key);
	        this.iHash = hash.create();
	        if (typeof this.iHash.update !== 'function')
	            throw new TypeError('Expected instance of class which extends utils.Hash');
	        this.blockLen = this.iHash.blockLen;
	        this.outputLen = this.iHash.outputLen;
	        const blockLen = this.blockLen;
	        const pad = new Uint8Array(blockLen);
	        // blockLen can be bigger than outputLen
	        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
	        for (let i = 0; i < pad.length; i++)
	            pad[i] ^= 0x36;
	        this.iHash.update(pad);
	        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone
	        this.oHash = hash.create();
	        // Undo internal XOR && apply outer XOR
	        for (let i = 0; i < pad.length; i++)
	            pad[i] ^= 0x36 ^ 0x5c;
	        this.oHash.update(pad);
	        pad.fill(0);
	    }
	    update(buf) {
	        _assert_js_1.default.exists(this);
	        this.iHash.update(buf);
	        return this;
	    }
	    digestInto(out) {
	        _assert_js_1.default.exists(this);
	        _assert_js_1.default.bytes(out, this.outputLen);
	        this.finished = true;
	        this.iHash.digestInto(out);
	        this.oHash.update(out);
	        this.oHash.digestInto(out);
	        this.destroy();
	    }
	    digest() {
	        const out = new Uint8Array(this.oHash.outputLen);
	        this.digestInto(out);
	        return out;
	    }
	    _cloneInto(to) {
	        // Create new instance without calling constructor since key already in state and we don't know it.
	        to || (to = Object.create(Object.getPrototypeOf(this), {}));
	        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
	        to = to;
	        to.finished = finished;
	        to.destroyed = destroyed;
	        to.blockLen = blockLen;
	        to.outputLen = outputLen;
	        to.oHash = oHash._cloneInto(to.oHash);
	        to.iHash = iHash._cloneInto(to.iHash);
	        return to;
	    }
	    destroy() {
	        this.destroyed = true;
	        this.oHash.destroy();
	        this.iHash.destroy();
	    }
	}
	/**
	 * HMAC: RFC2104 message authentication code.
	 * @param hash - function that would be used e.g. sha256
	 * @param key - message key
	 * @param message - message data
	 */
	const hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
	exports.hmac = hmac;
	exports.hmac.create = (hash, key) => new HMAC(hash, key);
	
} (hmac$1));

Object.defineProperty(pbkdf2$2, "__esModule", { value: true });
pbkdf2$2.pbkdf2Async = pbkdf2$2.pbkdf2 = void 0;
const _assert_js_1 = _assert;
const hmac_js_1 = hmac$1;
const utils_js_1 = utils$a;
// Common prologue and epilogue for sync/async functions
function pbkdf2Init(hash, _password, _salt, _opts) {
    _assert_js_1.default.hash(hash);
    const opts = (0, utils_js_1.checkOpts)({ dkLen: 32, asyncTick: 10 }, _opts);
    const { c, dkLen, asyncTick } = opts;
    _assert_js_1.default.number(c);
    _assert_js_1.default.number(dkLen);
    _assert_js_1.default.number(asyncTick);
    if (c < 1)
        throw new Error('PBKDF2: iterations (c) should be >= 1');
    const password = (0, utils_js_1.toBytes)(_password);
    const salt = (0, utils_js_1.toBytes)(_salt);
    // DK = PBKDF2(PRF, Password, Salt, c, dkLen);
    const DK = new Uint8Array(dkLen);
    // U1 = PRF(Password, Salt + INT_32_BE(i))
    const PRF = hmac_js_1.hmac.create(hash, password);
    const PRFSalt = PRF._cloneInto().update(salt);
    return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
}
function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
    PRF.destroy();
    PRFSalt.destroy();
    if (prfW)
        prfW.destroy();
    u.fill(0);
    return DK;
}
/**
 * PBKDF2-HMAC: RFC 2898 key derivation function
 * @param hash - hash function that would be used e.g. sha256
 * @param password - password from which a derived key is generated
 * @param salt - cryptographic salt
 * @param opts - {c, dkLen} where c is work factor and dkLen is output message size
 */
function pbkdf2$1(hash, password, salt, opts) {
    const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
    let prfW; // Working copy
    const arr = new Uint8Array(4);
    const view = (0, utils_js_1.createView)(arr);
    const u = new Uint8Array(PRF.outputLen);
    // DK = T1 + T2 +  + Tdklen/hlen
    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
        // Ti = F(Password, Salt, c, i)
        const Ti = DK.subarray(pos, pos + PRF.outputLen);
        view.setInt32(0, ti, false);
        // F(Password, Salt, c, i) = U1 ^ U2 ^  ^ Uc
        // U1 = PRF(Password, Salt + INT_32_BE(i))
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
        Ti.set(u.subarray(0, Ti.length));
        for (let ui = 1; ui < c; ui++) {
            // Uc = PRF(Password, Uc1)
            PRF._cloneInto(prfW).update(u).digestInto(u);
            for (let i = 0; i < Ti.length; i++)
                Ti[i] ^= u[i];
        }
    }
    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
}
pbkdf2$2.pbkdf2 = pbkdf2$1;
async function pbkdf2Async(hash, password, salt, opts) {
    const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
    let prfW; // Working copy
    const arr = new Uint8Array(4);
    const view = (0, utils_js_1.createView)(arr);
    const u = new Uint8Array(PRF.outputLen);
    // DK = T1 + T2 +  + Tdklen/hlen
    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
        // Ti = F(Password, Salt, c, i)
        const Ti = DK.subarray(pos, pos + PRF.outputLen);
        view.setInt32(0, ti, false);
        // F(Password, Salt, c, i) = U1 ^ U2 ^  ^ Uc
        // U1 = PRF(Password, Salt + INT_32_BE(i))
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
        Ti.set(u.subarray(0, Ti.length));
        await (0, utils_js_1.asyncLoop)(c - 1, asyncTick, (i) => {
            // Uc = PRF(Password, Uc1)
            PRF._cloneInto(prfW).update(u).digestInto(u);
            for (let i = 0; i < Ti.length; i++)
                Ti[i] ^= u[i];
        });
    }
    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
}
pbkdf2$2.pbkdf2Async = pbkdf2Async;

var _wordlists = {};

var require$$0$1 = [
	"abdikace",
	"abeceda",
	"adresa",
	"agrese",
	"akce",
	"aktovka",
	"alej",
	"alkohol",
	"amputace",
	"ananas",
	"andulka",
	"anekdota",
	"anketa",
	"antika",
	"anulovat",
	"archa",
	"arogance",
	"asfalt",
	"asistent",
	"aspirace",
	"astma",
	"astronom",
	"atlas",
	"atletika",
	"atol",
	"autobus",
	"azyl",
	"babka",
	"bachor",
	"bacil",
	"baculka",
	"badatel",
	"bageta",
	"bagr",
	"bahno",
	"bakterie",
	"balada",
	"baletka",
	"balkon",
	"balonek",
	"balvan",
	"balza",
	"bambus",
	"bankomat",
	"barbar",
	"baret",
	"barman",
	"baroko",
	"barva",
	"baterka",
	"batoh",
	"bavlna",
	"bazalka",
	"bazilika",
	"bazuka",
	"bedna",
	"beran",
	"beseda",
	"bestie",
	"beton",
	"bezinka",
	"bezmoc",
	"beztak",
	"bicykl",
	"bidlo",
	"biftek",
	"bikiny",
	"bilance",
	"biograf",
	"biolog",
	"bitva",
	"bizon",
	"blahobyt",
	"blatouch",
	"blecha",
	"bledule",
	"blesk",
	"blikat",
	"blizna",
	"blokovat",
	"bloudit",
	"blud",
	"bobek",
	"bobr",
	"bodlina",
	"bodnout",
	"bohatost",
	"bojkot",
	"bojovat",
	"bokorys",
	"bolest",
	"borec",
	"borovice",
	"bota",
	"boubel",
	"bouchat",
	"bouda",
	"boule",
	"bourat",
	"boxer",
	"bradavka",
	"brambora",
	"branka",
	"bratr",
	"brepta",
	"briketa",
	"brko",
	"brloh",
	"bronz",
	"broskev",
	"brunetka",
	"brusinka",
	"brzda",
	"brzy",
	"bublina",
	"bubnovat",
	"buchta",
	"buditel",
	"budka",
	"budova",
	"bufet",
	"bujarost",
	"bukvice",
	"buldok",
	"bulva",
	"bunda",
	"bunkr",
	"burza",
	"butik",
	"buvol",
	"buzola",
	"bydlet",
	"bylina",
	"bytovka",
	"bzukot",
	"capart",
	"carevna",
	"cedr",
	"cedule",
	"cejch",
	"cejn",
	"cela",
	"celer",
	"celkem",
	"celnice",
	"cenina",
	"cennost",
	"cenovka",
	"centrum",
	"cenzor",
	"cestopis",
	"cetka",
	"chalupa",
	"chapadlo",
	"charita",
	"chata",
	"chechtat",
	"chemie",
	"chichot",
	"chirurg",
	"chlad",
	"chleba",
	"chlubit",
	"chmel",
	"chmura",
	"chobot",
	"chochol",
	"chodba",
	"cholera",
	"chomout",
	"chopit",
	"choroba",
	"chov",
	"chrapot",
	"chrlit",
	"chrt",
	"chrup",
	"chtivost",
	"chudina",
	"chutnat",
	"chvat",
	"chvilka",
	"chvost",
	"chyba",
	"chystat",
	"chytit",
	"cibule",
	"cigareta",
	"cihelna",
	"cihla",
	"cinkot",
	"cirkus",
	"cisterna",
	"citace",
	"citrus",
	"cizinec",
	"cizost",
	"clona",
	"cokoliv",
	"couvat",
	"ctitel",
	"ctnost",
	"cudnost",
	"cuketa",
	"cukr",
	"cupot",
	"cvaknout",
	"cval",
	"cvik",
	"cvrkot",
	"cyklista",
	"daleko",
	"dareba",
	"datel",
	"datum",
	"dcera",
	"debata",
	"dechovka",
	"decibel",
	"deficit",
	"deflace",
	"dekl",
	"dekret",
	"demokrat",
	"deprese",
	"derby",
	"deska",
	"detektiv",
	"dikobraz",
	"diktovat",
	"dioda",
	"diplom",
	"disk",
	"displej",
	"divadlo",
	"divoch",
	"dlaha",
	"dlouho",
	"dluhopis",
	"dnes",
	"dobro",
	"dobytek",
	"docent",
	"dochutit",
	"dodnes",
	"dohled",
	"dohoda",
	"dohra",
	"dojem",
	"dojnice",
	"doklad",
	"dokola",
	"doktor",
	"dokument",
	"dolar",
	"doleva",
	"dolina",
	"doma",
	"dominant",
	"domluvit",
	"domov",
	"donutit",
	"dopad",
	"dopis",
	"doplnit",
	"doposud",
	"doprovod",
	"dopustit",
	"dorazit",
	"dorost",
	"dort",
	"dosah",
	"doslov",
	"dostatek",
	"dosud",
	"dosyta",
	"dotaz",
	"dotek",
	"dotknout",
	"doufat",
	"doutnat",
	"dovozce",
	"dozadu",
	"doznat",
	"dozorce",
	"drahota",
	"drak",
	"dramatik",
	"dravec",
	"draze",
	"drdol",
	"drobnost",
	"drogerie",
	"drozd",
	"drsnost",
	"drtit",
	"drzost",
	"duben",
	"duchovno",
	"dudek",
	"duha",
	"duhovka",
	"dusit",
	"dusno",
	"dutost",
	"dvojice",
	"dvorec",
	"dynamit",
	"ekolog",
	"ekonomie",
	"elektron",
	"elipsa",
	"email",
	"emise",
	"emoce",
	"empatie",
	"epizoda",
	"epocha",
	"epopej",
	"epos",
	"esej",
	"esence",
	"eskorta",
	"eskymo",
	"etiketa",
	"euforie",
	"evoluce",
	"exekuce",
	"exkurze",
	"expedice",
	"exploze",
	"export",
	"extrakt",
	"facka",
	"fajfka",
	"fakulta",
	"fanatik",
	"fantazie",
	"farmacie",
	"favorit",
	"fazole",
	"federace",
	"fejeton",
	"fenka",
	"fialka",
	"figurant",
	"filozof",
	"filtr",
	"finance",
	"finta",
	"fixace",
	"fjord",
	"flanel",
	"flirt",
	"flotila",
	"fond",
	"fosfor",
	"fotbal",
	"fotka",
	"foton",
	"frakce",
	"freska",
	"fronta",
	"fukar",
	"funkce",
	"fyzika",
	"galeje",
	"garant",
	"genetika",
	"geolog",
	"gilotina",
	"glazura",
	"glejt",
	"golem",
	"golfista",
	"gotika",
	"graf",
	"gramofon",
	"granule",
	"grep",
	"gril",
	"grog",
	"groteska",
	"guma",
	"hadice",
	"hadr",
	"hala",
	"halenka",
	"hanba",
	"hanopis",
	"harfa",
	"harpuna",
	"havran",
	"hebkost",
	"hejkal",
	"hejno",
	"hejtman",
	"hektar",
	"helma",
	"hematom",
	"herec",
	"herna",
	"heslo",
	"hezky",
	"historik",
	"hladovka",
	"hlasivky",
	"hlava",
	"hledat",
	"hlen",
	"hlodavec",
	"hloh",
	"hloupost",
	"hltat",
	"hlubina",
	"hluchota",
	"hmat",
	"hmota",
	"hmyz",
	"hnis",
	"hnojivo",
	"hnout",
	"hoblina",
	"hoboj",
	"hoch",
	"hodiny",
	"hodlat",
	"hodnota",
	"hodovat",
	"hojnost",
	"hokej",
	"holinka",
	"holka",
	"holub",
	"homole",
	"honitba",
	"honorace",
	"horal",
	"horda",
	"horizont",
	"horko",
	"horlivec",
	"hormon",
	"hornina",
	"horoskop",
	"horstvo",
	"hospoda",
	"hostina",
	"hotovost",
	"houba",
	"houf",
	"houpat",
	"houska",
	"hovor",
	"hradba",
	"hranice",
	"hravost",
	"hrazda",
	"hrbolek",
	"hrdina",
	"hrdlo",
	"hrdost",
	"hrnek",
	"hrobka",
	"hromada",
	"hrot",
	"hrouda",
	"hrozen",
	"hrstka",
	"hrubost",
	"hryzat",
	"hubenost",
	"hubnout",
	"hudba",
	"hukot",
	"humr",
	"husita",
	"hustota",
	"hvozd",
	"hybnost",
	"hydrant",
	"hygiena",
	"hymna",
	"hysterik",
	"idylka",
	"ihned",
	"ikona",
	"iluze",
	"imunita",
	"infekce",
	"inflace",
	"inkaso",
	"inovace",
	"inspekce",
	"internet",
	"invalida",
	"investor",
	"inzerce",
	"ironie",
	"jablko",
	"jachta",
	"jahoda",
	"jakmile",
	"jakost",
	"jalovec",
	"jantar",
	"jarmark",
	"jaro",
	"jasan",
	"jasno",
	"jatka",
	"javor",
	"jazyk",
	"jedinec",
	"jedle",
	"jednatel",
	"jehlan",
	"jekot",
	"jelen",
	"jelito",
	"jemnost",
	"jenom",
	"jepice",
	"jeseter",
	"jevit",
	"jezdec",
	"jezero",
	"jinak",
	"jindy",
	"jinoch",
	"jiskra",
	"jistota",
	"jitrnice",
	"jizva",
	"jmenovat",
	"jogurt",
	"jurta",
	"kabaret",
	"kabel",
	"kabinet",
	"kachna",
	"kadet",
	"kadidlo",
	"kahan",
	"kajak",
	"kajuta",
	"kakao",
	"kaktus",
	"kalamita",
	"kalhoty",
	"kalibr",
	"kalnost",
	"kamera",
	"kamkoliv",
	"kamna",
	"kanibal",
	"kanoe",
	"kantor",
	"kapalina",
	"kapela",
	"kapitola",
	"kapka",
	"kaple",
	"kapota",
	"kapr",
	"kapusta",
	"kapybara",
	"karamel",
	"karotka",
	"karton",
	"kasa",
	"katalog",
	"katedra",
	"kauce",
	"kauza",
	"kavalec",
	"kazajka",
	"kazeta",
	"kazivost",
	"kdekoliv",
	"kdesi",
	"kedluben",
	"kemp",
	"keramika",
	"kino",
	"klacek",
	"kladivo",
	"klam",
	"klapot",
	"klasika",
	"klaun",
	"klec",
	"klenba",
	"klepat",
	"klesnout",
	"klid",
	"klima",
	"klisna",
	"klobouk",
	"klokan",
	"klopa",
	"kloub",
	"klubovna",
	"klusat",
	"kluzkost",
	"kmen",
	"kmitat",
	"kmotr",
	"kniha",
	"knot",
	"koalice",
	"koberec",
	"kobka",
	"kobliha",
	"kobyla",
	"kocour",
	"kohout",
	"kojenec",
	"kokos",
	"koktejl",
	"kolaps",
	"koleda",
	"kolize",
	"kolo",
	"komando",
	"kometa",
	"komik",
	"komnata",
	"komora",
	"kompas",
	"komunita",
	"konat",
	"koncept",
	"kondice",
	"konec",
	"konfese",
	"kongres",
	"konina",
	"konkurs",
	"kontakt",
	"konzerva",
	"kopanec",
	"kopie",
	"kopnout",
	"koprovka",
	"korbel",
	"korektor",
	"kormidlo",
	"koroptev",
	"korpus",
	"koruna",
	"koryto",
	"korzet",
	"kosatec",
	"kostka",
	"kotel",
	"kotleta",
	"kotoul",
	"koukat",
	"koupelna",
	"kousek",
	"kouzlo",
	"kovboj",
	"koza",
	"kozoroh",
	"krabice",
	"krach",
	"krajina",
	"kralovat",
	"krasopis",
	"kravata",
	"kredit",
	"krejcar",
	"kresba",
	"kreveta",
	"kriket",
	"kritik",
	"krize",
	"krkavec",
	"krmelec",
	"krmivo",
	"krocan",
	"krok",
	"kronika",
	"kropit",
	"kroupa",
	"krovka",
	"krtek",
	"kruhadlo",
	"krupice",
	"krutost",
	"krvinka",
	"krychle",
	"krypta",
	"krystal",
	"kryt",
	"kudlanka",
	"kufr",
	"kujnost",
	"kukla",
	"kulajda",
	"kulich",
	"kulka",
	"kulomet",
	"kultura",
	"kuna",
	"kupodivu",
	"kurt",
	"kurzor",
	"kutil",
	"kvalita",
	"kvasinka",
	"kvestor",
	"kynolog",
	"kyselina",
	"kytara",
	"kytice",
	"kytka",
	"kytovec",
	"kyvadlo",
	"labrador",
	"lachtan",
	"ladnost",
	"laik",
	"lakomec",
	"lamela",
	"lampa",
	"lanovka",
	"lasice",
	"laso",
	"lastura",
	"latinka",
	"lavina",
	"lebka",
	"leckdy",
	"leden",
	"lednice",
	"ledovka",
	"ledvina",
	"legenda",
	"legie",
	"legrace",
	"lehce",
	"lehkost",
	"lehnout",
	"lektvar",
	"lenochod",
	"lentilka",
	"lepenka",
	"lepidlo",
	"letadlo",
	"letec",
	"letmo",
	"letokruh",
	"levhart",
	"levitace",
	"levobok",
	"libra",
	"lichotka",
	"lidojed",
	"lidskost",
	"lihovina",
	"lijavec",
	"lilek",
	"limetka",
	"linie",
	"linka",
	"linoleum",
	"listopad",
	"litina",
	"litovat",
	"lobista",
	"lodivod",
	"logika",
	"logoped",
	"lokalita",
	"loket",
	"lomcovat",
	"lopata",
	"lopuch",
	"lord",
	"losos",
	"lotr",
	"loudal",
	"louh",
	"louka",
	"louskat",
	"lovec",
	"lstivost",
	"lucerna",
	"lucifer",
	"lump",
	"lusk",
	"lustrace",
	"lvice",
	"lyra",
	"lyrika",
	"lysina",
	"madam",
	"madlo",
	"magistr",
	"mahagon",
	"majetek",
	"majitel",
	"majorita",
	"makak",
	"makovice",
	"makrela",
	"malba",
	"malina",
	"malovat",
	"malvice",
	"maminka",
	"mandle",
	"manko",
	"marnost",
	"masakr",
	"maskot",
	"masopust",
	"matice",
	"matrika",
	"maturita",
	"mazanec",
	"mazivo",
	"mazlit",
	"mazurka",
	"mdloba",
	"mechanik",
	"meditace",
	"medovina",
	"melasa",
	"meloun",
	"mentolka",
	"metla",
	"metoda",
	"metr",
	"mezera",
	"migrace",
	"mihnout",
	"mihule",
	"mikina",
	"mikrofon",
	"milenec",
	"milimetr",
	"milost",
	"mimika",
	"mincovna",
	"minibar",
	"minomet",
	"minulost",
	"miska",
	"mistr",
	"mixovat",
	"mladost",
	"mlha",
	"mlhovina",
	"mlok",
	"mlsat",
	"mluvit",
	"mnich",
	"mnohem",
	"mobil",
	"mocnost",
	"modelka",
	"modlitba",
	"mohyla",
	"mokro",
	"molekula",
	"momentka",
	"monarcha",
	"monokl",
	"monstrum",
	"montovat",
	"monzun",
	"mosaz",
	"moskyt",
	"most",
	"motivace",
	"motorka",
	"motyka",
	"moucha",
	"moudrost",
	"mozaika",
	"mozek",
	"mozol",
	"mramor",
	"mravenec",
	"mrkev",
	"mrtvola",
	"mrzet",
	"mrzutost",
	"mstitel",
	"mudrc",
	"muflon",
	"mulat",
	"mumie",
	"munice",
	"muset",
	"mutace",
	"muzeum",
	"muzikant",
	"myslivec",
	"mzda",
	"nabourat",
	"nachytat",
	"nadace",
	"nadbytek",
	"nadhoz",
	"nadobro",
	"nadpis",
	"nahlas",
	"nahnat",
	"nahodile",
	"nahradit",
	"naivita",
	"najednou",
	"najisto",
	"najmout",
	"naklonit",
	"nakonec",
	"nakrmit",
	"nalevo",
	"namazat",
	"namluvit",
	"nanometr",
	"naoko",
	"naopak",
	"naostro",
	"napadat",
	"napevno",
	"naplnit",
	"napnout",
	"naposled",
	"naprosto",
	"narodit",
	"naruby",
	"narychlo",
	"nasadit",
	"nasekat",
	"naslepo",
	"nastat",
	"natolik",
	"navenek",
	"navrch",
	"navzdory",
	"nazvat",
	"nebe",
	"nechat",
	"necky",
	"nedaleko",
	"nedbat",
	"neduh",
	"negace",
	"nehet",
	"nehoda",
	"nejen",
	"nejprve",
	"neklid",
	"nelibost",
	"nemilost",
	"nemoc",
	"neochota",
	"neonka",
	"nepokoj",
	"nerost",
	"nerv",
	"nesmysl",
	"nesoulad",
	"netvor",
	"neuron",
	"nevina",
	"nezvykle",
	"nicota",
	"nijak",
	"nikam",
	"nikdy",
	"nikl",
	"nikterak",
	"nitro",
	"nocleh",
	"nohavice",
	"nominace",
	"nora",
	"norek",
	"nositel",
	"nosnost",
	"nouze",
	"noviny",
	"novota",
	"nozdra",
	"nuda",
	"nudle",
	"nuget",
	"nutit",
	"nutnost",
	"nutrie",
	"nymfa",
	"obal",
	"obarvit",
	"obava",
	"obdiv",
	"obec",
	"obehnat",
	"obejmout",
	"obezita",
	"obhajoba",
	"obilnice",
	"objasnit",
	"objekt",
	"obklopit",
	"oblast",
	"oblek",
	"obliba",
	"obloha",
	"obluda",
	"obnos",
	"obohatit",
	"obojek",
	"obout",
	"obrazec",
	"obrna",
	"obruba",
	"obrys",
	"obsah",
	"obsluha",
	"obstarat",
	"obuv",
	"obvaz",
	"obvinit",
	"obvod",
	"obvykle",
	"obyvatel",
	"obzor",
	"ocas",
	"ocel",
	"ocenit",
	"ochladit",
	"ochota",
	"ochrana",
	"ocitnout",
	"odboj",
	"odbyt",
	"odchod",
	"odcizit",
	"odebrat",
	"odeslat",
	"odevzdat",
	"odezva",
	"odhadce",
	"odhodit",
	"odjet",
	"odjinud",
	"odkaz",
	"odkoupit",
	"odliv",
	"odluka",
	"odmlka",
	"odolnost",
	"odpad",
	"odpis",
	"odplout",
	"odpor",
	"odpustit",
	"odpykat",
	"odrazka",
	"odsoudit",
	"odstup",
	"odsun",
	"odtok",
	"odtud",
	"odvaha",
	"odveta",
	"odvolat",
	"odvracet",
	"odznak",
	"ofina",
	"ofsajd",
	"ohlas",
	"ohnisko",
	"ohrada",
	"ohrozit",
	"ohryzek",
	"okap",
	"okenice",
	"oklika",
	"okno",
	"okouzlit",
	"okovy",
	"okrasa",
	"okres",
	"okrsek",
	"okruh",
	"okupant",
	"okurka",
	"okusit",
	"olejnina",
	"olizovat",
	"omak",
	"omeleta",
	"omezit",
	"omladina",
	"omlouvat",
	"omluva",
	"omyl",
	"onehdy",
	"opakovat",
	"opasek",
	"operace",
	"opice",
	"opilost",
	"opisovat",
	"opora",
	"opozice",
	"opravdu",
	"oproti",
	"orbital",
	"orchestr",
	"orgie",
	"orlice",
	"orloj",
	"ortel",
	"osada",
	"oschnout",
	"osika",
	"osivo",
	"oslava",
	"oslepit",
	"oslnit",
	"oslovit",
	"osnova",
	"osoba",
	"osolit",
	"ospalec",
	"osten",
	"ostraha",
	"ostuda",
	"ostych",
	"osvojit",
	"oteplit",
	"otisk",
	"otop",
	"otrhat",
	"otrlost",
	"otrok",
	"otruby",
	"otvor",
	"ovanout",
	"ovar",
	"oves",
	"ovlivnit",
	"ovoce",
	"oxid",
	"ozdoba",
	"pachatel",
	"pacient",
	"padouch",
	"pahorek",
	"pakt",
	"palanda",
	"palec",
	"palivo",
	"paluba",
	"pamflet",
	"pamlsek",
	"panenka",
	"panika",
	"panna",
	"panovat",
	"panstvo",
	"pantofle",
	"paprika",
	"parketa",
	"parodie",
	"parta",
	"paruka",
	"paryba",
	"paseka",
	"pasivita",
	"pastelka",
	"patent",
	"patrona",
	"pavouk",
	"pazneht",
	"pazourek",
	"pecka",
	"pedagog",
	"pejsek",
	"peklo",
	"peloton",
	"penalta",
	"pendrek",
	"penze",
	"periskop",
	"pero",
	"pestrost",
	"petarda",
	"petice",
	"petrolej",
	"pevnina",
	"pexeso",
	"pianista",
	"piha",
	"pijavice",
	"pikle",
	"piknik",
	"pilina",
	"pilnost",
	"pilulka",
	"pinzeta",
	"pipeta",
	"pisatel",
	"pistole",
	"pitevna",
	"pivnice",
	"pivovar",
	"placenta",
	"plakat",
	"plamen",
	"planeta",
	"plastika",
	"platit",
	"plavidlo",
	"plaz",
	"plech",
	"plemeno",
	"plenta",
	"ples",
	"pletivo",
	"plevel",
	"plivat",
	"plnit",
	"plno",
	"plocha",
	"plodina",
	"plomba",
	"plout",
	"pluk",
	"plyn",
	"pobavit",
	"pobyt",
	"pochod",
	"pocit",
	"poctivec",
	"podat",
	"podcenit",
	"podepsat",
	"podhled",
	"podivit",
	"podklad",
	"podmanit",
	"podnik",
	"podoba",
	"podpora",
	"podraz",
	"podstata",
	"podvod",
	"podzim",
	"poezie",
	"pohanka",
	"pohnutka",
	"pohovor",
	"pohroma",
	"pohyb",
	"pointa",
	"pojistka",
	"pojmout",
	"pokazit",
	"pokles",
	"pokoj",
	"pokrok",
	"pokuta",
	"pokyn",
	"poledne",
	"polibek",
	"polknout",
	"poloha",
	"polynom",
	"pomalu",
	"pominout",
	"pomlka",
	"pomoc",
	"pomsta",
	"pomyslet",
	"ponechat",
	"ponorka",
	"ponurost",
	"popadat",
	"popel",
	"popisek",
	"poplach",
	"poprosit",
	"popsat",
	"popud",
	"poradce",
	"porce",
	"porod",
	"porucha",
	"poryv",
	"posadit",
	"posed",
	"posila",
	"poskok",
	"poslanec",
	"posoudit",
	"pospolu",
	"postava",
	"posudek",
	"posyp",
	"potah",
	"potkan",
	"potlesk",
	"potomek",
	"potrava",
	"potupa",
	"potvora",
	"poukaz",
	"pouto",
	"pouzdro",
	"povaha",
	"povidla",
	"povlak",
	"povoz",
	"povrch",
	"povstat",
	"povyk",
	"povzdech",
	"pozdrav",
	"pozemek",
	"poznatek",
	"pozor",
	"pozvat",
	"pracovat",
	"prahory",
	"praktika",
	"prales",
	"praotec",
	"praporek",
	"prase",
	"pravda",
	"princip",
	"prkno",
	"probudit",
	"procento",
	"prodej",
	"profese",
	"prohra",
	"projekt",
	"prolomit",
	"promile",
	"pronikat",
	"propad",
	"prorok",
	"prosba",
	"proton",
	"proutek",
	"provaz",
	"prskavka",
	"prsten",
	"prudkost",
	"prut",
	"prvek",
	"prvohory",
	"psanec",
	"psovod",
	"pstruh",
	"ptactvo",
	"puberta",
	"puch",
	"pudl",
	"pukavec",
	"puklina",
	"pukrle",
	"pult",
	"pumpa",
	"punc",
	"pupen",
	"pusa",
	"pusinka",
	"pustina",
	"putovat",
	"putyka",
	"pyramida",
	"pysk",
	"pytel",
	"racek",
	"rachot",
	"radiace",
	"radnice",
	"radon",
	"raft",
	"ragby",
	"raketa",
	"rakovina",
	"rameno",
	"rampouch",
	"rande",
	"rarach",
	"rarita",
	"rasovna",
	"rastr",
	"ratolest",
	"razance",
	"razidlo",
	"reagovat",
	"reakce",
	"recept",
	"redaktor",
	"referent",
	"reflex",
	"rejnok",
	"reklama",
	"rekord",
	"rekrut",
	"rektor",
	"reputace",
	"revize",
	"revma",
	"revolver",
	"rezerva",
	"riskovat",
	"riziko",
	"robotika",
	"rodokmen",
	"rohovka",
	"rokle",
	"rokoko",
	"romaneto",
	"ropovod",
	"ropucha",
	"rorejs",
	"rosol",
	"rostlina",
	"rotmistr",
	"rotoped",
	"rotunda",
	"roubenka",
	"roucho",
	"roup",
	"roura",
	"rovina",
	"rovnice",
	"rozbor",
	"rozchod",
	"rozdat",
	"rozeznat",
	"rozhodce",
	"rozinka",
	"rozjezd",
	"rozkaz",
	"rozloha",
	"rozmar",
	"rozpad",
	"rozruch",
	"rozsah",
	"roztok",
	"rozum",
	"rozvod",
	"rubrika",
	"ruchadlo",
	"rukavice",
	"rukopis",
	"ryba",
	"rybolov",
	"rychlost",
	"rydlo",
	"rypadlo",
	"rytina",
	"ryzost",
	"sadista",
	"sahat",
	"sako",
	"samec",
	"samizdat",
	"samota",
	"sanitka",
	"sardinka",
	"sasanka",
	"satelit",
	"sazba",
	"sazenice",
	"sbor",
	"schovat",
	"sebranka",
	"secese",
	"sedadlo",
	"sediment",
	"sedlo",
	"sehnat",
	"sejmout",
	"sekera",
	"sekta",
	"sekunda",
	"sekvoje",
	"semeno",
	"seno",
	"servis",
	"sesadit",
	"seshora",
	"seskok",
	"seslat",
	"sestra",
	"sesuv",
	"sesypat",
	"setba",
	"setina",
	"setkat",
	"setnout",
	"setrvat",
	"sever",
	"seznam",
	"shoda",
	"shrnout",
	"sifon",
	"silnice",
	"sirka",
	"sirotek",
	"sirup",
	"situace",
	"skafandr",
	"skalisko",
	"skanzen",
	"skaut",
	"skeptik",
	"skica",
	"skladba",
	"sklenice",
	"sklo",
	"skluz",
	"skoba",
	"skokan",
	"skoro",
	"skripta",
	"skrz",
	"skupina",
	"skvost",
	"skvrna",
	"slabika",
	"sladidlo",
	"slanina",
	"slast",
	"slavnost",
	"sledovat",
	"slepec",
	"sleva",
	"slezina",
	"slib",
	"slina",
	"sliznice",
	"slon",
	"sloupek",
	"slovo",
	"sluch",
	"sluha",
	"slunce",
	"slupka",
	"slza",
	"smaragd",
	"smetana",
	"smilstvo",
	"smlouva",
	"smog",
	"smrad",
	"smrk",
	"smrtka",
	"smutek",
	"smysl",
	"snad",
	"snaha",
	"snob",
	"sobota",
	"socha",
	"sodovka",
	"sokol",
	"sopka",
	"sotva",
	"souboj",
	"soucit",
	"soudce",
	"souhlas",
	"soulad",
	"soumrak",
	"souprava",
	"soused",
	"soutok",
	"souviset",
	"spalovna",
	"spasitel",
	"spis",
	"splav",
	"spodek",
	"spojenec",
	"spolu",
	"sponzor",
	"spornost",
	"spousta",
	"sprcha",
	"spustit",
	"sranda",
	"sraz",
	"srdce",
	"srna",
	"srnec",
	"srovnat",
	"srpen",
	"srst",
	"srub",
	"stanice",
	"starosta",
	"statika",
	"stavba",
	"stehno",
	"stezka",
	"stodola",
	"stolek",
	"stopa",
	"storno",
	"stoupat",
	"strach",
	"stres",
	"strhnout",
	"strom",
	"struna",
	"studna",
	"stupnice",
	"stvol",
	"styk",
	"subjekt",
	"subtropy",
	"suchar",
	"sudost",
	"sukno",
	"sundat",
	"sunout",
	"surikata",
	"surovina",
	"svah",
	"svalstvo",
	"svetr",
	"svatba",
	"svazek",
	"svisle",
	"svitek",
	"svoboda",
	"svodidlo",
	"svorka",
	"svrab",
	"sykavka",
	"sykot",
	"synek",
	"synovec",
	"sypat",
	"sypkost",
	"syrovost",
	"sysel",
	"sytost",
	"tabletka",
	"tabule",
	"tahoun",
	"tajemno",
	"tajfun",
	"tajga",
	"tajit",
	"tajnost",
	"taktika",
	"tamhle",
	"tampon",
	"tancovat",
	"tanec",
	"tanker",
	"tapeta",
	"tavenina",
	"tazatel",
	"technika",
	"tehdy",
	"tekutina",
	"telefon",
	"temnota",
	"tendence",
	"tenista",
	"tenor",
	"teplota",
	"tepna",
	"teprve",
	"terapie",
	"termoska",
	"textil",
	"ticho",
	"tiskopis",
	"titulek",
	"tkadlec",
	"tkanina",
	"tlapka",
	"tleskat",
	"tlukot",
	"tlupa",
	"tmel",
	"toaleta",
	"topinka",
	"topol",
	"torzo",
	"touha",
	"toulec",
	"tradice",
	"traktor",
	"tramp",
	"trasa",
	"traverza",
	"trefit",
	"trest",
	"trezor",
	"trhavina",
	"trhlina",
	"trochu",
	"trojice",
	"troska",
	"trouba",
	"trpce",
	"trpitel",
	"trpkost",
	"trubec",
	"truchlit",
	"truhlice",
	"trus",
	"trvat",
	"tudy",
	"tuhnout",
	"tuhost",
	"tundra",
	"turista",
	"turnaj",
	"tuzemsko",
	"tvaroh",
	"tvorba",
	"tvrdost",
	"tvrz",
	"tygr",
	"tykev",
	"ubohost",
	"uboze",
	"ubrat",
	"ubrousek",
	"ubrus",
	"ubytovna",
	"ucho",
	"uctivost",
	"udivit",
	"uhradit",
	"ujednat",
	"ujistit",
	"ujmout",
	"ukazatel",
	"uklidnit",
	"uklonit",
	"ukotvit",
	"ukrojit",
	"ulice",
	"ulita",
	"ulovit",
	"umyvadlo",
	"unavit",
	"uniforma",
	"uniknout",
	"upadnout",
	"uplatnit",
	"uplynout",
	"upoutat",
	"upravit",
	"uran",
	"urazit",
	"usednout",
	"usilovat",
	"usmrtit",
	"usnadnit",
	"usnout",
	"usoudit",
	"ustlat",
	"ustrnout",
	"utahovat",
	"utkat",
	"utlumit",
	"utonout",
	"utopenec",
	"utrousit",
	"uvalit",
	"uvolnit",
	"uvozovka",
	"uzdravit",
	"uzel",
	"uzenina",
	"uzlina",
	"uznat",
	"vagon",
	"valcha",
	"valoun",
	"vana",
	"vandal",
	"vanilka",
	"varan",
	"varhany",
	"varovat",
	"vcelku",
	"vchod",
	"vdova",
	"vedro",
	"vegetace",
	"vejce",
	"velbloud",
	"veletrh",
	"velitel",
	"velmoc",
	"velryba",
	"venkov",
	"veranda",
	"verze",
	"veselka",
	"veskrze",
	"vesnice",
	"vespodu",
	"vesta",
	"veterina",
	"veverka",
	"vibrace",
	"vichr",
	"videohra",
	"vidina",
	"vidle",
	"vila",
	"vinice",
	"viset",
	"vitalita",
	"vize",
	"vizitka",
	"vjezd",
	"vklad",
	"vkus",
	"vlajka",
	"vlak",
	"vlasec",
	"vlevo",
	"vlhkost",
	"vliv",
	"vlnovka",
	"vloupat",
	"vnucovat",
	"vnuk",
	"voda",
	"vodivost",
	"vodoznak",
	"vodstvo",
	"vojensky",
	"vojna",
	"vojsko",
	"volant",
	"volba",
	"volit",
	"volno",
	"voskovka",
	"vozidlo",
	"vozovna",
	"vpravo",
	"vrabec",
	"vracet",
	"vrah",
	"vrata",
	"vrba",
	"vrcholek",
	"vrhat",
	"vrstva",
	"vrtule",
	"vsadit",
	"vstoupit",
	"vstup",
	"vtip",
	"vybavit",
	"vybrat",
	"vychovat",
	"vydat",
	"vydra",
	"vyfotit",
	"vyhledat",
	"vyhnout",
	"vyhodit",
	"vyhradit",
	"vyhubit",
	"vyjasnit",
	"vyjet",
	"vyjmout",
	"vyklopit",
	"vykonat",
	"vylekat",
	"vymazat",
	"vymezit",
	"vymizet",
	"vymyslet",
	"vynechat",
	"vynikat",
	"vynutit",
	"vypadat",
	"vyplatit",
	"vypravit",
	"vypustit",
	"vyrazit",
	"vyrovnat",
	"vyrvat",
	"vyslovit",
	"vysoko",
	"vystavit",
	"vysunout",
	"vysypat",
	"vytasit",
	"vytesat",
	"vytratit",
	"vyvinout",
	"vyvolat",
	"vyvrhel",
	"vyzdobit",
	"vyznat",
	"vzadu",
	"vzbudit",
	"vzchopit",
	"vzdor",
	"vzduch",
	"vzdychat",
	"vzestup",
	"vzhledem",
	"vzkaz",
	"vzlykat",
	"vznik",
	"vzorek",
	"vzpoura",
	"vztah",
	"vztek",
	"xylofon",
	"zabrat",
	"zabydlet",
	"zachovat",
	"zadarmo",
	"zadusit",
	"zafoukat",
	"zahltit",
	"zahodit",
	"zahrada",
	"zahynout",
	"zajatec",
	"zajet",
	"zajistit",
	"zaklepat",
	"zakoupit",
	"zalepit",
	"zamezit",
	"zamotat",
	"zamyslet",
	"zanechat",
	"zanikat",
	"zaplatit",
	"zapojit",
	"zapsat",
	"zarazit",
	"zastavit",
	"zasunout",
	"zatajit",
	"zatemnit",
	"zatknout",
	"zaujmout",
	"zavalit",
	"zavelet",
	"zavinit",
	"zavolat",
	"zavrtat",
	"zazvonit",
	"zbavit",
	"zbrusu",
	"zbudovat",
	"zbytek",
	"zdaleka",
	"zdarma",
	"zdatnost",
	"zdivo",
	"zdobit",
	"zdroj",
	"zdvih",
	"zdymadlo",
	"zelenina",
	"zeman",
	"zemina",
	"zeptat",
	"zezadu",
	"zezdola",
	"zhatit",
	"zhltnout",
	"zhluboka",
	"zhotovit",
	"zhruba",
	"zima",
	"zimnice",
	"zjemnit",
	"zklamat",
	"zkoumat",
	"zkratka",
	"zkumavka",
	"zlato",
	"zlehka",
	"zloba",
	"zlom",
	"zlost",
	"zlozvyk",
	"zmapovat",
	"zmar",
	"zmatek",
	"zmije",
	"zmizet",
	"zmocnit",
	"zmodrat",
	"zmrzlina",
	"zmutovat",
	"znak",
	"znalost",
	"znamenat",
	"znovu",
	"zobrazit",
	"zotavit",
	"zoubek",
	"zoufale",
	"zplodit",
	"zpomalit",
	"zprava",
	"zprostit",
	"zprudka",
	"zprvu",
	"zrada",
	"zranit",
	"zrcadlo",
	"zrnitost",
	"zrno",
	"zrovna",
	"zrychlit",
	"zrzavost",
	"zticha",
	"ztratit",
	"zubovina",
	"zubr",
	"zvednout",
	"zvenku",
	"zvesela",
	"zvon",
	"zvrat",
	"zvukovod",
	"zvyk"
];

var require$$1 = [
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	""
];

var require$$2 = [
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	""
];

var require$$3 = [
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	""
];

var require$$4 = [
	"abaisser",
	"abandon",
	"abdiquer",
	"abeille",
	"abolir",
	"aborder",
	"aboutir",
	"aboyer",
	"abrasif",
	"abreuver",
	"abriter",
	"abroger",
	"abrupt",
	"absence",
	"absolu",
	"absurde",
	"abusif",
	"abyssal",
	"academie",
	"acajou",
	"acarien",
	"accabler",
	"accepter",
	"acclamer",
	"accolade",
	"accroche",
	"accuser",
	"acerbe",
	"achat",
	"acheter",
	"aciduler",
	"acier",
	"acompte",
	"acquerir",
	"acronyme",
	"acteur",
	"actif",
	"actuel",
	"adepte",
	"adequat",
	"adhesif",
	"adjectif",
	"adjuger",
	"admettre",
	"admirer",
	"adopter",
	"adorer",
	"adoucir",
	"adresse",
	"adroit",
	"adulte",
	"adverbe",
	"aerer",
	"aeronef",
	"affaire",
	"affecter",
	"affiche",
	"affreux",
	"affubler",
	"agacer",
	"agencer",
	"agile",
	"agiter",
	"agrafer",
	"agreable",
	"agrume",
	"aider",
	"aiguille",
	"ailier",
	"aimable",
	"aisance",
	"ajouter",
	"ajuster",
	"alarmer",
	"alchimie",
	"alerte",
	"algebre",
	"algue",
	"aliener",
	"aliment",
	"alleger",
	"alliage",
	"allouer",
	"allumer",
	"alourdir",
	"alpaga",
	"altesse",
	"alveole",
	"amateur",
	"ambigu",
	"ambre",
	"amenager",
	"amertume",
	"amidon",
	"amiral",
	"amorcer",
	"amour",
	"amovible",
	"amphibie",
	"ampleur",
	"amusant",
	"analyse",
	"anaphore",
	"anarchie",
	"anatomie",
	"ancien",
	"aneantir",
	"angle",
	"angoisse",
	"anguleux",
	"animal",
	"annexer",
	"annonce",
	"annuel",
	"anodin",
	"anomalie",
	"anonyme",
	"anormal",
	"antenne",
	"antidote",
	"anxieux",
	"apaiser",
	"aperitif",
	"aplanir",
	"apologie",
	"appareil",
	"appeler",
	"apporter",
	"appuyer",
	"aquarium",
	"aqueduc",
	"arbitre",
	"arbuste",
	"ardeur",
	"ardoise",
	"argent",
	"arlequin",
	"armature",
	"armement",
	"armoire",
	"armure",
	"arpenter",
	"arracher",
	"arriver",
	"arroser",
	"arsenic",
	"arteriel",
	"article",
	"aspect",
	"asphalte",
	"aspirer",
	"assaut",
	"asservir",
	"assiette",
	"associer",
	"assurer",
	"asticot",
	"astre",
	"astuce",
	"atelier",
	"atome",
	"atrium",
	"atroce",
	"attaque",
	"attentif",
	"attirer",
	"attraper",
	"aubaine",
	"auberge",
	"audace",
	"audible",
	"augurer",
	"aurore",
	"automne",
	"autruche",
	"avaler",
	"avancer",
	"avarice",
	"avenir",
	"averse",
	"aveugle",
	"aviateur",
	"avide",
	"avion",
	"aviser",
	"avoine",
	"avouer",
	"avril",
	"axial",
	"axiome",
	"badge",
	"bafouer",
	"bagage",
	"baguette",
	"baignade",
	"balancer",
	"balcon",
	"baleine",
	"balisage",
	"bambin",
	"bancaire",
	"bandage",
	"banlieue",
	"banniere",
	"banquier",
	"barbier",
	"baril",
	"baron",
	"barque",
	"barrage",
	"bassin",
	"bastion",
	"bataille",
	"bateau",
	"batterie",
	"baudrier",
	"bavarder",
	"belette",
	"belier",
	"belote",
	"benefice",
	"berceau",
	"berger",
	"berline",
	"bermuda",
	"besace",
	"besogne",
	"betail",
	"beurre",
	"biberon",
	"bicycle",
	"bidule",
	"bijou",
	"bilan",
	"bilingue",
	"billard",
	"binaire",
	"biologie",
	"biopsie",
	"biotype",
	"biscuit",
	"bison",
	"bistouri",
	"bitume",
	"bizarre",
	"blafard",
	"blague",
	"blanchir",
	"blessant",
	"blinder",
	"blond",
	"bloquer",
	"blouson",
	"bobard",
	"bobine",
	"boire",
	"boiser",
	"bolide",
	"bonbon",
	"bondir",
	"bonheur",
	"bonifier",
	"bonus",
	"bordure",
	"borne",
	"botte",
	"boucle",
	"boueux",
	"bougie",
	"boulon",
	"bouquin",
	"bourse",
	"boussole",
	"boutique",
	"boxeur",
	"branche",
	"brasier",
	"brave",
	"brebis",
	"breche",
	"breuvage",
	"bricoler",
	"brigade",
	"brillant",
	"brioche",
	"brique",
	"brochure",
	"broder",
	"bronzer",
	"brousse",
	"broyeur",
	"brume",
	"brusque",
	"brutal",
	"bruyant",
	"buffle",
	"buisson",
	"bulletin",
	"bureau",
	"burin",
	"bustier",
	"butiner",
	"butoir",
	"buvable",
	"buvette",
	"cabanon",
	"cabine",
	"cachette",
	"cadeau",
	"cadre",
	"cafeine",
	"caillou",
	"caisson",
	"calculer",
	"calepin",
	"calibre",
	"calmer",
	"calomnie",
	"calvaire",
	"camarade",
	"camera",
	"camion",
	"campagne",
	"canal",
	"caneton",
	"canon",
	"cantine",
	"canular",
	"capable",
	"caporal",
	"caprice",
	"capsule",
	"capter",
	"capuche",
	"carabine",
	"carbone",
	"caresser",
	"caribou",
	"carnage",
	"carotte",
	"carreau",
	"carton",
	"cascade",
	"casier",
	"casque",
	"cassure",
	"causer",
	"caution",
	"cavalier",
	"caverne",
	"caviar",
	"cedille",
	"ceinture",
	"celeste",
	"cellule",
	"cendrier",
	"censurer",
	"central",
	"cercle",
	"cerebral",
	"cerise",
	"cerner",
	"cerveau",
	"cesser",
	"chagrin",
	"chaise",
	"chaleur",
	"chambre",
	"chance",
	"chapitre",
	"charbon",
	"chasseur",
	"chaton",
	"chausson",
	"chavirer",
	"chemise",
	"chenille",
	"chequier",
	"chercher",
	"cheval",
	"chien",
	"chiffre",
	"chignon",
	"chimere",
	"chiot",
	"chlorure",
	"chocolat",
	"choisir",
	"chose",
	"chouette",
	"chrome",
	"chute",
	"cigare",
	"cigogne",
	"cimenter",
	"cinema",
	"cintrer",
	"circuler",
	"cirer",
	"cirque",
	"citerne",
	"citoyen",
	"citron",
	"civil",
	"clairon",
	"clameur",
	"claquer",
	"classe",
	"clavier",
	"client",
	"cligner",
	"climat",
	"clivage",
	"cloche",
	"clonage",
	"cloporte",
	"cobalt",
	"cobra",
	"cocasse",
	"cocotier",
	"coder",
	"codifier",
	"coffre",
	"cogner",
	"cohesion",
	"coiffer",
	"coincer",
	"colere",
	"colibri",
	"colline",
	"colmater",
	"colonel",
	"combat",
	"comedie",
	"commande",
	"compact",
	"concert",
	"conduire",
	"confier",
	"congeler",
	"connoter",
	"consonne",
	"contact",
	"convexe",
	"copain",
	"copie",
	"corail",
	"corbeau",
	"cordage",
	"corniche",
	"corpus",
	"correct",
	"cortege",
	"cosmique",
	"costume",
	"coton",
	"coude",
	"coupure",
	"courage",
	"couteau",
	"couvrir",
	"coyote",
	"crabe",
	"crainte",
	"cravate",
	"crayon",
	"creature",
	"crediter",
	"cremeux",
	"creuser",
	"crevette",
	"cribler",
	"crier",
	"cristal",
	"critere",
	"croire",
	"croquer",
	"crotale",
	"crucial",
	"cruel",
	"crypter",
	"cubique",
	"cueillir",
	"cuillere",
	"cuisine",
	"cuivre",
	"culminer",
	"cultiver",
	"cumuler",
	"cupide",
	"curatif",
	"curseur",
	"cyanure",
	"cycle",
	"cylindre",
	"cynique",
	"daigner",
	"damier",
	"danger",
	"danseur",
	"dauphin",
	"debattre",
	"debiter",
	"deborder",
	"debrider",
	"debutant",
	"decaler",
	"decembre",
	"dechirer",
	"decider",
	"declarer",
	"decorer",
	"decrire",
	"decupler",
	"dedale",
	"deductif",
	"deesse",
	"defensif",
	"defiler",
	"defrayer",
	"degager",
	"degivrer",
	"deglutir",
	"degrafer",
	"dejeuner",
	"delice",
	"deloger",
	"demander",
	"demeurer",
	"demolir",
	"denicher",
	"denouer",
	"dentelle",
	"denuder",
	"depart",
	"depenser",
	"dephaser",
	"deplacer",
	"deposer",
	"deranger",
	"derober",
	"desastre",
	"descente",
	"desert",
	"designer",
	"desobeir",
	"dessiner",
	"destrier",
	"detacher",
	"detester",
	"detourer",
	"detresse",
	"devancer",
	"devenir",
	"deviner",
	"devoir",
	"diable",
	"dialogue",
	"diamant",
	"dicter",
	"differer",
	"digerer",
	"digital",
	"digne",
	"diluer",
	"dimanche",
	"diminuer",
	"dioxyde",
	"directif",
	"diriger",
	"discuter",
	"disposer",
	"dissiper",
	"distance",
	"divertir",
	"diviser",
	"docile",
	"docteur",
	"dogme",
	"doigt",
	"domaine",
	"domicile",
	"dompter",
	"donateur",
	"donjon",
	"donner",
	"dopamine",
	"dortoir",
	"dorure",
	"dosage",
	"doseur",
	"dossier",
	"dotation",
	"douanier",
	"double",
	"douceur",
	"douter",
	"doyen",
	"dragon",
	"draper",
	"dresser",
	"dribbler",
	"droiture",
	"duperie",
	"duplexe",
	"durable",
	"durcir",
	"dynastie",
	"eblouir",
	"ecarter",
	"echarpe",
	"echelle",
	"eclairer",
	"eclipse",
	"eclore",
	"ecluse",
	"ecole",
	"economie",
	"ecorce",
	"ecouter",
	"ecraser",
	"ecremer",
	"ecrivain",
	"ecrou",
	"ecume",
	"ecureuil",
	"edifier",
	"eduquer",
	"effacer",
	"effectif",
	"effigie",
	"effort",
	"effrayer",
	"effusion",
	"egaliser",
	"egarer",
	"ejecter",
	"elaborer",
	"elargir",
	"electron",
	"elegant",
	"elephant",
	"eleve",
	"eligible",
	"elitisme",
	"eloge",
	"elucider",
	"eluder",
	"emballer",
	"embellir",
	"embryon",
	"emeraude",
	"emission",
	"emmener",
	"emotion",
	"emouvoir",
	"empereur",
	"employer",
	"emporter",
	"emprise",
	"emulsion",
	"encadrer",
	"enchere",
	"enclave",
	"encoche",
	"endiguer",
	"endosser",
	"endroit",
	"enduire",
	"energie",
	"enfance",
	"enfermer",
	"enfouir",
	"engager",
	"engin",
	"englober",
	"enigme",
	"enjamber",
	"enjeu",
	"enlever",
	"ennemi",
	"ennuyeux",
	"enrichir",
	"enrobage",
	"enseigne",
	"entasser",
	"entendre",
	"entier",
	"entourer",
	"entraver",
	"enumerer",
	"envahir",
	"enviable",
	"envoyer",
	"enzyme",
	"eolien",
	"epaissir",
	"epargne",
	"epatant",
	"epaule",
	"epicerie",
	"epidemie",
	"epier",
	"epilogue",
	"epine",
	"episode",
	"epitaphe",
	"epoque",
	"epreuve",
	"eprouver",
	"epuisant",
	"equerre",
	"equipe",
	"eriger",
	"erosion",
	"erreur",
	"eruption",
	"escalier",
	"espadon",
	"espece",
	"espiegle",
	"espoir",
	"esprit",
	"esquiver",
	"essayer",
	"essence",
	"essieu",
	"essorer",
	"estime",
	"estomac",
	"estrade",
	"etagere",
	"etaler",
	"etanche",
	"etatique",
	"eteindre",
	"etendoir",
	"eternel",
	"ethanol",
	"ethique",
	"ethnie",
	"etirer",
	"etoffer",
	"etoile",
	"etonnant",
	"etourdir",
	"etrange",
	"etroit",
	"etude",
	"euphorie",
	"evaluer",
	"evasion",
	"eventail",
	"evidence",
	"eviter",
	"evolutif",
	"evoquer",
	"exact",
	"exagerer",
	"exaucer",
	"exceller",
	"excitant",
	"exclusif",
	"excuse",
	"executer",
	"exemple",
	"exercer",
	"exhaler",
	"exhorter",
	"exigence",
	"exiler",
	"exister",
	"exotique",
	"expedier",
	"explorer",
	"exposer",
	"exprimer",
	"exquis",
	"extensif",
	"extraire",
	"exulter",
	"fable",
	"fabuleux",
	"facette",
	"facile",
	"facture",
	"faiblir",
	"falaise",
	"fameux",
	"famille",
	"farceur",
	"farfelu",
	"farine",
	"farouche",
	"fasciner",
	"fatal",
	"fatigue",
	"faucon",
	"fautif",
	"faveur",
	"favori",
	"febrile",
	"feconder",
	"federer",
	"felin",
	"femme",
	"femur",
	"fendoir",
	"feodal",
	"fermer",
	"feroce",
	"ferveur",
	"festival",
	"feuille",
	"feutre",
	"fevrier",
	"fiasco",
	"ficeler",
	"fictif",
	"fidele",
	"figure",
	"filature",
	"filetage",
	"filiere",
	"filleul",
	"filmer",
	"filou",
	"filtrer",
	"financer",
	"finir",
	"fiole",
	"firme",
	"fissure",
	"fixer",
	"flairer",
	"flamme",
	"flasque",
	"flatteur",
	"fleau",
	"fleche",
	"fleur",
	"flexion",
	"flocon",
	"flore",
	"fluctuer",
	"fluide",
	"fluvial",
	"folie",
	"fonderie",
	"fongible",
	"fontaine",
	"forcer",
	"forgeron",
	"formuler",
	"fortune",
	"fossile",
	"foudre",
	"fougere",
	"fouiller",
	"foulure",
	"fourmi",
	"fragile",
	"fraise",
	"franchir",
	"frapper",
	"frayeur",
	"fregate",
	"freiner",
	"frelon",
	"fremir",
	"frenesie",
	"frere",
	"friable",
	"friction",
	"frisson",
	"frivole",
	"froid",
	"fromage",
	"frontal",
	"frotter",
	"fruit",
	"fugitif",
	"fuite",
	"fureur",
	"furieux",
	"furtif",
	"fusion",
	"futur",
	"gagner",
	"galaxie",
	"galerie",
	"gambader",
	"garantir",
	"gardien",
	"garnir",
	"garrigue",
	"gazelle",
	"gazon",
	"geant",
	"gelatine",
	"gelule",
	"gendarme",
	"general",
	"genie",
	"genou",
	"gentil",
	"geologie",
	"geometre",
	"geranium",
	"germe",
	"gestuel",
	"geyser",
	"gibier",
	"gicler",
	"girafe",
	"givre",
	"glace",
	"glaive",
	"glisser",
	"globe",
	"gloire",
	"glorieux",
	"golfeur",
	"gomme",
	"gonfler",
	"gorge",
	"gorille",
	"goudron",
	"gouffre",
	"goulot",
	"goupille",
	"gourmand",
	"goutte",
	"graduel",
	"graffiti",
	"graine",
	"grand",
	"grappin",
	"gratuit",
	"gravir",
	"grenat",
	"griffure",
	"griller",
	"grimper",
	"grogner",
	"gronder",
	"grotte",
	"groupe",
	"gruger",
	"grutier",
	"gruyere",
	"guepard",
	"guerrier",
	"guide",
	"guimauve",
	"guitare",
	"gustatif",
	"gymnaste",
	"gyrostat",
	"habitude",
	"hachoir",
	"halte",
	"hameau",
	"hangar",
	"hanneton",
	"haricot",
	"harmonie",
	"harpon",
	"hasard",
	"helium",
	"hematome",
	"herbe",
	"herisson",
	"hermine",
	"heron",
	"hesiter",
	"heureux",
	"hiberner",
	"hibou",
	"hilarant",
	"histoire",
	"hiver",
	"homard",
	"hommage",
	"homogene",
	"honneur",
	"honorer",
	"honteux",
	"horde",
	"horizon",
	"horloge",
	"hormone",
	"horrible",
	"houleux",
	"housse",
	"hublot",
	"huileux",
	"humain",
	"humble",
	"humide",
	"humour",
	"hurler",
	"hydromel",
	"hygiene",
	"hymne",
	"hypnose",
	"idylle",
	"ignorer",
	"iguane",
	"illicite",
	"illusion",
	"image",
	"imbiber",
	"imiter",
	"immense",
	"immobile",
	"immuable",
	"impact",
	"imperial",
	"implorer",
	"imposer",
	"imprimer",
	"imputer",
	"incarner",
	"incendie",
	"incident",
	"incliner",
	"incolore",
	"indexer",
	"indice",
	"inductif",
	"inedit",
	"ineptie",
	"inexact",
	"infini",
	"infliger",
	"informer",
	"infusion",
	"ingerer",
	"inhaler",
	"inhiber",
	"injecter",
	"injure",
	"innocent",
	"inoculer",
	"inonder",
	"inscrire",
	"insecte",
	"insigne",
	"insolite",
	"inspirer",
	"instinct",
	"insulter",
	"intact",
	"intense",
	"intime",
	"intrigue",
	"intuitif",
	"inutile",
	"invasion",
	"inventer",
	"inviter",
	"invoquer",
	"ironique",
	"irradier",
	"irreel",
	"irriter",
	"isoler",
	"ivoire",
	"ivresse",
	"jaguar",
	"jaillir",
	"jambe",
	"janvier",
	"jardin",
	"jauger",
	"jaune",
	"javelot",
	"jetable",
	"jeton",
	"jeudi",
	"jeunesse",
	"joindre",
	"joncher",
	"jongler",
	"joueur",
	"jouissif",
	"journal",
	"jovial",
	"joyau",
	"joyeux",
	"jubiler",
	"jugement",
	"junior",
	"jupon",
	"juriste",
	"justice",
	"juteux",
	"juvenile",
	"kayak",
	"kimono",
	"kiosque",
	"label",
	"labial",
	"labourer",
	"lacerer",
	"lactose",
	"lagune",
	"laine",
	"laisser",
	"laitier",
	"lambeau",
	"lamelle",
	"lampe",
	"lanceur",
	"langage",
	"lanterne",
	"lapin",
	"largeur",
	"larme",
	"laurier",
	"lavabo",
	"lavoir",
	"lecture",
	"legal",
	"leger",
	"legume",
	"lessive",
	"lettre",
	"levier",
	"lexique",
	"lezard",
	"liasse",
	"liberer",
	"libre",
	"licence",
	"licorne",
	"liege",
	"lievre",
	"ligature",
	"ligoter",
	"ligue",
	"limer",
	"limite",
	"limonade",
	"limpide",
	"lineaire",
	"lingot",
	"lionceau",
	"liquide",
	"lisiere",
	"lister",
	"lithium",
	"litige",
	"littoral",
	"livreur",
	"logique",
	"lointain",
	"loisir",
	"lombric",
	"loterie",
	"louer",
	"lourd",
	"loutre",
	"louve",
	"loyal",
	"lubie",
	"lucide",
	"lucratif",
	"lueur",
	"lugubre",
	"luisant",
	"lumiere",
	"lunaire",
	"lundi",
	"luron",
	"lutter",
	"luxueux",
	"machine",
	"magasin",
	"magenta",
	"magique",
	"maigre",
	"maillon",
	"maintien",
	"mairie",
	"maison",
	"majorer",
	"malaxer",
	"malefice",
	"malheur",
	"malice",
	"mallette",
	"mammouth",
	"mandater",
	"maniable",
	"manquant",
	"manteau",
	"manuel",
	"marathon",
	"marbre",
	"marchand",
	"mardi",
	"maritime",
	"marqueur",
	"marron",
	"marteler",
	"mascotte",
	"massif",
	"materiel",
	"matiere",
	"matraque",
	"maudire",
	"maussade",
	"mauve",
	"maximal",
	"mechant",
	"meconnu",
	"medaille",
	"medecin",
	"mediter",
	"meduse",
	"meilleur",
	"melange",
	"melodie",
	"membre",
	"memoire",
	"menacer",
	"mener",
	"menhir",
	"mensonge",
	"mentor",
	"mercredi",
	"merite",
	"merle",
	"messager",
	"mesure",
	"metal",
	"meteore",
	"methode",
	"metier",
	"meuble",
	"miauler",
	"microbe",
	"miette",
	"mignon",
	"migrer",
	"milieu",
	"million",
	"mimique",
	"mince",
	"mineral",
	"minimal",
	"minorer",
	"minute",
	"miracle",
	"miroiter",
	"missile",
	"mixte",
	"mobile",
	"moderne",
	"moelleux",
	"mondial",
	"moniteur",
	"monnaie",
	"monotone",
	"monstre",
	"montagne",
	"monument",
	"moqueur",
	"morceau",
	"morsure",
	"mortier",
	"moteur",
	"motif",
	"mouche",
	"moufle",
	"moulin",
	"mousson",
	"mouton",
	"mouvant",
	"multiple",
	"munition",
	"muraille",
	"murene",
	"murmure",
	"muscle",
	"museum",
	"musicien",
	"mutation",
	"muter",
	"mutuel",
	"myriade",
	"myrtille",
	"mystere",
	"mythique",
	"nageur",
	"nappe",
	"narquois",
	"narrer",
	"natation",
	"nation",
	"nature",
	"naufrage",
	"nautique",
	"navire",
	"nebuleux",
	"nectar",
	"nefaste",
	"negation",
	"negliger",
	"negocier",
	"neige",
	"nerveux",
	"nettoyer",
	"neurone",
	"neutron",
	"neveu",
	"niche",
	"nickel",
	"nitrate",
	"niveau",
	"noble",
	"nocif",
	"nocturne",
	"noirceur",
	"noisette",
	"nomade",
	"nombreux",
	"nommer",
	"normatif",
	"notable",
	"notifier",
	"notoire",
	"nourrir",
	"nouveau",
	"novateur",
	"novembre",
	"novice",
	"nuage",
	"nuancer",
	"nuire",
	"nuisible",
	"numero",
	"nuptial",
	"nuque",
	"nutritif",
	"obeir",
	"objectif",
	"obliger",
	"obscur",
	"observer",
	"obstacle",
	"obtenir",
	"obturer",
	"occasion",
	"occuper",
	"ocean",
	"octobre",
	"octroyer",
	"octupler",
	"oculaire",
	"odeur",
	"odorant",
	"offenser",
	"officier",
	"offrir",
	"ogive",
	"oiseau",
	"oisillon",
	"olfactif",
	"olivier",
	"ombrage",
	"omettre",
	"onctueux",
	"onduler",
	"onereux",
	"onirique",
	"opale",
	"opaque",
	"operer",
	"opinion",
	"opportun",
	"opprimer",
	"opter",
	"optique",
	"orageux",
	"orange",
	"orbite",
	"ordonner",
	"oreille",
	"organe",
	"orgueil",
	"orifice",
	"ornement",
	"orque",
	"ortie",
	"osciller",
	"osmose",
	"ossature",
	"otarie",
	"ouragan",
	"ourson",
	"outil",
	"outrager",
	"ouvrage",
	"ovation",
	"oxyde",
	"oxygene",
	"ozone",
	"paisible",
	"palace",
	"palmares",
	"palourde",
	"palper",
	"panache",
	"panda",
	"pangolin",
	"paniquer",
	"panneau",
	"panorama",
	"pantalon",
	"papaye",
	"papier",
	"papoter",
	"papyrus",
	"paradoxe",
	"parcelle",
	"paresse",
	"parfumer",
	"parler",
	"parole",
	"parrain",
	"parsemer",
	"partager",
	"parure",
	"parvenir",
	"passion",
	"pasteque",
	"paternel",
	"patience",
	"patron",
	"pavillon",
	"pavoiser",
	"payer",
	"paysage",
	"peigne",
	"peintre",
	"pelage",
	"pelican",
	"pelle",
	"pelouse",
	"peluche",
	"pendule",
	"penetrer",
	"penible",
	"pensif",
	"penurie",
	"pepite",
	"peplum",
	"perdrix",
	"perforer",
	"periode",
	"permuter",
	"perplexe",
	"persil",
	"perte",
	"peser",
	"petale",
	"petit",
	"petrir",
	"peuple",
	"pharaon",
	"phobie",
	"phoque",
	"photon",
	"phrase",
	"physique",
	"piano",
	"pictural",
	"piece",
	"pierre",
	"pieuvre",
	"pilote",
	"pinceau",
	"pipette",
	"piquer",
	"pirogue",
	"piscine",
	"piston",
	"pivoter",
	"pixel",
	"pizza",
	"placard",
	"plafond",
	"plaisir",
	"planer",
	"plaque",
	"plastron",
	"plateau",
	"pleurer",
	"plexus",
	"pliage",
	"plomb",
	"plonger",
	"pluie",
	"plumage",
	"pochette",
	"poesie",
	"poete",
	"pointe",
	"poirier",
	"poisson",
	"poivre",
	"polaire",
	"policier",
	"pollen",
	"polygone",
	"pommade",
	"pompier",
	"ponctuel",
	"ponderer",
	"poney",
	"portique",
	"position",
	"posseder",
	"posture",
	"potager",
	"poteau",
	"potion",
	"pouce",
	"poulain",
	"poumon",
	"pourpre",
	"poussin",
	"pouvoir",
	"prairie",
	"pratique",
	"precieux",
	"predire",
	"prefixe",
	"prelude",
	"prenom",
	"presence",
	"pretexte",
	"prevoir",
	"primitif",
	"prince",
	"prison",
	"priver",
	"probleme",
	"proceder",
	"prodige",
	"profond",
	"progres",
	"proie",
	"projeter",
	"prologue",
	"promener",
	"propre",
	"prospere",
	"proteger",
	"prouesse",
	"proverbe",
	"prudence",
	"pruneau",
	"psychose",
	"public",
	"puceron",
	"puiser",
	"pulpe",
	"pulsar",
	"punaise",
	"punitif",
	"pupitre",
	"purifier",
	"puzzle",
	"pyramide",
	"quasar",
	"querelle",
	"question",
	"quietude",
	"quitter",
	"quotient",
	"racine",
	"raconter",
	"radieux",
	"ragondin",
	"raideur",
	"raisin",
	"ralentir",
	"rallonge",
	"ramasser",
	"rapide",
	"rasage",
	"ratisser",
	"ravager",
	"ravin",
	"rayonner",
	"reactif",
	"reagir",
	"realiser",
	"reanimer",
	"recevoir",
	"reciter",
	"reclamer",
	"recolter",
	"recruter",
	"reculer",
	"recycler",
	"rediger",
	"redouter",
	"refaire",
	"reflexe",
	"reformer",
	"refrain",
	"refuge",
	"regalien",
	"region",
	"reglage",
	"regulier",
	"reiterer",
	"rejeter",
	"rejouer",
	"relatif",
	"relever",
	"relief",
	"remarque",
	"remede",
	"remise",
	"remonter",
	"remplir",
	"remuer",
	"renard",
	"renfort",
	"renifler",
	"renoncer",
	"rentrer",
	"renvoi",
	"replier",
	"reporter",
	"reprise",
	"reptile",
	"requin",
	"reserve",
	"resineux",
	"resoudre",
	"respect",
	"rester",
	"resultat",
	"retablir",
	"retenir",
	"reticule",
	"retomber",
	"retracer",
	"reunion",
	"reussir",
	"revanche",
	"revivre",
	"revolte",
	"revulsif",
	"richesse",
	"rideau",
	"rieur",
	"rigide",
	"rigoler",
	"rincer",
	"riposter",
	"risible",
	"risque",
	"rituel",
	"rival",
	"riviere",
	"rocheux",
	"romance",
	"rompre",
	"ronce",
	"rondin",
	"roseau",
	"rosier",
	"rotatif",
	"rotor",
	"rotule",
	"rouge",
	"rouille",
	"rouleau",
	"routine",
	"royaume",
	"ruban",
	"rubis",
	"ruche",
	"ruelle",
	"rugueux",
	"ruiner",
	"ruisseau",
	"ruser",
	"rustique",
	"rythme",
	"sabler",
	"saboter",
	"sabre",
	"sacoche",
	"safari",
	"sagesse",
	"saisir",
	"salade",
	"salive",
	"salon",
	"saluer",
	"samedi",
	"sanction",
	"sanglier",
	"sarcasme",
	"sardine",
	"saturer",
	"saugrenu",
	"saumon",
	"sauter",
	"sauvage",
	"savant",
	"savonner",
	"scalpel",
	"scandale",
	"scelerat",
	"scenario",
	"sceptre",
	"schema",
	"science",
	"scinder",
	"score",
	"scrutin",
	"sculpter",
	"seance",
	"secable",
	"secher",
	"secouer",
	"secreter",
	"sedatif",
	"seduire",
	"seigneur",
	"sejour",
	"selectif",
	"semaine",
	"sembler",
	"semence",
	"seminal",
	"senateur",
	"sensible",
	"sentence",
	"separer",
	"sequence",
	"serein",
	"sergent",
	"serieux",
	"serrure",
	"serum",
	"service",
	"sesame",
	"sevir",
	"sevrage",
	"sextuple",
	"sideral",
	"siecle",
	"sieger",
	"siffler",
	"sigle",
	"signal",
	"silence",
	"silicium",
	"simple",
	"sincere",
	"sinistre",
	"siphon",
	"sirop",
	"sismique",
	"situer",
	"skier",
	"social",
	"socle",
	"sodium",
	"soigneux",
	"soldat",
	"soleil",
	"solitude",
	"soluble",
	"sombre",
	"sommeil",
	"somnoler",
	"sonde",
	"songeur",
	"sonnette",
	"sonore",
	"sorcier",
	"sortir",
	"sosie",
	"sottise",
	"soucieux",
	"soudure",
	"souffle",
	"soulever",
	"soupape",
	"source",
	"soutirer",
	"souvenir",
	"spacieux",
	"spatial",
	"special",
	"sphere",
	"spiral",
	"stable",
	"station",
	"sternum",
	"stimulus",
	"stipuler",
	"strict",
	"studieux",
	"stupeur",
	"styliste",
	"sublime",
	"substrat",
	"subtil",
	"subvenir",
	"succes",
	"sucre",
	"suffixe",
	"suggerer",
	"suiveur",
	"sulfate",
	"superbe",
	"supplier",
	"surface",
	"suricate",
	"surmener",
	"surprise",
	"sursaut",
	"survie",
	"suspect",
	"syllabe",
	"symbole",
	"symetrie",
	"synapse",
	"syntaxe",
	"systeme",
	"tabac",
	"tablier",
	"tactile",
	"tailler",
	"talent",
	"talisman",
	"talonner",
	"tambour",
	"tamiser",
	"tangible",
	"tapis",
	"taquiner",
	"tarder",
	"tarif",
	"tartine",
	"tasse",
	"tatami",
	"tatouage",
	"taupe",
	"taureau",
	"taxer",
	"temoin",
	"temporel",
	"tenaille",
	"tendre",
	"teneur",
	"tenir",
	"tension",
	"terminer",
	"terne",
	"terrible",
	"tetine",
	"texte",
	"theme",
	"theorie",
	"therapie",
	"thorax",
	"tibia",
	"tiede",
	"timide",
	"tirelire",
	"tiroir",
	"tissu",
	"titane",
	"titre",
	"tituber",
	"toboggan",
	"tolerant",
	"tomate",
	"tonique",
	"tonneau",
	"toponyme",
	"torche",
	"tordre",
	"tornade",
	"torpille",
	"torrent",
	"torse",
	"tortue",
	"totem",
	"toucher",
	"tournage",
	"tousser",
	"toxine",
	"traction",
	"trafic",
	"tragique",
	"trahir",
	"train",
	"trancher",
	"travail",
	"trefle",
	"tremper",
	"tresor",
	"treuil",
	"triage",
	"tribunal",
	"tricoter",
	"trilogie",
	"triomphe",
	"tripler",
	"triturer",
	"trivial",
	"trombone",
	"tronc",
	"tropical",
	"troupeau",
	"tuile",
	"tulipe",
	"tumulte",
	"tunnel",
	"turbine",
	"tuteur",
	"tutoyer",
	"tuyau",
	"tympan",
	"typhon",
	"typique",
	"tyran",
	"ubuesque",
	"ultime",
	"ultrason",
	"unanime",
	"unifier",
	"union",
	"unique",
	"unitaire",
	"univers",
	"uranium",
	"urbain",
	"urticant",
	"usage",
	"usine",
	"usuel",
	"usure",
	"utile",
	"utopie",
	"vacarme",
	"vaccin",
	"vagabond",
	"vague",
	"vaillant",
	"vaincre",
	"vaisseau",
	"valable",
	"valise",
	"vallon",
	"valve",
	"vampire",
	"vanille",
	"vapeur",
	"varier",
	"vaseux",
	"vassal",
	"vaste",
	"vecteur",
	"vedette",
	"vegetal",
	"vehicule",
	"veinard",
	"veloce",
	"vendredi",
	"venerer",
	"venger",
	"venimeux",
	"ventouse",
	"verdure",
	"verin",
	"vernir",
	"verrou",
	"verser",
	"vertu",
	"veston",
	"veteran",
	"vetuste",
	"vexant",
	"vexer",
	"viaduc",
	"viande",
	"victoire",
	"vidange",
	"video",
	"vignette",
	"vigueur",
	"vilain",
	"village",
	"vinaigre",
	"violon",
	"vipere",
	"virement",
	"virtuose",
	"virus",
	"visage",
	"viseur",
	"vision",
	"visqueux",
	"visuel",
	"vital",
	"vitesse",
	"viticole",
	"vitrine",
	"vivace",
	"vivipare",
	"vocation",
	"voguer",
	"voile",
	"voisin",
	"voiture",
	"volaille",
	"volcan",
	"voltiger",
	"volume",
	"vorace",
	"vortex",
	"voter",
	"vouloir",
	"voyage",
	"voyelle",
	"wagon",
	"xenon",
	"yacht",
	"zebre",
	"zenith",
	"zeste",
	"zoologie"
];

var require$$5 = [
	"abaco",
	"abbaglio",
	"abbinato",
	"abete",
	"abisso",
	"abolire",
	"abrasivo",
	"abrogato",
	"accadere",
	"accenno",
	"accusato",
	"acetone",
	"achille",
	"acido",
	"acqua",
	"acre",
	"acrilico",
	"acrobata",
	"acuto",
	"adagio",
	"addebito",
	"addome",
	"adeguato",
	"aderire",
	"adipe",
	"adottare",
	"adulare",
	"affabile",
	"affetto",
	"affisso",
	"affranto",
	"aforisma",
	"afoso",
	"africano",
	"agave",
	"agente",
	"agevole",
	"aggancio",
	"agire",
	"agitare",
	"agonismo",
	"agricolo",
	"agrumeto",
	"aguzzo",
	"alabarda",
	"alato",
	"albatro",
	"alberato",
	"albo",
	"albume",
	"alce",
	"alcolico",
	"alettone",
	"alfa",
	"algebra",
	"aliante",
	"alibi",
	"alimento",
	"allagato",
	"allegro",
	"allievo",
	"allodola",
	"allusivo",
	"almeno",
	"alogeno",
	"alpaca",
	"alpestre",
	"altalena",
	"alterno",
	"alticcio",
	"altrove",
	"alunno",
	"alveolo",
	"alzare",
	"amalgama",
	"amanita",
	"amarena",
	"ambito",
	"ambrato",
	"ameba",
	"america",
	"ametista",
	"amico",
	"ammasso",
	"ammenda",
	"ammirare",
	"ammonito",
	"amore",
	"ampio",
	"ampliare",
	"amuleto",
	"anacardo",
	"anagrafe",
	"analista",
	"anarchia",
	"anatra",
	"anca",
	"ancella",
	"ancora",
	"andare",
	"andrea",
	"anello",
	"angelo",
	"angolare",
	"angusto",
	"anima",
	"annegare",
	"annidato",
	"anno",
	"annuncio",
	"anonimo",
	"anticipo",
	"anzi",
	"apatico",
	"apertura",
	"apode",
	"apparire",
	"appetito",
	"appoggio",
	"approdo",
	"appunto",
	"aprile",
	"arabica",
	"arachide",
	"aragosta",
	"araldica",
	"arancio",
	"aratura",
	"arazzo",
	"arbitro",
	"archivio",
	"ardito",
	"arenile",
	"argento",
	"argine",
	"arguto",
	"aria",
	"armonia",
	"arnese",
	"arredato",
	"arringa",
	"arrosto",
	"arsenico",
	"arso",
	"artefice",
	"arzillo",
	"asciutto",
	"ascolto",
	"asepsi",
	"asettico",
	"asfalto",
	"asino",
	"asola",
	"aspirato",
	"aspro",
	"assaggio",
	"asse",
	"assoluto",
	"assurdo",
	"asta",
	"astenuto",
	"astice",
	"astratto",
	"atavico",
	"ateismo",
	"atomico",
	"atono",
	"attesa",
	"attivare",
	"attorno",
	"attrito",
	"attuale",
	"ausilio",
	"austria",
	"autista",
	"autonomo",
	"autunno",
	"avanzato",
	"avere",
	"avvenire",
	"avviso",
	"avvolgere",
	"azione",
	"azoto",
	"azzimo",
	"azzurro",
	"babele",
	"baccano",
	"bacino",
	"baco",
	"badessa",
	"badilata",
	"bagnato",
	"baita",
	"balcone",
	"baldo",
	"balena",
	"ballata",
	"balzano",
	"bambino",
	"bandire",
	"baraonda",
	"barbaro",
	"barca",
	"baritono",
	"barlume",
	"barocco",
	"basilico",
	"basso",
	"batosta",
	"battuto",
	"baule",
	"bava",
	"bavosa",
	"becco",
	"beffa",
	"belgio",
	"belva",
	"benda",
	"benevole",
	"benigno",
	"benzina",
	"bere",
	"berlina",
	"beta",
	"bibita",
	"bici",
	"bidone",
	"bifido",
	"biga",
	"bilancia",
	"bimbo",
	"binocolo",
	"biologo",
	"bipede",
	"bipolare",
	"birbante",
	"birra",
	"biscotto",
	"bisesto",
	"bisnonno",
	"bisonte",
	"bisturi",
	"bizzarro",
	"blando",
	"blatta",
	"bollito",
	"bonifico",
	"bordo",
	"bosco",
	"botanico",
	"bottino",
	"bozzolo",
	"braccio",
	"bradipo",
	"brama",
	"branca",
	"bravura",
	"bretella",
	"brevetto",
	"brezza",
	"briglia",
	"brillante",
	"brindare",
	"broccolo",
	"brodo",
	"bronzina",
	"brullo",
	"bruno",
	"bubbone",
	"buca",
	"budino",
	"buffone",
	"buio",
	"bulbo",
	"buono",
	"burlone",
	"burrasca",
	"bussola",
	"busta",
	"cadetto",
	"caduco",
	"calamaro",
	"calcolo",
	"calesse",
	"calibro",
	"calmo",
	"caloria",
	"cambusa",
	"camerata",
	"camicia",
	"cammino",
	"camola",
	"campale",
	"canapa",
	"candela",
	"cane",
	"canino",
	"canotto",
	"cantina",
	"capace",
	"capello",
	"capitolo",
	"capogiro",
	"cappero",
	"capra",
	"capsula",
	"carapace",
	"carcassa",
	"cardo",
	"carisma",
	"carovana",
	"carretto",
	"cartolina",
	"casaccio",
	"cascata",
	"caserma",
	"caso",
	"cassone",
	"castello",
	"casuale",
	"catasta",
	"catena",
	"catrame",
	"cauto",
	"cavillo",
	"cedibile",
	"cedrata",
	"cefalo",
	"celebre",
	"cellulare",
	"cena",
	"cenone",
	"centesimo",
	"ceramica",
	"cercare",
	"certo",
	"cerume",
	"cervello",
	"cesoia",
	"cespo",
	"ceto",
	"chela",
	"chiaro",
	"chicca",
	"chiedere",
	"chimera",
	"china",
	"chirurgo",
	"chitarra",
	"ciao",
	"ciclismo",
	"cifrare",
	"cigno",
	"cilindro",
	"ciottolo",
	"circa",
	"cirrosi",
	"citrico",
	"cittadino",
	"ciuffo",
	"civetta",
	"civile",
	"classico",
	"clinica",
	"cloro",
	"cocco",
	"codardo",
	"codice",
	"coerente",
	"cognome",
	"collare",
	"colmato",
	"colore",
	"colposo",
	"coltivato",
	"colza",
	"coma",
	"cometa",
	"commando",
	"comodo",
	"computer",
	"comune",
	"conciso",
	"condurre",
	"conferma",
	"congelare",
	"coniuge",
	"connesso",
	"conoscere",
	"consumo",
	"continuo",
	"convegno",
	"coperto",
	"copione",
	"coppia",
	"copricapo",
	"corazza",
	"cordata",
	"coricato",
	"cornice",
	"corolla",
	"corpo",
	"corredo",
	"corsia",
	"cortese",
	"cosmico",
	"costante",
	"cottura",
	"covato",
	"cratere",
	"cravatta",
	"creato",
	"credere",
	"cremoso",
	"crescita",
	"creta",
	"criceto",
	"crinale",
	"crisi",
	"critico",
	"croce",
	"cronaca",
	"crostata",
	"cruciale",
	"crusca",
	"cucire",
	"cuculo",
	"cugino",
	"cullato",
	"cupola",
	"curatore",
	"cursore",
	"curvo",
	"cuscino",
	"custode",
	"dado",
	"daino",
	"dalmata",
	"damerino",
	"daniela",
	"dannoso",
	"danzare",
	"datato",
	"davanti",
	"davvero",
	"debutto",
	"decennio",
	"deciso",
	"declino",
	"decollo",
	"decreto",
	"dedicato",
	"definito",
	"deforme",
	"degno",
	"delegare",
	"delfino",
	"delirio",
	"delta",
	"demenza",
	"denotato",
	"dentro",
	"deposito",
	"derapata",
	"derivare",
	"deroga",
	"descritto",
	"deserto",
	"desiderio",
	"desumere",
	"detersivo",
	"devoto",
	"diametro",
	"dicembre",
	"diedro",
	"difeso",
	"diffuso",
	"digerire",
	"digitale",
	"diluvio",
	"dinamico",
	"dinnanzi",
	"dipinto",
	"diploma",
	"dipolo",
	"diradare",
	"dire",
	"dirotto",
	"dirupo",
	"disagio",
	"discreto",
	"disfare",
	"disgelo",
	"disposto",
	"distanza",
	"disumano",
	"dito",
	"divano",
	"divelto",
	"dividere",
	"divorato",
	"doblone",
	"docente",
	"doganale",
	"dogma",
	"dolce",
	"domato",
	"domenica",
	"dominare",
	"dondolo",
	"dono",
	"dormire",
	"dote",
	"dottore",
	"dovuto",
	"dozzina",
	"drago",
	"druido",
	"dubbio",
	"dubitare",
	"ducale",
	"duna",
	"duomo",
	"duplice",
	"duraturo",
	"ebano",
	"eccesso",
	"ecco",
	"eclissi",
	"economia",
	"edera",
	"edicola",
	"edile",
	"editoria",
	"educare",
	"egemonia",
	"egli",
	"egoismo",
	"egregio",
	"elaborato",
	"elargire",
	"elegante",
	"elencato",
	"eletto",
	"elevare",
	"elfico",
	"elica",
	"elmo",
	"elsa",
	"eluso",
	"emanato",
	"emblema",
	"emesso",
	"emiro",
	"emotivo",
	"emozione",
	"empirico",
	"emulo",
	"endemico",
	"enduro",
	"energia",
	"enfasi",
	"enoteca",
	"entrare",
	"enzima",
	"epatite",
	"epilogo",
	"episodio",
	"epocale",
	"eppure",
	"equatore",
	"erario",
	"erba",
	"erboso",
	"erede",
	"eremita",
	"erigere",
	"ermetico",
	"eroe",
	"erosivo",
	"errante",
	"esagono",
	"esame",
	"esanime",
	"esaudire",
	"esca",
	"esempio",
	"esercito",
	"esibito",
	"esigente",
	"esistere",
	"esito",
	"esofago",
	"esortato",
	"esoso",
	"espanso",
	"espresso",
	"essenza",
	"esso",
	"esteso",
	"estimare",
	"estonia",
	"estroso",
	"esultare",
	"etilico",
	"etnico",
	"etrusco",
	"etto",
	"euclideo",
	"europa",
	"evaso",
	"evidenza",
	"evitato",
	"evoluto",
	"evviva",
	"fabbrica",
	"faccenda",
	"fachiro",
	"falco",
	"famiglia",
	"fanale",
	"fanfara",
	"fango",
	"fantasma",
	"fare",
	"farfalla",
	"farinoso",
	"farmaco",
	"fascia",
	"fastoso",
	"fasullo",
	"faticare",
	"fato",
	"favoloso",
	"febbre",
	"fecola",
	"fede",
	"fegato",
	"felpa",
	"feltro",
	"femmina",
	"fendere",
	"fenomeno",
	"fermento",
	"ferro",
	"fertile",
	"fessura",
	"festivo",
	"fetta",
	"feudo",
	"fiaba",
	"fiducia",
	"fifa",
	"figurato",
	"filo",
	"finanza",
	"finestra",
	"finire",
	"fiore",
	"fiscale",
	"fisico",
	"fiume",
	"flacone",
	"flamenco",
	"flebo",
	"flemma",
	"florido",
	"fluente",
	"fluoro",
	"fobico",
	"focaccia",
	"focoso",
	"foderato",
	"foglio",
	"folata",
	"folclore",
	"folgore",
	"fondente",
	"fonetico",
	"fonia",
	"fontana",
	"forbito",
	"forchetta",
	"foresta",
	"formica",
	"fornaio",
	"foro",
	"fortezza",
	"forzare",
	"fosfato",
	"fosso",
	"fracasso",
	"frana",
	"frassino",
	"fratello",
	"freccetta",
	"frenata",
	"fresco",
	"frigo",
	"frollino",
	"fronde",
	"frugale",
	"frutta",
	"fucilata",
	"fucsia",
	"fuggente",
	"fulmine",
	"fulvo",
	"fumante",
	"fumetto",
	"fumoso",
	"fune",
	"funzione",
	"fuoco",
	"furbo",
	"furgone",
	"furore",
	"fuso",
	"futile",
	"gabbiano",
	"gaffe",
	"galateo",
	"gallina",
	"galoppo",
	"gambero",
	"gamma",
	"garanzia",
	"garbo",
	"garofano",
	"garzone",
	"gasdotto",
	"gasolio",
	"gastrico",
	"gatto",
	"gaudio",
	"gazebo",
	"gazzella",
	"geco",
	"gelatina",
	"gelso",
	"gemello",
	"gemmato",
	"gene",
	"genitore",
	"gennaio",
	"genotipo",
	"gergo",
	"ghepardo",
	"ghiaccio",
	"ghisa",
	"giallo",
	"gilda",
	"ginepro",
	"giocare",
	"gioiello",
	"giorno",
	"giove",
	"girato",
	"girone",
	"gittata",
	"giudizio",
	"giurato",
	"giusto",
	"globulo",
	"glutine",
	"gnomo",
	"gobba",
	"golf",
	"gomito",
	"gommone",
	"gonfio",
	"gonna",
	"governo",
	"gracile",
	"grado",
	"grafico",
	"grammo",
	"grande",
	"grattare",
	"gravoso",
	"grazia",
	"greca",
	"gregge",
	"grifone",
	"grigio",
	"grinza",
	"grotta",
	"gruppo",
	"guadagno",
	"guaio",
	"guanto",
	"guardare",
	"gufo",
	"guidare",
	"ibernato",
	"icona",
	"identico",
	"idillio",
	"idolo",
	"idra",
	"idrico",
	"idrogeno",
	"igiene",
	"ignaro",
	"ignorato",
	"ilare",
	"illeso",
	"illogico",
	"illudere",
	"imballo",
	"imbevuto",
	"imbocco",
	"imbuto",
	"immane",
	"immerso",
	"immolato",
	"impacco",
	"impeto",
	"impiego",
	"importo",
	"impronta",
	"inalare",
	"inarcare",
	"inattivo",
	"incanto",
	"incendio",
	"inchino",
	"incisivo",
	"incluso",
	"incontro",
	"incrocio",
	"incubo",
	"indagine",
	"india",
	"indole",
	"inedito",
	"infatti",
	"infilare",
	"inflitto",
	"ingaggio",
	"ingegno",
	"inglese",
	"ingordo",
	"ingrosso",
	"innesco",
	"inodore",
	"inoltrare",
	"inondato",
	"insano",
	"insetto",
	"insieme",
	"insonnia",
	"insulina",
	"intasato",
	"intero",
	"intonaco",
	"intuito",
	"inumidire",
	"invalido",
	"invece",
	"invito",
	"iperbole",
	"ipnotico",
	"ipotesi",
	"ippica",
	"iride",
	"irlanda",
	"ironico",
	"irrigato",
	"irrorare",
	"isolato",
	"isotopo",
	"isterico",
	"istituto",
	"istrice",
	"italia",
	"iterare",
	"labbro",
	"labirinto",
	"lacca",
	"lacerato",
	"lacrima",
	"lacuna",
	"laddove",
	"lago",
	"lampo",
	"lancetta",
	"lanterna",
	"lardoso",
	"larga",
	"laringe",
	"lastra",
	"latenza",
	"latino",
	"lattuga",
	"lavagna",
	"lavoro",
	"legale",
	"leggero",
	"lembo",
	"lentezza",
	"lenza",
	"leone",
	"lepre",
	"lesivo",
	"lessato",
	"lesto",
	"letterale",
	"leva",
	"levigato",
	"libero",
	"lido",
	"lievito",
	"lilla",
	"limatura",
	"limitare",
	"limpido",
	"lineare",
	"lingua",
	"liquido",
	"lira",
	"lirica",
	"lisca",
	"lite",
	"litigio",
	"livrea",
	"locanda",
	"lode",
	"logica",
	"lombare",
	"londra",
	"longevo",
	"loquace",
	"lorenzo",
	"loto",
	"lotteria",
	"luce",
	"lucidato",
	"lumaca",
	"luminoso",
	"lungo",
	"lupo",
	"luppolo",
	"lusinga",
	"lusso",
	"lutto",
	"macabro",
	"macchina",
	"macero",
	"macinato",
	"madama",
	"magico",
	"maglia",
	"magnete",
	"magro",
	"maiolica",
	"malafede",
	"malgrado",
	"malinteso",
	"malsano",
	"malto",
	"malumore",
	"mana",
	"mancia",
	"mandorla",
	"mangiare",
	"manifesto",
	"mannaro",
	"manovra",
	"mansarda",
	"mantide",
	"manubrio",
	"mappa",
	"maratona",
	"marcire",
	"maretta",
	"marmo",
	"marsupio",
	"maschera",
	"massaia",
	"mastino",
	"materasso",
	"matricola",
	"mattone",
	"maturo",
	"mazurca",
	"meandro",
	"meccanico",
	"mecenate",
	"medesimo",
	"meditare",
	"mega",
	"melassa",
	"melis",
	"melodia",
	"meninge",
	"meno",
	"mensola",
	"mercurio",
	"merenda",
	"merlo",
	"meschino",
	"mese",
	"messere",
	"mestolo",
	"metallo",
	"metodo",
	"mettere",
	"miagolare",
	"mica",
	"micelio",
	"michele",
	"microbo",
	"midollo",
	"miele",
	"migliore",
	"milano",
	"milite",
	"mimosa",
	"minerale",
	"mini",
	"minore",
	"mirino",
	"mirtillo",
	"miscela",
	"missiva",
	"misto",
	"misurare",
	"mitezza",
	"mitigare",
	"mitra",
	"mittente",
	"mnemonico",
	"modello",
	"modifica",
	"modulo",
	"mogano",
	"mogio",
	"mole",
	"molosso",
	"monastero",
	"monco",
	"mondina",
	"monetario",
	"monile",
	"monotono",
	"monsone",
	"montato",
	"monviso",
	"mora",
	"mordere",
	"morsicato",
	"mostro",
	"motivato",
	"motosega",
	"motto",
	"movenza",
	"movimento",
	"mozzo",
	"mucca",
	"mucosa",
	"muffa",
	"mughetto",
	"mugnaio",
	"mulatto",
	"mulinello",
	"multiplo",
	"mummia",
	"munto",
	"muovere",
	"murale",
	"musa",
	"muscolo",
	"musica",
	"mutevole",
	"muto",
	"nababbo",
	"nafta",
	"nanometro",
	"narciso",
	"narice",
	"narrato",
	"nascere",
	"nastrare",
	"naturale",
	"nautica",
	"naviglio",
	"nebulosa",
	"necrosi",
	"negativo",
	"negozio",
	"nemmeno",
	"neofita",
	"neretto",
	"nervo",
	"nessuno",
	"nettuno",
	"neutrale",
	"neve",
	"nevrotico",
	"nicchia",
	"ninfa",
	"nitido",
	"nobile",
	"nocivo",
	"nodo",
	"nome",
	"nomina",
	"nordico",
	"normale",
	"norvegese",
	"nostrano",
	"notare",
	"notizia",
	"notturno",
	"novella",
	"nucleo",
	"nulla",
	"numero",
	"nuovo",
	"nutrire",
	"nuvola",
	"nuziale",
	"oasi",
	"obbedire",
	"obbligo",
	"obelisco",
	"oblio",
	"obolo",
	"obsoleto",
	"occasione",
	"occhio",
	"occidente",
	"occorrere",
	"occultare",
	"ocra",
	"oculato",
	"odierno",
	"odorare",
	"offerta",
	"offrire",
	"offuscato",
	"oggetto",
	"oggi",
	"ognuno",
	"olandese",
	"olfatto",
	"oliato",
	"oliva",
	"ologramma",
	"oltre",
	"omaggio",
	"ombelico",
	"ombra",
	"omega",
	"omissione",
	"ondoso",
	"onere",
	"onice",
	"onnivoro",
	"onorevole",
	"onta",
	"operato",
	"opinione",
	"opposto",
	"oracolo",
	"orafo",
	"ordine",
	"orecchino",
	"orefice",
	"orfano",
	"organico",
	"origine",
	"orizzonte",
	"orma",
	"ormeggio",
	"ornativo",
	"orologio",
	"orrendo",
	"orribile",
	"ortensia",
	"ortica",
	"orzata",
	"orzo",
	"osare",
	"oscurare",
	"osmosi",
	"ospedale",
	"ospite",
	"ossa",
	"ossidare",
	"ostacolo",
	"oste",
	"otite",
	"otre",
	"ottagono",
	"ottimo",
	"ottobre",
	"ovale",
	"ovest",
	"ovino",
	"oviparo",
	"ovocito",
	"ovunque",
	"ovviare",
	"ozio",
	"pacchetto",
	"pace",
	"pacifico",
	"padella",
	"padrone",
	"paese",
	"paga",
	"pagina",
	"palazzina",
	"palesare",
	"pallido",
	"palo",
	"palude",
	"pandoro",
	"pannello",
	"paolo",
	"paonazzo",
	"paprica",
	"parabola",
	"parcella",
	"parere",
	"pargolo",
	"pari",
	"parlato",
	"parola",
	"partire",
	"parvenza",
	"parziale",
	"passivo",
	"pasticca",
	"patacca",
	"patologia",
	"pattume",
	"pavone",
	"peccato",
	"pedalare",
	"pedonale",
	"peggio",
	"peloso",
	"penare",
	"pendice",
	"penisola",
	"pennuto",
	"penombra",
	"pensare",
	"pentola",
	"pepe",
	"pepita",
	"perbene",
	"percorso",
	"perdonato",
	"perforare",
	"pergamena",
	"periodo",
	"permesso",
	"perno",
	"perplesso",
	"persuaso",
	"pertugio",
	"pervaso",
	"pesatore",
	"pesista",
	"peso",
	"pestifero",
	"petalo",
	"pettine",
	"petulante",
	"pezzo",
	"piacere",
	"pianta",
	"piattino",
	"piccino",
	"picozza",
	"piega",
	"pietra",
	"piffero",
	"pigiama",
	"pigolio",
	"pigro",
	"pila",
	"pilifero",
	"pillola",
	"pilota",
	"pimpante",
	"pineta",
	"pinna",
	"pinolo",
	"pioggia",
	"piombo",
	"piramide",
	"piretico",
	"pirite",
	"pirolisi",
	"pitone",
	"pizzico",
	"placebo",
	"planare",
	"plasma",
	"platano",
	"plenario",
	"pochezza",
	"poderoso",
	"podismo",
	"poesia",
	"poggiare",
	"polenta",
	"poligono",
	"pollice",
	"polmonite",
	"polpetta",
	"polso",
	"poltrona",
	"polvere",
	"pomice",
	"pomodoro",
	"ponte",
	"popoloso",
	"porfido",
	"poroso",
	"porpora",
	"porre",
	"portata",
	"posa",
	"positivo",
	"possesso",
	"postulato",
	"potassio",
	"potere",
	"pranzo",
	"prassi",
	"pratica",
	"precluso",
	"predica",
	"prefisso",
	"pregiato",
	"prelievo",
	"premere",
	"prenotare",
	"preparato",
	"presenza",
	"pretesto",
	"prevalso",
	"prima",
	"principe",
	"privato",
	"problema",
	"procura",
	"produrre",
	"profumo",
	"progetto",
	"prolunga",
	"promessa",
	"pronome",
	"proposta",
	"proroga",
	"proteso",
	"prova",
	"prudente",
	"prugna",
	"prurito",
	"psiche",
	"pubblico",
	"pudica",
	"pugilato",
	"pugno",
	"pulce",
	"pulito",
	"pulsante",
	"puntare",
	"pupazzo",
	"pupilla",
	"puro",
	"quadro",
	"qualcosa",
	"quasi",
	"querela",
	"quota",
	"raccolto",
	"raddoppio",
	"radicale",
	"radunato",
	"raffica",
	"ragazzo",
	"ragione",
	"ragno",
	"ramarro",
	"ramingo",
	"ramo",
	"randagio",
	"rantolare",
	"rapato",
	"rapina",
	"rappreso",
	"rasatura",
	"raschiato",
	"rasente",
	"rassegna",
	"rastrello",
	"rata",
	"ravveduto",
	"reale",
	"recepire",
	"recinto",
	"recluta",
	"recondito",
	"recupero",
	"reddito",
	"redimere",
	"regalato",
	"registro",
	"regola",
	"regresso",
	"relazione",
	"remare",
	"remoto",
	"renna",
	"replica",
	"reprimere",
	"reputare",
	"resa",
	"residente",
	"responso",
	"restauro",
	"rete",
	"retina",
	"retorica",
	"rettifica",
	"revocato",
	"riassunto",
	"ribadire",
	"ribelle",
	"ribrezzo",
	"ricarica",
	"ricco",
	"ricevere",
	"riciclato",
	"ricordo",
	"ricreduto",
	"ridicolo",
	"ridurre",
	"rifasare",
	"riflesso",
	"riforma",
	"rifugio",
	"rigare",
	"rigettato",
	"righello",
	"rilassato",
	"rilevato",
	"rimanere",
	"rimbalzo",
	"rimedio",
	"rimorchio",
	"rinascita",
	"rincaro",
	"rinforzo",
	"rinnovo",
	"rinomato",
	"rinsavito",
	"rintocco",
	"rinuncia",
	"rinvenire",
	"riparato",
	"ripetuto",
	"ripieno",
	"riportare",
	"ripresa",
	"ripulire",
	"risata",
	"rischio",
	"riserva",
	"risibile",
	"riso",
	"rispetto",
	"ristoro",
	"risultato",
	"risvolto",
	"ritardo",
	"ritegno",
	"ritmico",
	"ritrovo",
	"riunione",
	"riva",
	"riverso",
	"rivincita",
	"rivolto",
	"rizoma",
	"roba",
	"robotico",
	"robusto",
	"roccia",
	"roco",
	"rodaggio",
	"rodere",
	"roditore",
	"rogito",
	"rollio",
	"romantico",
	"rompere",
	"ronzio",
	"rosolare",
	"rospo",
	"rotante",
	"rotondo",
	"rotula",
	"rovescio",
	"rubizzo",
	"rubrica",
	"ruga",
	"rullino",
	"rumine",
	"rumoroso",
	"ruolo",
	"rupe",
	"russare",
	"rustico",
	"sabato",
	"sabbiare",
	"sabotato",
	"sagoma",
	"salasso",
	"saldatura",
	"salgemma",
	"salivare",
	"salmone",
	"salone",
	"saltare",
	"saluto",
	"salvo",
	"sapere",
	"sapido",
	"saporito",
	"saraceno",
	"sarcasmo",
	"sarto",
	"sassoso",
	"satellite",
	"satira",
	"satollo",
	"saturno",
	"savana",
	"savio",
	"saziato",
	"sbadiglio",
	"sbalzo",
	"sbancato",
	"sbarra",
	"sbattere",
	"sbavare",
	"sbendare",
	"sbirciare",
	"sbloccato",
	"sbocciato",
	"sbrinare",
	"sbruffone",
	"sbuffare",
	"scabroso",
	"scadenza",
	"scala",
	"scambiare",
	"scandalo",
	"scapola",
	"scarso",
	"scatenare",
	"scavato",
	"scelto",
	"scenico",
	"scettro",
	"scheda",
	"schiena",
	"sciarpa",
	"scienza",
	"scindere",
	"scippo",
	"sciroppo",
	"scivolo",
	"sclerare",
	"scodella",
	"scolpito",
	"scomparto",
	"sconforto",
	"scoprire",
	"scorta",
	"scossone",
	"scozzese",
	"scriba",
	"scrollare",
	"scrutinio",
	"scuderia",
	"scultore",
	"scuola",
	"scuro",
	"scusare",
	"sdebitare",
	"sdoganare",
	"seccatura",
	"secondo",
	"sedano",
	"seggiola",
	"segnalato",
	"segregato",
	"seguito",
	"selciato",
	"selettivo",
	"sella",
	"selvaggio",
	"semaforo",
	"sembrare",
	"seme",
	"seminato",
	"sempre",
	"senso",
	"sentire",
	"sepolto",
	"sequenza",
	"serata",
	"serbato",
	"sereno",
	"serio",
	"serpente",
	"serraglio",
	"servire",
	"sestina",
	"setola",
	"settimana",
	"sfacelo",
	"sfaldare",
	"sfamato",
	"sfarzoso",
	"sfaticato",
	"sfera",
	"sfida",
	"sfilato",
	"sfinge",
	"sfocato",
	"sfoderare",
	"sfogo",
	"sfoltire",
	"sforzato",
	"sfratto",
	"sfruttato",
	"sfuggito",
	"sfumare",
	"sfuso",
	"sgabello",
	"sgarbato",
	"sgonfiare",
	"sgorbio",
	"sgrassato",
	"sguardo",
	"sibilo",
	"siccome",
	"sierra",
	"sigla",
	"signore",
	"silenzio",
	"sillaba",
	"simbolo",
	"simpatico",
	"simulato",
	"sinfonia",
	"singolo",
	"sinistro",
	"sino",
	"sintesi",
	"sinusoide",
	"sipario",
	"sisma",
	"sistole",
	"situato",
	"slitta",
	"slogatura",
	"sloveno",
	"smarrito",
	"smemorato",
	"smentito",
	"smeraldo",
	"smilzo",
	"smontare",
	"smottato",
	"smussato",
	"snellire",
	"snervato",
	"snodo",
	"sobbalzo",
	"sobrio",
	"soccorso",
	"sociale",
	"sodale",
	"soffitto",
	"sogno",
	"soldato",
	"solenne",
	"solido",
	"sollazzo",
	"solo",
	"solubile",
	"solvente",
	"somatico",
	"somma",
	"sonda",
	"sonetto",
	"sonnifero",
	"sopire",
	"soppeso",
	"sopra",
	"sorgere",
	"sorpasso",
	"sorriso",
	"sorso",
	"sorteggio",
	"sorvolato",
	"sospiro",
	"sosta",
	"sottile",
	"spada",
	"spalla",
	"spargere",
	"spatola",
	"spavento",
	"spazzola",
	"specie",
	"spedire",
	"spegnere",
	"spelatura",
	"speranza",
	"spessore",
	"spettrale",
	"spezzato",
	"spia",
	"spigoloso",
	"spillato",
	"spinoso",
	"spirale",
	"splendido",
	"sportivo",
	"sposo",
	"spranga",
	"sprecare",
	"spronato",
	"spruzzo",
	"spuntino",
	"squillo",
	"sradicare",
	"srotolato",
	"stabile",
	"stacco",
	"staffa",
	"stagnare",
	"stampato",
	"stantio",
	"starnuto",
	"stasera",
	"statuto",
	"stelo",
	"steppa",
	"sterzo",
	"stiletto",
	"stima",
	"stirpe",
	"stivale",
	"stizzoso",
	"stonato",
	"storico",
	"strappo",
	"stregato",
	"stridulo",
	"strozzare",
	"strutto",
	"stuccare",
	"stufo",
	"stupendo",
	"subentro",
	"succoso",
	"sudore",
	"suggerito",
	"sugo",
	"sultano",
	"suonare",
	"superbo",
	"supporto",
	"surgelato",
	"surrogato",
	"sussurro",
	"sutura",
	"svagare",
	"svedese",
	"sveglio",
	"svelare",
	"svenuto",
	"svezia",
	"sviluppo",
	"svista",
	"svizzera",
	"svolta",
	"svuotare",
	"tabacco",
	"tabulato",
	"tacciare",
	"taciturno",
	"tale",
	"talismano",
	"tampone",
	"tannino",
	"tara",
	"tardivo",
	"targato",
	"tariffa",
	"tarpare",
	"tartaruga",
	"tasto",
	"tattico",
	"taverna",
	"tavolata",
	"tazza",
	"teca",
	"tecnico",
	"telefono",
	"temerario",
	"tempo",
	"temuto",
	"tendone",
	"tenero",
	"tensione",
	"tentacolo",
	"teorema",
	"terme",
	"terrazzo",
	"terzetto",
	"tesi",
	"tesserato",
	"testato",
	"tetro",
	"tettoia",
	"tifare",
	"tigella",
	"timbro",
	"tinto",
	"tipico",
	"tipografo",
	"tiraggio",
	"tiro",
	"titanio",
	"titolo",
	"titubante",
	"tizio",
	"tizzone",
	"toccare",
	"tollerare",
	"tolto",
	"tombola",
	"tomo",
	"tonfo",
	"tonsilla",
	"topazio",
	"topologia",
	"toppa",
	"torba",
	"tornare",
	"torrone",
	"tortora",
	"toscano",
	"tossire",
	"tostatura",
	"totano",
	"trabocco",
	"trachea",
	"trafila",
	"tragedia",
	"tralcio",
	"tramonto",
	"transito",
	"trapano",
	"trarre",
	"trasloco",
	"trattato",
	"trave",
	"treccia",
	"tremolio",
	"trespolo",
	"tributo",
	"tricheco",
	"trifoglio",
	"trillo",
	"trincea",
	"trio",
	"tristezza",
	"triturato",
	"trivella",
	"tromba",
	"trono",
	"troppo",
	"trottola",
	"trovare",
	"truccato",
	"tubatura",
	"tuffato",
	"tulipano",
	"tumulto",
	"tunisia",
	"turbare",
	"turchino",
	"tuta",
	"tutela",
	"ubicato",
	"uccello",
	"uccisore",
	"udire",
	"uditivo",
	"uffa",
	"ufficio",
	"uguale",
	"ulisse",
	"ultimato",
	"umano",
	"umile",
	"umorismo",
	"uncinetto",
	"ungere",
	"ungherese",
	"unicorno",
	"unificato",
	"unisono",
	"unitario",
	"unte",
	"uovo",
	"upupa",
	"uragano",
	"urgenza",
	"urlo",
	"usanza",
	"usato",
	"uscito",
	"usignolo",
	"usuraio",
	"utensile",
	"utilizzo",
	"utopia",
	"vacante",
	"vaccinato",
	"vagabondo",
	"vagliato",
	"valanga",
	"valgo",
	"valico",
	"valletta",
	"valoroso",
	"valutare",
	"valvola",
	"vampata",
	"vangare",
	"vanitoso",
	"vano",
	"vantaggio",
	"vanvera",
	"vapore",
	"varano",
	"varcato",
	"variante",
	"vasca",
	"vedetta",
	"vedova",
	"veduto",
	"vegetale",
	"veicolo",
	"velcro",
	"velina",
	"velluto",
	"veloce",
	"venato",
	"vendemmia",
	"vento",
	"verace",
	"verbale",
	"vergogna",
	"verifica",
	"vero",
	"verruca",
	"verticale",
	"vescica",
	"vessillo",
	"vestale",
	"veterano",
	"vetrina",
	"vetusto",
	"viandante",
	"vibrante",
	"vicenda",
	"vichingo",
	"vicinanza",
	"vidimare",
	"vigilia",
	"vigneto",
	"vigore",
	"vile",
	"villano",
	"vimini",
	"vincitore",
	"viola",
	"vipera",
	"virgola",
	"virologo",
	"virulento",
	"viscoso",
	"visione",
	"vispo",
	"vissuto",
	"visura",
	"vita",
	"vitello",
	"vittima",
	"vivanda",
	"vivido",
	"viziare",
	"voce",
	"voga",
	"volatile",
	"volere",
	"volpe",
	"voragine",
	"vulcano",
	"zampogna",
	"zanna",
	"zappato",
	"zattera",
	"zavorra",
	"zefiro",
	"zelante",
	"zelo",
	"zenzero",
	"zerbino",
	"zibetto",
	"zinco",
	"zircone",
	"zitto",
	"zolla",
	"zotico",
	"zucchero",
	"zufolo",
	"zulu",
	"zuppa"
];

var require$$6 = [
	"abaco",
	"abdomen",
	"abeja",
	"abierto",
	"abogado",
	"abono",
	"aborto",
	"abrazo",
	"abrir",
	"abuelo",
	"abuso",
	"acabar",
	"academia",
	"acceso",
	"accion",
	"aceite",
	"acelga",
	"acento",
	"aceptar",
	"acido",
	"aclarar",
	"acne",
	"acoger",
	"acoso",
	"activo",
	"acto",
	"actriz",
	"actuar",
	"acudir",
	"acuerdo",
	"acusar",
	"adicto",
	"admitir",
	"adoptar",
	"adorno",
	"aduana",
	"adulto",
	"aereo",
	"afectar",
	"aficion",
	"afinar",
	"afirmar",
	"agil",
	"agitar",
	"agonia",
	"agosto",
	"agotar",
	"agregar",
	"agrio",
	"agua",
	"agudo",
	"aguila",
	"aguja",
	"ahogo",
	"ahorro",
	"aire",
	"aislar",
	"ajedrez",
	"ajeno",
	"ajuste",
	"alacran",
	"alambre",
	"alarma",
	"alba",
	"album",
	"alcalde",
	"aldea",
	"alegre",
	"alejar",
	"alerta",
	"aleta",
	"alfiler",
	"alga",
	"algodon",
	"aliado",
	"aliento",
	"alivio",
	"alma",
	"almeja",
	"almibar",
	"altar",
	"alteza",
	"altivo",
	"alto",
	"altura",
	"alumno",
	"alzar",
	"amable",
	"amante",
	"amapola",
	"amargo",
	"amasar",
	"ambar",
	"ambito",
	"ameno",
	"amigo",
	"amistad",
	"amor",
	"amparo",
	"amplio",
	"ancho",
	"anciano",
	"ancla",
	"andar",
	"anden",
	"anemia",
	"angulo",
	"anillo",
	"animo",
	"anis",
	"anotar",
	"antena",
	"antiguo",
	"antojo",
	"anual",
	"anular",
	"anuncio",
	"anadir",
	"anejo",
	"ano",
	"apagar",
	"aparato",
	"apetito",
	"apio",
	"aplicar",
	"apodo",
	"aporte",
	"apoyo",
	"aprender",
	"aprobar",
	"apuesta",
	"apuro",
	"arado",
	"arana",
	"arar",
	"arbitro",
	"arbol",
	"arbusto",
	"archivo",
	"arco",
	"arder",
	"ardilla",
	"arduo",
	"area",
	"arido",
	"aries",
	"armonia",
	"arnes",
	"aroma",
	"arpa",
	"arpon",
	"arreglo",
	"arroz",
	"arruga",
	"arte",
	"artista",
	"asa",
	"asado",
	"asalto",
	"ascenso",
	"asegurar",
	"aseo",
	"asesor",
	"asiento",
	"asilo",
	"asistir",
	"asno",
	"asombro",
	"aspero",
	"astilla",
	"astro",
	"astuto",
	"asumir",
	"asunto",
	"atajo",
	"ataque",
	"atar",
	"atento",
	"ateo",
	"atico",
	"atleta",
	"atomo",
	"atraer",
	"atroz",
	"atun",
	"audaz",
	"audio",
	"auge",
	"aula",
	"aumento",
	"ausente",
	"autor",
	"aval",
	"avance",
	"avaro",
	"ave",
	"avellana",
	"avena",
	"avestruz",
	"avion",
	"aviso",
	"ayer",
	"ayuda",
	"ayuno",
	"azafran",
	"azar",
	"azote",
	"azucar",
	"azufre",
	"azul",
	"baba",
	"babor",
	"bache",
	"bahia",
	"baile",
	"bajar",
	"balanza",
	"balcon",
	"balde",
	"bambu",
	"banco",
	"banda",
	"bano",
	"barba",
	"barco",
	"barniz",
	"barro",
	"bascula",
	"baston",
	"basura",
	"batalla",
	"bateria",
	"batir",
	"batuta",
	"baul",
	"bazar",
	"bebe",
	"bebida",
	"bello",
	"besar",
	"beso",
	"bestia",
	"bicho",
	"bien",
	"bingo",
	"blanco",
	"bloque",
	"blusa",
	"boa",
	"bobina",
	"bobo",
	"boca",
	"bocina",
	"boda",
	"bodega",
	"boina",
	"bola",
	"bolero",
	"bolsa",
	"bomba",
	"bondad",
	"bonito",
	"bono",
	"bonsai",
	"borde",
	"borrar",
	"bosque",
	"bote",
	"botin",
	"boveda",
	"bozal",
	"bravo",
	"brazo",
	"brecha",
	"breve",
	"brillo",
	"brinco",
	"brisa",
	"broca",
	"broma",
	"bronce",
	"brote",
	"bruja",
	"brusco",
	"bruto",
	"buceo",
	"bucle",
	"bueno",
	"buey",
	"bufanda",
	"bufon",
	"buho",
	"buitre",
	"bulto",
	"burbuja",
	"burla",
	"burro",
	"buscar",
	"butaca",
	"buzon",
	"caballo",
	"cabeza",
	"cabina",
	"cabra",
	"cacao",
	"cadaver",
	"cadena",
	"caer",
	"cafe",
	"caida",
	"caiman",
	"caja",
	"cajon",
	"cal",
	"calamar",
	"calcio",
	"caldo",
	"calidad",
	"calle",
	"calma",
	"calor",
	"calvo",
	"cama",
	"cambio",
	"camello",
	"camino",
	"campo",
	"cancer",
	"candil",
	"canela",
	"canguro",
	"canica",
	"canto",
	"cana",
	"canon",
	"caoba",
	"caos",
	"capaz",
	"capitan",
	"capote",
	"captar",
	"capucha",
	"cara",
	"carbon",
	"carcel",
	"careta",
	"carga",
	"carino",
	"carne",
	"carpeta",
	"carro",
	"carta",
	"casa",
	"casco",
	"casero",
	"caspa",
	"castor",
	"catorce",
	"catre",
	"caudal",
	"causa",
	"cazo",
	"cebolla",
	"ceder",
	"cedro",
	"celda",
	"celebre",
	"celoso",
	"celula",
	"cemento",
	"ceniza",
	"centro",
	"cerca",
	"cerdo",
	"cereza",
	"cero",
	"cerrar",
	"certeza",
	"cesped",
	"cetro",
	"chacal",
	"chaleco",
	"champu",
	"chancla",
	"chapa",
	"charla",
	"chico",
	"chiste",
	"chivo",
	"choque",
	"choza",
	"chuleta",
	"chupar",
	"ciclon",
	"ciego",
	"cielo",
	"cien",
	"cierto",
	"cifra",
	"cigarro",
	"cima",
	"cinco",
	"cine",
	"cinta",
	"cipres",
	"circo",
	"ciruela",
	"cisne",
	"cita",
	"ciudad",
	"clamor",
	"clan",
	"claro",
	"clase",
	"clave",
	"cliente",
	"clima",
	"clinica",
	"cobre",
	"coccion",
	"cochino",
	"cocina",
	"coco",
	"codigo",
	"codo",
	"cofre",
	"coger",
	"cohete",
	"cojin",
	"cojo",
	"cola",
	"colcha",
	"colegio",
	"colgar",
	"colina",
	"collar",
	"colmo",
	"columna",
	"combate",
	"comer",
	"comida",
	"comodo",
	"compra",
	"conde",
	"conejo",
	"conga",
	"conocer",
	"consejo",
	"contar",
	"copa",
	"copia",
	"corazon",
	"corbata",
	"corcho",
	"cordon",
	"corona",
	"correr",
	"coser",
	"cosmos",
	"costa",
	"craneo",
	"crater",
	"crear",
	"crecer",
	"creido",
	"crema",
	"cria",
	"crimen",
	"cripta",
	"crisis",
	"cromo",
	"cronica",
	"croqueta",
	"crudo",
	"cruz",
	"cuadro",
	"cuarto",
	"cuatro",
	"cubo",
	"cubrir",
	"cuchara",
	"cuello",
	"cuento",
	"cuerda",
	"cuesta",
	"cueva",
	"cuidar",
	"culebra",
	"culpa",
	"culto",
	"cumbre",
	"cumplir",
	"cuna",
	"cuneta",
	"cuota",
	"cupon",
	"cupula",
	"curar",
	"curioso",
	"curso",
	"curva",
	"cutis",
	"dama",
	"danza",
	"dar",
	"dardo",
	"datil",
	"deber",
	"debil",
	"decada",
	"decir",
	"dedo",
	"defensa",
	"definir",
	"dejar",
	"delfin",
	"delgado",
	"delito",
	"demora",
	"denso",
	"dental",
	"deporte",
	"derecho",
	"derrota",
	"desayuno",
	"deseo",
	"desfile",
	"desnudo",
	"destino",
	"desvio",
	"detalle",
	"detener",
	"deuda",
	"dia",
	"diablo",
	"diadema",
	"diamante",
	"diana",
	"diario",
	"dibujo",
	"dictar",
	"diente",
	"dieta",
	"diez",
	"dificil",
	"digno",
	"dilema",
	"diluir",
	"dinero",
	"directo",
	"dirigir",
	"disco",
	"diseno",
	"disfraz",
	"diva",
	"divino",
	"doble",
	"doce",
	"dolor",
	"domingo",
	"don",
	"donar",
	"dorado",
	"dormir",
	"dorso",
	"dos",
	"dosis",
	"dragon",
	"droga",
	"ducha",
	"duda",
	"duelo",
	"dueno",
	"dulce",
	"duo",
	"duque",
	"durar",
	"dureza",
	"duro",
	"ebano",
	"ebrio",
	"echar",
	"eco",
	"ecuador",
	"edad",
	"edicion",
	"edificio",
	"editor",
	"educar",
	"efecto",
	"eficaz",
	"eje",
	"ejemplo",
	"elefante",
	"elegir",
	"elemento",
	"elevar",
	"elipse",
	"elite",
	"elixir",
	"elogio",
	"eludir",
	"embudo",
	"emitir",
	"emocion",
	"empate",
	"empeno",
	"empleo",
	"empresa",
	"enano",
	"encargo",
	"enchufe",
	"encia",
	"enemigo",
	"enero",
	"enfado",
	"enfermo",
	"engano",
	"enigma",
	"enlace",
	"enorme",
	"enredo",
	"ensayo",
	"ensenar",
	"entero",
	"entrar",
	"envase",
	"envio",
	"epoca",
	"equipo",
	"erizo",
	"escala",
	"escena",
	"escolar",
	"escribir",
	"escudo",
	"esencia",
	"esfera",
	"esfuerzo",
	"espada",
	"espejo",
	"espia",
	"esposa",
	"espuma",
	"esqui",
	"estar",
	"este",
	"estilo",
	"estufa",
	"etapa",
	"eterno",
	"etica",
	"etnia",
	"evadir",
	"evaluar",
	"evento",
	"evitar",
	"exacto",
	"examen",
	"exceso",
	"excusa",
	"exento",
	"exigir",
	"exilio",
	"existir",
	"exito",
	"experto",
	"explicar",
	"exponer",
	"extremo",
	"fabrica",
	"fabula",
	"fachada",
	"facil",
	"factor",
	"faena",
	"faja",
	"falda",
	"fallo",
	"falso",
	"faltar",
	"fama",
	"familia",
	"famoso",
	"faraon",
	"farmacia",
	"farol",
	"farsa",
	"fase",
	"fatiga",
	"fauna",
	"favor",
	"fax",
	"febrero",
	"fecha",
	"feliz",
	"feo",
	"feria",
	"feroz",
	"fertil",
	"fervor",
	"festin",
	"fiable",
	"fianza",
	"fiar",
	"fibra",
	"ficcion",
	"ficha",
	"fideo",
	"fiebre",
	"fiel",
	"fiera",
	"fiesta",
	"figura",
	"fijar",
	"fijo",
	"fila",
	"filete",
	"filial",
	"filtro",
	"fin",
	"finca",
	"fingir",
	"finito",
	"firma",
	"flaco",
	"flauta",
	"flecha",
	"flor",
	"flota",
	"fluir",
	"flujo",
	"fluor",
	"fobia",
	"foca",
	"fogata",
	"fogon",
	"folio",
	"folleto",
	"fondo",
	"forma",
	"forro",
	"fortuna",
	"forzar",
	"fosa",
	"foto",
	"fracaso",
	"fragil",
	"franja",
	"frase",
	"fraude",
	"freir",
	"freno",
	"fresa",
	"frio",
	"frito",
	"fruta",
	"fuego",
	"fuente",
	"fuerza",
	"fuga",
	"fumar",
	"funcion",
	"funda",
	"furgon",
	"furia",
	"fusil",
	"futbol",
	"futuro",
	"gacela",
	"gafas",
	"gaita",
	"gajo",
	"gala",
	"galeria",
	"gallo",
	"gamba",
	"ganar",
	"gancho",
	"ganga",
	"ganso",
	"garaje",
	"garza",
	"gasolina",
	"gastar",
	"gato",
	"gavilan",
	"gemelo",
	"gemir",
	"gen",
	"genero",
	"genio",
	"gente",
	"geranio",
	"gerente",
	"germen",
	"gesto",
	"gigante",
	"gimnasio",
	"girar",
	"giro",
	"glaciar",
	"globo",
	"gloria",
	"gol",
	"golfo",
	"goloso",
	"golpe",
	"goma",
	"gordo",
	"gorila",
	"gorra",
	"gota",
	"goteo",
	"gozar",
	"grada",
	"grafico",
	"grano",
	"grasa",
	"gratis",
	"grave",
	"grieta",
	"grillo",
	"gripe",
	"gris",
	"grito",
	"grosor",
	"grua",
	"grueso",
	"grumo",
	"grupo",
	"guante",
	"guapo",
	"guardia",
	"guerra",
	"guia",
	"guino",
	"guion",
	"guiso",
	"guitarra",
	"gusano",
	"gustar",
	"haber",
	"habil",
	"hablar",
	"hacer",
	"hacha",
	"hada",
	"hallar",
	"hamaca",
	"harina",
	"haz",
	"hazana",
	"hebilla",
	"hebra",
	"hecho",
	"helado",
	"helio",
	"hembra",
	"herir",
	"hermano",
	"heroe",
	"hervir",
	"hielo",
	"hierro",
	"higado",
	"higiene",
	"hijo",
	"himno",
	"historia",
	"hocico",
	"hogar",
	"hoguera",
	"hoja",
	"hombre",
	"hongo",
	"honor",
	"honra",
	"hora",
	"hormiga",
	"horno",
	"hostil",
	"hoyo",
	"hueco",
	"huelga",
	"huerta",
	"hueso",
	"huevo",
	"huida",
	"huir",
	"humano",
	"humedo",
	"humilde",
	"humo",
	"hundir",
	"huracan",
	"hurto",
	"icono",
	"ideal",
	"idioma",
	"idolo",
	"iglesia",
	"iglu",
	"igual",
	"ilegal",
	"ilusion",
	"imagen",
	"iman",
	"imitar",
	"impar",
	"imperio",
	"imponer",
	"impulso",
	"incapaz",
	"indice",
	"inerte",
	"infiel",
	"informe",
	"ingenio",
	"inicio",
	"inmenso",
	"inmune",
	"innato",
	"insecto",
	"instante",
	"interes",
	"intimo",
	"intuir",
	"inutil",
	"invierno",
	"ira",
	"iris",
	"ironia",
	"isla",
	"islote",
	"jabali",
	"jabon",
	"jamon",
	"jarabe",
	"jardin",
	"jarra",
	"jaula",
	"jazmin",
	"jefe",
	"jeringa",
	"jinete",
	"jornada",
	"joroba",
	"joven",
	"joya",
	"juerga",
	"jueves",
	"juez",
	"jugador",
	"jugo",
	"juguete",
	"juicio",
	"junco",
	"jungla",
	"junio",
	"juntar",
	"jupiter",
	"jurar",
	"justo",
	"juvenil",
	"juzgar",
	"kilo",
	"koala",
	"labio",
	"lacio",
	"lacra",
	"lado",
	"ladron",
	"lagarto",
	"lagrima",
	"laguna",
	"laico",
	"lamer",
	"lamina",
	"lampara",
	"lana",
	"lancha",
	"langosta",
	"lanza",
	"lapiz",
	"largo",
	"larva",
	"lastima",
	"lata",
	"latex",
	"latir",
	"laurel",
	"lavar",
	"lazo",
	"leal",
	"leccion",
	"leche",
	"lector",
	"leer",
	"legion",
	"legumbre",
	"lejano",
	"lengua",
	"lento",
	"lena",
	"leon",
	"leopardo",
	"lesion",
	"letal",
	"letra",
	"leve",
	"leyenda",
	"libertad",
	"libro",
	"licor",
	"lider",
	"lidiar",
	"lienzo",
	"liga",
	"ligero",
	"lima",
	"limite",
	"limon",
	"limpio",
	"lince",
	"lindo",
	"linea",
	"lingote",
	"lino",
	"linterna",
	"liquido",
	"liso",
	"lista",
	"litera",
	"litio",
	"litro",
	"llaga",
	"llama",
	"llanto",
	"llave",
	"llegar",
	"llenar",
	"llevar",
	"llorar",
	"llover",
	"lluvia",
	"lobo",
	"locion",
	"loco",
	"locura",
	"logica",
	"logro",
	"lombriz",
	"lomo",
	"lonja",
	"lote",
	"lucha",
	"lucir",
	"lugar",
	"lujo",
	"luna",
	"lunes",
	"lupa",
	"lustro",
	"luto",
	"luz",
	"maceta",
	"macho",
	"madera",
	"madre",
	"maduro",
	"maestro",
	"mafia",
	"magia",
	"mago",
	"maiz",
	"maldad",
	"maleta",
	"malla",
	"malo",
	"mama",
	"mambo",
	"mamut",
	"manco",
	"mando",
	"manejar",
	"manga",
	"maniqui",
	"manjar",
	"mano",
	"manso",
	"manta",
	"manana",
	"mapa",
	"maquina",
	"mar",
	"marco",
	"marea",
	"marfil",
	"margen",
	"marido",
	"marmol",
	"marron",
	"martes",
	"marzo",
	"masa",
	"mascara",
	"masivo",
	"matar",
	"materia",
	"matiz",
	"matriz",
	"maximo",
	"mayor",
	"mazorca",
	"mecha",
	"medalla",
	"medio",
	"medula",
	"mejilla",
	"mejor",
	"melena",
	"melon",
	"memoria",
	"menor",
	"mensaje",
	"mente",
	"menu",
	"mercado",
	"merengue",
	"merito",
	"mes",
	"meson",
	"meta",
	"meter",
	"metodo",
	"metro",
	"mezcla",
	"miedo",
	"miel",
	"miembro",
	"miga",
	"mil",
	"milagro",
	"militar",
	"millon",
	"mimo",
	"mina",
	"minero",
	"minimo",
	"minuto",
	"miope",
	"mirar",
	"misa",
	"miseria",
	"misil",
	"mismo",
	"mitad",
	"mito",
	"mochila",
	"mocion",
	"moda",
	"modelo",
	"moho",
	"mojar",
	"molde",
	"moler",
	"molino",
	"momento",
	"momia",
	"monarca",
	"moneda",
	"monja",
	"monto",
	"mono",
	"morada",
	"morder",
	"moreno",
	"morir",
	"morro",
	"morsa",
	"mortal",
	"mosca",
	"mostrar",
	"motivo",
	"mover",
	"movil",
	"mozo",
	"mucho",
	"mudar",
	"mueble",
	"muela",
	"muerte",
	"muestra",
	"mugre",
	"mujer",
	"mula",
	"muleta",
	"multa",
	"mundo",
	"muneca",
	"mural",
	"muro",
	"musculo",
	"museo",
	"musgo",
	"musica",
	"muslo",
	"nacar",
	"nacion",
	"nadar",
	"naipe",
	"naranja",
	"nariz",
	"narrar",
	"nasal",
	"natal",
	"nativo",
	"natural",
	"nausea",
	"naval",
	"nave",
	"navidad",
	"necio",
	"nectar",
	"negar",
	"negocio",
	"negro",
	"neon",
	"nervio",
	"neto",
	"neutro",
	"nevar",
	"nevera",
	"nicho",
	"nido",
	"niebla",
	"nieto",
	"ninez",
	"nino",
	"nitido",
	"nivel",
	"nobleza",
	"noche",
	"nomina",
	"noria",
	"norma",
	"norte",
	"nota",
	"noticia",
	"novato",
	"novela",
	"novio",
	"nube",
	"nuca",
	"nucleo",
	"nudillo",
	"nudo",
	"nuera",
	"nueve",
	"nuez",
	"nulo",
	"numero",
	"nutria",
	"oasis",
	"obeso",
	"obispo",
	"objeto",
	"obra",
	"obrero",
	"observar",
	"obtener",
	"obvio",
	"oca",
	"ocaso",
	"oceano",
	"ochenta",
	"ocho",
	"ocio",
	"ocre",
	"octavo",
	"octubre",
	"oculto",
	"ocupar",
	"ocurrir",
	"odiar",
	"odio",
	"odisea",
	"oeste",
	"ofensa",
	"oferta",
	"oficio",
	"ofrecer",
	"ogro",
	"oido",
	"oir",
	"ojo",
	"ola",
	"oleada",
	"olfato",
	"olivo",
	"olla",
	"olmo",
	"olor",
	"olvido",
	"ombligo",
	"onda",
	"onza",
	"opaco",
	"opcion",
	"opera",
	"opinar",
	"oponer",
	"optar",
	"optica",
	"opuesto",
	"oracion",
	"orador",
	"oral",
	"orbita",
	"orca",
	"orden",
	"oreja",
	"organo",
	"orgia",
	"orgullo",
	"oriente",
	"origen",
	"orilla",
	"oro",
	"orquesta",
	"oruga",
	"osadia",
	"oscuro",
	"osezno",
	"oso",
	"ostra",
	"otono",
	"otro",
	"oveja",
	"ovulo",
	"oxido",
	"oxigeno",
	"oyente",
	"ozono",
	"pacto",
	"padre",
	"paella",
	"pagina",
	"pago",
	"pais",
	"pajaro",
	"palabra",
	"palco",
	"paleta",
	"palido",
	"palma",
	"paloma",
	"palpar",
	"pan",
	"panal",
	"panico",
	"pantera",
	"panuelo",
	"papa",
	"papel",
	"papilla",
	"paquete",
	"parar",
	"parcela",
	"pared",
	"parir",
	"paro",
	"parpado",
	"parque",
	"parrafo",
	"parte",
	"pasar",
	"paseo",
	"pasion",
	"paso",
	"pasta",
	"pata",
	"patio",
	"patria",
	"pausa",
	"pauta",
	"pavo",
	"payaso",
	"peaton",
	"pecado",
	"pecera",
	"pecho",
	"pedal",
	"pedir",
	"pegar",
	"peine",
	"pelar",
	"peldano",
	"pelea",
	"peligro",
	"pellejo",
	"pelo",
	"peluca",
	"pena",
	"pensar",
	"penon",
	"peon",
	"peor",
	"pepino",
	"pequeno",
	"pera",
	"percha",
	"perder",
	"pereza",
	"perfil",
	"perico",
	"perla",
	"permiso",
	"perro",
	"persona",
	"pesa",
	"pesca",
	"pesimo",
	"pestana",
	"petalo",
	"petroleo",
	"pez",
	"pezuna",
	"picar",
	"pichon",
	"pie",
	"piedra",
	"pierna",
	"pieza",
	"pijama",
	"pilar",
	"piloto",
	"pimienta",
	"pino",
	"pintor",
	"pinza",
	"pina",
	"piojo",
	"pipa",
	"pirata",
	"pisar",
	"piscina",
	"piso",
	"pista",
	"piton",
	"pizca",
	"placa",
	"plan",
	"plata",
	"playa",
	"plaza",
	"pleito",
	"pleno",
	"plomo",
	"pluma",
	"plural",
	"pobre",
	"poco",
	"poder",
	"podio",
	"poema",
	"poesia",
	"poeta",
	"polen",
	"policia",
	"pollo",
	"polvo",
	"pomada",
	"pomelo",
	"pomo",
	"pompa",
	"poner",
	"porcion",
	"portal",
	"posada",
	"poseer",
	"posible",
	"poste",
	"potencia",
	"potro",
	"pozo",
	"prado",
	"precoz",
	"pregunta",
	"premio",
	"prensa",
	"preso",
	"previo",
	"primo",
	"principe",
	"prision",
	"privar",
	"proa",
	"probar",
	"proceso",
	"producto",
	"proeza",
	"profesor",
	"programa",
	"prole",
	"promesa",
	"pronto",
	"propio",
	"proximo",
	"prueba",
	"publico",
	"puchero",
	"pudor",
	"pueblo",
	"puerta",
	"puesto",
	"pulga",
	"pulir",
	"pulmon",
	"pulpo",
	"pulso",
	"puma",
	"punto",
	"punal",
	"puno",
	"pupa",
	"pupila",
	"pure",
	"quedar",
	"queja",
	"quemar",
	"querer",
	"queso",
	"quieto",
	"quimica",
	"quince",
	"quitar",
	"rabano",
	"rabia",
	"rabo",
	"racion",
	"radical",
	"raiz",
	"rama",
	"rampa",
	"rancho",
	"rango",
	"rapaz",
	"rapido",
	"rapto",
	"rasgo",
	"raspa",
	"rato",
	"rayo",
	"raza",
	"razon",
	"reaccion",
	"realidad",
	"rebano",
	"rebote",
	"recaer",
	"receta",
	"rechazo",
	"recoger",
	"recreo",
	"recto",
	"recurso",
	"red",
	"redondo",
	"reducir",
	"reflejo",
	"reforma",
	"refran",
	"refugio",
	"regalo",
	"regir",
	"regla",
	"regreso",
	"rehen",
	"reino",
	"reir",
	"reja",
	"relato",
	"relevo",
	"relieve",
	"relleno",
	"reloj",
	"remar",
	"remedio",
	"remo",
	"rencor",
	"rendir",
	"renta",
	"reparto",
	"repetir",
	"reposo",
	"reptil",
	"res",
	"rescate",
	"resina",
	"respeto",
	"resto",
	"resumen",
	"retiro",
	"retorno",
	"retrato",
	"reunir",
	"reves",
	"revista",
	"rey",
	"rezar",
	"rico",
	"riego",
	"rienda",
	"riesgo",
	"rifa",
	"rigido",
	"rigor",
	"rincon",
	"rinon",
	"rio",
	"riqueza",
	"risa",
	"ritmo",
	"rito",
	"rizo",
	"roble",
	"roce",
	"rociar",
	"rodar",
	"rodeo",
	"rodilla",
	"roer",
	"rojizo",
	"rojo",
	"romero",
	"romper",
	"ron",
	"ronco",
	"ronda",
	"ropa",
	"ropero",
	"rosa",
	"rosca",
	"rostro",
	"rotar",
	"rubi",
	"rubor",
	"rudo",
	"rueda",
	"rugir",
	"ruido",
	"ruina",
	"ruleta",
	"rulo",
	"rumbo",
	"rumor",
	"ruptura",
	"ruta",
	"rutina",
	"sabado",
	"saber",
	"sabio",
	"sable",
	"sacar",
	"sagaz",
	"sagrado",
	"sala",
	"saldo",
	"salero",
	"salir",
	"salmon",
	"salon",
	"salsa",
	"salto",
	"salud",
	"salvar",
	"samba",
	"sancion",
	"sandia",
	"sanear",
	"sangre",
	"sanidad",
	"sano",
	"santo",
	"sapo",
	"saque",
	"sardina",
	"sarten",
	"sastre",
	"satan",
	"sauna",
	"saxofon",
	"seccion",
	"seco",
	"secreto",
	"secta",
	"sed",
	"seguir",
	"seis",
	"sello",
	"selva",
	"semana",
	"semilla",
	"senda",
	"sensor",
	"senal",
	"senor",
	"separar",
	"sepia",
	"sequia",
	"ser",
	"serie",
	"sermon",
	"servir",
	"sesenta",
	"sesion",
	"seta",
	"setenta",
	"severo",
	"sexo",
	"sexto",
	"sidra",
	"siesta",
	"siete",
	"siglo",
	"signo",
	"silaba",
	"silbar",
	"silencio",
	"silla",
	"simbolo",
	"simio",
	"sirena",
	"sistema",
	"sitio",
	"situar",
	"sobre",
	"socio",
	"sodio",
	"sol",
	"solapa",
	"soldado",
	"soledad",
	"solido",
	"soltar",
	"solucion",
	"sombra",
	"sondeo",
	"sonido",
	"sonoro",
	"sonrisa",
	"sopa",
	"soplar",
	"soporte",
	"sordo",
	"sorpresa",
	"sorteo",
	"sosten",
	"sotano",
	"suave",
	"subir",
	"suceso",
	"sudor",
	"suegra",
	"suelo",
	"sueno",
	"suerte",
	"sufrir",
	"sujeto",
	"sultan",
	"sumar",
	"superar",
	"suplir",
	"suponer",
	"supremo",
	"sur",
	"surco",
	"sureno",
	"surgir",
	"susto",
	"sutil",
	"tabaco",
	"tabique",
	"tabla",
	"tabu",
	"taco",
	"tacto",
	"tajo",
	"talar",
	"talco",
	"talento",
	"talla",
	"talon",
	"tamano",
	"tambor",
	"tango",
	"tanque",
	"tapa",
	"tapete",
	"tapia",
	"tapon",
	"taquilla",
	"tarde",
	"tarea",
	"tarifa",
	"tarjeta",
	"tarot",
	"tarro",
	"tarta",
	"tatuaje",
	"tauro",
	"taza",
	"tazon",
	"teatro",
	"techo",
	"tecla",
	"tecnica",
	"tejado",
	"tejer",
	"tejido",
	"tela",
	"telefono",
	"tema",
	"temor",
	"templo",
	"tenaz",
	"tender",
	"tener",
	"tenis",
	"tenso",
	"teoria",
	"terapia",
	"terco",
	"termino",
	"ternura",
	"terror",
	"tesis",
	"tesoro",
	"testigo",
	"tetera",
	"texto",
	"tez",
	"tibio",
	"tiburon",
	"tiempo",
	"tienda",
	"tierra",
	"tieso",
	"tigre",
	"tijera",
	"tilde",
	"timbre",
	"timido",
	"timo",
	"tinta",
	"tio",
	"tipico",
	"tipo",
	"tira",
	"tiron",
	"titan",
	"titere",
	"titulo",
	"tiza",
	"toalla",
	"tobillo",
	"tocar",
	"tocino",
	"todo",
	"toga",
	"toldo",
	"tomar",
	"tono",
	"tonto",
	"topar",
	"tope",
	"toque",
	"torax",
	"torero",
	"tormenta",
	"torneo",
	"toro",
	"torpedo",
	"torre",
	"torso",
	"tortuga",
	"tos",
	"tosco",
	"toser",
	"toxico",
	"trabajo",
	"tractor",
	"traer",
	"trafico",
	"trago",
	"traje",
	"tramo",
	"trance",
	"trato",
	"trauma",
	"trazar",
	"trebol",
	"tregua",
	"treinta",
	"tren",
	"trepar",
	"tres",
	"tribu",
	"trigo",
	"tripa",
	"triste",
	"triunfo",
	"trofeo",
	"trompa",
	"tronco",
	"tropa",
	"trote",
	"trozo",
	"truco",
	"trueno",
	"trufa",
	"tuberia",
	"tubo",
	"tuerto",
	"tumba",
	"tumor",
	"tunel",
	"tunica",
	"turbina",
	"turismo",
	"turno",
	"tutor",
	"ubicar",
	"ulcera",
	"umbral",
	"unidad",
	"unir",
	"universo",
	"uno",
	"untar",
	"una",
	"urbano",
	"urbe",
	"urgente",
	"urna",
	"usar",
	"usuario",
	"util",
	"utopia",
	"uva",
	"vaca",
	"vacio",
	"vacuna",
	"vagar",
	"vago",
	"vaina",
	"vajilla",
	"vale",
	"valido",
	"valle",
	"valor",
	"valvula",
	"vampiro",
	"vara",
	"variar",
	"varon",
	"vaso",
	"vecino",
	"vector",
	"vehiculo",
	"veinte",
	"vejez",
	"vela",
	"velero",
	"veloz",
	"vena",
	"vencer",
	"venda",
	"veneno",
	"vengar",
	"venir",
	"venta",
	"venus",
	"ver",
	"verano",
	"verbo",
	"verde",
	"vereda",
	"verja",
	"verso",
	"verter",
	"via",
	"viaje",
	"vibrar",
	"vicio",
	"victima",
	"vida",
	"video",
	"vidrio",
	"viejo",
	"viernes",
	"vigor",
	"vil",
	"villa",
	"vinagre",
	"vino",
	"vinedo",
	"violin",
	"viral",
	"virgo",
	"virtud",
	"visor",
	"vispera",
	"vista",
	"vitamina",
	"viudo",
	"vivaz",
	"vivero",
	"vivir",
	"vivo",
	"volcan",
	"volumen",
	"volver",
	"voraz",
	"votar",
	"voto",
	"voz",
	"vuelo",
	"vulgar",
	"yacer",
	"yate",
	"yegua",
	"yema",
	"yerno",
	"yeso",
	"yodo",
	"yoga",
	"yogur",
	"zafiro",
	"zanja",
	"zapato",
	"zarza",
	"zona",
	"zorro",
	"zumo",
	"zurdo"
];

var require$$7 = [
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	""
];

var require$$8 = [
	"abacate",
	"abaixo",
	"abalar",
	"abater",
	"abduzir",
	"abelha",
	"aberto",
	"abismo",
	"abotoar",
	"abranger",
	"abreviar",
	"abrigar",
	"abrupto",
	"absinto",
	"absoluto",
	"absurdo",
	"abutre",
	"acabado",
	"acalmar",
	"acampar",
	"acanhar",
	"acaso",
	"aceitar",
	"acelerar",
	"acenar",
	"acervo",
	"acessar",
	"acetona",
	"achatar",
	"acidez",
	"acima",
	"acionado",
	"acirrar",
	"aclamar",
	"aclive",
	"acolhida",
	"acomodar",
	"acoplar",
	"acordar",
	"acumular",
	"acusador",
	"adaptar",
	"adega",
	"adentro",
	"adepto",
	"adequar",
	"aderente",
	"adesivo",
	"adeus",
	"adiante",
	"aditivo",
	"adjetivo",
	"adjunto",
	"admirar",
	"adorar",
	"adquirir",
	"adubo",
	"adverso",
	"advogado",
	"aeronave",
	"afastar",
	"aferir",
	"afetivo",
	"afinador",
	"afivelar",
	"aflito",
	"afluente",
	"afrontar",
	"agachar",
	"agarrar",
	"agasalho",
	"agenciar",
	"agilizar",
	"agiota",
	"agitado",
	"agora",
	"agradar",
	"agreste",
	"agrupar",
	"aguardar",
	"agulha",
	"ajoelhar",
	"ajudar",
	"ajustar",
	"alameda",
	"alarme",
	"alastrar",
	"alavanca",
	"albergue",
	"albino",
	"alcatra",
	"aldeia",
	"alecrim",
	"alegria",
	"alertar",
	"alface",
	"alfinete",
	"algum",
	"alheio",
	"aliar",
	"alicate",
	"alienar",
	"alinhar",
	"aliviar",
	"almofada",
	"alocar",
	"alpiste",
	"alterar",
	"altitude",
	"alucinar",
	"alugar",
	"aluno",
	"alusivo",
	"alvo",
	"amaciar",
	"amador",
	"amarelo",
	"amassar",
	"ambas",
	"ambiente",
	"ameixa",
	"amenizar",
	"amido",
	"amistoso",
	"amizade",
	"amolador",
	"amontoar",
	"amoroso",
	"amostra",
	"amparar",
	"ampliar",
	"ampola",
	"anagrama",
	"analisar",
	"anarquia",
	"anatomia",
	"andaime",
	"anel",
	"anexo",
	"angular",
	"animar",
	"anjo",
	"anomalia",
	"anotado",
	"ansioso",
	"anterior",
	"anuidade",
	"anunciar",
	"anzol",
	"apagador",
	"apalpar",
	"apanhado",
	"apego",
	"apelido",
	"apertada",
	"apesar",
	"apetite",
	"apito",
	"aplauso",
	"aplicada",
	"apoio",
	"apontar",
	"aposta",
	"aprendiz",
	"aprovar",
	"aquecer",
	"arame",
	"aranha",
	"arara",
	"arcada",
	"ardente",
	"areia",
	"arejar",
	"arenito",
	"aresta",
	"argiloso",
	"argola",
	"arma",
	"arquivo",
	"arraial",
	"arrebate",
	"arriscar",
	"arroba",
	"arrumar",
	"arsenal",
	"arterial",
	"artigo",
	"arvoredo",
	"asfaltar",
	"asilado",
	"aspirar",
	"assador",
	"assinar",
	"assoalho",
	"assunto",
	"astral",
	"atacado",
	"atadura",
	"atalho",
	"atarefar",
	"atear",
	"atender",
	"aterro",
	"ateu",
	"atingir",
	"atirador",
	"ativo",
	"atoleiro",
	"atracar",
	"atrevido",
	"atriz",
	"atual",
	"atum",
	"auditor",
	"aumentar",
	"aura",
	"aurora",
	"autismo",
	"autoria",
	"autuar",
	"avaliar",
	"avante",
	"avaria",
	"avental",
	"avesso",
	"aviador",
	"avisar",
	"avulso",
	"axila",
	"azarar",
	"azedo",
	"azeite",
	"azulejo",
	"babar",
	"babosa",
	"bacalhau",
	"bacharel",
	"bacia",
	"bagagem",
	"baiano",
	"bailar",
	"baioneta",
	"bairro",
	"baixista",
	"bajular",
	"baleia",
	"baliza",
	"balsa",
	"banal",
	"bandeira",
	"banho",
	"banir",
	"banquete",
	"barato",
	"barbado",
	"baronesa",
	"barraca",
	"barulho",
	"baseado",
	"bastante",
	"batata",
	"batedor",
	"batida",
	"batom",
	"batucar",
	"baunilha",
	"beber",
	"beijo",
	"beirada",
	"beisebol",
	"beldade",
	"beleza",
	"belga",
	"beliscar",
	"bendito",
	"bengala",
	"benzer",
	"berimbau",
	"berlinda",
	"berro",
	"besouro",
	"bexiga",
	"bezerro",
	"bico",
	"bicudo",
	"bienal",
	"bifocal",
	"bifurcar",
	"bigorna",
	"bilhete",
	"bimestre",
	"bimotor",
	"biologia",
	"biombo",
	"biosfera",
	"bipolar",
	"birrento",
	"biscoito",
	"bisneto",
	"bispo",
	"bissexto",
	"bitola",
	"bizarro",
	"blindado",
	"bloco",
	"bloquear",
	"boato",
	"bobagem",
	"bocado",
	"bocejo",
	"bochecha",
	"boicotar",
	"bolada",
	"boletim",
	"bolha",
	"bolo",
	"bombeiro",
	"bonde",
	"boneco",
	"bonita",
	"borbulha",
	"borda",
	"boreal",
	"borracha",
	"bovino",
	"boxeador",
	"branco",
	"brasa",
	"braveza",
	"breu",
	"briga",
	"brilho",
	"brincar",
	"broa",
	"brochura",
	"bronzear",
	"broto",
	"bruxo",
	"bucha",
	"budismo",
	"bufar",
	"bule",
	"buraco",
	"busca",
	"busto",
	"buzina",
	"cabana",
	"cabelo",
	"cabide",
	"cabo",
	"cabrito",
	"cacau",
	"cacetada",
	"cachorro",
	"cacique",
	"cadastro",
	"cadeado",
	"cafezal",
	"caiaque",
	"caipira",
	"caixote",
	"cajado",
	"caju",
	"calafrio",
	"calcular",
	"caldeira",
	"calibrar",
	"calmante",
	"calota",
	"camada",
	"cambista",
	"camisa",
	"camomila",
	"campanha",
	"camuflar",
	"canavial",
	"cancelar",
	"caneta",
	"canguru",
	"canhoto",
	"canivete",
	"canoa",
	"cansado",
	"cantar",
	"canudo",
	"capacho",
	"capela",
	"capinar",
	"capotar",
	"capricho",
	"captador",
	"capuz",
	"caracol",
	"carbono",
	"cardeal",
	"careca",
	"carimbar",
	"carneiro",
	"carpete",
	"carreira",
	"cartaz",
	"carvalho",
	"casaco",
	"casca",
	"casebre",
	"castelo",
	"casulo",
	"catarata",
	"cativar",
	"caule",
	"causador",
	"cautelar",
	"cavalo",
	"caverna",
	"cebola",
	"cedilha",
	"cegonha",
	"celebrar",
	"celular",
	"cenoura",
	"censo",
	"centeio",
	"cercar",
	"cerrado",
	"certeiro",
	"cerveja",
	"cetim",
	"cevada",
	"chacota",
	"chaleira",
	"chamado",
	"chapada",
	"charme",
	"chatice",
	"chave",
	"chefe",
	"chegada",
	"cheiro",
	"cheque",
	"chicote",
	"chifre",
	"chinelo",
	"chocalho",
	"chover",
	"chumbo",
	"chutar",
	"chuva",
	"cicatriz",
	"ciclone",
	"cidade",
	"cidreira",
	"ciente",
	"cigana",
	"cimento",
	"cinto",
	"cinza",
	"ciranda",
	"circuito",
	"cirurgia",
	"citar",
	"clareza",
	"clero",
	"clicar",
	"clone",
	"clube",
	"coado",
	"coagir",
	"cobaia",
	"cobertor",
	"cobrar",
	"cocada",
	"coelho",
	"coentro",
	"coeso",
	"cogumelo",
	"coibir",
	"coifa",
	"coiote",
	"colar",
	"coleira",
	"colher",
	"colidir",
	"colmeia",
	"colono",
	"coluna",
	"comando",
	"combinar",
	"comentar",
	"comitiva",
	"comover",
	"complexo",
	"comum",
	"concha",
	"condor",
	"conectar",
	"confuso",
	"congelar",
	"conhecer",
	"conjugar",
	"consumir",
	"contrato",
	"convite",
	"cooperar",
	"copeiro",
	"copiador",
	"copo",
	"coquetel",
	"coragem",
	"cordial",
	"corneta",
	"coronha",
	"corporal",
	"correio",
	"cortejo",
	"coruja",
	"corvo",
	"cosseno",
	"costela",
	"cotonete",
	"couro",
	"couve",
	"covil",
	"cozinha",
	"cratera",
	"cravo",
	"creche",
	"credor",
	"creme",
	"crer",
	"crespo",
	"criada",
	"criminal",
	"crioulo",
	"crise",
	"criticar",
	"crosta",
	"crua",
	"cruzeiro",
	"cubano",
	"cueca",
	"cuidado",
	"cujo",
	"culatra",
	"culminar",
	"culpar",
	"cultura",
	"cumprir",
	"cunhado",
	"cupido",
	"curativo",
	"curral",
	"cursar",
	"curto",
	"cuspir",
	"custear",
	"cutelo",
	"damasco",
	"datar",
	"debater",
	"debitar",
	"deboche",
	"debulhar",
	"decalque",
	"decimal",
	"declive",
	"decote",
	"decretar",
	"dedal",
	"dedicado",
	"deduzir",
	"defesa",
	"defumar",
	"degelo",
	"degrau",
	"degustar",
	"deitado",
	"deixar",
	"delator",
	"delegado",
	"delinear",
	"delonga",
	"demanda",
	"demitir",
	"demolido",
	"dentista",
	"depenado",
	"depilar",
	"depois",
	"depressa",
	"depurar",
	"deriva",
	"derramar",
	"desafio",
	"desbotar",
	"descanso",
	"desenho",
	"desfiado",
	"desgaste",
	"desigual",
	"deslize",
	"desmamar",
	"desova",
	"despesa",
	"destaque",
	"desviar",
	"detalhar",
	"detentor",
	"detonar",
	"detrito",
	"deusa",
	"dever",
	"devido",
	"devotado",
	"dezena",
	"diagrama",
	"dialeto",
	"didata",
	"difuso",
	"digitar",
	"dilatado",
	"diluente",
	"diminuir",
	"dinastia",
	"dinheiro",
	"diocese",
	"direto",
	"discreta",
	"disfarce",
	"disparo",
	"disquete",
	"dissipar",
	"distante",
	"ditador",
	"diurno",
	"diverso",
	"divisor",
	"divulgar",
	"dizer",
	"dobrador",
	"dolorido",
	"domador",
	"dominado",
	"donativo",
	"donzela",
	"dormente",
	"dorsal",
	"dosagem",
	"dourado",
	"doutor",
	"drenagem",
	"drible",
	"drogaria",
	"duelar",
	"duende",
	"dueto",
	"duplo",
	"duquesa",
	"durante",
	"duvidoso",
	"eclodir",
	"ecoar",
	"ecologia",
	"edificar",
	"edital",
	"educado",
	"efeito",
	"efetivar",
	"ejetar",
	"elaborar",
	"eleger",
	"eleitor",
	"elenco",
	"elevador",
	"eliminar",
	"elogiar",
	"embargo",
	"embolado",
	"embrulho",
	"embutido",
	"emenda",
	"emergir",
	"emissor",
	"empatia",
	"empenho",
	"empinado",
	"empolgar",
	"emprego",
	"empurrar",
	"emulador",
	"encaixe",
	"encenado",
	"enchente",
	"encontro",
	"endeusar",
	"endossar",
	"enfaixar",
	"enfeite",
	"enfim",
	"engajado",
	"engenho",
	"englobar",
	"engomado",
	"engraxar",
	"enguia",
	"enjoar",
	"enlatar",
	"enquanto",
	"enraizar",
	"enrolado",
	"enrugar",
	"ensaio",
	"enseada",
	"ensino",
	"ensopado",
	"entanto",
	"enteado",
	"entidade",
	"entortar",
	"entrada",
	"entulho",
	"envergar",
	"enviado",
	"envolver",
	"enxame",
	"enxerto",
	"enxofre",
	"enxuto",
	"epiderme",
	"equipar",
	"ereto",
	"erguido",
	"errata",
	"erva",
	"ervilha",
	"esbanjar",
	"esbelto",
	"escama",
	"escola",
	"escrita",
	"escuta",
	"esfinge",
	"esfolar",
	"esfregar",
	"esfumado",
	"esgrima",
	"esmalte",
	"espanto",
	"espelho",
	"espiga",
	"esponja",
	"espreita",
	"espumar",
	"esquerda",
	"estaca",
	"esteira",
	"esticar",
	"estofado",
	"estrela",
	"estudo",
	"esvaziar",
	"etanol",
	"etiqueta",
	"euforia",
	"europeu",
	"evacuar",
	"evaporar",
	"evasivo",
	"eventual",
	"evidente",
	"evoluir",
	"exagero",
	"exalar",
	"examinar",
	"exato",
	"exausto",
	"excesso",
	"excitar",
	"exclamar",
	"executar",
	"exemplo",
	"exibir",
	"exigente",
	"exonerar",
	"expandir",
	"expelir",
	"expirar",
	"explanar",
	"exposto",
	"expresso",
	"expulsar",
	"externo",
	"extinto",
	"extrato",
	"fabricar",
	"fabuloso",
	"faceta",
	"facial",
	"fada",
	"fadiga",
	"faixa",
	"falar",
	"falta",
	"familiar",
	"fandango",
	"fanfarra",
	"fantoche",
	"fardado",
	"farelo",
	"farinha",
	"farofa",
	"farpa",
	"fartura",
	"fatia",
	"fator",
	"favorita",
	"faxina",
	"fazenda",
	"fechado",
	"feijoada",
	"feirante",
	"felino",
	"feminino",
	"fenda",
	"feno",
	"fera",
	"feriado",
	"ferrugem",
	"ferver",
	"festejar",
	"fetal",
	"feudal",
	"fiapo",
	"fibrose",
	"ficar",
	"ficheiro",
	"figurado",
	"fileira",
	"filho",
	"filme",
	"filtrar",
	"firmeza",
	"fisgada",
	"fissura",
	"fita",
	"fivela",
	"fixador",
	"fixo",
	"flacidez",
	"flamingo",
	"flanela",
	"flechada",
	"flora",
	"flutuar",
	"fluxo",
	"focal",
	"focinho",
	"fofocar",
	"fogo",
	"foguete",
	"foice",
	"folgado",
	"folheto",
	"forjar",
	"formiga",
	"forno",
	"forte",
	"fosco",
	"fossa",
	"fragata",
	"fralda",
	"frango",
	"frasco",
	"fraterno",
	"freira",
	"frente",
	"fretar",
	"frieza",
	"friso",
	"fritura",
	"fronha",
	"frustrar",
	"fruteira",
	"fugir",
	"fulano",
	"fuligem",
	"fundar",
	"fungo",
	"funil",
	"furador",
	"furioso",
	"futebol",
	"gabarito",
	"gabinete",
	"gado",
	"gaiato",
	"gaiola",
	"gaivota",
	"galega",
	"galho",
	"galinha",
	"galocha",
	"ganhar",
	"garagem",
	"garfo",
	"gargalo",
	"garimpo",
	"garoupa",
	"garrafa",
	"gasoduto",
	"gasto",
	"gata",
	"gatilho",
	"gaveta",
	"gazela",
	"gelado",
	"geleia",
	"gelo",
	"gemada",
	"gemer",
	"gemido",
	"generoso",
	"gengiva",
	"genial",
	"genoma",
	"genro",
	"geologia",
	"gerador",
	"germinar",
	"gesso",
	"gestor",
	"ginasta",
	"gincana",
	"gingado",
	"girafa",
	"girino",
	"glacial",
	"glicose",
	"global",
	"glorioso",
	"goela",
	"goiaba",
	"golfe",
	"golpear",
	"gordura",
	"gorjeta",
	"gorro",
	"gostoso",
	"goteira",
	"governar",
	"gracejo",
	"gradual",
	"grafite",
	"gralha",
	"grampo",
	"granada",
	"gratuito",
	"graveto",
	"graxa",
	"grego",
	"grelhar",
	"greve",
	"grilo",
	"grisalho",
	"gritaria",
	"grosso",
	"grotesco",
	"grudado",
	"grunhido",
	"gruta",
	"guache",
	"guarani",
	"guaxinim",
	"guerrear",
	"guiar",
	"guincho",
	"guisado",
	"gula",
	"guloso",
	"guru",
	"habitar",
	"harmonia",
	"haste",
	"haver",
	"hectare",
	"herdar",
	"heresia",
	"hesitar",
	"hiato",
	"hibernar",
	"hidratar",
	"hiena",
	"hino",
	"hipismo",
	"hipnose",
	"hipoteca",
	"hoje",
	"holofote",
	"homem",
	"honesto",
	"honrado",
	"hormonal",
	"hospedar",
	"humorado",
	"iate",
	"ideia",
	"idoso",
	"ignorado",
	"igreja",
	"iguana",
	"ileso",
	"ilha",
	"iludido",
	"iluminar",
	"ilustrar",
	"imagem",
	"imediato",
	"imenso",
	"imersivo",
	"iminente",
	"imitador",
	"imortal",
	"impacto",
	"impedir",
	"implante",
	"impor",
	"imprensa",
	"impune",
	"imunizar",
	"inalador",
	"inapto",
	"inativo",
	"incenso",
	"inchar",
	"incidir",
	"incluir",
	"incolor",
	"indeciso",
	"indireto",
	"indutor",
	"ineficaz",
	"inerente",
	"infantil",
	"infestar",
	"infinito",
	"inflamar",
	"informal",
	"infrator",
	"ingerir",
	"inibido",
	"inicial",
	"inimigo",
	"injetar",
	"inocente",
	"inodoro",
	"inovador",
	"inox",
	"inquieto",
	"inscrito",
	"inseto",
	"insistir",
	"inspetor",
	"instalar",
	"insulto",
	"intacto",
	"integral",
	"intimar",
	"intocado",
	"intriga",
	"invasor",
	"inverno",
	"invicto",
	"invocar",
	"iogurte",
	"iraniano",
	"ironizar",
	"irreal",
	"irritado",
	"isca",
	"isento",
	"isolado",
	"isqueiro",
	"italiano",
	"janeiro",
	"jangada",
	"janta",
	"jararaca",
	"jardim",
	"jarro",
	"jasmim",
	"jato",
	"javali",
	"jazida",
	"jejum",
	"joaninha",
	"joelhada",
	"jogador",
	"joia",
	"jornal",
	"jorrar",
	"jovem",
	"juba",
	"judeu",
	"judoca",
	"juiz",
	"julgador",
	"julho",
	"jurado",
	"jurista",
	"juro",
	"justa",
	"labareda",
	"laboral",
	"lacre",
	"lactante",
	"ladrilho",
	"lagarta",
	"lagoa",
	"laje",
	"lamber",
	"lamentar",
	"laminar",
	"lampejo",
	"lanche",
	"lapidar",
	"lapso",
	"laranja",
	"lareira",
	"largura",
	"lasanha",
	"lastro",
	"lateral",
	"latido",
	"lavanda",
	"lavoura",
	"lavrador",
	"laxante",
	"lazer",
	"lealdade",
	"lebre",
	"legado",
	"legendar",
	"legista",
	"leigo",
	"leiloar",
	"leitura",
	"lembrete",
	"leme",
	"lenhador",
	"lentilha",
	"leoa",
	"lesma",
	"leste",
	"letivo",
	"letreiro",
	"levar",
	"leveza",
	"levitar",
	"liberal",
	"libido",
	"liderar",
	"ligar",
	"ligeiro",
	"limitar",
	"limoeiro",
	"limpador",
	"linda",
	"linear",
	"linhagem",
	"liquidez",
	"listagem",
	"lisura",
	"litoral",
	"livro",
	"lixa",
	"lixeira",
	"locador",
	"locutor",
	"lojista",
	"lombo",
	"lona",
	"longe",
	"lontra",
	"lorde",
	"lotado",
	"loteria",
	"loucura",
	"lousa",
	"louvar",
	"luar",
	"lucidez",
	"lucro",
	"luneta",
	"lustre",
	"lutador",
	"luva",
	"macaco",
	"macete",
	"machado",
	"macio",
	"madeira",
	"madrinha",
	"magnata",
	"magreza",
	"maior",
	"mais",
	"malandro",
	"malha",
	"malote",
	"maluco",
	"mamilo",
	"mamoeiro",
	"mamute",
	"manada",
	"mancha",
	"mandato",
	"manequim",
	"manhoso",
	"manivela",
	"manobrar",
	"mansa",
	"manter",
	"manusear",
	"mapeado",
	"maquinar",
	"marcador",
	"maresia",
	"marfim",
	"margem",
	"marinho",
	"marmita",
	"maroto",
	"marquise",
	"marreco",
	"martelo",
	"marujo",
	"mascote",
	"masmorra",
	"massagem",
	"mastigar",
	"matagal",
	"materno",
	"matinal",
	"matutar",
	"maxilar",
	"medalha",
	"medida",
	"medusa",
	"megafone",
	"meiga",
	"melancia",
	"melhor",
	"membro",
	"memorial",
	"menino",
	"menos",
	"mensagem",
	"mental",
	"merecer",
	"mergulho",
	"mesada",
	"mesclar",
	"mesmo",
	"mesquita",
	"mestre",
	"metade",
	"meteoro",
	"metragem",
	"mexer",
	"mexicano",
	"micro",
	"migalha",
	"migrar",
	"milagre",
	"milenar",
	"milhar",
	"mimado",
	"minerar",
	"minhoca",
	"ministro",
	"minoria",
	"miolo",
	"mirante",
	"mirtilo",
	"misturar",
	"mocidade",
	"moderno",
	"modular",
	"moeda",
	"moer",
	"moinho",
	"moita",
	"moldura",
	"moleza",
	"molho",
	"molinete",
	"molusco",
	"montanha",
	"moqueca",
	"morango",
	"morcego",
	"mordomo",
	"morena",
	"mosaico",
	"mosquete",
	"mostarda",
	"motel",
	"motim",
	"moto",
	"motriz",
	"muda",
	"muito",
	"mulata",
	"mulher",
	"multar",
	"mundial",
	"munido",
	"muralha",
	"murcho",
	"muscular",
	"museu",
	"musical",
	"nacional",
	"nadador",
	"naja",
	"namoro",
	"narina",
	"narrado",
	"nascer",
	"nativa",
	"natureza",
	"navalha",
	"navegar",
	"navio",
	"neblina",
	"nebuloso",
	"negativa",
	"negociar",
	"negrito",
	"nervoso",
	"neta",
	"neural",
	"nevasca",
	"nevoeiro",
	"ninar",
	"ninho",
	"nitidez",
	"nivelar",
	"nobreza",
	"noite",
	"noiva",
	"nomear",
	"nominal",
	"nordeste",
	"nortear",
	"notar",
	"noticiar",
	"noturno",
	"novelo",
	"novilho",
	"novo",
	"nublado",
	"nudez",
	"numeral",
	"nupcial",
	"nutrir",
	"nuvem",
	"obcecado",
	"obedecer",
	"objetivo",
	"obrigado",
	"obscuro",
	"obstetra",
	"obter",
	"obturar",
	"ocidente",
	"ocioso",
	"ocorrer",
	"oculista",
	"ocupado",
	"ofegante",
	"ofensiva",
	"oferenda",
	"oficina",
	"ofuscado",
	"ogiva",
	"olaria",
	"oleoso",
	"olhar",
	"oliveira",
	"ombro",
	"omelete",
	"omisso",
	"omitir",
	"ondulado",
	"oneroso",
	"ontem",
	"opcional",
	"operador",
	"oponente",
	"oportuno",
	"oposto",
	"orar",
	"orbitar",
	"ordem",
	"ordinal",
	"orfanato",
	"orgasmo",
	"orgulho",
	"oriental",
	"origem",
	"oriundo",
	"orla",
	"ortodoxo",
	"orvalho",
	"oscilar",
	"ossada",
	"osso",
	"ostentar",
	"otimismo",
	"ousadia",
	"outono",
	"outubro",
	"ouvido",
	"ovelha",
	"ovular",
	"oxidar",
	"oxigenar",
	"pacato",
	"paciente",
	"pacote",
	"pactuar",
	"padaria",
	"padrinho",
	"pagar",
	"pagode",
	"painel",
	"pairar",
	"paisagem",
	"palavra",
	"palestra",
	"palheta",
	"palito",
	"palmada",
	"palpitar",
	"pancada",
	"panela",
	"panfleto",
	"panqueca",
	"pantanal",
	"papagaio",
	"papelada",
	"papiro",
	"parafina",
	"parcial",
	"pardal",
	"parede",
	"partida",
	"pasmo",
	"passado",
	"pastel",
	"patamar",
	"patente",
	"patinar",
	"patrono",
	"paulada",
	"pausar",
	"peculiar",
	"pedalar",
	"pedestre",
	"pediatra",
	"pedra",
	"pegada",
	"peitoral",
	"peixe",
	"pele",
	"pelicano",
	"penca",
	"pendurar",
	"peneira",
	"penhasco",
	"pensador",
	"pente",
	"perceber",
	"perfeito",
	"pergunta",
	"perito",
	"permitir",
	"perna",
	"perplexo",
	"persiana",
	"pertence",
	"peruca",
	"pescado",
	"pesquisa",
	"pessoa",
	"petiscar",
	"piada",
	"picado",
	"piedade",
	"pigmento",
	"pilastra",
	"pilhado",
	"pilotar",
	"pimenta",
	"pincel",
	"pinguim",
	"pinha",
	"pinote",
	"pintar",
	"pioneiro",
	"pipoca",
	"piquete",
	"piranha",
	"pires",
	"pirueta",
	"piscar",
	"pistola",
	"pitanga",
	"pivete",
	"planta",
	"plaqueta",
	"platina",
	"plebeu",
	"plumagem",
	"pluvial",
	"pneu",
	"poda",
	"poeira",
	"poetisa",
	"polegada",
	"policiar",
	"poluente",
	"polvilho",
	"pomar",
	"pomba",
	"ponderar",
	"pontaria",
	"populoso",
	"porta",
	"possuir",
	"postal",
	"pote",
	"poupar",
	"pouso",
	"povoar",
	"praia",
	"prancha",
	"prato",
	"praxe",
	"prece",
	"predador",
	"prefeito",
	"premiar",
	"prensar",
	"preparar",
	"presilha",
	"pretexto",
	"prevenir",
	"prezar",
	"primata",
	"princesa",
	"prisma",
	"privado",
	"processo",
	"produto",
	"profeta",
	"proibido",
	"projeto",
	"prometer",
	"propagar",
	"prosa",
	"protetor",
	"provador",
	"publicar",
	"pudim",
	"pular",
	"pulmonar",
	"pulseira",
	"punhal",
	"punir",
	"pupilo",
	"pureza",
	"puxador",
	"quadra",
	"quantia",
	"quarto",
	"quase",
	"quebrar",
	"queda",
	"queijo",
	"quente",
	"querido",
	"quimono",
	"quina",
	"quiosque",
	"rabanada",
	"rabisco",
	"rachar",
	"racionar",
	"radial",
	"raiar",
	"rainha",
	"raio",
	"raiva",
	"rajada",
	"ralado",
	"ramal",
	"ranger",
	"ranhura",
	"rapadura",
	"rapel",
	"rapidez",
	"raposa",
	"raquete",
	"raridade",
	"rasante",
	"rascunho",
	"rasgar",
	"raspador",
	"rasteira",
	"rasurar",
	"ratazana",
	"ratoeira",
	"realeza",
	"reanimar",
	"reaver",
	"rebaixar",
	"rebelde",
	"rebolar",
	"recado",
	"recente",
	"recheio",
	"recibo",
	"recordar",
	"recrutar",
	"recuar",
	"rede",
	"redimir",
	"redonda",
	"reduzida",
	"reenvio",
	"refinar",
	"refletir",
	"refogar",
	"refresco",
	"refugiar",
	"regalia",
	"regime",
	"regra",
	"reinado",
	"reitor",
	"rejeitar",
	"relativo",
	"remador",
	"remendo",
	"remorso",
	"renovado",
	"reparo",
	"repelir",
	"repleto",
	"repolho",
	"represa",
	"repudiar",
	"requerer",
	"resenha",
	"resfriar",
	"resgatar",
	"residir",
	"resolver",
	"respeito",
	"ressaca",
	"restante",
	"resumir",
	"retalho",
	"reter",
	"retirar",
	"retomada",
	"retratar",
	"revelar",
	"revisor",
	"revolta",
	"riacho",
	"rica",
	"rigidez",
	"rigoroso",
	"rimar",
	"ringue",
	"risada",
	"risco",
	"risonho",
	"robalo",
	"rochedo",
	"rodada",
	"rodeio",
	"rodovia",
	"roedor",
	"roleta",
	"romano",
	"roncar",
	"rosado",
	"roseira",
	"rosto",
	"rota",
	"roteiro",
	"rotina",
	"rotular",
	"rouco",
	"roupa",
	"roxo",
	"rubro",
	"rugido",
	"rugoso",
	"ruivo",
	"rumo",
	"rupestre",
	"russo",
	"sabor",
	"saciar",
	"sacola",
	"sacudir",
	"sadio",
	"safira",
	"saga",
	"sagrada",
	"saibro",
	"salada",
	"saleiro",
	"salgado",
	"saliva",
	"salpicar",
	"salsicha",
	"saltar",
	"salvador",
	"sambar",
	"samurai",
	"sanar",
	"sanfona",
	"sangue",
	"sanidade",
	"sapato",
	"sarda",
	"sargento",
	"sarjeta",
	"saturar",
	"saudade",
	"saxofone",
	"sazonal",
	"secar",
	"secular",
	"seda",
	"sedento",
	"sediado",
	"sedoso",
	"sedutor",
	"segmento",
	"segredo",
	"segundo",
	"seiva",
	"seleto",
	"selvagem",
	"semanal",
	"semente",
	"senador",
	"senhor",
	"sensual",
	"sentado",
	"separado",
	"sereia",
	"seringa",
	"serra",
	"servo",
	"setembro",
	"setor",
	"sigilo",
	"silhueta",
	"silicone",
	"simetria",
	"simpatia",
	"simular",
	"sinal",
	"sincero",
	"singular",
	"sinopse",
	"sintonia",
	"sirene",
	"siri",
	"situado",
	"soberano",
	"sobra",
	"socorro",
	"sogro",
	"soja",
	"solda",
	"soletrar",
	"solteiro",
	"sombrio",
	"sonata",
	"sondar",
	"sonegar",
	"sonhador",
	"sono",
	"soprano",
	"soquete",
	"sorrir",
	"sorteio",
	"sossego",
	"sotaque",
	"soterrar",
	"sovado",
	"sozinho",
	"suavizar",
	"subida",
	"submerso",
	"subsolo",
	"subtrair",
	"sucata",
	"sucesso",
	"suco",
	"sudeste",
	"sufixo",
	"sugador",
	"sugerir",
	"sujeito",
	"sulfato",
	"sumir",
	"suor",
	"superior",
	"suplicar",
	"suposto",
	"suprimir",
	"surdina",
	"surfista",
	"surpresa",
	"surreal",
	"surtir",
	"suspiro",
	"sustento",
	"tabela",
	"tablete",
	"tabuada",
	"tacho",
	"tagarela",
	"talher",
	"talo",
	"talvez",
	"tamanho",
	"tamborim",
	"tampa",
	"tangente",
	"tanto",
	"tapar",
	"tapioca",
	"tardio",
	"tarefa",
	"tarja",
	"tarraxa",
	"tatuagem",
	"taurino",
	"taxativo",
	"taxista",
	"teatral",
	"tecer",
	"tecido",
	"teclado",
	"tedioso",
	"teia",
	"teimar",
	"telefone",
	"telhado",
	"tempero",
	"tenente",
	"tensor",
	"tentar",
	"termal",
	"terno",
	"terreno",
	"tese",
	"tesoura",
	"testado",
	"teto",
	"textura",
	"texugo",
	"tiara",
	"tigela",
	"tijolo",
	"timbrar",
	"timidez",
	"tingido",
	"tinteiro",
	"tiragem",
	"titular",
	"toalha",
	"tocha",
	"tolerar",
	"tolice",
	"tomada",
	"tomilho",
	"tonel",
	"tontura",
	"topete",
	"tora",
	"torcido",
	"torneio",
	"torque",
	"torrada",
	"torto",
	"tostar",
	"touca",
	"toupeira",
	"toxina",
	"trabalho",
	"tracejar",
	"tradutor",
	"trafegar",
	"trajeto",
	"trama",
	"trancar",
	"trapo",
	"traseiro",
	"tratador",
	"travar",
	"treino",
	"tremer",
	"trepidar",
	"trevo",
	"triagem",
	"tribo",
	"triciclo",
	"tridente",
	"trilogia",
	"trindade",
	"triplo",
	"triturar",
	"triunfal",
	"trocar",
	"trombeta",
	"trova",
	"trunfo",
	"truque",
	"tubular",
	"tucano",
	"tudo",
	"tulipa",
	"tupi",
	"turbo",
	"turma",
	"turquesa",
	"tutelar",
	"tutorial",
	"uivar",
	"umbigo",
	"unha",
	"unidade",
	"uniforme",
	"urologia",
	"urso",
	"urtiga",
	"urubu",
	"usado",
	"usina",
	"usufruir",
	"vacina",
	"vadiar",
	"vagaroso",
	"vaidoso",
	"vala",
	"valente",
	"validade",
	"valores",
	"vantagem",
	"vaqueiro",
	"varanda",
	"vareta",
	"varrer",
	"vascular",
	"vasilha",
	"vassoura",
	"vazar",
	"vazio",
	"veado",
	"vedar",
	"vegetar",
	"veicular",
	"veleiro",
	"velhice",
	"veludo",
	"vencedor",
	"vendaval",
	"venerar",
	"ventre",
	"verbal",
	"verdade",
	"vereador",
	"vergonha",
	"vermelho",
	"verniz",
	"versar",
	"vertente",
	"vespa",
	"vestido",
	"vetorial",
	"viaduto",
	"viagem",
	"viajar",
	"viatura",
	"vibrador",
	"videira",
	"vidraria",
	"viela",
	"viga",
	"vigente",
	"vigiar",
	"vigorar",
	"vilarejo",
	"vinco",
	"vinheta",
	"vinil",
	"violeta",
	"virada",
	"virtude",
	"visitar",
	"visto",
	"vitral",
	"viveiro",
	"vizinho",
	"voador",
	"voar",
	"vogal",
	"volante",
	"voleibol",
	"voltagem",
	"volumoso",
	"vontade",
	"vulto",
	"vuvuzela",
	"xadrez",
	"xarope",
	"xeque",
	"xeretar",
	"xerife",
	"xingar",
	"zangado",
	"zarpar",
	"zebu",
	"zelador",
	"zombar",
	"zoologia",
	"zumbido"
];

var require$$9 = [
	"abandon",
	"ability",
	"able",
	"about",
	"above",
	"absent",
	"absorb",
	"abstract",
	"absurd",
	"abuse",
	"access",
	"accident",
	"account",
	"accuse",
	"achieve",
	"acid",
	"acoustic",
	"acquire",
	"across",
	"act",
	"action",
	"actor",
	"actress",
	"actual",
	"adapt",
	"add",
	"addict",
	"address",
	"adjust",
	"admit",
	"adult",
	"advance",
	"advice",
	"aerobic",
	"affair",
	"afford",
	"afraid",
	"again",
	"age",
	"agent",
	"agree",
	"ahead",
	"aim",
	"air",
	"airport",
	"aisle",
	"alarm",
	"album",
	"alcohol",
	"alert",
	"alien",
	"all",
	"alley",
	"allow",
	"almost",
	"alone",
	"alpha",
	"already",
	"also",
	"alter",
	"always",
	"amateur",
	"amazing",
	"among",
	"amount",
	"amused",
	"analyst",
	"anchor",
	"ancient",
	"anger",
	"angle",
	"angry",
	"animal",
	"ankle",
	"announce",
	"annual",
	"another",
	"answer",
	"antenna",
	"antique",
	"anxiety",
	"any",
	"apart",
	"apology",
	"appear",
	"apple",
	"approve",
	"april",
	"arch",
	"arctic",
	"area",
	"arena",
	"argue",
	"arm",
	"armed",
	"armor",
	"army",
	"around",
	"arrange",
	"arrest",
	"arrive",
	"arrow",
	"art",
	"artefact",
	"artist",
	"artwork",
	"ask",
	"aspect",
	"assault",
	"asset",
	"assist",
	"assume",
	"asthma",
	"athlete",
	"atom",
	"attack",
	"attend",
	"attitude",
	"attract",
	"auction",
	"audit",
	"august",
	"aunt",
	"author",
	"auto",
	"autumn",
	"average",
	"avocado",
	"avoid",
	"awake",
	"aware",
	"away",
	"awesome",
	"awful",
	"awkward",
	"axis",
	"baby",
	"bachelor",
	"bacon",
	"badge",
	"bag",
	"balance",
	"balcony",
	"ball",
	"bamboo",
	"banana",
	"banner",
	"bar",
	"barely",
	"bargain",
	"barrel",
	"base",
	"basic",
	"basket",
	"battle",
	"beach",
	"bean",
	"beauty",
	"because",
	"become",
	"beef",
	"before",
	"begin",
	"behave",
	"behind",
	"believe",
	"below",
	"belt",
	"bench",
	"benefit",
	"best",
	"betray",
	"better",
	"between",
	"beyond",
	"bicycle",
	"bid",
	"bike",
	"bind",
	"biology",
	"bird",
	"birth",
	"bitter",
	"black",
	"blade",
	"blame",
	"blanket",
	"blast",
	"bleak",
	"bless",
	"blind",
	"blood",
	"blossom",
	"blouse",
	"blue",
	"blur",
	"blush",
	"board",
	"boat",
	"body",
	"boil",
	"bomb",
	"bone",
	"bonus",
	"book",
	"boost",
	"border",
	"boring",
	"borrow",
	"boss",
	"bottom",
	"bounce",
	"box",
	"boy",
	"bracket",
	"brain",
	"brand",
	"brass",
	"brave",
	"bread",
	"breeze",
	"brick",
	"bridge",
	"brief",
	"bright",
	"bring",
	"brisk",
	"broccoli",
	"broken",
	"bronze",
	"broom",
	"brother",
	"brown",
	"brush",
	"bubble",
	"buddy",
	"budget",
	"buffalo",
	"build",
	"bulb",
	"bulk",
	"bullet",
	"bundle",
	"bunker",
	"burden",
	"burger",
	"burst",
	"bus",
	"business",
	"busy",
	"butter",
	"buyer",
	"buzz",
	"cabbage",
	"cabin",
	"cable",
	"cactus",
	"cage",
	"cake",
	"call",
	"calm",
	"camera",
	"camp",
	"can",
	"canal",
	"cancel",
	"candy",
	"cannon",
	"canoe",
	"canvas",
	"canyon",
	"capable",
	"capital",
	"captain",
	"car",
	"carbon",
	"card",
	"cargo",
	"carpet",
	"carry",
	"cart",
	"case",
	"cash",
	"casino",
	"castle",
	"casual",
	"cat",
	"catalog",
	"catch",
	"category",
	"cattle",
	"caught",
	"cause",
	"caution",
	"cave",
	"ceiling",
	"celery",
	"cement",
	"census",
	"century",
	"cereal",
	"certain",
	"chair",
	"chalk",
	"champion",
	"change",
	"chaos",
	"chapter",
	"charge",
	"chase",
	"chat",
	"cheap",
	"check",
	"cheese",
	"chef",
	"cherry",
	"chest",
	"chicken",
	"chief",
	"child",
	"chimney",
	"choice",
	"choose",
	"chronic",
	"chuckle",
	"chunk",
	"churn",
	"cigar",
	"cinnamon",
	"circle",
	"citizen",
	"city",
	"civil",
	"claim",
	"clap",
	"clarify",
	"claw",
	"clay",
	"clean",
	"clerk",
	"clever",
	"click",
	"client",
	"cliff",
	"climb",
	"clinic",
	"clip",
	"clock",
	"clog",
	"close",
	"cloth",
	"cloud",
	"clown",
	"club",
	"clump",
	"cluster",
	"clutch",
	"coach",
	"coast",
	"coconut",
	"code",
	"coffee",
	"coil",
	"coin",
	"collect",
	"color",
	"column",
	"combine",
	"come",
	"comfort",
	"comic",
	"common",
	"company",
	"concert",
	"conduct",
	"confirm",
	"congress",
	"connect",
	"consider",
	"control",
	"convince",
	"cook",
	"cool",
	"copper",
	"copy",
	"coral",
	"core",
	"corn",
	"correct",
	"cost",
	"cotton",
	"couch",
	"country",
	"couple",
	"course",
	"cousin",
	"cover",
	"coyote",
	"crack",
	"cradle",
	"craft",
	"cram",
	"crane",
	"crash",
	"crater",
	"crawl",
	"crazy",
	"cream",
	"credit",
	"creek",
	"crew",
	"cricket",
	"crime",
	"crisp",
	"critic",
	"crop",
	"cross",
	"crouch",
	"crowd",
	"crucial",
	"cruel",
	"cruise",
	"crumble",
	"crunch",
	"crush",
	"cry",
	"crystal",
	"cube",
	"culture",
	"cup",
	"cupboard",
	"curious",
	"current",
	"curtain",
	"curve",
	"cushion",
	"custom",
	"cute",
	"cycle",
	"dad",
	"damage",
	"damp",
	"dance",
	"danger",
	"daring",
	"dash",
	"daughter",
	"dawn",
	"day",
	"deal",
	"debate",
	"debris",
	"decade",
	"december",
	"decide",
	"decline",
	"decorate",
	"decrease",
	"deer",
	"defense",
	"define",
	"defy",
	"degree",
	"delay",
	"deliver",
	"demand",
	"demise",
	"denial",
	"dentist",
	"deny",
	"depart",
	"depend",
	"deposit",
	"depth",
	"deputy",
	"derive",
	"describe",
	"desert",
	"design",
	"desk",
	"despair",
	"destroy",
	"detail",
	"detect",
	"develop",
	"device",
	"devote",
	"diagram",
	"dial",
	"diamond",
	"diary",
	"dice",
	"diesel",
	"diet",
	"differ",
	"digital",
	"dignity",
	"dilemma",
	"dinner",
	"dinosaur",
	"direct",
	"dirt",
	"disagree",
	"discover",
	"disease",
	"dish",
	"dismiss",
	"disorder",
	"display",
	"distance",
	"divert",
	"divide",
	"divorce",
	"dizzy",
	"doctor",
	"document",
	"dog",
	"doll",
	"dolphin",
	"domain",
	"donate",
	"donkey",
	"donor",
	"door",
	"dose",
	"double",
	"dove",
	"draft",
	"dragon",
	"drama",
	"drastic",
	"draw",
	"dream",
	"dress",
	"drift",
	"drill",
	"drink",
	"drip",
	"drive",
	"drop",
	"drum",
	"dry",
	"duck",
	"dumb",
	"dune",
	"during",
	"dust",
	"dutch",
	"duty",
	"dwarf",
	"dynamic",
	"eager",
	"eagle",
	"early",
	"earn",
	"earth",
	"easily",
	"east",
	"easy",
	"echo",
	"ecology",
	"economy",
	"edge",
	"edit",
	"educate",
	"effort",
	"egg",
	"eight",
	"either",
	"elbow",
	"elder",
	"electric",
	"elegant",
	"element",
	"elephant",
	"elevator",
	"elite",
	"else",
	"embark",
	"embody",
	"embrace",
	"emerge",
	"emotion",
	"employ",
	"empower",
	"empty",
	"enable",
	"enact",
	"end",
	"endless",
	"endorse",
	"enemy",
	"energy",
	"enforce",
	"engage",
	"engine",
	"enhance",
	"enjoy",
	"enlist",
	"enough",
	"enrich",
	"enroll",
	"ensure",
	"enter",
	"entire",
	"entry",
	"envelope",
	"episode",
	"equal",
	"equip",
	"era",
	"erase",
	"erode",
	"erosion",
	"error",
	"erupt",
	"escape",
	"essay",
	"essence",
	"estate",
	"eternal",
	"ethics",
	"evidence",
	"evil",
	"evoke",
	"evolve",
	"exact",
	"example",
	"excess",
	"exchange",
	"excite",
	"exclude",
	"excuse",
	"execute",
	"exercise",
	"exhaust",
	"exhibit",
	"exile",
	"exist",
	"exit",
	"exotic",
	"expand",
	"expect",
	"expire",
	"explain",
	"expose",
	"express",
	"extend",
	"extra",
	"eye",
	"eyebrow",
	"fabric",
	"face",
	"faculty",
	"fade",
	"faint",
	"faith",
	"fall",
	"false",
	"fame",
	"family",
	"famous",
	"fan",
	"fancy",
	"fantasy",
	"farm",
	"fashion",
	"fat",
	"fatal",
	"father",
	"fatigue",
	"fault",
	"favorite",
	"feature",
	"february",
	"federal",
	"fee",
	"feed",
	"feel",
	"female",
	"fence",
	"festival",
	"fetch",
	"fever",
	"few",
	"fiber",
	"fiction",
	"field",
	"figure",
	"file",
	"film",
	"filter",
	"final",
	"find",
	"fine",
	"finger",
	"finish",
	"fire",
	"firm",
	"first",
	"fiscal",
	"fish",
	"fit",
	"fitness",
	"fix",
	"flag",
	"flame",
	"flash",
	"flat",
	"flavor",
	"flee",
	"flight",
	"flip",
	"float",
	"flock",
	"floor",
	"flower",
	"fluid",
	"flush",
	"fly",
	"foam",
	"focus",
	"fog",
	"foil",
	"fold",
	"follow",
	"food",
	"foot",
	"force",
	"forest",
	"forget",
	"fork",
	"fortune",
	"forum",
	"forward",
	"fossil",
	"foster",
	"found",
	"fox",
	"fragile",
	"frame",
	"frequent",
	"fresh",
	"friend",
	"fringe",
	"frog",
	"front",
	"frost",
	"frown",
	"frozen",
	"fruit",
	"fuel",
	"fun",
	"funny",
	"furnace",
	"fury",
	"future",
	"gadget",
	"gain",
	"galaxy",
	"gallery",
	"game",
	"gap",
	"garage",
	"garbage",
	"garden",
	"garlic",
	"garment",
	"gas",
	"gasp",
	"gate",
	"gather",
	"gauge",
	"gaze",
	"general",
	"genius",
	"genre",
	"gentle",
	"genuine",
	"gesture",
	"ghost",
	"giant",
	"gift",
	"giggle",
	"ginger",
	"giraffe",
	"girl",
	"give",
	"glad",
	"glance",
	"glare",
	"glass",
	"glide",
	"glimpse",
	"globe",
	"gloom",
	"glory",
	"glove",
	"glow",
	"glue",
	"goat",
	"goddess",
	"gold",
	"good",
	"goose",
	"gorilla",
	"gospel",
	"gossip",
	"govern",
	"gown",
	"grab",
	"grace",
	"grain",
	"grant",
	"grape",
	"grass",
	"gravity",
	"great",
	"green",
	"grid",
	"grief",
	"grit",
	"grocery",
	"group",
	"grow",
	"grunt",
	"guard",
	"guess",
	"guide",
	"guilt",
	"guitar",
	"gun",
	"gym",
	"habit",
	"hair",
	"half",
	"hammer",
	"hamster",
	"hand",
	"happy",
	"harbor",
	"hard",
	"harsh",
	"harvest",
	"hat",
	"have",
	"hawk",
	"hazard",
	"head",
	"health",
	"heart",
	"heavy",
	"hedgehog",
	"height",
	"hello",
	"helmet",
	"help",
	"hen",
	"hero",
	"hidden",
	"high",
	"hill",
	"hint",
	"hip",
	"hire",
	"history",
	"hobby",
	"hockey",
	"hold",
	"hole",
	"holiday",
	"hollow",
	"home",
	"honey",
	"hood",
	"hope",
	"horn",
	"horror",
	"horse",
	"hospital",
	"host",
	"hotel",
	"hour",
	"hover",
	"hub",
	"huge",
	"human",
	"humble",
	"humor",
	"hundred",
	"hungry",
	"hunt",
	"hurdle",
	"hurry",
	"hurt",
	"husband",
	"hybrid",
	"ice",
	"icon",
	"idea",
	"identify",
	"idle",
	"ignore",
	"ill",
	"illegal",
	"illness",
	"image",
	"imitate",
	"immense",
	"immune",
	"impact",
	"impose",
	"improve",
	"impulse",
	"inch",
	"include",
	"income",
	"increase",
	"index",
	"indicate",
	"indoor",
	"industry",
	"infant",
	"inflict",
	"inform",
	"inhale",
	"inherit",
	"initial",
	"inject",
	"injury",
	"inmate",
	"inner",
	"innocent",
	"input",
	"inquiry",
	"insane",
	"insect",
	"inside",
	"inspire",
	"install",
	"intact",
	"interest",
	"into",
	"invest",
	"invite",
	"involve",
	"iron",
	"island",
	"isolate",
	"issue",
	"item",
	"ivory",
	"jacket",
	"jaguar",
	"jar",
	"jazz",
	"jealous",
	"jeans",
	"jelly",
	"jewel",
	"job",
	"join",
	"joke",
	"journey",
	"joy",
	"judge",
	"juice",
	"jump",
	"jungle",
	"junior",
	"junk",
	"just",
	"kangaroo",
	"keen",
	"keep",
	"ketchup",
	"key",
	"kick",
	"kid",
	"kidney",
	"kind",
	"kingdom",
	"kiss",
	"kit",
	"kitchen",
	"kite",
	"kitten",
	"kiwi",
	"knee",
	"knife",
	"knock",
	"know",
	"lab",
	"label",
	"labor",
	"ladder",
	"lady",
	"lake",
	"lamp",
	"language",
	"laptop",
	"large",
	"later",
	"latin",
	"laugh",
	"laundry",
	"lava",
	"law",
	"lawn",
	"lawsuit",
	"layer",
	"lazy",
	"leader",
	"leaf",
	"learn",
	"leave",
	"lecture",
	"left",
	"leg",
	"legal",
	"legend",
	"leisure",
	"lemon",
	"lend",
	"length",
	"lens",
	"leopard",
	"lesson",
	"letter",
	"level",
	"liar",
	"liberty",
	"library",
	"license",
	"life",
	"lift",
	"light",
	"like",
	"limb",
	"limit",
	"link",
	"lion",
	"liquid",
	"list",
	"little",
	"live",
	"lizard",
	"load",
	"loan",
	"lobster",
	"local",
	"lock",
	"logic",
	"lonely",
	"long",
	"loop",
	"lottery",
	"loud",
	"lounge",
	"love",
	"loyal",
	"lucky",
	"luggage",
	"lumber",
	"lunar",
	"lunch",
	"luxury",
	"lyrics",
	"machine",
	"mad",
	"magic",
	"magnet",
	"maid",
	"mail",
	"main",
	"major",
	"make",
	"mammal",
	"man",
	"manage",
	"mandate",
	"mango",
	"mansion",
	"manual",
	"maple",
	"marble",
	"march",
	"margin",
	"marine",
	"market",
	"marriage",
	"mask",
	"mass",
	"master",
	"match",
	"material",
	"math",
	"matrix",
	"matter",
	"maximum",
	"maze",
	"meadow",
	"mean",
	"measure",
	"meat",
	"mechanic",
	"medal",
	"media",
	"melody",
	"melt",
	"member",
	"memory",
	"mention",
	"menu",
	"mercy",
	"merge",
	"merit",
	"merry",
	"mesh",
	"message",
	"metal",
	"method",
	"middle",
	"midnight",
	"milk",
	"million",
	"mimic",
	"mind",
	"minimum",
	"minor",
	"minute",
	"miracle",
	"mirror",
	"misery",
	"miss",
	"mistake",
	"mix",
	"mixed",
	"mixture",
	"mobile",
	"model",
	"modify",
	"mom",
	"moment",
	"monitor",
	"monkey",
	"monster",
	"month",
	"moon",
	"moral",
	"more",
	"morning",
	"mosquito",
	"mother",
	"motion",
	"motor",
	"mountain",
	"mouse",
	"move",
	"movie",
	"much",
	"muffin",
	"mule",
	"multiply",
	"muscle",
	"museum",
	"mushroom",
	"music",
	"must",
	"mutual",
	"myself",
	"mystery",
	"myth",
	"naive",
	"name",
	"napkin",
	"narrow",
	"nasty",
	"nation",
	"nature",
	"near",
	"neck",
	"need",
	"negative",
	"neglect",
	"neither",
	"nephew",
	"nerve",
	"nest",
	"net",
	"network",
	"neutral",
	"never",
	"news",
	"next",
	"nice",
	"night",
	"noble",
	"noise",
	"nominee",
	"noodle",
	"normal",
	"north",
	"nose",
	"notable",
	"note",
	"nothing",
	"notice",
	"novel",
	"now",
	"nuclear",
	"number",
	"nurse",
	"nut",
	"oak",
	"obey",
	"object",
	"oblige",
	"obscure",
	"observe",
	"obtain",
	"obvious",
	"occur",
	"ocean",
	"october",
	"odor",
	"off",
	"offer",
	"office",
	"often",
	"oil",
	"okay",
	"old",
	"olive",
	"olympic",
	"omit",
	"once",
	"one",
	"onion",
	"online",
	"only",
	"open",
	"opera",
	"opinion",
	"oppose",
	"option",
	"orange",
	"orbit",
	"orchard",
	"order",
	"ordinary",
	"organ",
	"orient",
	"original",
	"orphan",
	"ostrich",
	"other",
	"outdoor",
	"outer",
	"output",
	"outside",
	"oval",
	"oven",
	"over",
	"own",
	"owner",
	"oxygen",
	"oyster",
	"ozone",
	"pact",
	"paddle",
	"page",
	"pair",
	"palace",
	"palm",
	"panda",
	"panel",
	"panic",
	"panther",
	"paper",
	"parade",
	"parent",
	"park",
	"parrot",
	"party",
	"pass",
	"patch",
	"path",
	"patient",
	"patrol",
	"pattern",
	"pause",
	"pave",
	"payment",
	"peace",
	"peanut",
	"pear",
	"peasant",
	"pelican",
	"pen",
	"penalty",
	"pencil",
	"people",
	"pepper",
	"perfect",
	"permit",
	"person",
	"pet",
	"phone",
	"photo",
	"phrase",
	"physical",
	"piano",
	"picnic",
	"picture",
	"piece",
	"pig",
	"pigeon",
	"pill",
	"pilot",
	"pink",
	"pioneer",
	"pipe",
	"pistol",
	"pitch",
	"pizza",
	"place",
	"planet",
	"plastic",
	"plate",
	"play",
	"please",
	"pledge",
	"pluck",
	"plug",
	"plunge",
	"poem",
	"poet",
	"point",
	"polar",
	"pole",
	"police",
	"pond",
	"pony",
	"pool",
	"popular",
	"portion",
	"position",
	"possible",
	"post",
	"potato",
	"pottery",
	"poverty",
	"powder",
	"power",
	"practice",
	"praise",
	"predict",
	"prefer",
	"prepare",
	"present",
	"pretty",
	"prevent",
	"price",
	"pride",
	"primary",
	"print",
	"priority",
	"prison",
	"private",
	"prize",
	"problem",
	"process",
	"produce",
	"profit",
	"program",
	"project",
	"promote",
	"proof",
	"property",
	"prosper",
	"protect",
	"proud",
	"provide",
	"public",
	"pudding",
	"pull",
	"pulp",
	"pulse",
	"pumpkin",
	"punch",
	"pupil",
	"puppy",
	"purchase",
	"purity",
	"purpose",
	"purse",
	"push",
	"put",
	"puzzle",
	"pyramid",
	"quality",
	"quantum",
	"quarter",
	"question",
	"quick",
	"quit",
	"quiz",
	"quote",
	"rabbit",
	"raccoon",
	"race",
	"rack",
	"radar",
	"radio",
	"rail",
	"rain",
	"raise",
	"rally",
	"ramp",
	"ranch",
	"random",
	"range",
	"rapid",
	"rare",
	"rate",
	"rather",
	"raven",
	"raw",
	"razor",
	"ready",
	"real",
	"reason",
	"rebel",
	"rebuild",
	"recall",
	"receive",
	"recipe",
	"record",
	"recycle",
	"reduce",
	"reflect",
	"reform",
	"refuse",
	"region",
	"regret",
	"regular",
	"reject",
	"relax",
	"release",
	"relief",
	"rely",
	"remain",
	"remember",
	"remind",
	"remove",
	"render",
	"renew",
	"rent",
	"reopen",
	"repair",
	"repeat",
	"replace",
	"report",
	"require",
	"rescue",
	"resemble",
	"resist",
	"resource",
	"response",
	"result",
	"retire",
	"retreat",
	"return",
	"reunion",
	"reveal",
	"review",
	"reward",
	"rhythm",
	"rib",
	"ribbon",
	"rice",
	"rich",
	"ride",
	"ridge",
	"rifle",
	"right",
	"rigid",
	"ring",
	"riot",
	"ripple",
	"risk",
	"ritual",
	"rival",
	"river",
	"road",
	"roast",
	"robot",
	"robust",
	"rocket",
	"romance",
	"roof",
	"rookie",
	"room",
	"rose",
	"rotate",
	"rough",
	"round",
	"route",
	"royal",
	"rubber",
	"rude",
	"rug",
	"rule",
	"run",
	"runway",
	"rural",
	"sad",
	"saddle",
	"sadness",
	"safe",
	"sail",
	"salad",
	"salmon",
	"salon",
	"salt",
	"salute",
	"same",
	"sample",
	"sand",
	"satisfy",
	"satoshi",
	"sauce",
	"sausage",
	"save",
	"say",
	"scale",
	"scan",
	"scare",
	"scatter",
	"scene",
	"scheme",
	"school",
	"science",
	"scissors",
	"scorpion",
	"scout",
	"scrap",
	"screen",
	"script",
	"scrub",
	"sea",
	"search",
	"season",
	"seat",
	"second",
	"secret",
	"section",
	"security",
	"seed",
	"seek",
	"segment",
	"select",
	"sell",
	"seminar",
	"senior",
	"sense",
	"sentence",
	"series",
	"service",
	"session",
	"settle",
	"setup",
	"seven",
	"shadow",
	"shaft",
	"shallow",
	"share",
	"shed",
	"shell",
	"sheriff",
	"shield",
	"shift",
	"shine",
	"ship",
	"shiver",
	"shock",
	"shoe",
	"shoot",
	"shop",
	"short",
	"shoulder",
	"shove",
	"shrimp",
	"shrug",
	"shuffle",
	"shy",
	"sibling",
	"sick",
	"side",
	"siege",
	"sight",
	"sign",
	"silent",
	"silk",
	"silly",
	"silver",
	"similar",
	"simple",
	"since",
	"sing",
	"siren",
	"sister",
	"situate",
	"six",
	"size",
	"skate",
	"sketch",
	"ski",
	"skill",
	"skin",
	"skirt",
	"skull",
	"slab",
	"slam",
	"sleep",
	"slender",
	"slice",
	"slide",
	"slight",
	"slim",
	"slogan",
	"slot",
	"slow",
	"slush",
	"small",
	"smart",
	"smile",
	"smoke",
	"smooth",
	"snack",
	"snake",
	"snap",
	"sniff",
	"snow",
	"soap",
	"soccer",
	"social",
	"sock",
	"soda",
	"soft",
	"solar",
	"soldier",
	"solid",
	"solution",
	"solve",
	"someone",
	"song",
	"soon",
	"sorry",
	"sort",
	"soul",
	"sound",
	"soup",
	"source",
	"south",
	"space",
	"spare",
	"spatial",
	"spawn",
	"speak",
	"special",
	"speed",
	"spell",
	"spend",
	"sphere",
	"spice",
	"spider",
	"spike",
	"spin",
	"spirit",
	"split",
	"spoil",
	"sponsor",
	"spoon",
	"sport",
	"spot",
	"spray",
	"spread",
	"spring",
	"spy",
	"square",
	"squeeze",
	"squirrel",
	"stable",
	"stadium",
	"staff",
	"stage",
	"stairs",
	"stamp",
	"stand",
	"start",
	"state",
	"stay",
	"steak",
	"steel",
	"stem",
	"step",
	"stereo",
	"stick",
	"still",
	"sting",
	"stock",
	"stomach",
	"stone",
	"stool",
	"story",
	"stove",
	"strategy",
	"street",
	"strike",
	"strong",
	"struggle",
	"student",
	"stuff",
	"stumble",
	"style",
	"subject",
	"submit",
	"subway",
	"success",
	"such",
	"sudden",
	"suffer",
	"sugar",
	"suggest",
	"suit",
	"summer",
	"sun",
	"sunny",
	"sunset",
	"super",
	"supply",
	"supreme",
	"sure",
	"surface",
	"surge",
	"surprise",
	"surround",
	"survey",
	"suspect",
	"sustain",
	"swallow",
	"swamp",
	"swap",
	"swarm",
	"swear",
	"sweet",
	"swift",
	"swim",
	"swing",
	"switch",
	"sword",
	"symbol",
	"symptom",
	"syrup",
	"system",
	"table",
	"tackle",
	"tag",
	"tail",
	"talent",
	"talk",
	"tank",
	"tape",
	"target",
	"task",
	"taste",
	"tattoo",
	"taxi",
	"teach",
	"team",
	"tell",
	"ten",
	"tenant",
	"tennis",
	"tent",
	"term",
	"test",
	"text",
	"thank",
	"that",
	"theme",
	"then",
	"theory",
	"there",
	"they",
	"thing",
	"this",
	"thought",
	"three",
	"thrive",
	"throw",
	"thumb",
	"thunder",
	"ticket",
	"tide",
	"tiger",
	"tilt",
	"timber",
	"time",
	"tiny",
	"tip",
	"tired",
	"tissue",
	"title",
	"toast",
	"tobacco",
	"today",
	"toddler",
	"toe",
	"together",
	"toilet",
	"token",
	"tomato",
	"tomorrow",
	"tone",
	"tongue",
	"tonight",
	"tool",
	"tooth",
	"top",
	"topic",
	"topple",
	"torch",
	"tornado",
	"tortoise",
	"toss",
	"total",
	"tourist",
	"toward",
	"tower",
	"town",
	"toy",
	"track",
	"trade",
	"traffic",
	"tragic",
	"train",
	"transfer",
	"trap",
	"trash",
	"travel",
	"tray",
	"treat",
	"tree",
	"trend",
	"trial",
	"tribe",
	"trick",
	"trigger",
	"trim",
	"trip",
	"trophy",
	"trouble",
	"truck",
	"true",
	"truly",
	"trumpet",
	"trust",
	"truth",
	"try",
	"tube",
	"tuition",
	"tumble",
	"tuna",
	"tunnel",
	"turkey",
	"turn",
	"turtle",
	"twelve",
	"twenty",
	"twice",
	"twin",
	"twist",
	"two",
	"type",
	"typical",
	"ugly",
	"umbrella",
	"unable",
	"unaware",
	"uncle",
	"uncover",
	"under",
	"undo",
	"unfair",
	"unfold",
	"unhappy",
	"uniform",
	"unique",
	"unit",
	"universe",
	"unknown",
	"unlock",
	"until",
	"unusual",
	"unveil",
	"update",
	"upgrade",
	"uphold",
	"upon",
	"upper",
	"upset",
	"urban",
	"urge",
	"usage",
	"use",
	"used",
	"useful",
	"useless",
	"usual",
	"utility",
	"vacant",
	"vacuum",
	"vague",
	"valid",
	"valley",
	"valve",
	"van",
	"vanish",
	"vapor",
	"various",
	"vast",
	"vault",
	"vehicle",
	"velvet",
	"vendor",
	"venture",
	"venue",
	"verb",
	"verify",
	"version",
	"very",
	"vessel",
	"veteran",
	"viable",
	"vibrant",
	"vicious",
	"victory",
	"video",
	"view",
	"village",
	"vintage",
	"violin",
	"virtual",
	"virus",
	"visa",
	"visit",
	"visual",
	"vital",
	"vivid",
	"vocal",
	"voice",
	"void",
	"volcano",
	"volume",
	"vote",
	"voyage",
	"wage",
	"wagon",
	"wait",
	"walk",
	"wall",
	"walnut",
	"want",
	"warfare",
	"warm",
	"warrior",
	"wash",
	"wasp",
	"waste",
	"water",
	"wave",
	"way",
	"wealth",
	"weapon",
	"wear",
	"weasel",
	"weather",
	"web",
	"wedding",
	"weekend",
	"weird",
	"welcome",
	"west",
	"wet",
	"whale",
	"what",
	"wheat",
	"wheel",
	"when",
	"where",
	"whip",
	"whisper",
	"wide",
	"width",
	"wife",
	"wild",
	"will",
	"win",
	"window",
	"wine",
	"wing",
	"wink",
	"winner",
	"winter",
	"wire",
	"wisdom",
	"wise",
	"wish",
	"witness",
	"wolf",
	"woman",
	"wonder",
	"wood",
	"wool",
	"word",
	"work",
	"world",
	"worry",
	"worth",
	"wrap",
	"wreck",
	"wrestle",
	"wrist",
	"write",
	"wrong",
	"yard",
	"year",
	"yellow",
	"you",
	"young",
	"youth",
	"zebra",
	"zero",
	"zone",
	"zoo"
];

Object.defineProperty(_wordlists, "__esModule", { value: true });
// browserify by default only pulls in files that are hard coded in requires
// In order of last to first in this file, the default wordlist will be chosen
// based on what is present. (Bundles may remove wordlists they don't need)
const wordlists = {};
_wordlists.wordlists = wordlists;
let _default;
var _default_1 = _wordlists._default = _default;
try {
    _default_1 = _wordlists._default = _default = require$$0$1;
    wordlists.czech = _default;
}
catch (err) { }
try {
    _default_1 = _wordlists._default = _default = require$$1;
    wordlists.chinese_simplified = _default;
}
catch (err) { }
try {
    _default_1 = _wordlists._default = _default = require$$2;
    wordlists.chinese_traditional = _default;
}
catch (err) { }
try {
    _default_1 = _wordlists._default = _default = require$$3;
    wordlists.korean = _default;
}
catch (err) { }
try {
    _default_1 = _wordlists._default = _default = require$$4;
    wordlists.french = _default;
}
catch (err) { }
try {
    _default_1 = _wordlists._default = _default = require$$5;
    wordlists.italian = _default;
}
catch (err) { }
try {
    _default_1 = _wordlists._default = _default = require$$6;
    wordlists.spanish = _default;
}
catch (err) { }
try {
    _default_1 = _wordlists._default = _default = require$$7;
    wordlists.japanese = _default;
    wordlists.JA = _default;
}
catch (err) { }
try {
    _default_1 = _wordlists._default = _default = require$$8;
    wordlists.portuguese = _default;
}
catch (err) { }
try {
    _default_1 = _wordlists._default = _default = require$$9;
    wordlists.english = _default;
    wordlists.EN = _default;
}
catch (err) { }

Object.defineProperty(src$1, "__esModule", { value: true });
const sha256_1 = sha256$1;
const sha512_1 = sha512$1;
const pbkdf2_1 = pbkdf2$2;
const utils_1 = utils$a;
const _wordlists_1 = _wordlists;
let DEFAULT_WORDLIST = _wordlists_1._default;
const INVALID_MNEMONIC = 'Invalid mnemonic';
const INVALID_ENTROPY = 'Invalid entropy';
const INVALID_CHECKSUM = 'Invalid mnemonic checksum';
const WORDLIST_REQUIRED = 'A wordlist is required but a default could not be found.\n' +
    'Please pass a 2048 word array explicitly.';
function normalize(str) {
    return (str || '').normalize('NFKD');
}
function lpad(str, padString, length) {
    while (str.length < length) {
        str = padString + str;
    }
    return str;
}
function binaryToByte(bin) {
    return parseInt(bin, 2);
}
function bytesToBinary(bytes) {
    return bytes.map((x) => lpad(x.toString(2), '0', 8)).join('');
}
function deriveChecksumBits(entropyBuffer) {
    const ENT = entropyBuffer.length * 8;
    const CS = ENT / 32;
    const hash = sha256_1.sha256(Uint8Array.from(entropyBuffer));
    return bytesToBinary(Array.from(hash)).slice(0, CS);
}
function salt(password) {
    return 'mnemonic' + (password || '');
}
function mnemonicToSeedSync(mnemonic, password) {
    const mnemonicBuffer = Uint8Array.from(Buffer.from(normalize(mnemonic), 'utf8'));
    const saltBuffer = Uint8Array.from(Buffer.from(salt(normalize(password)), 'utf8'));
    const res = pbkdf2_1.pbkdf2(sha512_1.sha512, mnemonicBuffer, saltBuffer, {
        c: 2048,
        dkLen: 64,
    });
    return Buffer.from(res);
}
src$1.mnemonicToSeedSync = mnemonicToSeedSync;
function mnemonicToSeed(mnemonic, password) {
    const mnemonicBuffer = Uint8Array.from(Buffer.from(normalize(mnemonic), 'utf8'));
    const saltBuffer = Uint8Array.from(Buffer.from(salt(normalize(password)), 'utf8'));
    return pbkdf2_1.pbkdf2Async(sha512_1.sha512, mnemonicBuffer, saltBuffer, {
        c: 2048,
        dkLen: 64,
    }).then((res) => Buffer.from(res));
}
src$1.mnemonicToSeed = mnemonicToSeed;
function mnemonicToEntropy(mnemonic, wordlist) {
    wordlist = wordlist || DEFAULT_WORDLIST;
    if (!wordlist) {
        throw new Error(WORDLIST_REQUIRED);
    }
    const words = normalize(mnemonic).split(' ');
    if (words.length % 3 !== 0) {
        throw new Error(INVALID_MNEMONIC);
    }
    // convert word indices to 11 bit binary strings
    const bits = words
        .map((word) => {
        const index = wordlist.indexOf(word);
        if (index === -1) {
            throw new Error(INVALID_MNEMONIC);
        }
        return lpad(index.toString(2), '0', 11);
    })
        .join('');
    // split the binary string into ENT/CS
    const dividerIndex = Math.floor(bits.length / 33) * 32;
    const entropyBits = bits.slice(0, dividerIndex);
    const checksumBits = bits.slice(dividerIndex);
    // calculate the checksum and compare
    const entropyBytes = entropyBits.match(/(.{1,8})/g).map(binaryToByte);
    if (entropyBytes.length < 16) {
        throw new Error(INVALID_ENTROPY);
    }
    if (entropyBytes.length > 32) {
        throw new Error(INVALID_ENTROPY);
    }
    if (entropyBytes.length % 4 !== 0) {
        throw new Error(INVALID_ENTROPY);
    }
    const entropy = Buffer.from(entropyBytes);
    const newChecksum = deriveChecksumBits(entropy);
    if (newChecksum !== checksumBits) {
        throw new Error(INVALID_CHECKSUM);
    }
    return entropy.toString('hex');
}
src$1.mnemonicToEntropy = mnemonicToEntropy;
function entropyToMnemonic(entropy, wordlist) {
    if (!isBuffer$2(entropy)) {
        entropy = Buffer.from(entropy, 'hex');
    }
    wordlist = wordlist || DEFAULT_WORDLIST;
    if (!wordlist) {
        throw new Error(WORDLIST_REQUIRED);
    }
    // 128 <= ENT <= 256
    if (entropy.length < 16) {
        throw new TypeError(INVALID_ENTROPY);
    }
    if (entropy.length > 32) {
        throw new TypeError(INVALID_ENTROPY);
    }
    if (entropy.length % 4 !== 0) {
        throw new TypeError(INVALID_ENTROPY);
    }
    const entropyBits = bytesToBinary(Array.from(entropy));
    const checksumBits = deriveChecksumBits(entropy);
    const bits = entropyBits + checksumBits;
    const chunks = bits.match(/(.{1,11})/g);
    const words = chunks.map((binary) => {
        const index = binaryToByte(binary);
        return wordlist[index];
    });
    return wordlist[0] === '\u3042\u3044\u3053\u304f\u3057\u3093' // Japanese wordlist
        ? words.join('\u3000')
        : words.join(' ');
}
src$1.entropyToMnemonic = entropyToMnemonic;
function generateMnemonic(strength, rng, wordlist) {
    strength = strength || 128;
    if (strength % 32 !== 0) {
        throw new TypeError(INVALID_ENTROPY);
    }
    rng = rng || ((size) => Buffer.from(utils_1.randomBytes(size)));
    return entropyToMnemonic(rng(strength / 8), wordlist);
}
src$1.generateMnemonic = generateMnemonic;
function validateMnemonic(mnemonic, wordlist) {
    try {
        mnemonicToEntropy(mnemonic, wordlist);
    }
    catch (e) {
        return false;
    }
    return true;
}
src$1.validateMnemonic = validateMnemonic;
function setDefaultWordlist(language) {
    const result = _wordlists_1.wordlists[language];
    if (result) {
        DEFAULT_WORDLIST = result;
    }
    else {
        throw new Error('Could not find wordlist for language "' + language + '"');
    }
}
src$1.setDefaultWordlist = setDefaultWordlist;
function getDefaultWordlist() {
    if (!DEFAULT_WORDLIST) {
        throw new Error('No Default Wordlist set');
    }
    return Object.keys(_wordlists_1.wordlists).filter((lang) => {
        if (lang === 'JA' || lang === 'EN') {
            return false;
        }
        return _wordlists_1.wordlists[lang].every((word, index) => word === DEFAULT_WORDLIST[index]);
    })[0];
}
src$1.getDefaultWordlist = getDefaultWordlist;
var _wordlists_2 = _wordlists;
src$1.wordlists = _wordlists_2.wordlists;

var aesJs = {exports: {}};

/*! MIT License. Copyright 2015-2018 Richard Moore <me@ricmoo.com>. See LICENSE.txt. */

(function (module, exports) {
	(function(root) {

	    function checkInt(value) {
	        return (parseInt(value) === value);
	    }

	    function checkInts(arrayish) {
	        if (!checkInt(arrayish.length)) { return false; }

	        for (var i = 0; i < arrayish.length; i++) {
	            if (!checkInt(arrayish[i]) || arrayish[i] < 0 || arrayish[i] > 255) {
	                return false;
	            }
	        }

	        return true;
	    }

	    function coerceArray(arg, copy) {

	        // ArrayBuffer view
	        if (arg.buffer && arg.name === 'Uint8Array') {

	            if (copy) {
	                if (arg.slice) {
	                    arg = arg.slice();
	                } else {
	                    arg = Array.prototype.slice.call(arg);
	                }
	            }

	            return arg;
	        }

	        // It's an array; check it is a valid representation of a byte
	        if (Array.isArray(arg)) {
	            if (!checkInts(arg)) {
	                throw new Error('Array contains invalid value: ' + arg);
	            }

	            return new Uint8Array(arg);
	        }

	        // Something else, but behaves like an array (maybe a Buffer? Arguments?)
	        if (checkInt(arg.length) && checkInts(arg)) {
	            return new Uint8Array(arg);
	        }

	        throw new Error('unsupported array-like object');
	    }

	    function createArray(length) {
	        return new Uint8Array(length);
	    }

	    function copyArray(sourceArray, targetArray, targetStart, sourceStart, sourceEnd) {
	        if (sourceStart != null || sourceEnd != null) {
	            if (sourceArray.slice) {
	                sourceArray = sourceArray.slice(sourceStart, sourceEnd);
	            } else {
	                sourceArray = Array.prototype.slice.call(sourceArray, sourceStart, sourceEnd);
	            }
	        }
	        targetArray.set(sourceArray, targetStart);
	    }



	    var convertUtf8 = (function() {
	        function toBytes(text) {
	            var result = [], i = 0;
	            text = encodeURI(text);
	            while (i < text.length) {
	                var c = text.charCodeAt(i++);

	                // if it is a % sign, encode the following 2 bytes as a hex value
	                if (c === 37) {
	                    result.push(parseInt(text.substr(i, 2), 16));
	                    i += 2;

	                // otherwise, just the actual byte
	                } else {
	                    result.push(c);
	                }
	            }

	            return coerceArray(result);
	        }

	        function fromBytes(bytes) {
	            var result = [], i = 0;

	            while (i < bytes.length) {
	                var c = bytes[i];

	                if (c < 128) {
	                    result.push(String.fromCharCode(c));
	                    i++;
	                } else if (c > 191 && c < 224) {
	                    result.push(String.fromCharCode(((c & 0x1f) << 6) | (bytes[i + 1] & 0x3f)));
	                    i += 2;
	                } else {
	                    result.push(String.fromCharCode(((c & 0x0f) << 12) | ((bytes[i + 1] & 0x3f) << 6) | (bytes[i + 2] & 0x3f)));
	                    i += 3;
	                }
	            }

	            return result.join('');
	        }

	        return {
	            toBytes: toBytes,
	            fromBytes: fromBytes,
	        }
	    })();

	    var convertHex = (function() {
	        function toBytes(text) {
	            var result = [];
	            for (var i = 0; i < text.length; i += 2) {
	                result.push(parseInt(text.substr(i, 2), 16));
	            }

	            return result;
	        }

	        // http://ixti.net/development/javascript/2011/11/11/base64-encodedecode-of-utf8-in-browser-with-js.html
	        var Hex = '0123456789abcdef';

	        function fromBytes(bytes) {
	                var result = [];
	                for (var i = 0; i < bytes.length; i++) {
	                    var v = bytes[i];
	                    result.push(Hex[(v & 0xf0) >> 4] + Hex[v & 0x0f]);
	                }
	                return result.join('');
	        }

	        return {
	            toBytes: toBytes,
	            fromBytes: fromBytes,
	        }
	    })();


	    // Number of rounds by keysize
	    var numberOfRounds = {16: 10, 24: 12, 32: 14};

	    // Round constant words
	    var rcon = [0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91];

	    // S-box and Inverse S-box (S is for Substitution)
	    var S = [0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16];
	    var Si =[0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d];

	    // Transformations for encryption
	    var T1 = [0xc66363a5, 0xf87c7c84, 0xee777799, 0xf67b7b8d, 0xfff2f20d, 0xd66b6bbd, 0xde6f6fb1, 0x91c5c554, 0x60303050, 0x02010103, 0xce6767a9, 0x562b2b7d, 0xe7fefe19, 0xb5d7d762, 0x4dababe6, 0xec76769a, 0x8fcaca45, 0x1f82829d, 0x89c9c940, 0xfa7d7d87, 0xeffafa15, 0xb25959eb, 0x8e4747c9, 0xfbf0f00b, 0x41adadec, 0xb3d4d467, 0x5fa2a2fd, 0x45afafea, 0x239c9cbf, 0x53a4a4f7, 0xe4727296, 0x9bc0c05b, 0x75b7b7c2, 0xe1fdfd1c, 0x3d9393ae, 0x4c26266a, 0x6c36365a, 0x7e3f3f41, 0xf5f7f702, 0x83cccc4f, 0x6834345c, 0x51a5a5f4, 0xd1e5e534, 0xf9f1f108, 0xe2717193, 0xabd8d873, 0x62313153, 0x2a15153f, 0x0804040c, 0x95c7c752, 0x46232365, 0x9dc3c35e, 0x30181828, 0x379696a1, 0x0a05050f, 0x2f9a9ab5, 0x0e070709, 0x24121236, 0x1b80809b, 0xdfe2e23d, 0xcdebeb26, 0x4e272769, 0x7fb2b2cd, 0xea75759f, 0x1209091b, 0x1d83839e, 0x582c2c74, 0x341a1a2e, 0x361b1b2d, 0xdc6e6eb2, 0xb45a5aee, 0x5ba0a0fb, 0xa45252f6, 0x763b3b4d, 0xb7d6d661, 0x7db3b3ce, 0x5229297b, 0xdde3e33e, 0x5e2f2f71, 0x13848497, 0xa65353f5, 0xb9d1d168, 0x00000000, 0xc1eded2c, 0x40202060, 0xe3fcfc1f, 0x79b1b1c8, 0xb65b5bed, 0xd46a6abe, 0x8dcbcb46, 0x67bebed9, 0x7239394b, 0x944a4ade, 0x984c4cd4, 0xb05858e8, 0x85cfcf4a, 0xbbd0d06b, 0xc5efef2a, 0x4faaaae5, 0xedfbfb16, 0x864343c5, 0x9a4d4dd7, 0x66333355, 0x11858594, 0x8a4545cf, 0xe9f9f910, 0x04020206, 0xfe7f7f81, 0xa05050f0, 0x783c3c44, 0x259f9fba, 0x4ba8a8e3, 0xa25151f3, 0x5da3a3fe, 0x804040c0, 0x058f8f8a, 0x3f9292ad, 0x219d9dbc, 0x70383848, 0xf1f5f504, 0x63bcbcdf, 0x77b6b6c1, 0xafdada75, 0x42212163, 0x20101030, 0xe5ffff1a, 0xfdf3f30e, 0xbfd2d26d, 0x81cdcd4c, 0x180c0c14, 0x26131335, 0xc3ecec2f, 0xbe5f5fe1, 0x359797a2, 0x884444cc, 0x2e171739, 0x93c4c457, 0x55a7a7f2, 0xfc7e7e82, 0x7a3d3d47, 0xc86464ac, 0xba5d5de7, 0x3219192b, 0xe6737395, 0xc06060a0, 0x19818198, 0x9e4f4fd1, 0xa3dcdc7f, 0x44222266, 0x542a2a7e, 0x3b9090ab, 0x0b888883, 0x8c4646ca, 0xc7eeee29, 0x6bb8b8d3, 0x2814143c, 0xa7dede79, 0xbc5e5ee2, 0x160b0b1d, 0xaddbdb76, 0xdbe0e03b, 0x64323256, 0x743a3a4e, 0x140a0a1e, 0x924949db, 0x0c06060a, 0x4824246c, 0xb85c5ce4, 0x9fc2c25d, 0xbdd3d36e, 0x43acacef, 0xc46262a6, 0x399191a8, 0x319595a4, 0xd3e4e437, 0xf279798b, 0xd5e7e732, 0x8bc8c843, 0x6e373759, 0xda6d6db7, 0x018d8d8c, 0xb1d5d564, 0x9c4e4ed2, 0x49a9a9e0, 0xd86c6cb4, 0xac5656fa, 0xf3f4f407, 0xcfeaea25, 0xca6565af, 0xf47a7a8e, 0x47aeaee9, 0x10080818, 0x6fbabad5, 0xf0787888, 0x4a25256f, 0x5c2e2e72, 0x381c1c24, 0x57a6a6f1, 0x73b4b4c7, 0x97c6c651, 0xcbe8e823, 0xa1dddd7c, 0xe874749c, 0x3e1f1f21, 0x964b4bdd, 0x61bdbddc, 0x0d8b8b86, 0x0f8a8a85, 0xe0707090, 0x7c3e3e42, 0x71b5b5c4, 0xcc6666aa, 0x904848d8, 0x06030305, 0xf7f6f601, 0x1c0e0e12, 0xc26161a3, 0x6a35355f, 0xae5757f9, 0x69b9b9d0, 0x17868691, 0x99c1c158, 0x3a1d1d27, 0x279e9eb9, 0xd9e1e138, 0xebf8f813, 0x2b9898b3, 0x22111133, 0xd26969bb, 0xa9d9d970, 0x078e8e89, 0x339494a7, 0x2d9b9bb6, 0x3c1e1e22, 0x15878792, 0xc9e9e920, 0x87cece49, 0xaa5555ff, 0x50282878, 0xa5dfdf7a, 0x038c8c8f, 0x59a1a1f8, 0x09898980, 0x1a0d0d17, 0x65bfbfda, 0xd7e6e631, 0x844242c6, 0xd06868b8, 0x824141c3, 0x299999b0, 0x5a2d2d77, 0x1e0f0f11, 0x7bb0b0cb, 0xa85454fc, 0x6dbbbbd6, 0x2c16163a];
	    var T2 = [0xa5c66363, 0x84f87c7c, 0x99ee7777, 0x8df67b7b, 0x0dfff2f2, 0xbdd66b6b, 0xb1de6f6f, 0x5491c5c5, 0x50603030, 0x03020101, 0xa9ce6767, 0x7d562b2b, 0x19e7fefe, 0x62b5d7d7, 0xe64dabab, 0x9aec7676, 0x458fcaca, 0x9d1f8282, 0x4089c9c9, 0x87fa7d7d, 0x15effafa, 0xebb25959, 0xc98e4747, 0x0bfbf0f0, 0xec41adad, 0x67b3d4d4, 0xfd5fa2a2, 0xea45afaf, 0xbf239c9c, 0xf753a4a4, 0x96e47272, 0x5b9bc0c0, 0xc275b7b7, 0x1ce1fdfd, 0xae3d9393, 0x6a4c2626, 0x5a6c3636, 0x417e3f3f, 0x02f5f7f7, 0x4f83cccc, 0x5c683434, 0xf451a5a5, 0x34d1e5e5, 0x08f9f1f1, 0x93e27171, 0x73abd8d8, 0x53623131, 0x3f2a1515, 0x0c080404, 0x5295c7c7, 0x65462323, 0x5e9dc3c3, 0x28301818, 0xa1379696, 0x0f0a0505, 0xb52f9a9a, 0x090e0707, 0x36241212, 0x9b1b8080, 0x3ddfe2e2, 0x26cdebeb, 0x694e2727, 0xcd7fb2b2, 0x9fea7575, 0x1b120909, 0x9e1d8383, 0x74582c2c, 0x2e341a1a, 0x2d361b1b, 0xb2dc6e6e, 0xeeb45a5a, 0xfb5ba0a0, 0xf6a45252, 0x4d763b3b, 0x61b7d6d6, 0xce7db3b3, 0x7b522929, 0x3edde3e3, 0x715e2f2f, 0x97138484, 0xf5a65353, 0x68b9d1d1, 0x00000000, 0x2cc1eded, 0x60402020, 0x1fe3fcfc, 0xc879b1b1, 0xedb65b5b, 0xbed46a6a, 0x468dcbcb, 0xd967bebe, 0x4b723939, 0xde944a4a, 0xd4984c4c, 0xe8b05858, 0x4a85cfcf, 0x6bbbd0d0, 0x2ac5efef, 0xe54faaaa, 0x16edfbfb, 0xc5864343, 0xd79a4d4d, 0x55663333, 0x94118585, 0xcf8a4545, 0x10e9f9f9, 0x06040202, 0x81fe7f7f, 0xf0a05050, 0x44783c3c, 0xba259f9f, 0xe34ba8a8, 0xf3a25151, 0xfe5da3a3, 0xc0804040, 0x8a058f8f, 0xad3f9292, 0xbc219d9d, 0x48703838, 0x04f1f5f5, 0xdf63bcbc, 0xc177b6b6, 0x75afdada, 0x63422121, 0x30201010, 0x1ae5ffff, 0x0efdf3f3, 0x6dbfd2d2, 0x4c81cdcd, 0x14180c0c, 0x35261313, 0x2fc3ecec, 0xe1be5f5f, 0xa2359797, 0xcc884444, 0x392e1717, 0x5793c4c4, 0xf255a7a7, 0x82fc7e7e, 0x477a3d3d, 0xacc86464, 0xe7ba5d5d, 0x2b321919, 0x95e67373, 0xa0c06060, 0x98198181, 0xd19e4f4f, 0x7fa3dcdc, 0x66442222, 0x7e542a2a, 0xab3b9090, 0x830b8888, 0xca8c4646, 0x29c7eeee, 0xd36bb8b8, 0x3c281414, 0x79a7dede, 0xe2bc5e5e, 0x1d160b0b, 0x76addbdb, 0x3bdbe0e0, 0x56643232, 0x4e743a3a, 0x1e140a0a, 0xdb924949, 0x0a0c0606, 0x6c482424, 0xe4b85c5c, 0x5d9fc2c2, 0x6ebdd3d3, 0xef43acac, 0xa6c46262, 0xa8399191, 0xa4319595, 0x37d3e4e4, 0x8bf27979, 0x32d5e7e7, 0x438bc8c8, 0x596e3737, 0xb7da6d6d, 0x8c018d8d, 0x64b1d5d5, 0xd29c4e4e, 0xe049a9a9, 0xb4d86c6c, 0xfaac5656, 0x07f3f4f4, 0x25cfeaea, 0xafca6565, 0x8ef47a7a, 0xe947aeae, 0x18100808, 0xd56fbaba, 0x88f07878, 0x6f4a2525, 0x725c2e2e, 0x24381c1c, 0xf157a6a6, 0xc773b4b4, 0x5197c6c6, 0x23cbe8e8, 0x7ca1dddd, 0x9ce87474, 0x213e1f1f, 0xdd964b4b, 0xdc61bdbd, 0x860d8b8b, 0x850f8a8a, 0x90e07070, 0x427c3e3e, 0xc471b5b5, 0xaacc6666, 0xd8904848, 0x05060303, 0x01f7f6f6, 0x121c0e0e, 0xa3c26161, 0x5f6a3535, 0xf9ae5757, 0xd069b9b9, 0x91178686, 0x5899c1c1, 0x273a1d1d, 0xb9279e9e, 0x38d9e1e1, 0x13ebf8f8, 0xb32b9898, 0x33221111, 0xbbd26969, 0x70a9d9d9, 0x89078e8e, 0xa7339494, 0xb62d9b9b, 0x223c1e1e, 0x92158787, 0x20c9e9e9, 0x4987cece, 0xffaa5555, 0x78502828, 0x7aa5dfdf, 0x8f038c8c, 0xf859a1a1, 0x80098989, 0x171a0d0d, 0xda65bfbf, 0x31d7e6e6, 0xc6844242, 0xb8d06868, 0xc3824141, 0xb0299999, 0x775a2d2d, 0x111e0f0f, 0xcb7bb0b0, 0xfca85454, 0xd66dbbbb, 0x3a2c1616];
	    var T3 = [0x63a5c663, 0x7c84f87c, 0x7799ee77, 0x7b8df67b, 0xf20dfff2, 0x6bbdd66b, 0x6fb1de6f, 0xc55491c5, 0x30506030, 0x01030201, 0x67a9ce67, 0x2b7d562b, 0xfe19e7fe, 0xd762b5d7, 0xabe64dab, 0x769aec76, 0xca458fca, 0x829d1f82, 0xc94089c9, 0x7d87fa7d, 0xfa15effa, 0x59ebb259, 0x47c98e47, 0xf00bfbf0, 0xadec41ad, 0xd467b3d4, 0xa2fd5fa2, 0xafea45af, 0x9cbf239c, 0xa4f753a4, 0x7296e472, 0xc05b9bc0, 0xb7c275b7, 0xfd1ce1fd, 0x93ae3d93, 0x266a4c26, 0x365a6c36, 0x3f417e3f, 0xf702f5f7, 0xcc4f83cc, 0x345c6834, 0xa5f451a5, 0xe534d1e5, 0xf108f9f1, 0x7193e271, 0xd873abd8, 0x31536231, 0x153f2a15, 0x040c0804, 0xc75295c7, 0x23654623, 0xc35e9dc3, 0x18283018, 0x96a13796, 0x050f0a05, 0x9ab52f9a, 0x07090e07, 0x12362412, 0x809b1b80, 0xe23ddfe2, 0xeb26cdeb, 0x27694e27, 0xb2cd7fb2, 0x759fea75, 0x091b1209, 0x839e1d83, 0x2c74582c, 0x1a2e341a, 0x1b2d361b, 0x6eb2dc6e, 0x5aeeb45a, 0xa0fb5ba0, 0x52f6a452, 0x3b4d763b, 0xd661b7d6, 0xb3ce7db3, 0x297b5229, 0xe33edde3, 0x2f715e2f, 0x84971384, 0x53f5a653, 0xd168b9d1, 0x00000000, 0xed2cc1ed, 0x20604020, 0xfc1fe3fc, 0xb1c879b1, 0x5bedb65b, 0x6abed46a, 0xcb468dcb, 0xbed967be, 0x394b7239, 0x4ade944a, 0x4cd4984c, 0x58e8b058, 0xcf4a85cf, 0xd06bbbd0, 0xef2ac5ef, 0xaae54faa, 0xfb16edfb, 0x43c58643, 0x4dd79a4d, 0x33556633, 0x85941185, 0x45cf8a45, 0xf910e9f9, 0x02060402, 0x7f81fe7f, 0x50f0a050, 0x3c44783c, 0x9fba259f, 0xa8e34ba8, 0x51f3a251, 0xa3fe5da3, 0x40c08040, 0x8f8a058f, 0x92ad3f92, 0x9dbc219d, 0x38487038, 0xf504f1f5, 0xbcdf63bc, 0xb6c177b6, 0xda75afda, 0x21634221, 0x10302010, 0xff1ae5ff, 0xf30efdf3, 0xd26dbfd2, 0xcd4c81cd, 0x0c14180c, 0x13352613, 0xec2fc3ec, 0x5fe1be5f, 0x97a23597, 0x44cc8844, 0x17392e17, 0xc45793c4, 0xa7f255a7, 0x7e82fc7e, 0x3d477a3d, 0x64acc864, 0x5de7ba5d, 0x192b3219, 0x7395e673, 0x60a0c060, 0x81981981, 0x4fd19e4f, 0xdc7fa3dc, 0x22664422, 0x2a7e542a, 0x90ab3b90, 0x88830b88, 0x46ca8c46, 0xee29c7ee, 0xb8d36bb8, 0x143c2814, 0xde79a7de, 0x5ee2bc5e, 0x0b1d160b, 0xdb76addb, 0xe03bdbe0, 0x32566432, 0x3a4e743a, 0x0a1e140a, 0x49db9249, 0x060a0c06, 0x246c4824, 0x5ce4b85c, 0xc25d9fc2, 0xd36ebdd3, 0xacef43ac, 0x62a6c462, 0x91a83991, 0x95a43195, 0xe437d3e4, 0x798bf279, 0xe732d5e7, 0xc8438bc8, 0x37596e37, 0x6db7da6d, 0x8d8c018d, 0xd564b1d5, 0x4ed29c4e, 0xa9e049a9, 0x6cb4d86c, 0x56faac56, 0xf407f3f4, 0xea25cfea, 0x65afca65, 0x7a8ef47a, 0xaee947ae, 0x08181008, 0xbad56fba, 0x7888f078, 0x256f4a25, 0x2e725c2e, 0x1c24381c, 0xa6f157a6, 0xb4c773b4, 0xc65197c6, 0xe823cbe8, 0xdd7ca1dd, 0x749ce874, 0x1f213e1f, 0x4bdd964b, 0xbddc61bd, 0x8b860d8b, 0x8a850f8a, 0x7090e070, 0x3e427c3e, 0xb5c471b5, 0x66aacc66, 0x48d89048, 0x03050603, 0xf601f7f6, 0x0e121c0e, 0x61a3c261, 0x355f6a35, 0x57f9ae57, 0xb9d069b9, 0x86911786, 0xc15899c1, 0x1d273a1d, 0x9eb9279e, 0xe138d9e1, 0xf813ebf8, 0x98b32b98, 0x11332211, 0x69bbd269, 0xd970a9d9, 0x8e89078e, 0x94a73394, 0x9bb62d9b, 0x1e223c1e, 0x87921587, 0xe920c9e9, 0xce4987ce, 0x55ffaa55, 0x28785028, 0xdf7aa5df, 0x8c8f038c, 0xa1f859a1, 0x89800989, 0x0d171a0d, 0xbfda65bf, 0xe631d7e6, 0x42c68442, 0x68b8d068, 0x41c38241, 0x99b02999, 0x2d775a2d, 0x0f111e0f, 0xb0cb7bb0, 0x54fca854, 0xbbd66dbb, 0x163a2c16];
	    var T4 = [0x6363a5c6, 0x7c7c84f8, 0x777799ee, 0x7b7b8df6, 0xf2f20dff, 0x6b6bbdd6, 0x6f6fb1de, 0xc5c55491, 0x30305060, 0x01010302, 0x6767a9ce, 0x2b2b7d56, 0xfefe19e7, 0xd7d762b5, 0xababe64d, 0x76769aec, 0xcaca458f, 0x82829d1f, 0xc9c94089, 0x7d7d87fa, 0xfafa15ef, 0x5959ebb2, 0x4747c98e, 0xf0f00bfb, 0xadadec41, 0xd4d467b3, 0xa2a2fd5f, 0xafafea45, 0x9c9cbf23, 0xa4a4f753, 0x727296e4, 0xc0c05b9b, 0xb7b7c275, 0xfdfd1ce1, 0x9393ae3d, 0x26266a4c, 0x36365a6c, 0x3f3f417e, 0xf7f702f5, 0xcccc4f83, 0x34345c68, 0xa5a5f451, 0xe5e534d1, 0xf1f108f9, 0x717193e2, 0xd8d873ab, 0x31315362, 0x15153f2a, 0x04040c08, 0xc7c75295, 0x23236546, 0xc3c35e9d, 0x18182830, 0x9696a137, 0x05050f0a, 0x9a9ab52f, 0x0707090e, 0x12123624, 0x80809b1b, 0xe2e23ddf, 0xebeb26cd, 0x2727694e, 0xb2b2cd7f, 0x75759fea, 0x09091b12, 0x83839e1d, 0x2c2c7458, 0x1a1a2e34, 0x1b1b2d36, 0x6e6eb2dc, 0x5a5aeeb4, 0xa0a0fb5b, 0x5252f6a4, 0x3b3b4d76, 0xd6d661b7, 0xb3b3ce7d, 0x29297b52, 0xe3e33edd, 0x2f2f715e, 0x84849713, 0x5353f5a6, 0xd1d168b9, 0x00000000, 0xeded2cc1, 0x20206040, 0xfcfc1fe3, 0xb1b1c879, 0x5b5bedb6, 0x6a6abed4, 0xcbcb468d, 0xbebed967, 0x39394b72, 0x4a4ade94, 0x4c4cd498, 0x5858e8b0, 0xcfcf4a85, 0xd0d06bbb, 0xefef2ac5, 0xaaaae54f, 0xfbfb16ed, 0x4343c586, 0x4d4dd79a, 0x33335566, 0x85859411, 0x4545cf8a, 0xf9f910e9, 0x02020604, 0x7f7f81fe, 0x5050f0a0, 0x3c3c4478, 0x9f9fba25, 0xa8a8e34b, 0x5151f3a2, 0xa3a3fe5d, 0x4040c080, 0x8f8f8a05, 0x9292ad3f, 0x9d9dbc21, 0x38384870, 0xf5f504f1, 0xbcbcdf63, 0xb6b6c177, 0xdada75af, 0x21216342, 0x10103020, 0xffff1ae5, 0xf3f30efd, 0xd2d26dbf, 0xcdcd4c81, 0x0c0c1418, 0x13133526, 0xecec2fc3, 0x5f5fe1be, 0x9797a235, 0x4444cc88, 0x1717392e, 0xc4c45793, 0xa7a7f255, 0x7e7e82fc, 0x3d3d477a, 0x6464acc8, 0x5d5de7ba, 0x19192b32, 0x737395e6, 0x6060a0c0, 0x81819819, 0x4f4fd19e, 0xdcdc7fa3, 0x22226644, 0x2a2a7e54, 0x9090ab3b, 0x8888830b, 0x4646ca8c, 0xeeee29c7, 0xb8b8d36b, 0x14143c28, 0xdede79a7, 0x5e5ee2bc, 0x0b0b1d16, 0xdbdb76ad, 0xe0e03bdb, 0x32325664, 0x3a3a4e74, 0x0a0a1e14, 0x4949db92, 0x06060a0c, 0x24246c48, 0x5c5ce4b8, 0xc2c25d9f, 0xd3d36ebd, 0xacacef43, 0x6262a6c4, 0x9191a839, 0x9595a431, 0xe4e437d3, 0x79798bf2, 0xe7e732d5, 0xc8c8438b, 0x3737596e, 0x6d6db7da, 0x8d8d8c01, 0xd5d564b1, 0x4e4ed29c, 0xa9a9e049, 0x6c6cb4d8, 0x5656faac, 0xf4f407f3, 0xeaea25cf, 0x6565afca, 0x7a7a8ef4, 0xaeaee947, 0x08081810, 0xbabad56f, 0x787888f0, 0x25256f4a, 0x2e2e725c, 0x1c1c2438, 0xa6a6f157, 0xb4b4c773, 0xc6c65197, 0xe8e823cb, 0xdddd7ca1, 0x74749ce8, 0x1f1f213e, 0x4b4bdd96, 0xbdbddc61, 0x8b8b860d, 0x8a8a850f, 0x707090e0, 0x3e3e427c, 0xb5b5c471, 0x6666aacc, 0x4848d890, 0x03030506, 0xf6f601f7, 0x0e0e121c, 0x6161a3c2, 0x35355f6a, 0x5757f9ae, 0xb9b9d069, 0x86869117, 0xc1c15899, 0x1d1d273a, 0x9e9eb927, 0xe1e138d9, 0xf8f813eb, 0x9898b32b, 0x11113322, 0x6969bbd2, 0xd9d970a9, 0x8e8e8907, 0x9494a733, 0x9b9bb62d, 0x1e1e223c, 0x87879215, 0xe9e920c9, 0xcece4987, 0x5555ffaa, 0x28287850, 0xdfdf7aa5, 0x8c8c8f03, 0xa1a1f859, 0x89898009, 0x0d0d171a, 0xbfbfda65, 0xe6e631d7, 0x4242c684, 0x6868b8d0, 0x4141c382, 0x9999b029, 0x2d2d775a, 0x0f0f111e, 0xb0b0cb7b, 0x5454fca8, 0xbbbbd66d, 0x16163a2c];

	    // Transformations for decryption
	    var T5 = [0x51f4a750, 0x7e416553, 0x1a17a4c3, 0x3a275e96, 0x3bab6bcb, 0x1f9d45f1, 0xacfa58ab, 0x4be30393, 0x2030fa55, 0xad766df6, 0x88cc7691, 0xf5024c25, 0x4fe5d7fc, 0xc52acbd7, 0x26354480, 0xb562a38f, 0xdeb15a49, 0x25ba1b67, 0x45ea0e98, 0x5dfec0e1, 0xc32f7502, 0x814cf012, 0x8d4697a3, 0x6bd3f9c6, 0x038f5fe7, 0x15929c95, 0xbf6d7aeb, 0x955259da, 0xd4be832d, 0x587421d3, 0x49e06929, 0x8ec9c844, 0x75c2896a, 0xf48e7978, 0x99583e6b, 0x27b971dd, 0xbee14fb6, 0xf088ad17, 0xc920ac66, 0x7dce3ab4, 0x63df4a18, 0xe51a3182, 0x97513360, 0x62537f45, 0xb16477e0, 0xbb6bae84, 0xfe81a01c, 0xf9082b94, 0x70486858, 0x8f45fd19, 0x94de6c87, 0x527bf8b7, 0xab73d323, 0x724b02e2, 0xe31f8f57, 0x6655ab2a, 0xb2eb2807, 0x2fb5c203, 0x86c57b9a, 0xd33708a5, 0x302887f2, 0x23bfa5b2, 0x02036aba, 0xed16825c, 0x8acf1c2b, 0xa779b492, 0xf307f2f0, 0x4e69e2a1, 0x65daf4cd, 0x0605bed5, 0xd134621f, 0xc4a6fe8a, 0x342e539d, 0xa2f355a0, 0x058ae132, 0xa4f6eb75, 0x0b83ec39, 0x4060efaa, 0x5e719f06, 0xbd6e1051, 0x3e218af9, 0x96dd063d, 0xdd3e05ae, 0x4de6bd46, 0x91548db5, 0x71c45d05, 0x0406d46f, 0x605015ff, 0x1998fb24, 0xd6bde997, 0x894043cc, 0x67d99e77, 0xb0e842bd, 0x07898b88, 0xe7195b38, 0x79c8eedb, 0xa17c0a47, 0x7c420fe9, 0xf8841ec9, 0x00000000, 0x09808683, 0x322bed48, 0x1e1170ac, 0x6c5a724e, 0xfd0efffb, 0x0f853856, 0x3daed51e, 0x362d3927, 0x0a0fd964, 0x685ca621, 0x9b5b54d1, 0x24362e3a, 0x0c0a67b1, 0x9357e70f, 0xb4ee96d2, 0x1b9b919e, 0x80c0c54f, 0x61dc20a2, 0x5a774b69, 0x1c121a16, 0xe293ba0a, 0xc0a02ae5, 0x3c22e043, 0x121b171d, 0x0e090d0b, 0xf28bc7ad, 0x2db6a8b9, 0x141ea9c8, 0x57f11985, 0xaf75074c, 0xee99ddbb, 0xa37f60fd, 0xf701269f, 0x5c72f5bc, 0x44663bc5, 0x5bfb7e34, 0x8b432976, 0xcb23c6dc, 0xb6edfc68, 0xb8e4f163, 0xd731dcca, 0x42638510, 0x13972240, 0x84c61120, 0x854a247d, 0xd2bb3df8, 0xaef93211, 0xc729a16d, 0x1d9e2f4b, 0xdcb230f3, 0x0d8652ec, 0x77c1e3d0, 0x2bb3166c, 0xa970b999, 0x119448fa, 0x47e96422, 0xa8fc8cc4, 0xa0f03f1a, 0x567d2cd8, 0x223390ef, 0x87494ec7, 0xd938d1c1, 0x8ccaa2fe, 0x98d40b36, 0xa6f581cf, 0xa57ade28, 0xdab78e26, 0x3fadbfa4, 0x2c3a9de4, 0x5078920d, 0x6a5fcc9b, 0x547e4662, 0xf68d13c2, 0x90d8b8e8, 0x2e39f75e, 0x82c3aff5, 0x9f5d80be, 0x69d0937c, 0x6fd52da9, 0xcf2512b3, 0xc8ac993b, 0x10187da7, 0xe89c636e, 0xdb3bbb7b, 0xcd267809, 0x6e5918f4, 0xec9ab701, 0x834f9aa8, 0xe6956e65, 0xaaffe67e, 0x21bccf08, 0xef15e8e6, 0xbae79bd9, 0x4a6f36ce, 0xea9f09d4, 0x29b07cd6, 0x31a4b2af, 0x2a3f2331, 0xc6a59430, 0x35a266c0, 0x744ebc37, 0xfc82caa6, 0xe090d0b0, 0x33a7d815, 0xf104984a, 0x41ecdaf7, 0x7fcd500e, 0x1791f62f, 0x764dd68d, 0x43efb04d, 0xccaa4d54, 0xe49604df, 0x9ed1b5e3, 0x4c6a881b, 0xc12c1fb8, 0x4665517f, 0x9d5eea04, 0x018c355d, 0xfa877473, 0xfb0b412e, 0xb3671d5a, 0x92dbd252, 0xe9105633, 0x6dd64713, 0x9ad7618c, 0x37a10c7a, 0x59f8148e, 0xeb133c89, 0xcea927ee, 0xb761c935, 0xe11ce5ed, 0x7a47b13c, 0x9cd2df59, 0x55f2733f, 0x1814ce79, 0x73c737bf, 0x53f7cdea, 0x5ffdaa5b, 0xdf3d6f14, 0x7844db86, 0xcaaff381, 0xb968c43e, 0x3824342c, 0xc2a3405f, 0x161dc372, 0xbce2250c, 0x283c498b, 0xff0d9541, 0x39a80171, 0x080cb3de, 0xd8b4e49c, 0x6456c190, 0x7bcb8461, 0xd532b670, 0x486c5c74, 0xd0b85742];
	    var T6 = [0x5051f4a7, 0x537e4165, 0xc31a17a4, 0x963a275e, 0xcb3bab6b, 0xf11f9d45, 0xabacfa58, 0x934be303, 0x552030fa, 0xf6ad766d, 0x9188cc76, 0x25f5024c, 0xfc4fe5d7, 0xd7c52acb, 0x80263544, 0x8fb562a3, 0x49deb15a, 0x6725ba1b, 0x9845ea0e, 0xe15dfec0, 0x02c32f75, 0x12814cf0, 0xa38d4697, 0xc66bd3f9, 0xe7038f5f, 0x9515929c, 0xebbf6d7a, 0xda955259, 0x2dd4be83, 0xd3587421, 0x2949e069, 0x448ec9c8, 0x6a75c289, 0x78f48e79, 0x6b99583e, 0xdd27b971, 0xb6bee14f, 0x17f088ad, 0x66c920ac, 0xb47dce3a, 0x1863df4a, 0x82e51a31, 0x60975133, 0x4562537f, 0xe0b16477, 0x84bb6bae, 0x1cfe81a0, 0x94f9082b, 0x58704868, 0x198f45fd, 0x8794de6c, 0xb7527bf8, 0x23ab73d3, 0xe2724b02, 0x57e31f8f, 0x2a6655ab, 0x07b2eb28, 0x032fb5c2, 0x9a86c57b, 0xa5d33708, 0xf2302887, 0xb223bfa5, 0xba02036a, 0x5ced1682, 0x2b8acf1c, 0x92a779b4, 0xf0f307f2, 0xa14e69e2, 0xcd65daf4, 0xd50605be, 0x1fd13462, 0x8ac4a6fe, 0x9d342e53, 0xa0a2f355, 0x32058ae1, 0x75a4f6eb, 0x390b83ec, 0xaa4060ef, 0x065e719f, 0x51bd6e10, 0xf93e218a, 0x3d96dd06, 0xaedd3e05, 0x464de6bd, 0xb591548d, 0x0571c45d, 0x6f0406d4, 0xff605015, 0x241998fb, 0x97d6bde9, 0xcc894043, 0x7767d99e, 0xbdb0e842, 0x8807898b, 0x38e7195b, 0xdb79c8ee, 0x47a17c0a, 0xe97c420f, 0xc9f8841e, 0x00000000, 0x83098086, 0x48322bed, 0xac1e1170, 0x4e6c5a72, 0xfbfd0eff, 0x560f8538, 0x1e3daed5, 0x27362d39, 0x640a0fd9, 0x21685ca6, 0xd19b5b54, 0x3a24362e, 0xb10c0a67, 0x0f9357e7, 0xd2b4ee96, 0x9e1b9b91, 0x4f80c0c5, 0xa261dc20, 0x695a774b, 0x161c121a, 0x0ae293ba, 0xe5c0a02a, 0x433c22e0, 0x1d121b17, 0x0b0e090d, 0xadf28bc7, 0xb92db6a8, 0xc8141ea9, 0x8557f119, 0x4caf7507, 0xbbee99dd, 0xfda37f60, 0x9ff70126, 0xbc5c72f5, 0xc544663b, 0x345bfb7e, 0x768b4329, 0xdccb23c6, 0x68b6edfc, 0x63b8e4f1, 0xcad731dc, 0x10426385, 0x40139722, 0x2084c611, 0x7d854a24, 0xf8d2bb3d, 0x11aef932, 0x6dc729a1, 0x4b1d9e2f, 0xf3dcb230, 0xec0d8652, 0xd077c1e3, 0x6c2bb316, 0x99a970b9, 0xfa119448, 0x2247e964, 0xc4a8fc8c, 0x1aa0f03f, 0xd8567d2c, 0xef223390, 0xc787494e, 0xc1d938d1, 0xfe8ccaa2, 0x3698d40b, 0xcfa6f581, 0x28a57ade, 0x26dab78e, 0xa43fadbf, 0xe42c3a9d, 0x0d507892, 0x9b6a5fcc, 0x62547e46, 0xc2f68d13, 0xe890d8b8, 0x5e2e39f7, 0xf582c3af, 0xbe9f5d80, 0x7c69d093, 0xa96fd52d, 0xb3cf2512, 0x3bc8ac99, 0xa710187d, 0x6ee89c63, 0x7bdb3bbb, 0x09cd2678, 0xf46e5918, 0x01ec9ab7, 0xa8834f9a, 0x65e6956e, 0x7eaaffe6, 0x0821bccf, 0xe6ef15e8, 0xd9bae79b, 0xce4a6f36, 0xd4ea9f09, 0xd629b07c, 0xaf31a4b2, 0x312a3f23, 0x30c6a594, 0xc035a266, 0x37744ebc, 0xa6fc82ca, 0xb0e090d0, 0x1533a7d8, 0x4af10498, 0xf741ecda, 0x0e7fcd50, 0x2f1791f6, 0x8d764dd6, 0x4d43efb0, 0x54ccaa4d, 0xdfe49604, 0xe39ed1b5, 0x1b4c6a88, 0xb8c12c1f, 0x7f466551, 0x049d5eea, 0x5d018c35, 0x73fa8774, 0x2efb0b41, 0x5ab3671d, 0x5292dbd2, 0x33e91056, 0x136dd647, 0x8c9ad761, 0x7a37a10c, 0x8e59f814, 0x89eb133c, 0xeecea927, 0x35b761c9, 0xede11ce5, 0x3c7a47b1, 0x599cd2df, 0x3f55f273, 0x791814ce, 0xbf73c737, 0xea53f7cd, 0x5b5ffdaa, 0x14df3d6f, 0x867844db, 0x81caaff3, 0x3eb968c4, 0x2c382434, 0x5fc2a340, 0x72161dc3, 0x0cbce225, 0x8b283c49, 0x41ff0d95, 0x7139a801, 0xde080cb3, 0x9cd8b4e4, 0x906456c1, 0x617bcb84, 0x70d532b6, 0x74486c5c, 0x42d0b857];
	    var T7 = [0xa75051f4, 0x65537e41, 0xa4c31a17, 0x5e963a27, 0x6bcb3bab, 0x45f11f9d, 0x58abacfa, 0x03934be3, 0xfa552030, 0x6df6ad76, 0x769188cc, 0x4c25f502, 0xd7fc4fe5, 0xcbd7c52a, 0x44802635, 0xa38fb562, 0x5a49deb1, 0x1b6725ba, 0x0e9845ea, 0xc0e15dfe, 0x7502c32f, 0xf012814c, 0x97a38d46, 0xf9c66bd3, 0x5fe7038f, 0x9c951592, 0x7aebbf6d, 0x59da9552, 0x832dd4be, 0x21d35874, 0x692949e0, 0xc8448ec9, 0x896a75c2, 0x7978f48e, 0x3e6b9958, 0x71dd27b9, 0x4fb6bee1, 0xad17f088, 0xac66c920, 0x3ab47dce, 0x4a1863df, 0x3182e51a, 0x33609751, 0x7f456253, 0x77e0b164, 0xae84bb6b, 0xa01cfe81, 0x2b94f908, 0x68587048, 0xfd198f45, 0x6c8794de, 0xf8b7527b, 0xd323ab73, 0x02e2724b, 0x8f57e31f, 0xab2a6655, 0x2807b2eb, 0xc2032fb5, 0x7b9a86c5, 0x08a5d337, 0x87f23028, 0xa5b223bf, 0x6aba0203, 0x825ced16, 0x1c2b8acf, 0xb492a779, 0xf2f0f307, 0xe2a14e69, 0xf4cd65da, 0xbed50605, 0x621fd134, 0xfe8ac4a6, 0x539d342e, 0x55a0a2f3, 0xe132058a, 0xeb75a4f6, 0xec390b83, 0xefaa4060, 0x9f065e71, 0x1051bd6e, 0x8af93e21, 0x063d96dd, 0x05aedd3e, 0xbd464de6, 0x8db59154, 0x5d0571c4, 0xd46f0406, 0x15ff6050, 0xfb241998, 0xe997d6bd, 0x43cc8940, 0x9e7767d9, 0x42bdb0e8, 0x8b880789, 0x5b38e719, 0xeedb79c8, 0x0a47a17c, 0x0fe97c42, 0x1ec9f884, 0x00000000, 0x86830980, 0xed48322b, 0x70ac1e11, 0x724e6c5a, 0xfffbfd0e, 0x38560f85, 0xd51e3dae, 0x3927362d, 0xd9640a0f, 0xa621685c, 0x54d19b5b, 0x2e3a2436, 0x67b10c0a, 0xe70f9357, 0x96d2b4ee, 0x919e1b9b, 0xc54f80c0, 0x20a261dc, 0x4b695a77, 0x1a161c12, 0xba0ae293, 0x2ae5c0a0, 0xe0433c22, 0x171d121b, 0x0d0b0e09, 0xc7adf28b, 0xa8b92db6, 0xa9c8141e, 0x198557f1, 0x074caf75, 0xddbbee99, 0x60fda37f, 0x269ff701, 0xf5bc5c72, 0x3bc54466, 0x7e345bfb, 0x29768b43, 0xc6dccb23, 0xfc68b6ed, 0xf163b8e4, 0xdccad731, 0x85104263, 0x22401397, 0x112084c6, 0x247d854a, 0x3df8d2bb, 0x3211aef9, 0xa16dc729, 0x2f4b1d9e, 0x30f3dcb2, 0x52ec0d86, 0xe3d077c1, 0x166c2bb3, 0xb999a970, 0x48fa1194, 0x642247e9, 0x8cc4a8fc, 0x3f1aa0f0, 0x2cd8567d, 0x90ef2233, 0x4ec78749, 0xd1c1d938, 0xa2fe8cca, 0x0b3698d4, 0x81cfa6f5, 0xde28a57a, 0x8e26dab7, 0xbfa43fad, 0x9de42c3a, 0x920d5078, 0xcc9b6a5f, 0x4662547e, 0x13c2f68d, 0xb8e890d8, 0xf75e2e39, 0xaff582c3, 0x80be9f5d, 0x937c69d0, 0x2da96fd5, 0x12b3cf25, 0x993bc8ac, 0x7da71018, 0x636ee89c, 0xbb7bdb3b, 0x7809cd26, 0x18f46e59, 0xb701ec9a, 0x9aa8834f, 0x6e65e695, 0xe67eaaff, 0xcf0821bc, 0xe8e6ef15, 0x9bd9bae7, 0x36ce4a6f, 0x09d4ea9f, 0x7cd629b0, 0xb2af31a4, 0x23312a3f, 0x9430c6a5, 0x66c035a2, 0xbc37744e, 0xcaa6fc82, 0xd0b0e090, 0xd81533a7, 0x984af104, 0xdaf741ec, 0x500e7fcd, 0xf62f1791, 0xd68d764d, 0xb04d43ef, 0x4d54ccaa, 0x04dfe496, 0xb5e39ed1, 0x881b4c6a, 0x1fb8c12c, 0x517f4665, 0xea049d5e, 0x355d018c, 0x7473fa87, 0x412efb0b, 0x1d5ab367, 0xd25292db, 0x5633e910, 0x47136dd6, 0x618c9ad7, 0x0c7a37a1, 0x148e59f8, 0x3c89eb13, 0x27eecea9, 0xc935b761, 0xe5ede11c, 0xb13c7a47, 0xdf599cd2, 0x733f55f2, 0xce791814, 0x37bf73c7, 0xcdea53f7, 0xaa5b5ffd, 0x6f14df3d, 0xdb867844, 0xf381caaf, 0xc43eb968, 0x342c3824, 0x405fc2a3, 0xc372161d, 0x250cbce2, 0x498b283c, 0x9541ff0d, 0x017139a8, 0xb3de080c, 0xe49cd8b4, 0xc1906456, 0x84617bcb, 0xb670d532, 0x5c74486c, 0x5742d0b8];
	    var T8 = [0xf4a75051, 0x4165537e, 0x17a4c31a, 0x275e963a, 0xab6bcb3b, 0x9d45f11f, 0xfa58abac, 0xe303934b, 0x30fa5520, 0x766df6ad, 0xcc769188, 0x024c25f5, 0xe5d7fc4f, 0x2acbd7c5, 0x35448026, 0x62a38fb5, 0xb15a49de, 0xba1b6725, 0xea0e9845, 0xfec0e15d, 0x2f7502c3, 0x4cf01281, 0x4697a38d, 0xd3f9c66b, 0x8f5fe703, 0x929c9515, 0x6d7aebbf, 0x5259da95, 0xbe832dd4, 0x7421d358, 0xe0692949, 0xc9c8448e, 0xc2896a75, 0x8e7978f4, 0x583e6b99, 0xb971dd27, 0xe14fb6be, 0x88ad17f0, 0x20ac66c9, 0xce3ab47d, 0xdf4a1863, 0x1a3182e5, 0x51336097, 0x537f4562, 0x6477e0b1, 0x6bae84bb, 0x81a01cfe, 0x082b94f9, 0x48685870, 0x45fd198f, 0xde6c8794, 0x7bf8b752, 0x73d323ab, 0x4b02e272, 0x1f8f57e3, 0x55ab2a66, 0xeb2807b2, 0xb5c2032f, 0xc57b9a86, 0x3708a5d3, 0x2887f230, 0xbfa5b223, 0x036aba02, 0x16825ced, 0xcf1c2b8a, 0x79b492a7, 0x07f2f0f3, 0x69e2a14e, 0xdaf4cd65, 0x05bed506, 0x34621fd1, 0xa6fe8ac4, 0x2e539d34, 0xf355a0a2, 0x8ae13205, 0xf6eb75a4, 0x83ec390b, 0x60efaa40, 0x719f065e, 0x6e1051bd, 0x218af93e, 0xdd063d96, 0x3e05aedd, 0xe6bd464d, 0x548db591, 0xc45d0571, 0x06d46f04, 0x5015ff60, 0x98fb2419, 0xbde997d6, 0x4043cc89, 0xd99e7767, 0xe842bdb0, 0x898b8807, 0x195b38e7, 0xc8eedb79, 0x7c0a47a1, 0x420fe97c, 0x841ec9f8, 0x00000000, 0x80868309, 0x2bed4832, 0x1170ac1e, 0x5a724e6c, 0x0efffbfd, 0x8538560f, 0xaed51e3d, 0x2d392736, 0x0fd9640a, 0x5ca62168, 0x5b54d19b, 0x362e3a24, 0x0a67b10c, 0x57e70f93, 0xee96d2b4, 0x9b919e1b, 0xc0c54f80, 0xdc20a261, 0x774b695a, 0x121a161c, 0x93ba0ae2, 0xa02ae5c0, 0x22e0433c, 0x1b171d12, 0x090d0b0e, 0x8bc7adf2, 0xb6a8b92d, 0x1ea9c814, 0xf1198557, 0x75074caf, 0x99ddbbee, 0x7f60fda3, 0x01269ff7, 0x72f5bc5c, 0x663bc544, 0xfb7e345b, 0x4329768b, 0x23c6dccb, 0xedfc68b6, 0xe4f163b8, 0x31dccad7, 0x63851042, 0x97224013, 0xc6112084, 0x4a247d85, 0xbb3df8d2, 0xf93211ae, 0x29a16dc7, 0x9e2f4b1d, 0xb230f3dc, 0x8652ec0d, 0xc1e3d077, 0xb3166c2b, 0x70b999a9, 0x9448fa11, 0xe9642247, 0xfc8cc4a8, 0xf03f1aa0, 0x7d2cd856, 0x3390ef22, 0x494ec787, 0x38d1c1d9, 0xcaa2fe8c, 0xd40b3698, 0xf581cfa6, 0x7ade28a5, 0xb78e26da, 0xadbfa43f, 0x3a9de42c, 0x78920d50, 0x5fcc9b6a, 0x7e466254, 0x8d13c2f6, 0xd8b8e890, 0x39f75e2e, 0xc3aff582, 0x5d80be9f, 0xd0937c69, 0xd52da96f, 0x2512b3cf, 0xac993bc8, 0x187da710, 0x9c636ee8, 0x3bbb7bdb, 0x267809cd, 0x5918f46e, 0x9ab701ec, 0x4f9aa883, 0x956e65e6, 0xffe67eaa, 0xbccf0821, 0x15e8e6ef, 0xe79bd9ba, 0x6f36ce4a, 0x9f09d4ea, 0xb07cd629, 0xa4b2af31, 0x3f23312a, 0xa59430c6, 0xa266c035, 0x4ebc3774, 0x82caa6fc, 0x90d0b0e0, 0xa7d81533, 0x04984af1, 0xecdaf741, 0xcd500e7f, 0x91f62f17, 0x4dd68d76, 0xefb04d43, 0xaa4d54cc, 0x9604dfe4, 0xd1b5e39e, 0x6a881b4c, 0x2c1fb8c1, 0x65517f46, 0x5eea049d, 0x8c355d01, 0x877473fa, 0x0b412efb, 0x671d5ab3, 0xdbd25292, 0x105633e9, 0xd647136d, 0xd7618c9a, 0xa10c7a37, 0xf8148e59, 0x133c89eb, 0xa927eece, 0x61c935b7, 0x1ce5ede1, 0x47b13c7a, 0xd2df599c, 0xf2733f55, 0x14ce7918, 0xc737bf73, 0xf7cdea53, 0xfdaa5b5f, 0x3d6f14df, 0x44db8678, 0xaff381ca, 0x68c43eb9, 0x24342c38, 0xa3405fc2, 0x1dc37216, 0xe2250cbc, 0x3c498b28, 0x0d9541ff, 0xa8017139, 0x0cb3de08, 0xb4e49cd8, 0x56c19064, 0xcb84617b, 0x32b670d5, 0x6c5c7448, 0xb85742d0];

	    // Transformations for decryption key expansion
	    var U1 = [0x00000000, 0x0e090d0b, 0x1c121a16, 0x121b171d, 0x3824342c, 0x362d3927, 0x24362e3a, 0x2a3f2331, 0x70486858, 0x7e416553, 0x6c5a724e, 0x62537f45, 0x486c5c74, 0x4665517f, 0x547e4662, 0x5a774b69, 0xe090d0b0, 0xee99ddbb, 0xfc82caa6, 0xf28bc7ad, 0xd8b4e49c, 0xd6bde997, 0xc4a6fe8a, 0xcaaff381, 0x90d8b8e8, 0x9ed1b5e3, 0x8ccaa2fe, 0x82c3aff5, 0xa8fc8cc4, 0xa6f581cf, 0xb4ee96d2, 0xbae79bd9, 0xdb3bbb7b, 0xd532b670, 0xc729a16d, 0xc920ac66, 0xe31f8f57, 0xed16825c, 0xff0d9541, 0xf104984a, 0xab73d323, 0xa57ade28, 0xb761c935, 0xb968c43e, 0x9357e70f, 0x9d5eea04, 0x8f45fd19, 0x814cf012, 0x3bab6bcb, 0x35a266c0, 0x27b971dd, 0x29b07cd6, 0x038f5fe7, 0x0d8652ec, 0x1f9d45f1, 0x119448fa, 0x4be30393, 0x45ea0e98, 0x57f11985, 0x59f8148e, 0x73c737bf, 0x7dce3ab4, 0x6fd52da9, 0x61dc20a2, 0xad766df6, 0xa37f60fd, 0xb16477e0, 0xbf6d7aeb, 0x955259da, 0x9b5b54d1, 0x894043cc, 0x87494ec7, 0xdd3e05ae, 0xd33708a5, 0xc12c1fb8, 0xcf2512b3, 0xe51a3182, 0xeb133c89, 0xf9082b94, 0xf701269f, 0x4de6bd46, 0x43efb04d, 0x51f4a750, 0x5ffdaa5b, 0x75c2896a, 0x7bcb8461, 0x69d0937c, 0x67d99e77, 0x3daed51e, 0x33a7d815, 0x21bccf08, 0x2fb5c203, 0x058ae132, 0x0b83ec39, 0x1998fb24, 0x1791f62f, 0x764dd68d, 0x7844db86, 0x6a5fcc9b, 0x6456c190, 0x4e69e2a1, 0x4060efaa, 0x527bf8b7, 0x5c72f5bc, 0x0605bed5, 0x080cb3de, 0x1a17a4c3, 0x141ea9c8, 0x3e218af9, 0x302887f2, 0x223390ef, 0x2c3a9de4, 0x96dd063d, 0x98d40b36, 0x8acf1c2b, 0x84c61120, 0xaef93211, 0xa0f03f1a, 0xb2eb2807, 0xbce2250c, 0xe6956e65, 0xe89c636e, 0xfa877473, 0xf48e7978, 0xdeb15a49, 0xd0b85742, 0xc2a3405f, 0xccaa4d54, 0x41ecdaf7, 0x4fe5d7fc, 0x5dfec0e1, 0x53f7cdea, 0x79c8eedb, 0x77c1e3d0, 0x65daf4cd, 0x6bd3f9c6, 0x31a4b2af, 0x3fadbfa4, 0x2db6a8b9, 0x23bfa5b2, 0x09808683, 0x07898b88, 0x15929c95, 0x1b9b919e, 0xa17c0a47, 0xaf75074c, 0xbd6e1051, 0xb3671d5a, 0x99583e6b, 0x97513360, 0x854a247d, 0x8b432976, 0xd134621f, 0xdf3d6f14, 0xcd267809, 0xc32f7502, 0xe9105633, 0xe7195b38, 0xf5024c25, 0xfb0b412e, 0x9ad7618c, 0x94de6c87, 0x86c57b9a, 0x88cc7691, 0xa2f355a0, 0xacfa58ab, 0xbee14fb6, 0xb0e842bd, 0xea9f09d4, 0xe49604df, 0xf68d13c2, 0xf8841ec9, 0xd2bb3df8, 0xdcb230f3, 0xcea927ee, 0xc0a02ae5, 0x7a47b13c, 0x744ebc37, 0x6655ab2a, 0x685ca621, 0x42638510, 0x4c6a881b, 0x5e719f06, 0x5078920d, 0x0a0fd964, 0x0406d46f, 0x161dc372, 0x1814ce79, 0x322bed48, 0x3c22e043, 0x2e39f75e, 0x2030fa55, 0xec9ab701, 0xe293ba0a, 0xf088ad17, 0xfe81a01c, 0xd4be832d, 0xdab78e26, 0xc8ac993b, 0xc6a59430, 0x9cd2df59, 0x92dbd252, 0x80c0c54f, 0x8ec9c844, 0xa4f6eb75, 0xaaffe67e, 0xb8e4f163, 0xb6edfc68, 0x0c0a67b1, 0x02036aba, 0x10187da7, 0x1e1170ac, 0x342e539d, 0x3a275e96, 0x283c498b, 0x26354480, 0x7c420fe9, 0x724b02e2, 0x605015ff, 0x6e5918f4, 0x44663bc5, 0x4a6f36ce, 0x587421d3, 0x567d2cd8, 0x37a10c7a, 0x39a80171, 0x2bb3166c, 0x25ba1b67, 0x0f853856, 0x018c355d, 0x13972240, 0x1d9e2f4b, 0x47e96422, 0x49e06929, 0x5bfb7e34, 0x55f2733f, 0x7fcd500e, 0x71c45d05, 0x63df4a18, 0x6dd64713, 0xd731dcca, 0xd938d1c1, 0xcb23c6dc, 0xc52acbd7, 0xef15e8e6, 0xe11ce5ed, 0xf307f2f0, 0xfd0efffb, 0xa779b492, 0xa970b999, 0xbb6bae84, 0xb562a38f, 0x9f5d80be, 0x91548db5, 0x834f9aa8, 0x8d4697a3];
	    var U2 = [0x00000000, 0x0b0e090d, 0x161c121a, 0x1d121b17, 0x2c382434, 0x27362d39, 0x3a24362e, 0x312a3f23, 0x58704868, 0x537e4165, 0x4e6c5a72, 0x4562537f, 0x74486c5c, 0x7f466551, 0x62547e46, 0x695a774b, 0xb0e090d0, 0xbbee99dd, 0xa6fc82ca, 0xadf28bc7, 0x9cd8b4e4, 0x97d6bde9, 0x8ac4a6fe, 0x81caaff3, 0xe890d8b8, 0xe39ed1b5, 0xfe8ccaa2, 0xf582c3af, 0xc4a8fc8c, 0xcfa6f581, 0xd2b4ee96, 0xd9bae79b, 0x7bdb3bbb, 0x70d532b6, 0x6dc729a1, 0x66c920ac, 0x57e31f8f, 0x5ced1682, 0x41ff0d95, 0x4af10498, 0x23ab73d3, 0x28a57ade, 0x35b761c9, 0x3eb968c4, 0x0f9357e7, 0x049d5eea, 0x198f45fd, 0x12814cf0, 0xcb3bab6b, 0xc035a266, 0xdd27b971, 0xd629b07c, 0xe7038f5f, 0xec0d8652, 0xf11f9d45, 0xfa119448, 0x934be303, 0x9845ea0e, 0x8557f119, 0x8e59f814, 0xbf73c737, 0xb47dce3a, 0xa96fd52d, 0xa261dc20, 0xf6ad766d, 0xfda37f60, 0xe0b16477, 0xebbf6d7a, 0xda955259, 0xd19b5b54, 0xcc894043, 0xc787494e, 0xaedd3e05, 0xa5d33708, 0xb8c12c1f, 0xb3cf2512, 0x82e51a31, 0x89eb133c, 0x94f9082b, 0x9ff70126, 0x464de6bd, 0x4d43efb0, 0x5051f4a7, 0x5b5ffdaa, 0x6a75c289, 0x617bcb84, 0x7c69d093, 0x7767d99e, 0x1e3daed5, 0x1533a7d8, 0x0821bccf, 0x032fb5c2, 0x32058ae1, 0x390b83ec, 0x241998fb, 0x2f1791f6, 0x8d764dd6, 0x867844db, 0x9b6a5fcc, 0x906456c1, 0xa14e69e2, 0xaa4060ef, 0xb7527bf8, 0xbc5c72f5, 0xd50605be, 0xde080cb3, 0xc31a17a4, 0xc8141ea9, 0xf93e218a, 0xf2302887, 0xef223390, 0xe42c3a9d, 0x3d96dd06, 0x3698d40b, 0x2b8acf1c, 0x2084c611, 0x11aef932, 0x1aa0f03f, 0x07b2eb28, 0x0cbce225, 0x65e6956e, 0x6ee89c63, 0x73fa8774, 0x78f48e79, 0x49deb15a, 0x42d0b857, 0x5fc2a340, 0x54ccaa4d, 0xf741ecda, 0xfc4fe5d7, 0xe15dfec0, 0xea53f7cd, 0xdb79c8ee, 0xd077c1e3, 0xcd65daf4, 0xc66bd3f9, 0xaf31a4b2, 0xa43fadbf, 0xb92db6a8, 0xb223bfa5, 0x83098086, 0x8807898b, 0x9515929c, 0x9e1b9b91, 0x47a17c0a, 0x4caf7507, 0x51bd6e10, 0x5ab3671d, 0x6b99583e, 0x60975133, 0x7d854a24, 0x768b4329, 0x1fd13462, 0x14df3d6f, 0x09cd2678, 0x02c32f75, 0x33e91056, 0x38e7195b, 0x25f5024c, 0x2efb0b41, 0x8c9ad761, 0x8794de6c, 0x9a86c57b, 0x9188cc76, 0xa0a2f355, 0xabacfa58, 0xb6bee14f, 0xbdb0e842, 0xd4ea9f09, 0xdfe49604, 0xc2f68d13, 0xc9f8841e, 0xf8d2bb3d, 0xf3dcb230, 0xeecea927, 0xe5c0a02a, 0x3c7a47b1, 0x37744ebc, 0x2a6655ab, 0x21685ca6, 0x10426385, 0x1b4c6a88, 0x065e719f, 0x0d507892, 0x640a0fd9, 0x6f0406d4, 0x72161dc3, 0x791814ce, 0x48322bed, 0x433c22e0, 0x5e2e39f7, 0x552030fa, 0x01ec9ab7, 0x0ae293ba, 0x17f088ad, 0x1cfe81a0, 0x2dd4be83, 0x26dab78e, 0x3bc8ac99, 0x30c6a594, 0x599cd2df, 0x5292dbd2, 0x4f80c0c5, 0x448ec9c8, 0x75a4f6eb, 0x7eaaffe6, 0x63b8e4f1, 0x68b6edfc, 0xb10c0a67, 0xba02036a, 0xa710187d, 0xac1e1170, 0x9d342e53, 0x963a275e, 0x8b283c49, 0x80263544, 0xe97c420f, 0xe2724b02, 0xff605015, 0xf46e5918, 0xc544663b, 0xce4a6f36, 0xd3587421, 0xd8567d2c, 0x7a37a10c, 0x7139a801, 0x6c2bb316, 0x6725ba1b, 0x560f8538, 0x5d018c35, 0x40139722, 0x4b1d9e2f, 0x2247e964, 0x2949e069, 0x345bfb7e, 0x3f55f273, 0x0e7fcd50, 0x0571c45d, 0x1863df4a, 0x136dd647, 0xcad731dc, 0xc1d938d1, 0xdccb23c6, 0xd7c52acb, 0xe6ef15e8, 0xede11ce5, 0xf0f307f2, 0xfbfd0eff, 0x92a779b4, 0x99a970b9, 0x84bb6bae, 0x8fb562a3, 0xbe9f5d80, 0xb591548d, 0xa8834f9a, 0xa38d4697];
	    var U3 = [0x00000000, 0x0d0b0e09, 0x1a161c12, 0x171d121b, 0x342c3824, 0x3927362d, 0x2e3a2436, 0x23312a3f, 0x68587048, 0x65537e41, 0x724e6c5a, 0x7f456253, 0x5c74486c, 0x517f4665, 0x4662547e, 0x4b695a77, 0xd0b0e090, 0xddbbee99, 0xcaa6fc82, 0xc7adf28b, 0xe49cd8b4, 0xe997d6bd, 0xfe8ac4a6, 0xf381caaf, 0xb8e890d8, 0xb5e39ed1, 0xa2fe8cca, 0xaff582c3, 0x8cc4a8fc, 0x81cfa6f5, 0x96d2b4ee, 0x9bd9bae7, 0xbb7bdb3b, 0xb670d532, 0xa16dc729, 0xac66c920, 0x8f57e31f, 0x825ced16, 0x9541ff0d, 0x984af104, 0xd323ab73, 0xde28a57a, 0xc935b761, 0xc43eb968, 0xe70f9357, 0xea049d5e, 0xfd198f45, 0xf012814c, 0x6bcb3bab, 0x66c035a2, 0x71dd27b9, 0x7cd629b0, 0x5fe7038f, 0x52ec0d86, 0x45f11f9d, 0x48fa1194, 0x03934be3, 0x0e9845ea, 0x198557f1, 0x148e59f8, 0x37bf73c7, 0x3ab47dce, 0x2da96fd5, 0x20a261dc, 0x6df6ad76, 0x60fda37f, 0x77e0b164, 0x7aebbf6d, 0x59da9552, 0x54d19b5b, 0x43cc8940, 0x4ec78749, 0x05aedd3e, 0x08a5d337, 0x1fb8c12c, 0x12b3cf25, 0x3182e51a, 0x3c89eb13, 0x2b94f908, 0x269ff701, 0xbd464de6, 0xb04d43ef, 0xa75051f4, 0xaa5b5ffd, 0x896a75c2, 0x84617bcb, 0x937c69d0, 0x9e7767d9, 0xd51e3dae, 0xd81533a7, 0xcf0821bc, 0xc2032fb5, 0xe132058a, 0xec390b83, 0xfb241998, 0xf62f1791, 0xd68d764d, 0xdb867844, 0xcc9b6a5f, 0xc1906456, 0xe2a14e69, 0xefaa4060, 0xf8b7527b, 0xf5bc5c72, 0xbed50605, 0xb3de080c, 0xa4c31a17, 0xa9c8141e, 0x8af93e21, 0x87f23028, 0x90ef2233, 0x9de42c3a, 0x063d96dd, 0x0b3698d4, 0x1c2b8acf, 0x112084c6, 0x3211aef9, 0x3f1aa0f0, 0x2807b2eb, 0x250cbce2, 0x6e65e695, 0x636ee89c, 0x7473fa87, 0x7978f48e, 0x5a49deb1, 0x5742d0b8, 0x405fc2a3, 0x4d54ccaa, 0xdaf741ec, 0xd7fc4fe5, 0xc0e15dfe, 0xcdea53f7, 0xeedb79c8, 0xe3d077c1, 0xf4cd65da, 0xf9c66bd3, 0xb2af31a4, 0xbfa43fad, 0xa8b92db6, 0xa5b223bf, 0x86830980, 0x8b880789, 0x9c951592, 0x919e1b9b, 0x0a47a17c, 0x074caf75, 0x1051bd6e, 0x1d5ab367, 0x3e6b9958, 0x33609751, 0x247d854a, 0x29768b43, 0x621fd134, 0x6f14df3d, 0x7809cd26, 0x7502c32f, 0x5633e910, 0x5b38e719, 0x4c25f502, 0x412efb0b, 0x618c9ad7, 0x6c8794de, 0x7b9a86c5, 0x769188cc, 0x55a0a2f3, 0x58abacfa, 0x4fb6bee1, 0x42bdb0e8, 0x09d4ea9f, 0x04dfe496, 0x13c2f68d, 0x1ec9f884, 0x3df8d2bb, 0x30f3dcb2, 0x27eecea9, 0x2ae5c0a0, 0xb13c7a47, 0xbc37744e, 0xab2a6655, 0xa621685c, 0x85104263, 0x881b4c6a, 0x9f065e71, 0x920d5078, 0xd9640a0f, 0xd46f0406, 0xc372161d, 0xce791814, 0xed48322b, 0xe0433c22, 0xf75e2e39, 0xfa552030, 0xb701ec9a, 0xba0ae293, 0xad17f088, 0xa01cfe81, 0x832dd4be, 0x8e26dab7, 0x993bc8ac, 0x9430c6a5, 0xdf599cd2, 0xd25292db, 0xc54f80c0, 0xc8448ec9, 0xeb75a4f6, 0xe67eaaff, 0xf163b8e4, 0xfc68b6ed, 0x67b10c0a, 0x6aba0203, 0x7da71018, 0x70ac1e11, 0x539d342e, 0x5e963a27, 0x498b283c, 0x44802635, 0x0fe97c42, 0x02e2724b, 0x15ff6050, 0x18f46e59, 0x3bc54466, 0x36ce4a6f, 0x21d35874, 0x2cd8567d, 0x0c7a37a1, 0x017139a8, 0x166c2bb3, 0x1b6725ba, 0x38560f85, 0x355d018c, 0x22401397, 0x2f4b1d9e, 0x642247e9, 0x692949e0, 0x7e345bfb, 0x733f55f2, 0x500e7fcd, 0x5d0571c4, 0x4a1863df, 0x47136dd6, 0xdccad731, 0xd1c1d938, 0xc6dccb23, 0xcbd7c52a, 0xe8e6ef15, 0xe5ede11c, 0xf2f0f307, 0xfffbfd0e, 0xb492a779, 0xb999a970, 0xae84bb6b, 0xa38fb562, 0x80be9f5d, 0x8db59154, 0x9aa8834f, 0x97a38d46];
	    var U4 = [0x00000000, 0x090d0b0e, 0x121a161c, 0x1b171d12, 0x24342c38, 0x2d392736, 0x362e3a24, 0x3f23312a, 0x48685870, 0x4165537e, 0x5a724e6c, 0x537f4562, 0x6c5c7448, 0x65517f46, 0x7e466254, 0x774b695a, 0x90d0b0e0, 0x99ddbbee, 0x82caa6fc, 0x8bc7adf2, 0xb4e49cd8, 0xbde997d6, 0xa6fe8ac4, 0xaff381ca, 0xd8b8e890, 0xd1b5e39e, 0xcaa2fe8c, 0xc3aff582, 0xfc8cc4a8, 0xf581cfa6, 0xee96d2b4, 0xe79bd9ba, 0x3bbb7bdb, 0x32b670d5, 0x29a16dc7, 0x20ac66c9, 0x1f8f57e3, 0x16825ced, 0x0d9541ff, 0x04984af1, 0x73d323ab, 0x7ade28a5, 0x61c935b7, 0x68c43eb9, 0x57e70f93, 0x5eea049d, 0x45fd198f, 0x4cf01281, 0xab6bcb3b, 0xa266c035, 0xb971dd27, 0xb07cd629, 0x8f5fe703, 0x8652ec0d, 0x9d45f11f, 0x9448fa11, 0xe303934b, 0xea0e9845, 0xf1198557, 0xf8148e59, 0xc737bf73, 0xce3ab47d, 0xd52da96f, 0xdc20a261, 0x766df6ad, 0x7f60fda3, 0x6477e0b1, 0x6d7aebbf, 0x5259da95, 0x5b54d19b, 0x4043cc89, 0x494ec787, 0x3e05aedd, 0x3708a5d3, 0x2c1fb8c1, 0x2512b3cf, 0x1a3182e5, 0x133c89eb, 0x082b94f9, 0x01269ff7, 0xe6bd464d, 0xefb04d43, 0xf4a75051, 0xfdaa5b5f, 0xc2896a75, 0xcb84617b, 0xd0937c69, 0xd99e7767, 0xaed51e3d, 0xa7d81533, 0xbccf0821, 0xb5c2032f, 0x8ae13205, 0x83ec390b, 0x98fb2419, 0x91f62f17, 0x4dd68d76, 0x44db8678, 0x5fcc9b6a, 0x56c19064, 0x69e2a14e, 0x60efaa40, 0x7bf8b752, 0x72f5bc5c, 0x05bed506, 0x0cb3de08, 0x17a4c31a, 0x1ea9c814, 0x218af93e, 0x2887f230, 0x3390ef22, 0x3a9de42c, 0xdd063d96, 0xd40b3698, 0xcf1c2b8a, 0xc6112084, 0xf93211ae, 0xf03f1aa0, 0xeb2807b2, 0xe2250cbc, 0x956e65e6, 0x9c636ee8, 0x877473fa, 0x8e7978f4, 0xb15a49de, 0xb85742d0, 0xa3405fc2, 0xaa4d54cc, 0xecdaf741, 0xe5d7fc4f, 0xfec0e15d, 0xf7cdea53, 0xc8eedb79, 0xc1e3d077, 0xdaf4cd65, 0xd3f9c66b, 0xa4b2af31, 0xadbfa43f, 0xb6a8b92d, 0xbfa5b223, 0x80868309, 0x898b8807, 0x929c9515, 0x9b919e1b, 0x7c0a47a1, 0x75074caf, 0x6e1051bd, 0x671d5ab3, 0x583e6b99, 0x51336097, 0x4a247d85, 0x4329768b, 0x34621fd1, 0x3d6f14df, 0x267809cd, 0x2f7502c3, 0x105633e9, 0x195b38e7, 0x024c25f5, 0x0b412efb, 0xd7618c9a, 0xde6c8794, 0xc57b9a86, 0xcc769188, 0xf355a0a2, 0xfa58abac, 0xe14fb6be, 0xe842bdb0, 0x9f09d4ea, 0x9604dfe4, 0x8d13c2f6, 0x841ec9f8, 0xbb3df8d2, 0xb230f3dc, 0xa927eece, 0xa02ae5c0, 0x47b13c7a, 0x4ebc3774, 0x55ab2a66, 0x5ca62168, 0x63851042, 0x6a881b4c, 0x719f065e, 0x78920d50, 0x0fd9640a, 0x06d46f04, 0x1dc37216, 0x14ce7918, 0x2bed4832, 0x22e0433c, 0x39f75e2e, 0x30fa5520, 0x9ab701ec, 0x93ba0ae2, 0x88ad17f0, 0x81a01cfe, 0xbe832dd4, 0xb78e26da, 0xac993bc8, 0xa59430c6, 0xd2df599c, 0xdbd25292, 0xc0c54f80, 0xc9c8448e, 0xf6eb75a4, 0xffe67eaa, 0xe4f163b8, 0xedfc68b6, 0x0a67b10c, 0x036aba02, 0x187da710, 0x1170ac1e, 0x2e539d34, 0x275e963a, 0x3c498b28, 0x35448026, 0x420fe97c, 0x4b02e272, 0x5015ff60, 0x5918f46e, 0x663bc544, 0x6f36ce4a, 0x7421d358, 0x7d2cd856, 0xa10c7a37, 0xa8017139, 0xb3166c2b, 0xba1b6725, 0x8538560f, 0x8c355d01, 0x97224013, 0x9e2f4b1d, 0xe9642247, 0xe0692949, 0xfb7e345b, 0xf2733f55, 0xcd500e7f, 0xc45d0571, 0xdf4a1863, 0xd647136d, 0x31dccad7, 0x38d1c1d9, 0x23c6dccb, 0x2acbd7c5, 0x15e8e6ef, 0x1ce5ede1, 0x07f2f0f3, 0x0efffbfd, 0x79b492a7, 0x70b999a9, 0x6bae84bb, 0x62a38fb5, 0x5d80be9f, 0x548db591, 0x4f9aa883, 0x4697a38d];

	    function convertToInt32(bytes) {
	        var result = [];
	        for (var i = 0; i < bytes.length; i += 4) {
	            result.push(
	                (bytes[i    ] << 24) |
	                (bytes[i + 1] << 16) |
	                (bytes[i + 2] <<  8) |
	                 bytes[i + 3]
	            );
	        }
	        return result;
	    }

	    var AES = function(key) {
	        if (!(this instanceof AES)) {
	            throw Error('AES must be instanitated with `new`');
	        }

	        Object.defineProperty(this, 'key', {
	            value: coerceArray(key, true)
	        });

	        this._prepare();
	    };


	    AES.prototype._prepare = function() {

	        var rounds = numberOfRounds[this.key.length];
	        if (rounds == null) {
	            throw new Error('invalid key size (must be 16, 24 or 32 bytes)');
	        }

	        // encryption round keys
	        this._Ke = [];

	        // decryption round keys
	        this._Kd = [];

	        for (var i = 0; i <= rounds; i++) {
	            this._Ke.push([0, 0, 0, 0]);
	            this._Kd.push([0, 0, 0, 0]);
	        }

	        var roundKeyCount = (rounds + 1) * 4;
	        var KC = this.key.length / 4;

	        // convert the key into ints
	        var tk = convertToInt32(this.key);

	        // copy values into round key arrays
	        var index;
	        for (var i = 0; i < KC; i++) {
	            index = i >> 2;
	            this._Ke[index][i % 4] = tk[i];
	            this._Kd[rounds - index][i % 4] = tk[i];
	        }

	        // key expansion (fips-197 section 5.2)
	        var rconpointer = 0;
	        var t = KC, tt;
	        while (t < roundKeyCount) {
	            tt = tk[KC - 1];
	            tk[0] ^= ((S[(tt >> 16) & 0xFF] << 24) ^
	                      (S[(tt >>  8) & 0xFF] << 16) ^
	                      (S[ tt        & 0xFF] <<  8) ^
	                       S[(tt >> 24) & 0xFF]        ^
	                      (rcon[rconpointer] << 24));
	            rconpointer += 1;

	            // key expansion (for non-256 bit)
	            if (KC != 8) {
	                for (var i = 1; i < KC; i++) {
	                    tk[i] ^= tk[i - 1];
	                }

	            // key expansion for 256-bit keys is "slightly different" (fips-197)
	            } else {
	                for (var i = 1; i < (KC / 2); i++) {
	                    tk[i] ^= tk[i - 1];
	                }
	                tt = tk[(KC / 2) - 1];

	                tk[KC / 2] ^= (S[ tt        & 0xFF]        ^
	                              (S[(tt >>  8) & 0xFF] <<  8) ^
	                              (S[(tt >> 16) & 0xFF] << 16) ^
	                              (S[(tt >> 24) & 0xFF] << 24));

	                for (var i = (KC / 2) + 1; i < KC; i++) {
	                    tk[i] ^= tk[i - 1];
	                }
	            }

	            // copy values into round key arrays
	            var i = 0, r, c;
	            while (i < KC && t < roundKeyCount) {
	                r = t >> 2;
	                c = t % 4;
	                this._Ke[r][c] = tk[i];
	                this._Kd[rounds - r][c] = tk[i++];
	                t++;
	            }
	        }

	        // inverse-cipher-ify the decryption round key (fips-197 section 5.3)
	        for (var r = 1; r < rounds; r++) {
	            for (var c = 0; c < 4; c++) {
	                tt = this._Kd[r][c];
	                this._Kd[r][c] = (U1[(tt >> 24) & 0xFF] ^
	                                  U2[(tt >> 16) & 0xFF] ^
	                                  U3[(tt >>  8) & 0xFF] ^
	                                  U4[ tt        & 0xFF]);
	            }
	        }
	    };

	    AES.prototype.encrypt = function(plaintext) {
	        if (plaintext.length != 16) {
	            throw new Error('invalid plaintext size (must be 16 bytes)');
	        }

	        var rounds = this._Ke.length - 1;
	        var a = [0, 0, 0, 0];

	        // convert plaintext to (ints ^ key)
	        var t = convertToInt32(plaintext);
	        for (var i = 0; i < 4; i++) {
	            t[i] ^= this._Ke[0][i];
	        }

	        // apply round transforms
	        for (var r = 1; r < rounds; r++) {
	            for (var i = 0; i < 4; i++) {
	                a[i] = (T1[(t[ i         ] >> 24) & 0xff] ^
	                        T2[(t[(i + 1) % 4] >> 16) & 0xff] ^
	                        T3[(t[(i + 2) % 4] >>  8) & 0xff] ^
	                        T4[ t[(i + 3) % 4]        & 0xff] ^
	                        this._Ke[r][i]);
	            }
	            t = a.slice();
	        }

	        // the last round is special
	        var result = createArray(16), tt;
	        for (var i = 0; i < 4; i++) {
	            tt = this._Ke[rounds][i];
	            result[4 * i    ] = (S[(t[ i         ] >> 24) & 0xff] ^ (tt >> 24)) & 0xff;
	            result[4 * i + 1] = (S[(t[(i + 1) % 4] >> 16) & 0xff] ^ (tt >> 16)) & 0xff;
	            result[4 * i + 2] = (S[(t[(i + 2) % 4] >>  8) & 0xff] ^ (tt >>  8)) & 0xff;
	            result[4 * i + 3] = (S[ t[(i + 3) % 4]        & 0xff] ^  tt       ) & 0xff;
	        }

	        return result;
	    };

	    AES.prototype.decrypt = function(ciphertext) {
	        if (ciphertext.length != 16) {
	            throw new Error('invalid ciphertext size (must be 16 bytes)');
	        }

	        var rounds = this._Kd.length - 1;
	        var a = [0, 0, 0, 0];

	        // convert plaintext to (ints ^ key)
	        var t = convertToInt32(ciphertext);
	        for (var i = 0; i < 4; i++) {
	            t[i] ^= this._Kd[0][i];
	        }

	        // apply round transforms
	        for (var r = 1; r < rounds; r++) {
	            for (var i = 0; i < 4; i++) {
	                a[i] = (T5[(t[ i          ] >> 24) & 0xff] ^
	                        T6[(t[(i + 3) % 4] >> 16) & 0xff] ^
	                        T7[(t[(i + 2) % 4] >>  8) & 0xff] ^
	                        T8[ t[(i + 1) % 4]        & 0xff] ^
	                        this._Kd[r][i]);
	            }
	            t = a.slice();
	        }

	        // the last round is special
	        var result = createArray(16), tt;
	        for (var i = 0; i < 4; i++) {
	            tt = this._Kd[rounds][i];
	            result[4 * i    ] = (Si[(t[ i         ] >> 24) & 0xff] ^ (tt >> 24)) & 0xff;
	            result[4 * i + 1] = (Si[(t[(i + 3) % 4] >> 16) & 0xff] ^ (tt >> 16)) & 0xff;
	            result[4 * i + 2] = (Si[(t[(i + 2) % 4] >>  8) & 0xff] ^ (tt >>  8)) & 0xff;
	            result[4 * i + 3] = (Si[ t[(i + 1) % 4]        & 0xff] ^  tt       ) & 0xff;
	        }

	        return result;
	    };


	    /**
	     *  Mode Of Operation - Electonic Codebook (ECB)
	     */
	    var ModeOfOperationECB = function(key) {
	        if (!(this instanceof ModeOfOperationECB)) {
	            throw Error('AES must be instanitated with `new`');
	        }

	        this.description = "Electronic Code Block";
	        this.name = "ecb";

	        this._aes = new AES(key);
	    };

	    ModeOfOperationECB.prototype.encrypt = function(plaintext) {
	        plaintext = coerceArray(plaintext);

	        if ((plaintext.length % 16) !== 0) {
	            throw new Error('invalid plaintext size (must be multiple of 16 bytes)');
	        }

	        var ciphertext = createArray(plaintext.length);
	        var block = createArray(16);

	        for (var i = 0; i < plaintext.length; i += 16) {
	            copyArray(plaintext, block, 0, i, i + 16);
	            block = this._aes.encrypt(block);
	            copyArray(block, ciphertext, i);
	        }

	        return ciphertext;
	    };

	    ModeOfOperationECB.prototype.decrypt = function(ciphertext) {
	        ciphertext = coerceArray(ciphertext);

	        if ((ciphertext.length % 16) !== 0) {
	            throw new Error('invalid ciphertext size (must be multiple of 16 bytes)');
	        }

	        var plaintext = createArray(ciphertext.length);
	        var block = createArray(16);

	        for (var i = 0; i < ciphertext.length; i += 16) {
	            copyArray(ciphertext, block, 0, i, i + 16);
	            block = this._aes.decrypt(block);
	            copyArray(block, plaintext, i);
	        }

	        return plaintext;
	    };


	    /**
	     *  Mode Of Operation - Cipher Block Chaining (CBC)
	     */
	    var ModeOfOperationCBC = function(key, iv) {
	        if (!(this instanceof ModeOfOperationCBC)) {
	            throw Error('AES must be instanitated with `new`');
	        }

	        this.description = "Cipher Block Chaining";
	        this.name = "cbc";

	        if (!iv) {
	            iv = createArray(16);

	        } else if (iv.length != 16) {
	            throw new Error('invalid initialation vector size (must be 16 bytes)');
	        }

	        this._lastCipherblock = coerceArray(iv, true);

	        this._aes = new AES(key);
	    };

	    ModeOfOperationCBC.prototype.encrypt = function(plaintext) {
	        plaintext = coerceArray(plaintext);

	        if ((plaintext.length % 16) !== 0) {
	            throw new Error('invalid plaintext size (must be multiple of 16 bytes)');
	        }

	        var ciphertext = createArray(plaintext.length);
	        var block = createArray(16);

	        for (var i = 0; i < plaintext.length; i += 16) {
	            copyArray(plaintext, block, 0, i, i + 16);

	            for (var j = 0; j < 16; j++) {
	                block[j] ^= this._lastCipherblock[j];
	            }

	            this._lastCipherblock = this._aes.encrypt(block);
	            copyArray(this._lastCipherblock, ciphertext, i);
	        }

	        return ciphertext;
	    };

	    ModeOfOperationCBC.prototype.decrypt = function(ciphertext) {
	        ciphertext = coerceArray(ciphertext);

	        if ((ciphertext.length % 16) !== 0) {
	            throw new Error('invalid ciphertext size (must be multiple of 16 bytes)');
	        }

	        var plaintext = createArray(ciphertext.length);
	        var block = createArray(16);

	        for (var i = 0; i < ciphertext.length; i += 16) {
	            copyArray(ciphertext, block, 0, i, i + 16);
	            block = this._aes.decrypt(block);

	            for (var j = 0; j < 16; j++) {
	                plaintext[i + j] = block[j] ^ this._lastCipherblock[j];
	            }

	            copyArray(ciphertext, this._lastCipherblock, 0, i, i + 16);
	        }

	        return plaintext;
	    };


	    /**
	     *  Mode Of Operation - Cipher Feedback (CFB)
	     */
	    var ModeOfOperationCFB = function(key, iv, segmentSize) {
	        if (!(this instanceof ModeOfOperationCFB)) {
	            throw Error('AES must be instanitated with `new`');
	        }

	        this.description = "Cipher Feedback";
	        this.name = "cfb";

	        if (!iv) {
	            iv = createArray(16);

	        } else if (iv.length != 16) {
	            throw new Error('invalid initialation vector size (must be 16 size)');
	        }

	        if (!segmentSize) { segmentSize = 1; }

	        this.segmentSize = segmentSize;

	        this._shiftRegister = coerceArray(iv, true);

	        this._aes = new AES(key);
	    };

	    ModeOfOperationCFB.prototype.encrypt = function(plaintext) {
	        if ((plaintext.length % this.segmentSize) != 0) {
	            throw new Error('invalid plaintext size (must be segmentSize bytes)');
	        }

	        var encrypted = coerceArray(plaintext, true);

	        var xorSegment;
	        for (var i = 0; i < encrypted.length; i += this.segmentSize) {
	            xorSegment = this._aes.encrypt(this._shiftRegister);
	            for (var j = 0; j < this.segmentSize; j++) {
	                encrypted[i + j] ^= xorSegment[j];
	            }

	            // Shift the register
	            copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
	            copyArray(encrypted, this._shiftRegister, 16 - this.segmentSize, i, i + this.segmentSize);
	        }

	        return encrypted;
	    };

	    ModeOfOperationCFB.prototype.decrypt = function(ciphertext) {
	        if ((ciphertext.length % this.segmentSize) != 0) {
	            throw new Error('invalid ciphertext size (must be segmentSize bytes)');
	        }

	        var plaintext = coerceArray(ciphertext, true);

	        var xorSegment;
	        for (var i = 0; i < plaintext.length; i += this.segmentSize) {
	            xorSegment = this._aes.encrypt(this._shiftRegister);

	            for (var j = 0; j < this.segmentSize; j++) {
	                plaintext[i + j] ^= xorSegment[j];
	            }

	            // Shift the register
	            copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
	            copyArray(ciphertext, this._shiftRegister, 16 - this.segmentSize, i, i + this.segmentSize);
	        }

	        return plaintext;
	    };

	    /**
	     *  Mode Of Operation - Output Feedback (OFB)
	     */
	    var ModeOfOperationOFB = function(key, iv) {
	        if (!(this instanceof ModeOfOperationOFB)) {
	            throw Error('AES must be instanitated with `new`');
	        }

	        this.description = "Output Feedback";
	        this.name = "ofb";

	        if (!iv) {
	            iv = createArray(16);

	        } else if (iv.length != 16) {
	            throw new Error('invalid initialation vector size (must be 16 bytes)');
	        }

	        this._lastPrecipher = coerceArray(iv, true);
	        this._lastPrecipherIndex = 16;

	        this._aes = new AES(key);
	    };

	    ModeOfOperationOFB.prototype.encrypt = function(plaintext) {
	        var encrypted = coerceArray(plaintext, true);

	        for (var i = 0; i < encrypted.length; i++) {
	            if (this._lastPrecipherIndex === 16) {
	                this._lastPrecipher = this._aes.encrypt(this._lastPrecipher);
	                this._lastPrecipherIndex = 0;
	            }
	            encrypted[i] ^= this._lastPrecipher[this._lastPrecipherIndex++];
	        }

	        return encrypted;
	    };

	    // Decryption is symetric
	    ModeOfOperationOFB.prototype.decrypt = ModeOfOperationOFB.prototype.encrypt;


	    /**
	     *  Counter object for CTR common mode of operation
	     */
	    var Counter = function(initialValue) {
	        if (!(this instanceof Counter)) {
	            throw Error('Counter must be instanitated with `new`');
	        }

	        // We allow 0, but anything false-ish uses the default 1
	        if (initialValue !== 0 && !initialValue) { initialValue = 1; }

	        if (typeof(initialValue) === 'number') {
	            this._counter = createArray(16);
	            this.setValue(initialValue);

	        } else {
	            this.setBytes(initialValue);
	        }
	    };

	    Counter.prototype.setValue = function(value) {
	        if (typeof(value) !== 'number' || parseInt(value) != value) {
	            throw new Error('invalid counter value (must be an integer)');
	        }

	        // We cannot safely handle numbers beyond the safe range for integers
	        if (value > Number.MAX_SAFE_INTEGER) {
	            throw new Error('integer value out of safe range');
	        }

	        for (var index = 15; index >= 0; --index) {
	            this._counter[index] = value % 256;
	            value = parseInt(value / 256);
	        }
	    };

	    Counter.prototype.setBytes = function(bytes) {
	        bytes = coerceArray(bytes, true);

	        if (bytes.length != 16) {
	            throw new Error('invalid counter bytes size (must be 16 bytes)');
	        }

	        this._counter = bytes;
	    };

	    Counter.prototype.increment = function() {
	        for (var i = 15; i >= 0; i--) {
	            if (this._counter[i] === 255) {
	                this._counter[i] = 0;
	            } else {
	                this._counter[i]++;
	                break;
	            }
	        }
	    };


	    /**
	     *  Mode Of Operation - Counter (CTR)
	     */
	    var ModeOfOperationCTR = function(key, counter) {
	        if (!(this instanceof ModeOfOperationCTR)) {
	            throw Error('AES must be instanitated with `new`');
	        }

	        this.description = "Counter";
	        this.name = "ctr";

	        if (!(counter instanceof Counter)) {
	            counter = new Counter(counter);
	        }

	        this._counter = counter;

	        this._remainingCounter = null;
	        this._remainingCounterIndex = 16;

	        this._aes = new AES(key);
	    };

	    ModeOfOperationCTR.prototype.encrypt = function(plaintext) {
	        var encrypted = coerceArray(plaintext, true);

	        for (var i = 0; i < encrypted.length; i++) {
	            if (this._remainingCounterIndex === 16) {
	                this._remainingCounter = this._aes.encrypt(this._counter._counter);
	                this._remainingCounterIndex = 0;
	                this._counter.increment();
	            }
	            encrypted[i] ^= this._remainingCounter[this._remainingCounterIndex++];
	        }

	        return encrypted;
	    };

	    // Decryption is symetric
	    ModeOfOperationCTR.prototype.decrypt = ModeOfOperationCTR.prototype.encrypt;


	    ///////////////////////
	    // Padding

	    // See:https://tools.ietf.org/html/rfc2315
	    function pkcs7pad(data) {
	        data = coerceArray(data, true);
	        var padder = 16 - (data.length % 16);
	        var result = createArray(data.length + padder);
	        copyArray(data, result);
	        for (var i = data.length; i < result.length; i++) {
	            result[i] = padder;
	        }
	        return result;
	    }

	    function pkcs7strip(data) {
	        data = coerceArray(data, true);
	        if (data.length < 16) { throw new Error('PKCS#7 invalid length'); }

	        var padder = data[data.length - 1];
	        if (padder > 16) { throw new Error('PKCS#7 padding byte out of range'); }

	        var length = data.length - padder;
	        for (var i = 0; i < padder; i++) {
	            if (data[length + i] !== padder) {
	                throw new Error('PKCS#7 invalid padding byte');
	            }
	        }

	        var result = createArray(length);
	        copyArray(data, result, 0, 0, length);
	        return result;
	    }

	    ///////////////////////
	    // Exporting


	    // The block cipher
	    var aesjs = {
	        AES: AES,
	        Counter: Counter,

	        ModeOfOperation: {
	            ecb: ModeOfOperationECB,
	            cbc: ModeOfOperationCBC,
	            cfb: ModeOfOperationCFB,
	            ofb: ModeOfOperationOFB,
	            ctr: ModeOfOperationCTR
	        },

	        utils: {
	            hex: convertHex,
	            utf8: convertUtf8
	        },

	        padding: {
	            pkcs7: {
	                pad: pkcs7pad,
	                strip: pkcs7strip
	            }
	        },

	        _arrayTest: {
	            coerceArray: coerceArray,
	            createArray: createArray,
	            copyArray: copyArray,
	        }
	    };


	    // node.js
	    {
	        module.exports = aesjs;

	    // RequireJS/AMD
	    // http://www.requirejs.org/docs/api.html
	    // https://github.com/amdjs/amdjs-api/wiki/AMD
	    }


	})(); 
} (aesJs));

var aesJsExports = aesJs.exports;

var mvc$1 = mvcLibExports;

var PublicKey$1 = mvc$1.PublicKey;
var Hash$1 = mvc$1.crypto.Hash;
var $$1 = mvc$1.util.preconditions;
var aesjs$1 = aesJsExports;
var CBC$1 = aesjs$1.ModeOfOperation.cbc;
var Random = mvc$1.crypto.Random;

var AESCBC$1 = function AESCBC () {};

AESCBC$1.encrypt = function (messagebuf, cipherkeybuf, ivbuf) {
  $$1.checkArgument(messagebuf);
  $$1.checkArgument(cipherkeybuf);
  $$1.checkArgument(ivbuf);
  ivbuf = ivbuf || Random.getRandomBuffer(128 / 8);
  messagebuf = aesjs$1.padding.pkcs7.pad(messagebuf);
  var aesCbc = new CBC$1(cipherkeybuf, ivbuf);
  var ctbuf = aesCbc.encrypt(messagebuf);
  var encbuf = Buffer.concat([ivbuf, ctbuf]);
  return encbuf
};

AESCBC$1.decrypt = function (encbuf, cipherkeybuf) {
  $$1.checkArgument(encbuf);
  $$1.checkArgument(cipherkeybuf);
  var ivbuf = encbuf.slice(0, 128 / 8);
  var ctbuf = encbuf.slice(128 / 8);
  var aesCbc = new CBC$1(cipherkeybuf, ivbuf);
  var messagebuf = aesCbc.decrypt(ctbuf);
  messagebuf = aesjs$1.padding.pkcs7.strip(messagebuf);
  return Buffer.from(messagebuf)
};

// http://en.wikipedia.org/wiki/Integrated_Encryption_Scheme
var ECIES$1 = function ECIES (opts) {
  if (!(this instanceof ECIES)) {
    return new ECIES()
  }
  this.opts = opts || {};
};

ECIES$1.prototype.privateKey = function (privateKey) {
  $$1.checkArgument(privateKey, 'no private key provided');

  this._privateKey = privateKey || null;

  return this
};

ECIES$1.prototype.publicKey = function (publicKey) {
  $$1.checkArgument(publicKey, 'no public key provided');

  this._publicKey = publicKey || null;

  return this
};

var cachedProperty = function (name, getter) {
  var cachedName = '_' + name;
  Object.defineProperty(ECIES$1.prototype, name, {
    configurable: false,
    enumerable: true,
    get: function () {
      var value = this[cachedName];
      if (!value) {
        value = this[cachedName] = getter.apply(this);
      }
      return value
    }
  });
};

cachedProperty('Rbuf', function () {
  return this._privateKey.publicKey.toDER(true)
});

cachedProperty('kEkM', function () {
  var r = this._privateKey.bn;
  var KB = this._publicKey.point;
  var P = KB.mul(r);
  var S = P.getX();
  var Sbuf = S.toBuffer({ size: 32 });
  return Hash$1.sha512(Sbuf)
});

cachedProperty('kE', function () {
  return this.kEkM.slice(0, 32)
});

cachedProperty('kM', function () {
  return this.kEkM.slice(32, 64)
});

// Encrypts the message (String or Buffer).
// Optional `ivbuf` contains 16-byte Buffer to be used in AES-CBC.
// By default, `ivbuf` is computed deterministically from message and private key using HMAC-SHA256.
// Deterministic IV enables end-to-end test vectors for alternative implementations.
// Note that identical messages have identical ciphertexts. If your protocol does not include some
// kind of a sequence identifier inside the message *and* it is important to not allow attacker to learn
// that message is repeated, then you should use custom IV.
// For random IV, pass `Random.getRandomBuffer(16)` for the second argument.
ECIES$1.prototype.encrypt = function (message, ivbuf) {
  if (!isBuffer$2(message)) message = Buffer.from(message);
  if (ivbuf === undefined) {
    ivbuf = Hash$1.sha256hmac(message, this._privateKey.toBuffer()).slice(0, 16);
  }
  var c = AESCBC$1.encrypt(message, this.kE, ivbuf);
  var d = Hash$1.sha256hmac(c, this.kM);
  if (this.opts.shortTag) d = d.slice(0, 4);
  var encbuf;
  if (this.opts.noKey) {
    encbuf = Buffer.concat([c, d]);
  } else {
    encbuf = Buffer.concat([this.Rbuf, c, d]);
  }
  return encbuf
};

ECIES$1.prototype.decrypt = function (encbuf) {
  $$1.checkArgument(encbuf);
  var offset = 0;
  var tagLength = 32;
  if (this.opts.shortTag) {
    tagLength = 4;
  }
  if (!this.opts.noKey) {
    var pub;
    switch (encbuf[0]) {
      case 4:
        pub = encbuf.slice(0, 65);
        break
      case 3:
      case 2:
        pub = encbuf.slice(0, 33);
        break
      default:
        throw new Error('Invalid type: ' + encbuf[0])
    }
    this._publicKey = PublicKey$1.fromDER(pub);
    offset += pub.length;
  }

  var c = encbuf.slice(offset, encbuf.length - tagLength);
  var d = encbuf.slice(encbuf.length - tagLength, encbuf.length);

  var d2 = Hash$1.sha256hmac(c, this.kM);
  if (this.opts.shortTag) d2 = d2.slice(0, 4);

  var equal = true;
  for (var i = 0; i < d.length; i++) {
    equal &= (d[i] === d2[i]);
  }
  if (!equal) {
    throw new Error('Invalid checksum')
  }

  return AESCBC$1.decrypt(c, this.kE)
};

var bitcoreEcies = ECIES$1;

var spec = {
  name: 'ECIES',
  message: 'Internal Error on mvc-ecies Module {0}',
  errors: [{
    name: 'DecryptionError',
    message: 'Invalid Message: {0}'
  },
  {
    name: 'UnsupportAlgorithm',
    message: 'Unsupport Algorithm: {0}'
  }]
};

var errors$1 = mvcLibExports.errors.extend(spec);

var mvc = mvcLibExports;

var PublicKey = mvc.PublicKey;
var PrivateKey = mvc.PrivateKey;
var Hash = mvc.crypto.Hash;
var $ = mvc.util.preconditions;
var bitcoreECIES = bitcoreEcies;
var errors = errors$1;
var aesjs = aesJsExports;
var CBC = aesjs.ModeOfOperation.cbc;

var AESCBC = function AESCBC () {};

AESCBC.encrypt = function (messagebuf, keybuf, ivbuf) {
  $.checkArgument(messagebuf);
  $.checkArgument(keybuf);
  $.checkArgument(ivbuf);
  $.checkArgument(keybuf.length === 16, 'keybuf length must be 16');
  $.checkArgument(ivbuf.length === 16, 'ivbuf length must be 16');
  messagebuf = aesjs.padding.pkcs7.pad(messagebuf);
  var aesCbc = new CBC(keybuf, ivbuf);
  var encryptedBytes = aesCbc.encrypt(messagebuf);
  return Buffer.from(encryptedBytes)
};

AESCBC.decrypt = function (encbuf, keybuf, ivbuf) {
  $.checkArgument(encbuf);
  $.checkArgument(keybuf);
  $.checkArgument(ivbuf);
  $.checkArgument(keybuf.length === 16, 'keybuf length must be 16');
  $.checkArgument(ivbuf.length === 16, 'ivbuf length must be 16');
  var aesCbc = new CBC(keybuf, ivbuf);
  var decryptedBytes = aesCbc.decrypt(encbuf);
  return Buffer.from(aesjs.padding.pkcs7.strip(decryptedBytes))
};

// Electrum BIE1 ECIES
// Difference from Original Bitcore ECIES:
//  BIE1:
//      1.Secret S is compressed P(33 bytes), while Bitcore's Secret is Px(32 bytes). See ivkEkM.
//      2.use AES-128-CBC instead of AES-256-CBC.
//      3.IV is retrived from first 16 bytes of Hashed Secret Buffer. See iv
//      4.key Encryption(kE) is retrived from 17-32 bytes of Hashed Secret Buffer, instead of 1-32 bytes. See kE
//      5.a magic word 'BIE1' is used to identify message type.
//      6.ephemeral key is introduced, so you can encrypt messages only with public key.
//      7.HMAC is whole message.
//  Notice:
//      Electrum does not support shortTag nor noKey
//      Do NOT use those 2 options if you are to send a message to Electrum
//      Encrypted message is NOT recoverable if you use ephemeral key
//  Security:
//

// Default algorithm is set to BIE1, however original Bitcore ECIES is still preserved.
var ECIES = function ECIES (opts, algorithm = 'BIE1') {
  if (algorithm !== 'BIE1') throw new errors.UnsupportAlgorithm(algorithm)
  if (!(this instanceof ECIES)) {
    return new ECIES(opts, algorithm)
  }
  // use ephemeral key if privateKey is not set.
  this._privateKey = new mvc.PrivateKey();
  this.opts = opts || {};
  this.opts.ephemeralKey = true;
};

ECIES.prototype.privateKey = function (privateKey) {
  $.checkArgument(PrivateKey.isValid(privateKey), 'no private key provided');

  this._privateKey = PrivateKey(privateKey.toHex()) || null;
  this.opts.ephemeralKey = false;

  return this
};

ECIES.prototype.publicKey = function (publicKey) {
  $.checkArgument(PublicKey.isValid(publicKey), 'no public key provided');

  this._publicKey = PublicKey(publicKey.toString()) || null;
  if (this._publicKey != null) this.opts.fixedPublicKey = true;

  return this
};

var defineProperty = function (name, getter) {
  var cachedName = '_' + name;
  Object.defineProperty(ECIES.prototype, name, {
    configurable: false,
    enumerable: true,
    get: function () {
      var value = this[cachedName];
      value = this[cachedName] = getter.apply(this);
      return value
    }
  });
};

defineProperty('Rbuf', function () {
  return this._privateKey.publicKey.toDER(true)
});

defineProperty('ivkEkM', function () {
  var r = this._privateKey.bn;
  var KB = this._publicKey.point;
  var P = KB.mul(r);
  var S = PublicKey(P);
  var Sbuf = S.toBuffer();
  return Hash.sha512(Sbuf)
});

defineProperty('iv', function () {
  return this.ivkEkM.slice(0, 16)
});

defineProperty('kE', function () {
  return this.ivkEkM.slice(16, 32)
});

defineProperty('kM', function () {
  return this.ivkEkM.slice(32, 64)
});

// Encrypts the message (String or Buffer).
ECIES.prototype.encrypt = function (message) {
  if (!isBuffer$2(message)) message = Buffer.from(message);
  var ciphertext = AESCBC.encrypt(message, this.kE, this.iv);
  var encbuf;
  var BIE1 = Buffer.from('BIE1');
  if (this.opts.noKey && !this.opts.ephemeralKey) {
    encbuf = Buffer.concat([BIE1, ciphertext]);
  } else {
    encbuf = Buffer.concat([BIE1, this.Rbuf, ciphertext]);
  }
  var hmac = Hash.sha256hmac(encbuf, this.kM);
  if (this.opts.shortTag) hmac = hmac.slice(0, 4);
  return Buffer.concat([encbuf, hmac])
};

ECIES.prototype.decrypt = function (encbuf) {
  $.checkArgument(isBuffer$2(encbuf), 'ciphetext must be a buffer');
  var tagLength = 32;
  var offset = 4;
  if (this.opts.shortTag) {
    tagLength = 4;
  }
  var magic = encbuf.slice(0, 4);
  if (!magic.equals(Buffer.from('BIE1'))) {
    throw new errors.DecryptionError('Invalid Magic')
  }
  if (!this.opts.noKey) {
    var pub;
    // BIE1 use compressed public key, length is always 33.
    pub = encbuf.slice(4, 37);
    if (this.opts.fixedPublicKey) console.log('Notice: Overriding PublicKey in message. Consider use "noKey" option if you are not sending message to electrum and do not want to use ephemeral key');
    else this._publicKey = PublicKey.fromDER(pub);
    offset = 37;
  }

  var ciphertext = encbuf.slice(offset, encbuf.length - tagLength);
  var hmac = encbuf.slice(encbuf.length - tagLength, encbuf.length);

  var hmac2 = Hash.sha256hmac(encbuf.slice(0, encbuf.length - tagLength), this.kM);
  if (this.opts.shortTag) hmac2 = hmac2.slice(0, 4);

  if (!hmac.equals(hmac2)) {
    throw new errors.DecryptionError('Invalid checksum')
  }

  return AESCBC.decrypt(ciphertext, this.kE, this.iv)
};

ECIES.bitcoreECIES = bitcoreECIES;

const ProdConfig = {
    Aggregation: `https://api.show3.io/aggregation`,
    Dashbroad: `https://api.show3.io/tool/api`,
    BASEAPI: `https://api.show3.io`,
    WalletPath: 10001,
    WalletNetWork: Network$1.mainnet,
};
({
    Aggregation: `https://api.show3.io/aggregation`,
    Dashbroad: `https://api-test.microvisionchain.com/tool/api`,
    BASEAPI: `https://testmvc.showmoney.app`,
    WalletPath: 236,
    WalletNetWork: Network$1.testnet,
});
const Env = ProdConfig;

/*!
 * Compressor.js v1.2.1
 * https://fengyuanchen.github.io/compressorjs
 *
 * Copyright 2018-present Chen Fengyuan
 * Released under the MIT license
 *
 * Date: 2023-02-28T14:09:41.732Z
 */


var canvasToBlob = {exports: {}};

/*
 * JavaScript Canvas to Blob
 * https://github.com/blueimp/JavaScript-Canvas-to-Blob
 *
 * Copyright 2012, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 *
 * Based on stackoverflow user Stoive's code snippet:
 * http://stackoverflow.com/q/4998908
 */
(function (module) {
  if (typeof window === 'undefined') {
    return;
  }
  (function (window) {

    var CanvasPrototype = window.HTMLCanvasElement && window.HTMLCanvasElement.prototype;
    var hasBlobConstructor = window.Blob && function () {
      try {
        return Boolean(new Blob());
      } catch (e) {
        return false;
      }
    }();
    var hasArrayBufferViewSupport = hasBlobConstructor && window.Uint8Array && function () {
      try {
        return new Blob([new Uint8Array(100)]).size === 100;
      } catch (e) {
        return false;
      }
    }();
    var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
    var dataURIPattern = /^data:((.*?)(;charset=.*?)?)(;base64)?,/;
    var dataURLtoBlob = (hasBlobConstructor || BlobBuilder) && window.atob && window.ArrayBuffer && window.Uint8Array && function (dataURI) {
      var matches, mediaType, isBase64, dataString, byteString, arrayBuffer, intArray, i, bb;
      // Parse the dataURI components as per RFC 2397
      matches = dataURI.match(dataURIPattern);
      if (!matches) {
        throw new Error('invalid data URI');
      }
      // Default to text/plain;charset=US-ASCII
      mediaType = matches[2] ? matches[1] : 'text/plain' + (matches[3] || ';charset=US-ASCII');
      isBase64 = !!matches[4];
      dataString = dataURI.slice(matches[0].length);
      if (isBase64) {
        // Convert base64 to raw binary data held in a string:
        byteString = atob(dataString);
      } else {
        // Convert base64/URLEncoded data component to raw binary:
        byteString = decodeURIComponent(dataString);
      }
      // Write the bytes of the string to an ArrayBuffer:
      arrayBuffer = new ArrayBuffer(byteString.length);
      intArray = new Uint8Array(arrayBuffer);
      for (i = 0; i < byteString.length; i += 1) {
        intArray[i] = byteString.charCodeAt(i);
      }
      // Write the ArrayBuffer (or ArrayBufferView) to a blob:
      if (hasBlobConstructor) {
        return new Blob([hasArrayBufferViewSupport ? intArray : arrayBuffer], {
          type: mediaType
        });
      }
      bb = new BlobBuilder();
      bb.append(arrayBuffer);
      return bb.getBlob(mediaType);
    };
    if (window.HTMLCanvasElement && !CanvasPrototype.toBlob) {
      if (CanvasPrototype.mozGetAsFile) {
        CanvasPrototype.toBlob = function (callback, type, quality) {
          var self = this;
          setTimeout(function () {
            if (quality && CanvasPrototype.toDataURL && dataURLtoBlob) {
              callback(dataURLtoBlob(self.toDataURL(type, quality)));
            } else {
              callback(self.mozGetAsFile('blob', type));
            }
          });
        };
      } else if (CanvasPrototype.toDataURL && dataURLtoBlob) {
        if (CanvasPrototype.msToBlob) {
          CanvasPrototype.toBlob = function (callback, type, quality) {
            var self = this;
            setTimeout(function () {
              if ((type && type !== 'image/png' || quality) && CanvasPrototype.toDataURL && dataURLtoBlob) {
                callback(dataURLtoBlob(self.toDataURL(type, quality)));
              } else {
                callback(self.msToBlob(type));
              }
            });
          };
        } else {
          CanvasPrototype.toBlob = function (callback, type, quality) {
            var self = this;
            setTimeout(function () {
              callback(dataURLtoBlob(self.toDataURL(type, quality)));
            });
          };
        }
      }
    }
    if (module.exports) {
      module.exports = dataURLtoBlob;
    } else {
      window.dataURLtoBlob = dataURLtoBlob;
    }
  })(window);
})(canvasToBlob);

var cryptoJs = {exports: {}};

function commonjsRequire(path) {
	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}

var core = {exports: {}};

var hasRequiredCore;

function requireCore () {
	if (hasRequiredCore) return core.exports;
	hasRequiredCore = 1;
	(function (module, exports) {
(function (root, factory) {
			{
				// CommonJS
				module.exports = factory();
			}
		}(commonjsGlobal, function () {

			/*globals window, global, require*/

			/**
			 * CryptoJS core components.
			 */
			var CryptoJS = CryptoJS || (function (Math, undefined$1) {

			    var crypto;

			    // Native crypto from window (Browser)
			    if (typeof window !== 'undefined' && window.crypto) {
			        crypto = window.crypto;
			    }

			    // Native crypto in web worker (Browser)
			    if (typeof self !== 'undefined' && self.crypto) {
			        crypto = self.crypto;
			    }

			    // Native crypto from worker
			    if (typeof globalThis !== 'undefined' && globalThis.crypto) {
			        crypto = globalThis.crypto;
			    }

			    // Native (experimental IE 11) crypto from window (Browser)
			    if (!crypto && typeof window !== 'undefined' && window.msCrypto) {
			        crypto = window.msCrypto;
			    }

			    // Native crypto from global (NodeJS)
			    if (!crypto && typeof commonjsGlobal !== 'undefined' && commonjsGlobal.crypto) {
			        crypto = commonjsGlobal.crypto;
			    }

			    // Native crypto import via require (NodeJS)
			    if (!crypto && typeof commonjsRequire === 'function') {
			        try {
			            crypto = require('crypto');
			        } catch (err) {}
			    }

			    /*
			     * Cryptographically secure pseudorandom number generator
			     *
			     * As Math.random() is cryptographically not safe to use
			     */
			    var cryptoSecureRandomInt = function () {
			        if (crypto) {
			            // Use getRandomValues method (Browser)
			            if (typeof crypto.getRandomValues === 'function') {
			                try {
			                    return crypto.getRandomValues(new Uint32Array(1))[0];
			                } catch (err) {}
			            }

			            // Use randomBytes method (NodeJS)
			            if (typeof crypto.randomBytes === 'function') {
			                try {
			                    return crypto.randomBytes(4).readInt32LE();
			                } catch (err) {}
			            }
			        }

			        throw new Error('Native crypto module could not be used to get secure random number.');
			    };

			    /*
			     * Local polyfill of Object.create

			     */
			    var create = Object.create || (function () {
			        function F() {}

			        return function (obj) {
			            var subtype;

			            F.prototype = obj;

			            subtype = new F();

			            F.prototype = null;

			            return subtype;
			        };
			    }());

			    /**
			     * CryptoJS namespace.
			     */
			    var C = {};

			    /**
			     * Library namespace.
			     */
			    var C_lib = C.lib = {};

			    /**
			     * Base object for prototypal inheritance.
			     */
			    var Base = C_lib.Base = (function () {


			        return {
			            /**
			             * Creates a new object that inherits from this object.
			             *
			             * @param {Object} overrides Properties to copy into the new object.
			             *
			             * @return {Object} The new object.
			             *
			             * @static
			             *
			             * @example
			             *
			             *     var MyType = CryptoJS.lib.Base.extend({
			             *         field: 'value',
			             *
			             *         method: function () {
			             *         }
			             *     });
			             */
			            extend: function (overrides) {
			                // Spawn
			                var subtype = create(this);

			                // Augment
			                if (overrides) {
			                    subtype.mixIn(overrides);
			                }

			                // Create default initializer
			                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
			                    subtype.init = function () {
			                        subtype.$super.init.apply(this, arguments);
			                    };
			                }

			                // Initializer's prototype is the subtype object
			                subtype.init.prototype = subtype;

			                // Reference supertype
			                subtype.$super = this;

			                return subtype;
			            },

			            /**
			             * Extends this object and runs the init method.
			             * Arguments to create() will be passed to init().
			             *
			             * @return {Object} The new object.
			             *
			             * @static
			             *
			             * @example
			             *
			             *     var instance = MyType.create();
			             */
			            create: function () {
			                var instance = this.extend();
			                instance.init.apply(instance, arguments);

			                return instance;
			            },

			            /**
			             * Initializes a newly created object.
			             * Override this method to add some logic when your objects are created.
			             *
			             * @example
			             *
			             *     var MyType = CryptoJS.lib.Base.extend({
			             *         init: function () {
			             *             // ...
			             *         }
			             *     });
			             */
			            init: function () {
			            },

			            /**
			             * Copies properties into this object.
			             *
			             * @param {Object} properties The properties to mix in.
			             *
			             * @example
			             *
			             *     MyType.mixIn({
			             *         field: 'value'
			             *     });
			             */
			            mixIn: function (properties) {
			                for (var propertyName in properties) {
			                    if (properties.hasOwnProperty(propertyName)) {
			                        this[propertyName] = properties[propertyName];
			                    }
			                }

			                // IE won't copy toString using the loop above
			                if (properties.hasOwnProperty('toString')) {
			                    this.toString = properties.toString;
			                }
			            },

			            /**
			             * Creates a copy of this object.
			             *
			             * @return {Object} The clone.
			             *
			             * @example
			             *
			             *     var clone = instance.clone();
			             */
			            clone: function () {
			                return this.init.prototype.extend(this);
			            }
			        };
			    }());

			    /**
			     * An array of 32-bit words.
			     *
			     * @property {Array} words The array of 32-bit words.
			     * @property {number} sigBytes The number of significant bytes in this word array.
			     */
			    var WordArray = C_lib.WordArray = Base.extend({
			        /**
			         * Initializes a newly created word array.
			         *
			         * @param {Array} words (Optional) An array of 32-bit words.
			         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
			         *
			         * @example
			         *
			         *     var wordArray = CryptoJS.lib.WordArray.create();
			         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
			         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
			         */
			        init: function (words, sigBytes) {
			            words = this.words = words || [];

			            if (sigBytes != undefined$1) {
			                this.sigBytes = sigBytes;
			            } else {
			                this.sigBytes = words.length * 4;
			            }
			        },

			        /**
			         * Converts this word array to a string.
			         *
			         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
			         *
			         * @return {string} The stringified word array.
			         *
			         * @example
			         *
			         *     var string = wordArray + '';
			         *     var string = wordArray.toString();
			         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
			         */
			        toString: function (encoder) {
			            return (encoder || Hex).stringify(this);
			        },

			        /**
			         * Concatenates a word array to this word array.
			         *
			         * @param {WordArray} wordArray The word array to append.
			         *
			         * @return {WordArray} This word array.
			         *
			         * @example
			         *
			         *     wordArray1.concat(wordArray2);
			         */
			        concat: function (wordArray) {
			            // Shortcuts
			            var thisWords = this.words;
			            var thatWords = wordArray.words;
			            var thisSigBytes = this.sigBytes;
			            var thatSigBytes = wordArray.sigBytes;

			            // Clamp excess bits
			            this.clamp();

			            // Concat
			            if (thisSigBytes % 4) {
			                // Copy one byte at a time
			                for (var i = 0; i < thatSigBytes; i++) {
			                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
			                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
			                }
			            } else {
			                // Copy one word at a time
			                for (var j = 0; j < thatSigBytes; j += 4) {
			                    thisWords[(thisSigBytes + j) >>> 2] = thatWords[j >>> 2];
			                }
			            }
			            this.sigBytes += thatSigBytes;

			            // Chainable
			            return this;
			        },

			        /**
			         * Removes insignificant bits.
			         *
			         * @example
			         *
			         *     wordArray.clamp();
			         */
			        clamp: function () {
			            // Shortcuts
			            var words = this.words;
			            var sigBytes = this.sigBytes;

			            // Clamp
			            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
			            words.length = Math.ceil(sigBytes / 4);
			        },

			        /**
			         * Creates a copy of this word array.
			         *
			         * @return {WordArray} The clone.
			         *
			         * @example
			         *
			         *     var clone = wordArray.clone();
			         */
			        clone: function () {
			            var clone = Base.clone.call(this);
			            clone.words = this.words.slice(0);

			            return clone;
			        },

			        /**
			         * Creates a word array filled with random bytes.
			         *
			         * @param {number} nBytes The number of random bytes to generate.
			         *
			         * @return {WordArray} The random word array.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var wordArray = CryptoJS.lib.WordArray.random(16);
			         */
			        random: function (nBytes) {
			            var words = [];

			            for (var i = 0; i < nBytes; i += 4) {
			                words.push(cryptoSecureRandomInt());
			            }

			            return new WordArray.init(words, nBytes);
			        }
			    });

			    /**
			     * Encoder namespace.
			     */
			    var C_enc = C.enc = {};

			    /**
			     * Hex encoding strategy.
			     */
			    var Hex = C_enc.Hex = {
			        /**
			         * Converts a word array to a hex string.
			         *
			         * @param {WordArray} wordArray The word array.
			         *
			         * @return {string} The hex string.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
			         */
			        stringify: function (wordArray) {
			            // Shortcuts
			            var words = wordArray.words;
			            var sigBytes = wordArray.sigBytes;

			            // Convert
			            var hexChars = [];
			            for (var i = 0; i < sigBytes; i++) {
			                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
			                hexChars.push((bite >>> 4).toString(16));
			                hexChars.push((bite & 0x0f).toString(16));
			            }

			            return hexChars.join('');
			        },

			        /**
			         * Converts a hex string to a word array.
			         *
			         * @param {string} hexStr The hex string.
			         *
			         * @return {WordArray} The word array.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
			         */
			        parse: function (hexStr) {
			            // Shortcut
			            var hexStrLength = hexStr.length;

			            // Convert
			            var words = [];
			            for (var i = 0; i < hexStrLength; i += 2) {
			                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
			            }

			            return new WordArray.init(words, hexStrLength / 2);
			        }
			    };

			    /**
			     * Latin1 encoding strategy.
			     */
			    var Latin1 = C_enc.Latin1 = {
			        /**
			         * Converts a word array to a Latin1 string.
			         *
			         * @param {WordArray} wordArray The word array.
			         *
			         * @return {string} The Latin1 string.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
			         */
			        stringify: function (wordArray) {
			            // Shortcuts
			            var words = wordArray.words;
			            var sigBytes = wordArray.sigBytes;

			            // Convert
			            var latin1Chars = [];
			            for (var i = 0; i < sigBytes; i++) {
			                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
			                latin1Chars.push(String.fromCharCode(bite));
			            }

			            return latin1Chars.join('');
			        },

			        /**
			         * Converts a Latin1 string to a word array.
			         *
			         * @param {string} latin1Str The Latin1 string.
			         *
			         * @return {WordArray} The word array.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
			         */
			        parse: function (latin1Str) {
			            // Shortcut
			            var latin1StrLength = latin1Str.length;

			            // Convert
			            var words = [];
			            for (var i = 0; i < latin1StrLength; i++) {
			                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
			            }

			            return new WordArray.init(words, latin1StrLength);
			        }
			    };

			    /**
			     * UTF-8 encoding strategy.
			     */
			    var Utf8 = C_enc.Utf8 = {
			        /**
			         * Converts a word array to a UTF-8 string.
			         *
			         * @param {WordArray} wordArray The word array.
			         *
			         * @return {string} The UTF-8 string.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
			         */
			        stringify: function (wordArray) {
			            try {
			                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
			            } catch (e) {
			                throw new Error('Malformed UTF-8 data');
			            }
			        },

			        /**
			         * Converts a UTF-8 string to a word array.
			         *
			         * @param {string} utf8Str The UTF-8 string.
			         *
			         * @return {WordArray} The word array.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
			         */
			        parse: function (utf8Str) {
			            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
			        }
			    };

			    /**
			     * Abstract buffered block algorithm template.
			     *
			     * The property blockSize must be implemented in a concrete subtype.
			     *
			     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
			     */
			    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
			        /**
			         * Resets this block algorithm's data buffer to its initial state.
			         *
			         * @example
			         *
			         *     bufferedBlockAlgorithm.reset();
			         */
			        reset: function () {
			            // Initial values
			            this._data = new WordArray.init();
			            this._nDataBytes = 0;
			        },

			        /**
			         * Adds new data to this block algorithm's buffer.
			         *
			         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
			         *
			         * @example
			         *
			         *     bufferedBlockAlgorithm._append('data');
			         *     bufferedBlockAlgorithm._append(wordArray);
			         */
			        _append: function (data) {
			            // Convert string to WordArray, else assume WordArray already
			            if (typeof data == 'string') {
			                data = Utf8.parse(data);
			            }

			            // Append
			            this._data.concat(data);
			            this._nDataBytes += data.sigBytes;
			        },

			        /**
			         * Processes available data blocks.
			         *
			         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
			         *
			         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
			         *
			         * @return {WordArray} The processed data.
			         *
			         * @example
			         *
			         *     var processedData = bufferedBlockAlgorithm._process();
			         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
			         */
			        _process: function (doFlush) {
			            var processedWords;

			            // Shortcuts
			            var data = this._data;
			            var dataWords = data.words;
			            var dataSigBytes = data.sigBytes;
			            var blockSize = this.blockSize;
			            var blockSizeBytes = blockSize * 4;

			            // Count blocks ready
			            var nBlocksReady = dataSigBytes / blockSizeBytes;
			            if (doFlush) {
			                // Round up to include partial blocks
			                nBlocksReady = Math.ceil(nBlocksReady);
			            } else {
			                // Round down to include only full blocks,
			                // less the number of blocks that must remain in the buffer
			                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
			            }

			            // Count words ready
			            var nWordsReady = nBlocksReady * blockSize;

			            // Count bytes ready
			            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

			            // Process blocks
			            if (nWordsReady) {
			                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
			                    // Perform concrete-algorithm logic
			                    this._doProcessBlock(dataWords, offset);
			                }

			                // Remove processed words
			                processedWords = dataWords.splice(0, nWordsReady);
			                data.sigBytes -= nBytesReady;
			            }

			            // Return processed words
			            return new WordArray.init(processedWords, nBytesReady);
			        },

			        /**
			         * Creates a copy of this object.
			         *
			         * @return {Object} The clone.
			         *
			         * @example
			         *
			         *     var clone = bufferedBlockAlgorithm.clone();
			         */
			        clone: function () {
			            var clone = Base.clone.call(this);
			            clone._data = this._data.clone();

			            return clone;
			        },

			        _minBufferSize: 0
			    });

			    /**
			     * Abstract hasher template.
			     *
			     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
			     */
			    C_lib.Hasher = BufferedBlockAlgorithm.extend({
			        /**
			         * Configuration options.
			         */
			        cfg: Base.extend(),

			        /**
			         * Initializes a newly created hasher.
			         *
			         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
			         *
			         * @example
			         *
			         *     var hasher = CryptoJS.algo.SHA256.create();
			         */
			        init: function (cfg) {
			            // Apply config defaults
			            this.cfg = this.cfg.extend(cfg);

			            // Set initial values
			            this.reset();
			        },

			        /**
			         * Resets this hasher to its initial state.
			         *
			         * @example
			         *
			         *     hasher.reset();
			         */
			        reset: function () {
			            // Reset data buffer
			            BufferedBlockAlgorithm.reset.call(this);

			            // Perform concrete-hasher logic
			            this._doReset();
			        },

			        /**
			         * Updates this hasher with a message.
			         *
			         * @param {WordArray|string} messageUpdate The message to append.
			         *
			         * @return {Hasher} This hasher.
			         *
			         * @example
			         *
			         *     hasher.update('message');
			         *     hasher.update(wordArray);
			         */
			        update: function (messageUpdate) {
			            // Append
			            this._append(messageUpdate);

			            // Update the hash
			            this._process();

			            // Chainable
			            return this;
			        },

			        /**
			         * Finalizes the hash computation.
			         * Note that the finalize operation is effectively a destructive, read-once operation.
			         *
			         * @param {WordArray|string} messageUpdate (Optional) A final message update.
			         *
			         * @return {WordArray} The hash.
			         *
			         * @example
			         *
			         *     var hash = hasher.finalize();
			         *     var hash = hasher.finalize('message');
			         *     var hash = hasher.finalize(wordArray);
			         */
			        finalize: function (messageUpdate) {
			            // Final message update
			            if (messageUpdate) {
			                this._append(messageUpdate);
			            }

			            // Perform concrete-hasher logic
			            var hash = this._doFinalize();

			            return hash;
			        },

			        blockSize: 512/32,

			        /**
			         * Creates a shortcut function to a hasher's object interface.
			         *
			         * @param {Hasher} hasher The hasher to create a helper for.
			         *
			         * @return {Function} The shortcut function.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
			         */
			        _createHelper: function (hasher) {
			            return function (message, cfg) {
			                return new hasher.init(cfg).finalize(message);
			            };
			        },

			        /**
			         * Creates a shortcut function to the HMAC's object interface.
			         *
			         * @param {Hasher} hasher The hasher to use in this HMAC helper.
			         *
			         * @return {Function} The shortcut function.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
			         */
			        _createHmacHelper: function (hasher) {
			            return function (message, key) {
			                return new C_algo.HMAC.init(hasher, key).finalize(message);
			            };
			        }
			    });

			    /**
			     * Algorithm namespace.
			     */
			    var C_algo = C.algo = {};

			    return C;
			}(Math));


			return CryptoJS;

		})); 
	} (core));
	return core.exports;
}

var x64Core = {exports: {}};

var hasRequiredX64Core;

function requireX64Core () {
	if (hasRequiredX64Core) return x64Core.exports;
	hasRequiredX64Core = 1;
	(function (module, exports) {
(function (root, factory) {
			{
				// CommonJS
				module.exports = factory(requireCore());
			}
		}(commonjsGlobal, function (CryptoJS) {

			(function (undefined$1) {
			    // Shortcuts
			    var C = CryptoJS;
			    var C_lib = C.lib;
			    var Base = C_lib.Base;
			    var X32WordArray = C_lib.WordArray;

			    /**
			     * x64 namespace.
			     */
			    var C_x64 = C.x64 = {};

			    /**
			     * A 64-bit word.
			     */
			    C_x64.Word = Base.extend({
			        /**
			         * Initializes a newly created 64-bit word.
			         *
			         * @param {number} high The high 32 bits.
			         * @param {number} low The low 32 bits.
			         *
			         * @example
			         *
			         *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);
			         */
			        init: function (high, low) {
			            this.high = high;
			            this.low = low;
			        }

			        /**
			         * Bitwise NOTs this word.
			         *
			         * @return {X64Word} A new x64-Word object after negating.
			         *
			         * @example
			         *
			         *     var negated = x64Word.not();
			         */
			        // not: function () {
			            // var high = ~this.high;
			            // var low = ~this.low;

			            // return X64Word.create(high, low);
			        // },

			        /**
			         * Bitwise ANDs this word with the passed word.
			         *
			         * @param {X64Word} word The x64-Word to AND with this word.
			         *
			         * @return {X64Word} A new x64-Word object after ANDing.
			         *
			         * @example
			         *
			         *     var anded = x64Word.and(anotherX64Word);
			         */
			        // and: function (word) {
			            // var high = this.high & word.high;
			            // var low = this.low & word.low;

			            // return X64Word.create(high, low);
			        // },

			        /**
			         * Bitwise ORs this word with the passed word.
			         *
			         * @param {X64Word} word The x64-Word to OR with this word.
			         *
			         * @return {X64Word} A new x64-Word object after ORing.
			         *
			         * @example
			         *
			         *     var ored = x64Word.or(anotherX64Word);
			         */
			        // or: function (word) {
			            // var high = this.high | word.high;
			            // var low = this.low | word.low;

			            // return X64Word.create(high, low);
			        // },

			        /**
			         * Bitwise XORs this word with the passed word.
			         *
			         * @param {X64Word} word The x64-Word to XOR with this word.
			         *
			         * @return {X64Word} A new x64-Word object after XORing.
			         *
			         * @example
			         *
			         *     var xored = x64Word.xor(anotherX64Word);
			         */
			        // xor: function (word) {
			            // var high = this.high ^ word.high;
			            // var low = this.low ^ word.low;

			            // return X64Word.create(high, low);
			        // },

			        /**
			         * Shifts this word n bits to the left.
			         *
			         * @param {number} n The number of bits to shift.
			         *
			         * @return {X64Word} A new x64-Word object after shifting.
			         *
			         * @example
			         *
			         *     var shifted = x64Word.shiftL(25);
			         */
			        // shiftL: function (n) {
			            // if (n < 32) {
			                // var high = (this.high << n) | (this.low >>> (32 - n));
			                // var low = this.low << n;
			            // } else {
			                // var high = this.low << (n - 32);
			                // var low = 0;
			            // }

			            // return X64Word.create(high, low);
			        // },

			        /**
			         * Shifts this word n bits to the right.
			         *
			         * @param {number} n The number of bits to shift.
			         *
			         * @return {X64Word} A new x64-Word object after shifting.
			         *
			         * @example
			         *
			         *     var shifted = x64Word.shiftR(7);
			         */
			        // shiftR: function (n) {
			            // if (n < 32) {
			                // var low = (this.low >>> n) | (this.high << (32 - n));
			                // var high = this.high >>> n;
			            // } else {
			                // var low = this.high >>> (n - 32);
			                // var high = 0;
			            // }

			            // return X64Word.create(high, low);
			        // },

			        /**
			         * Rotates this word n bits to the left.
			         *
			         * @param {number} n The number of bits to rotate.
			         *
			         * @return {X64Word} A new x64-Word object after rotating.
			         *
			         * @example
			         *
			         *     var rotated = x64Word.rotL(25);
			         */
			        // rotL: function (n) {
			            // return this.shiftL(n).or(this.shiftR(64 - n));
			        // },

			        /**
			         * Rotates this word n bits to the right.
			         *
			         * @param {number} n The number of bits to rotate.
			         *
			         * @return {X64Word} A new x64-Word object after rotating.
			         *
			         * @example
			         *
			         *     var rotated = x64Word.rotR(7);
			         */
			        // rotR: function (n) {
			            // return this.shiftR(n).or(this.shiftL(64 - n));
			        // },

			        /**
			         * Adds this word with the passed word.
			         *
			         * @param {X64Word} word The x64-Word to add with this word.
			         *
			         * @return {X64Word} A new x64-Word object after adding.
			         *
			         * @example
			         *
			         *     var added = x64Word.add(anotherX64Word);
			         */
			        // add: function (word) {
			            // var low = (this.low + word.low) | 0;
			            // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;
			            // var high = (this.high + word.high + carry) | 0;

			            // return X64Word.create(high, low);
			        // }
			    });

			    /**
			     * An array of 64-bit words.
			     *
			     * @property {Array} words The array of CryptoJS.x64.Word objects.
			     * @property {number} sigBytes The number of significant bytes in this word array.
			     */
			    C_x64.WordArray = Base.extend({
			        /**
			         * Initializes a newly created word array.
			         *
			         * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.
			         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
			         *
			         * @example
			         *
			         *     var wordArray = CryptoJS.x64.WordArray.create();
			         *
			         *     var wordArray = CryptoJS.x64.WordArray.create([
			         *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
			         *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
			         *     ]);
			         *
			         *     var wordArray = CryptoJS.x64.WordArray.create([
			         *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
			         *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
			         *     ], 10);
			         */
			        init: function (words, sigBytes) {
			            words = this.words = words || [];

			            if (sigBytes != undefined$1) {
			                this.sigBytes = sigBytes;
			            } else {
			                this.sigBytes = words.length * 8;
			            }
			        },

			        /**
			         * Converts this 64-bit word array to a 32-bit word array.
			         *
			         * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.
			         *
			         * @example
			         *
			         *     var x32WordArray = x64WordArray.toX32();
			         */
			        toX32: function () {
			            // Shortcuts
			            var x64Words = this.words;
			            var x64WordsLength = x64Words.length;

			            // Convert
			            var x32Words = [];
			            for (var i = 0; i < x64WordsLength; i++) {
			                var x64Word = x64Words[i];
			                x32Words.push(x64Word.high);
			                x32Words.push(x64Word.low);
			            }

			            return X32WordArray.create(x32Words, this.sigBytes);
			        },

			        /**
			         * Creates a copy of this word array.
			         *
			         * @return {X64WordArray} The clone.
			         *
			         * @example
			         *
			         *     var clone = x64WordArray.clone();
			         */
			        clone: function () {
			            var clone = Base.clone.call(this);

			            // Clone "words" array
			            var words = clone.words = this.words.slice(0);

			            // Clone each X64Word object
			            var wordsLength = words.length;
			            for (var i = 0; i < wordsLength; i++) {
			                words[i] = words[i].clone();
			            }

			            return clone;
			        }
			    });
			}());


			return CryptoJS;

		})); 
	} (x64Core));
	return x64Core.exports;
}

var libTypedarrays = {exports: {}};

var hasRequiredLibTypedarrays;

function requireLibTypedarrays () {
	if (hasRequiredLibTypedarrays) return libTypedarrays.exports;
	hasRequiredLibTypedarrays = 1;
	(function (module, exports) {
(function (root, factory) {
			{
				// CommonJS
				module.exports = factory(requireCore());
			}
		}(commonjsGlobal, function (CryptoJS) {

			(function () {
			    // Check if typed arrays are supported
			    if (typeof ArrayBuffer != 'function') {
			        return;
			    }

			    // Shortcuts
			    var C = CryptoJS;
			    var C_lib = C.lib;
			    var WordArray = C_lib.WordArray;

			    // Reference original init
			    var superInit = WordArray.init;

			    // Augment WordArray.init to handle typed arrays
			    var subInit = WordArray.init = function (typedArray) {
			        // Convert buffers to uint8
			        if (typedArray instanceof ArrayBuffer) {
			            typedArray = new Uint8Array(typedArray);
			        }

			        // Convert other array views to uint8
			        if (
			            typedArray instanceof Int8Array ||
			            (typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray) ||
			            typedArray instanceof Int16Array ||
			            typedArray instanceof Uint16Array ||
			            typedArray instanceof Int32Array ||
			            typedArray instanceof Uint32Array ||
			            typedArray instanceof Float32Array ||
			            typedArray instanceof Float64Array
			        ) {
			            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
			        }

			        // Handle Uint8Array
			        if (typedArray instanceof Uint8Array) {
			            // Shortcut
			            var typedArrayByteLength = typedArray.byteLength;

			            // Extract bytes
			            var words = [];
			            for (var i = 0; i < typedArrayByteLength; i++) {
			                words[i >>> 2] |= typedArray[i] << (24 - (i % 4) * 8);
			            }

			            // Initialize this word array
			            superInit.call(this, words, typedArrayByteLength);
			        } else {
			            // Else call normal init
			            superInit.apply(this, arguments);
			        }
			    };

			    subInit.prototype = WordArray;
			}());


			return CryptoJS.lib.WordArray;

		})); 
	} (libTypedarrays));
	return libTypedarrays.exports;
}

var encUtf16 = {exports: {}};

var hasRequiredEncUtf16;

function requireEncUtf16 () {
	if (hasRequiredEncUtf16) return encUtf16.exports;
	hasRequiredEncUtf16 = 1;
	(function (module, exports) {
(function (root, factory) {
			{
				// CommonJS
				module.exports = factory(requireCore());
			}
		}(commonjsGlobal, function (CryptoJS) {

			(function () {
			    // Shortcuts
			    var C = CryptoJS;
			    var C_lib = C.lib;
			    var WordArray = C_lib.WordArray;
			    var C_enc = C.enc;

			    /**
			     * UTF-16 BE encoding strategy.
			     */
			    C_enc.Utf16 = C_enc.Utf16BE = {
			        /**
			         * Converts a word array to a UTF-16 BE string.
			         *
			         * @param {WordArray} wordArray The word array.
			         *
			         * @return {string} The UTF-16 BE string.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
			         */
			        stringify: function (wordArray) {
			            // Shortcuts
			            var words = wordArray.words;
			            var sigBytes = wordArray.sigBytes;

			            // Convert
			            var utf16Chars = [];
			            for (var i = 0; i < sigBytes; i += 2) {
			                var codePoint = (words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff;
			                utf16Chars.push(String.fromCharCode(codePoint));
			            }

			            return utf16Chars.join('');
			        },

			        /**
			         * Converts a UTF-16 BE string to a word array.
			         *
			         * @param {string} utf16Str The UTF-16 BE string.
			         *
			         * @return {WordArray} The word array.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
			         */
			        parse: function (utf16Str) {
			            // Shortcut
			            var utf16StrLength = utf16Str.length;

			            // Convert
			            var words = [];
			            for (var i = 0; i < utf16StrLength; i++) {
			                words[i >>> 1] |= utf16Str.charCodeAt(i) << (16 - (i % 2) * 16);
			            }

			            return WordArray.create(words, utf16StrLength * 2);
			        }
			    };

			    /**
			     * UTF-16 LE encoding strategy.
			     */
			    C_enc.Utf16LE = {
			        /**
			         * Converts a word array to a UTF-16 LE string.
			         *
			         * @param {WordArray} wordArray The word array.
			         *
			         * @return {string} The UTF-16 LE string.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
			         */
			        stringify: function (wordArray) {
			            // Shortcuts
			            var words = wordArray.words;
			            var sigBytes = wordArray.sigBytes;

			            // Convert
			            var utf16Chars = [];
			            for (var i = 0; i < sigBytes; i += 2) {
			                var codePoint = swapEndian((words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff);
			                utf16Chars.push(String.fromCharCode(codePoint));
			            }

			            return utf16Chars.join('');
			        },

			        /**
			         * Converts a UTF-16 LE string to a word array.
			         *
			         * @param {string} utf16Str The UTF-16 LE string.
			         *
			         * @return {WordArray} The word array.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
			         */
			        parse: function (utf16Str) {
			            // Shortcut
			            var utf16StrLength = utf16Str.length;

			            // Convert
			            var words = [];
			            for (var i = 0; i < utf16StrLength; i++) {
			                words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << (16 - (i % 2) * 16));
			            }

			            return WordArray.create(words, utf16StrLength * 2);
			        }
			    };

			    function swapEndian(word) {
			        return ((word << 8) & 0xff00ff00) | ((word >>> 8) & 0x00ff00ff);
			    }
			}());


			return CryptoJS.enc.Utf16;

		})); 
	} (encUtf16));
	return encUtf16.exports;
}

var encBase64 = {exports: {}};

var hasRequiredEncBase64;

function requireEncBase64 () {
	if (hasRequiredEncBase64) return encBase64.exports;
	hasRequiredEncBase64 = 1;
	(function (module, exports) {
(function (root, factory) {
			{
				// CommonJS
				module.exports = factory(requireCore());
			}
		}(commonjsGlobal, function (CryptoJS) {

			(function () {
			    // Shortcuts
			    var C = CryptoJS;
			    var C_lib = C.lib;
			    var WordArray = C_lib.WordArray;
			    var C_enc = C.enc;

			    /**
			     * Base64 encoding strategy.
			     */
			    C_enc.Base64 = {
			        /**
			         * Converts a word array to a Base64 string.
			         *
			         * @param {WordArray} wordArray The word array.
			         *
			         * @return {string} The Base64 string.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
			         */
			        stringify: function (wordArray) {
			            // Shortcuts
			            var words = wordArray.words;
			            var sigBytes = wordArray.sigBytes;
			            var map = this._map;

			            // Clamp excess bits
			            wordArray.clamp();

			            // Convert
			            var base64Chars = [];
			            for (var i = 0; i < sigBytes; i += 3) {
			                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;
			                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
			                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;

			                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;

			                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {
			                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
			                }
			            }

			            // Add padding
			            var paddingChar = map.charAt(64);
			            if (paddingChar) {
			                while (base64Chars.length % 4) {
			                    base64Chars.push(paddingChar);
			                }
			            }

			            return base64Chars.join('');
			        },

			        /**
			         * Converts a Base64 string to a word array.
			         *
			         * @param {string} base64Str The Base64 string.
			         *
			         * @return {WordArray} The word array.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
			         */
			        parse: function (base64Str) {
			            // Shortcuts
			            var base64StrLength = base64Str.length;
			            var map = this._map;
			            var reverseMap = this._reverseMap;

			            if (!reverseMap) {
			                    reverseMap = this._reverseMap = [];
			                    for (var j = 0; j < map.length; j++) {
			                        reverseMap[map.charCodeAt(j)] = j;
			                    }
			            }

			            // Ignore padding
			            var paddingChar = map.charAt(64);
			            if (paddingChar) {
			                var paddingIndex = base64Str.indexOf(paddingChar);
			                if (paddingIndex !== -1) {
			                    base64StrLength = paddingIndex;
			                }
			            }

			            // Convert
			            return parseLoop(base64Str, base64StrLength, reverseMap);

			        },

			        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
			    };

			    function parseLoop(base64Str, base64StrLength, reverseMap) {
			      var words = [];
			      var nBytes = 0;
			      for (var i = 0; i < base64StrLength; i++) {
			          if (i % 4) {
			              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);
			              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);
			              var bitsCombined = bits1 | bits2;
			              words[nBytes >>> 2] |= bitsCombined << (24 - (nBytes % 4) * 8);
			              nBytes++;
			          }
			      }
			      return WordArray.create(words, nBytes);
			    }
			}());


			return CryptoJS.enc.Base64;

		})); 
	} (encBase64));
	return encBase64.exports;
}

var encBase64url = {exports: {}};

var hasRequiredEncBase64url;

function requireEncBase64url () {
	if (hasRequiredEncBase64url) return encBase64url.exports;
	hasRequiredEncBase64url = 1;
	(function (module, exports) {
(function (root, factory) {
			{
				// CommonJS
				module.exports = factory(requireCore());
			}
		}(commonjsGlobal, function (CryptoJS) {

			(function () {
			    // Shortcuts
			    var C = CryptoJS;
			    var C_lib = C.lib;
			    var WordArray = C_lib.WordArray;
			    var C_enc = C.enc;

			    /**
			     * Base64url encoding strategy.
			     */
			    C_enc.Base64url = {
			        /**
			         * Converts a word array to a Base64url string.
			         *
			         * @param {WordArray} wordArray The word array.
			         *
			         * @param {boolean} urlSafe Whether to use url safe
			         *
			         * @return {string} The Base64url string.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var base64String = CryptoJS.enc.Base64url.stringify(wordArray);
			         */
			        stringify: function (wordArray, urlSafe=true) {
			            // Shortcuts
			            var words = wordArray.words;
			            var sigBytes = wordArray.sigBytes;
			            var map = urlSafe ? this._safe_map : this._map;

			            // Clamp excess bits
			            wordArray.clamp();

			            // Convert
			            var base64Chars = [];
			            for (var i = 0; i < sigBytes; i += 3) {
			                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;
			                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
			                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;

			                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;

			                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {
			                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
			                }
			            }

			            // Add padding
			            var paddingChar = map.charAt(64);
			            if (paddingChar) {
			                while (base64Chars.length % 4) {
			                    base64Chars.push(paddingChar);
			                }
			            }

			            return base64Chars.join('');
			        },

			        /**
			         * Converts a Base64url string to a word array.
			         *
			         * @param {string} base64Str The Base64url string.
			         *
			         * @param {boolean} urlSafe Whether to use url safe
			         *
			         * @return {WordArray} The word array.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var wordArray = CryptoJS.enc.Base64url.parse(base64String);
			         */
			        parse: function (base64Str, urlSafe=true) {
			            // Shortcuts
			            var base64StrLength = base64Str.length;
			            var map = urlSafe ? this._safe_map : this._map;
			            var reverseMap = this._reverseMap;

			            if (!reverseMap) {
			                reverseMap = this._reverseMap = [];
			                for (var j = 0; j < map.length; j++) {
			                    reverseMap[map.charCodeAt(j)] = j;
			                }
			            }

			            // Ignore padding
			            var paddingChar = map.charAt(64);
			            if (paddingChar) {
			                var paddingIndex = base64Str.indexOf(paddingChar);
			                if (paddingIndex !== -1) {
			                    base64StrLength = paddingIndex;
			                }
			            }

			            // Convert
			            return parseLoop(base64Str, base64StrLength, reverseMap);

			        },

			        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
			        _safe_map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',
			    };

			    function parseLoop(base64Str, base64StrLength, reverseMap) {
			        var words = [];
			        var nBytes = 0;
			        for (var i = 0; i < base64StrLength; i++) {
			            if (i % 4) {
			                var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);
			                var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);
			                var bitsCombined = bits1 | bits2;
			                words[nBytes >>> 2] |= bitsCombined << (24 - (nBytes % 4) * 8);
			                nBytes++;
			            }
			        }
			        return WordArray.create(words, nBytes);
			    }
			}());

			return CryptoJS.enc.Base64url;

		})); 
	} (encBase64url));
	return encBase64url.exports;
}

var md5 = {exports: {}};

var hasRequiredMd5;

function requireMd5 () {
	if (hasRequiredMd5) return md5.exports;
	hasRequiredMd5 = 1;
	(function (module, exports) {
(function (root, factory) {
			{
				// CommonJS
				module.exports = factory(requireCore());
			}
		}(commonjsGlobal, function (CryptoJS) {

			(function (Math) {
			    // Shortcuts
			    var C = CryptoJS;
			    var C_lib = C.lib;
			    var WordArray = C_lib.WordArray;
			    var Hasher = C_lib.Hasher;
			    var C_algo = C.algo;

			    // Constants table
			    var T = [];

			    // Compute constants
			    (function () {
			        for (var i = 0; i < 64; i++) {
			            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
			        }
			    }());

			    /**
			     * MD5 hash algorithm.
			     */
			    var MD5 = C_algo.MD5 = Hasher.extend({
			        _doReset: function () {
			            this._hash = new WordArray.init([
			                0x67452301, 0xefcdab89,
			                0x98badcfe, 0x10325476
			            ]);
			        },

			        _doProcessBlock: function (M, offset) {
			            // Swap endian
			            for (var i = 0; i < 16; i++) {
			                // Shortcuts
			                var offset_i = offset + i;
			                var M_offset_i = M[offset_i];

			                M[offset_i] = (
			                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
			                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
			                );
			            }

			            // Shortcuts
			            var H = this._hash.words;

			            var M_offset_0  = M[offset + 0];
			            var M_offset_1  = M[offset + 1];
			            var M_offset_2  = M[offset + 2];
			            var M_offset_3  = M[offset + 3];
			            var M_offset_4  = M[offset + 4];
			            var M_offset_5  = M[offset + 5];
			            var M_offset_6  = M[offset + 6];
			            var M_offset_7  = M[offset + 7];
			            var M_offset_8  = M[offset + 8];
			            var M_offset_9  = M[offset + 9];
			            var M_offset_10 = M[offset + 10];
			            var M_offset_11 = M[offset + 11];
			            var M_offset_12 = M[offset + 12];
			            var M_offset_13 = M[offset + 13];
			            var M_offset_14 = M[offset + 14];
			            var M_offset_15 = M[offset + 15];

			            // Working varialbes
			            var a = H[0];
			            var b = H[1];
			            var c = H[2];
			            var d = H[3];

			            // Computation
			            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);
			            d = FF(d, a, b, c, M_offset_1,  12, T[1]);
			            c = FF(c, d, a, b, M_offset_2,  17, T[2]);
			            b = FF(b, c, d, a, M_offset_3,  22, T[3]);
			            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);
			            d = FF(d, a, b, c, M_offset_5,  12, T[5]);
			            c = FF(c, d, a, b, M_offset_6,  17, T[6]);
			            b = FF(b, c, d, a, M_offset_7,  22, T[7]);
			            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);
			            d = FF(d, a, b, c, M_offset_9,  12, T[9]);
			            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
			            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
			            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);
			            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
			            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
			            b = FF(b, c, d, a, M_offset_15, 22, T[15]);

			            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);
			            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);
			            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
			            b = GG(b, c, d, a, M_offset_0,  20, T[19]);
			            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);
			            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);
			            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
			            b = GG(b, c, d, a, M_offset_4,  20, T[23]);
			            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);
			            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);
			            c = GG(c, d, a, b, M_offset_3,  14, T[26]);
			            b = GG(b, c, d, a, M_offset_8,  20, T[27]);
			            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);
			            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);
			            c = GG(c, d, a, b, M_offset_7,  14, T[30]);
			            b = GG(b, c, d, a, M_offset_12, 20, T[31]);

			            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);
			            d = HH(d, a, b, c, M_offset_8,  11, T[33]);
			            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
			            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
			            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);
			            d = HH(d, a, b, c, M_offset_4,  11, T[37]);
			            c = HH(c, d, a, b, M_offset_7,  16, T[38]);
			            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
			            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);
			            d = HH(d, a, b, c, M_offset_0,  11, T[41]);
			            c = HH(c, d, a, b, M_offset_3,  16, T[42]);
			            b = HH(b, c, d, a, M_offset_6,  23, T[43]);
			            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);
			            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
			            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
			            b = HH(b, c, d, a, M_offset_2,  23, T[47]);

			            a = II(a, b, c, d, M_offset_0,  6,  T[48]);
			            d = II(d, a, b, c, M_offset_7,  10, T[49]);
			            c = II(c, d, a, b, M_offset_14, 15, T[50]);
			            b = II(b, c, d, a, M_offset_5,  21, T[51]);
			            a = II(a, b, c, d, M_offset_12, 6,  T[52]);
			            d = II(d, a, b, c, M_offset_3,  10, T[53]);
			            c = II(c, d, a, b, M_offset_10, 15, T[54]);
			            b = II(b, c, d, a, M_offset_1,  21, T[55]);
			            a = II(a, b, c, d, M_offset_8,  6,  T[56]);
			            d = II(d, a, b, c, M_offset_15, 10, T[57]);
			            c = II(c, d, a, b, M_offset_6,  15, T[58]);
			            b = II(b, c, d, a, M_offset_13, 21, T[59]);
			            a = II(a, b, c, d, M_offset_4,  6,  T[60]);
			            d = II(d, a, b, c, M_offset_11, 10, T[61]);
			            c = II(c, d, a, b, M_offset_2,  15, T[62]);
			            b = II(b, c, d, a, M_offset_9,  21, T[63]);

			            // Intermediate hash value
			            H[0] = (H[0] + a) | 0;
			            H[1] = (H[1] + b) | 0;
			            H[2] = (H[2] + c) | 0;
			            H[3] = (H[3] + d) | 0;
			        },

			        _doFinalize: function () {
			            // Shortcuts
			            var data = this._data;
			            var dataWords = data.words;

			            var nBitsTotal = this._nDataBytes * 8;
			            var nBitsLeft = data.sigBytes * 8;

			            // Add padding
			            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);

			            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
			            var nBitsTotalL = nBitsTotal;
			            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (
			                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |
			                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)
			            );
			            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
			                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |
			                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)
			            );

			            data.sigBytes = (dataWords.length + 1) * 4;

			            // Hash final blocks
			            this._process();

			            // Shortcuts
			            var hash = this._hash;
			            var H = hash.words;

			            // Swap endian
			            for (var i = 0; i < 4; i++) {
			                // Shortcut
			                var H_i = H[i];

			                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
			                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
			            }

			            // Return final computed hash
			            return hash;
			        },

			        clone: function () {
			            var clone = Hasher.clone.call(this);
			            clone._hash = this._hash.clone();

			            return clone;
			        }
			    });

			    function FF(a, b, c, d, x, s, t) {
			        var n = a + ((b & c) | (~b & d)) + x + t;
			        return ((n << s) | (n >>> (32 - s))) + b;
			    }

			    function GG(a, b, c, d, x, s, t) {
			        var n = a + ((b & d) | (c & ~d)) + x + t;
			        return ((n << s) | (n >>> (32 - s))) + b;
			    }

			    function HH(a, b, c, d, x, s, t) {
			        var n = a + (b ^ c ^ d) + x + t;
			        return ((n << s) | (n >>> (32 - s))) + b;
			    }

			    function II(a, b, c, d, x, s, t) {
			        var n = a + (c ^ (b | ~d)) + x + t;
			        return ((n << s) | (n >>> (32 - s))) + b;
			    }

			    /**
			     * Shortcut function to the hasher's object interface.
			     *
			     * @param {WordArray|string} message The message to hash.
			     *
			     * @return {WordArray} The hash.
			     *
			     * @static
			     *
			     * @example
			     *
			     *     var hash = CryptoJS.MD5('message');
			     *     var hash = CryptoJS.MD5(wordArray);
			     */
			    C.MD5 = Hasher._createHelper(MD5);

			    /**
			     * Shortcut function to the HMAC's object interface.
			     *
			     * @param {WordArray|string} message The message to hash.
			     * @param {WordArray|string} key The secret key.
			     *
			     * @return {WordArray} The HMAC.
			     *
			     * @static
			     *
			     * @example
			     *
			     *     var hmac = CryptoJS.HmacMD5(message, key);
			     */
			    C.HmacMD5 = Hasher._createHmacHelper(MD5);
			}(Math));


			return CryptoJS.MD5;

		})); 
	} (md5));
	return md5.exports;
}

var sha1 = {exports: {}};

var hasRequiredSha1;

function requireSha1 () {
	if (hasRequiredSha1) return sha1.exports;
	hasRequiredSha1 = 1;
	(function (module, exports) {
(function (root, factory) {
			{
				// CommonJS
				module.exports = factory(requireCore());
			}
		}(commonjsGlobal, function (CryptoJS) {

			(function () {
			    // Shortcuts
			    var C = CryptoJS;
			    var C_lib = C.lib;
			    var WordArray = C_lib.WordArray;
			    var Hasher = C_lib.Hasher;
			    var C_algo = C.algo;

			    // Reusable object
			    var W = [];

			    /**
			     * SHA-1 hash algorithm.
			     */
			    var SHA1 = C_algo.SHA1 = Hasher.extend({
			        _doReset: function () {
			            this._hash = new WordArray.init([
			                0x67452301, 0xefcdab89,
			                0x98badcfe, 0x10325476,
			                0xc3d2e1f0
			            ]);
			        },

			        _doProcessBlock: function (M, offset) {
			            // Shortcut
			            var H = this._hash.words;

			            // Working variables
			            var a = H[0];
			            var b = H[1];
			            var c = H[2];
			            var d = H[3];
			            var e = H[4];

			            // Computation
			            for (var i = 0; i < 80; i++) {
			                if (i < 16) {
			                    W[i] = M[offset + i] | 0;
			                } else {
			                    var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
			                    W[i] = (n << 1) | (n >>> 31);
			                }

			                var t = ((a << 5) | (a >>> 27)) + e + W[i];
			                if (i < 20) {
			                    t += ((b & c) | (~b & d)) + 0x5a827999;
			                } else if (i < 40) {
			                    t += (b ^ c ^ d) + 0x6ed9eba1;
			                } else if (i < 60) {
			                    t += ((b & c) | (b & d) | (c & d)) - 0x70e44324;
			                } else /* if (i < 80) */ {
			                    t += (b ^ c ^ d) - 0x359d3e2a;
			                }

			                e = d;
			                d = c;
			                c = (b << 30) | (b >>> 2);
			                b = a;
			                a = t;
			            }

			            // Intermediate hash value
			            H[0] = (H[0] + a) | 0;
			            H[1] = (H[1] + b) | 0;
			            H[2] = (H[2] + c) | 0;
			            H[3] = (H[3] + d) | 0;
			            H[4] = (H[4] + e) | 0;
			        },

			        _doFinalize: function () {
			            // Shortcuts
			            var data = this._data;
			            var dataWords = data.words;

			            var nBitsTotal = this._nDataBytes * 8;
			            var nBitsLeft = data.sigBytes * 8;

			            // Add padding
			            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
			            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
			            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
			            data.sigBytes = dataWords.length * 4;

			            // Hash final blocks
			            this._process();

			            // Return final computed hash
			            return this._hash;
			        },

			        clone: function () {
			            var clone = Hasher.clone.call(this);
			            clone._hash = this._hash.clone();

			            return clone;
			        }
			    });

			    /**
			     * Shortcut function to the hasher's object interface.
			     *
			     * @param {WordArray|string} message The message to hash.
			     *
			     * @return {WordArray} The hash.
			     *
			     * @static
			     *
			     * @example
			     *
			     *     var hash = CryptoJS.SHA1('message');
			     *     var hash = CryptoJS.SHA1(wordArray);
			     */
			    C.SHA1 = Hasher._createHelper(SHA1);

			    /**
			     * Shortcut function to the HMAC's object interface.
			     *
			     * @param {WordArray|string} message The message to hash.
			     * @param {WordArray|string} key The secret key.
			     *
			     * @return {WordArray} The HMAC.
			     *
			     * @static
			     *
			     * @example
			     *
			     *     var hmac = CryptoJS.HmacSHA1(message, key);
			     */
			    C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
			}());


			return CryptoJS.SHA1;

		})); 
	} (sha1));
	return sha1.exports;
}

var sha256 = {exports: {}};

var hasRequiredSha256;

function requireSha256 () {
	if (hasRequiredSha256) return sha256.exports;
	hasRequiredSha256 = 1;
	(function (module, exports) {
(function (root, factory) {
			{
				// CommonJS
				module.exports = factory(requireCore());
			}
		}(commonjsGlobal, function (CryptoJS) {

			(function (Math) {
			    // Shortcuts
			    var C = CryptoJS;
			    var C_lib = C.lib;
			    var WordArray = C_lib.WordArray;
			    var Hasher = C_lib.Hasher;
			    var C_algo = C.algo;

			    // Initialization and round constants tables
			    var H = [];
			    var K = [];

			    // Compute constants
			    (function () {
			        function isPrime(n) {
			            var sqrtN = Math.sqrt(n);
			            for (var factor = 2; factor <= sqrtN; factor++) {
			                if (!(n % factor)) {
			                    return false;
			                }
			            }

			            return true;
			        }

			        function getFractionalBits(n) {
			            return ((n - (n | 0)) * 0x100000000) | 0;
			        }

			        var n = 2;
			        var nPrime = 0;
			        while (nPrime < 64) {
			            if (isPrime(n)) {
			                if (nPrime < 8) {
			                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));
			                }
			                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));

			                nPrime++;
			            }

			            n++;
			        }
			    }());

			    // Reusable object
			    var W = [];

			    /**
			     * SHA-256 hash algorithm.
			     */
			    var SHA256 = C_algo.SHA256 = Hasher.extend({
			        _doReset: function () {
			            this._hash = new WordArray.init(H.slice(0));
			        },

			        _doProcessBlock: function (M, offset) {
			            // Shortcut
			            var H = this._hash.words;

			            // Working variables
			            var a = H[0];
			            var b = H[1];
			            var c = H[2];
			            var d = H[3];
			            var e = H[4];
			            var f = H[5];
			            var g = H[6];
			            var h = H[7];

			            // Computation
			            for (var i = 0; i < 64; i++) {
			                if (i < 16) {
			                    W[i] = M[offset + i] | 0;
			                } else {
			                    var gamma0x = W[i - 15];
			                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^
			                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^
			                                   (gamma0x >>> 3);

			                    var gamma1x = W[i - 2];
			                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^
			                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^
			                                   (gamma1x >>> 10);

			                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
			                }

			                var ch  = (e & f) ^ (~e & g);
			                var maj = (a & b) ^ (a & c) ^ (b & c);

			                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));
			                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));

			                var t1 = h + sigma1 + ch + K[i] + W[i];
			                var t2 = sigma0 + maj;

			                h = g;
			                g = f;
			                f = e;
			                e = (d + t1) | 0;
			                d = c;
			                c = b;
			                b = a;
			                a = (t1 + t2) | 0;
			            }

			            // Intermediate hash value
			            H[0] = (H[0] + a) | 0;
			            H[1] = (H[1] + b) | 0;
			            H[2] = (H[2] + c) | 0;
			            H[3] = (H[3] + d) | 0;
			            H[4] = (H[4] + e) | 0;
			            H[5] = (H[5] + f) | 0;
			            H[6] = (H[6] + g) | 0;
			            H[7] = (H[7] + h) | 0;
			        },

			        _doFinalize: function () {
			            // Shortcuts
			            var data = this._data;
			            var dataWords = data.words;

			            var nBitsTotal = this._nDataBytes * 8;
			            var nBitsLeft = data.sigBytes * 8;

			            // Add padding
			            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
			            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
			            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
			            data.sigBytes = dataWords.length * 4;

			            // Hash final blocks
			            this._process();

			            // Return final computed hash
			            return this._hash;
			        },

			        clone: function () {
			            var clone = Hasher.clone.call(this);
			            clone._hash = this._hash.clone();

			            return clone;
			        }
			    });

			    /**
			     * Shortcut function to the hasher's object interface.
			     *
			     * @param {WordArray|string} message The message to hash.
			     *
			     * @return {WordArray} The hash.
			     *
			     * @static
			     *
			     * @example
			     *
			     *     var hash = CryptoJS.SHA256('message');
			     *     var hash = CryptoJS.SHA256(wordArray);
			     */
			    C.SHA256 = Hasher._createHelper(SHA256);

			    /**
			     * Shortcut function to the HMAC's object interface.
			     *
			     * @param {WordArray|string} message The message to hash.
			     * @param {WordArray|string} key The secret key.
			     *
			     * @return {WordArray} The HMAC.
			     *
			     * @static
			     *
			     * @example
			     *
			     *     var hmac = CryptoJS.HmacSHA256(message, key);
			     */
			    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
			}(Math));


			return CryptoJS.SHA256;

		})); 
	} (sha256));
	return sha256.exports;
}

var sha224 = {exports: {}};

var hasRequiredSha224;

function requireSha224 () {
	if (hasRequiredSha224) return sha224.exports;
	hasRequiredSha224 = 1;
	(function (module, exports) {
(function (root, factory, undef) {
			{
				// CommonJS
				module.exports = factory(requireCore(), requireSha256());
			}
		}(commonjsGlobal, function (CryptoJS) {

			(function () {
			    // Shortcuts
			    var C = CryptoJS;
			    var C_lib = C.lib;
			    var WordArray = C_lib.WordArray;
			    var C_algo = C.algo;
			    var SHA256 = C_algo.SHA256;

			    /**
			     * SHA-224 hash algorithm.
			     */
			    var SHA224 = C_algo.SHA224 = SHA256.extend({
			        _doReset: function () {
			            this._hash = new WordArray.init([
			                0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
			                0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4
			            ]);
			        },

			        _doFinalize: function () {
			            var hash = SHA256._doFinalize.call(this);

			            hash.sigBytes -= 4;

			            return hash;
			        }
			    });

			    /**
			     * Shortcut function to the hasher's object interface.
			     *
			     * @param {WordArray|string} message The message to hash.
			     *
			     * @return {WordArray} The hash.
			     *
			     * @static
			     *
			     * @example
			     *
			     *     var hash = CryptoJS.SHA224('message');
			     *     var hash = CryptoJS.SHA224(wordArray);
			     */
			    C.SHA224 = SHA256._createHelper(SHA224);

			    /**
			     * Shortcut function to the HMAC's object interface.
			     *
			     * @param {WordArray|string} message The message to hash.
			     * @param {WordArray|string} key The secret key.
			     *
			     * @return {WordArray} The HMAC.
			     *
			     * @static
			     *
			     * @example
			     *
			     *     var hmac = CryptoJS.HmacSHA224(message, key);
			     */
			    C.HmacSHA224 = SHA256._createHmacHelper(SHA224);
			}());


			return CryptoJS.SHA224;

		})); 
	} (sha224));
	return sha224.exports;
}

var sha512 = {exports: {}};

var hasRequiredSha512;

function requireSha512 () {
	if (hasRequiredSha512) return sha512.exports;
	hasRequiredSha512 = 1;
	(function (module, exports) {
(function (root, factory, undef) {
			{
				// CommonJS
				module.exports = factory(requireCore(), requireX64Core());
			}
		}(commonjsGlobal, function (CryptoJS) {

			(function () {
			    // Shortcuts
			    var C = CryptoJS;
			    var C_lib = C.lib;
			    var Hasher = C_lib.Hasher;
			    var C_x64 = C.x64;
			    var X64Word = C_x64.Word;
			    var X64WordArray = C_x64.WordArray;
			    var C_algo = C.algo;

			    function X64Word_create() {
			        return X64Word.create.apply(X64Word, arguments);
			    }

			    // Constants
			    var K = [
			        X64Word_create(0x428a2f98, 0xd728ae22), X64Word_create(0x71374491, 0x23ef65cd),
			        X64Word_create(0xb5c0fbcf, 0xec4d3b2f), X64Word_create(0xe9b5dba5, 0x8189dbbc),
			        X64Word_create(0x3956c25b, 0xf348b538), X64Word_create(0x59f111f1, 0xb605d019),
			        X64Word_create(0x923f82a4, 0xaf194f9b), X64Word_create(0xab1c5ed5, 0xda6d8118),
			        X64Word_create(0xd807aa98, 0xa3030242), X64Word_create(0x12835b01, 0x45706fbe),
			        X64Word_create(0x243185be, 0x4ee4b28c), X64Word_create(0x550c7dc3, 0xd5ffb4e2),
			        X64Word_create(0x72be5d74, 0xf27b896f), X64Word_create(0x80deb1fe, 0x3b1696b1),
			        X64Word_create(0x9bdc06a7, 0x25c71235), X64Word_create(0xc19bf174, 0xcf692694),
			        X64Word_create(0xe49b69c1, 0x9ef14ad2), X64Word_create(0xefbe4786, 0x384f25e3),
			        X64Word_create(0x0fc19dc6, 0x8b8cd5b5), X64Word_create(0x240ca1cc, 0x77ac9c65),
			        X64Word_create(0x2de92c6f, 0x592b0275), X64Word_create(0x4a7484aa, 0x6ea6e483),
			        X64Word_create(0x5cb0a9dc, 0xbd41fbd4), X64Word_create(0x76f988da, 0x831153b5),
			        X64Word_create(0x983e5152, 0xee66dfab), X64Word_create(0xa831c66d, 0x2db43210),
			        X64Word_create(0xb00327c8, 0x98fb213f), X64Word_create(0xbf597fc7, 0xbeef0ee4),
			        X64Word_create(0xc6e00bf3, 0x3da88fc2), X64Word_create(0xd5a79147, 0x930aa725),
			        X64Word_create(0x06ca6351, 0xe003826f), X64Word_create(0x14292967, 0x0a0e6e70),
			        X64Word_create(0x27b70a85, 0x46d22ffc), X64Word_create(0x2e1b2138, 0x5c26c926),
			        X64Word_create(0x4d2c6dfc, 0x5ac42aed), X64Word_create(0x53380d13, 0x9d95b3df),
			        X64Word_create(0x650a7354, 0x8baf63de), X64Word_create(0x766a0abb, 0x3c77b2a8),
			        X64Word_create(0x81c2c92e, 0x47edaee6), X64Word_create(0x92722c85, 0x1482353b),
			        X64Word_create(0xa2bfe8a1, 0x4cf10364), X64Word_create(0xa81a664b, 0xbc423001),
			        X64Word_create(0xc24b8b70, 0xd0f89791), X64Word_create(0xc76c51a3, 0x0654be30),
			        X64Word_create(0xd192e819, 0xd6ef5218), X64Word_create(0xd6990624, 0x5565a910),
			        X64Word_create(0xf40e3585, 0x5771202a), X64Word_create(0x106aa070, 0x32bbd1b8),
			        X64Word_create(0x19a4c116, 0xb8d2d0c8), X64Word_create(0x1e376c08, 0x5141ab53),
			        X64Word_create(0x2748774c, 0xdf8eeb99), X64Word_create(0x34b0bcb5, 0xe19b48a8),
			        X64Word_create(0x391c0cb3, 0xc5c95a63), X64Word_create(0x4ed8aa4a, 0xe3418acb),
			        X64Word_create(0x5b9cca4f, 0x7763e373), X64Word_create(0x682e6ff3, 0xd6b2b8a3),
			        X64Word_create(0x748f82ee, 0x5defb2fc), X64Word_create(0x78a5636f, 0x43172f60),
			        X64Word_create(0x84c87814, 0xa1f0ab72), X64Word_create(0x8cc70208, 0x1a6439ec),
			        X64Word_create(0x90befffa, 0x23631e28), X64Word_create(0xa4506ceb, 0xde82bde9),
			        X64Word_create(0xbef9a3f7, 0xb2c67915), X64Word_create(0xc67178f2, 0xe372532b),
			        X64Word_create(0xca273ece, 0xea26619c), X64Word_create(0xd186b8c7, 0x21c0c207),
			        X64Word_create(0xeada7dd6, 0xcde0eb1e), X64Word_create(0xf57d4f7f, 0xee6ed178),
			        X64Word_create(0x06f067aa, 0x72176fba), X64Word_create(0x0a637dc5, 0xa2c898a6),
			        X64Word_create(0x113f9804, 0xbef90dae), X64Word_create(0x1b710b35, 0x131c471b),
			        X64Word_create(0x28db77f5, 0x23047d84), X64Word_create(0x32caab7b, 0x40c72493),
			        X64Word_create(0x3c9ebe0a, 0x15c9bebc), X64Word_create(0x431d67c4, 0x9c100d4c),
			        X64Word_create(0x4cc5d4be, 0xcb3e42b6), X64Word_create(0x597f299c, 0xfc657e2a),
			        X64Word_create(0x5fcb6fab, 0x3ad6faec), X64Word_create(0x6c44198c, 0x4a475817)
			    ];

			    // Reusable objects
			    var W = [];
			    (function () {
			        for (var i = 0; i < 80; i++) {
			            W[i] = X64Word_create();
			        }
			    }());

			    /**
			     * SHA-512 hash algorithm.
			     */
			    var SHA512 = C_algo.SHA512 = Hasher.extend({
			        _doReset: function () {
			            this._hash = new X64WordArray.init([
			                new X64Word.init(0x6a09e667, 0xf3bcc908), new X64Word.init(0xbb67ae85, 0x84caa73b),
			                new X64Word.init(0x3c6ef372, 0xfe94f82b), new X64Word.init(0xa54ff53a, 0x5f1d36f1),
			                new X64Word.init(0x510e527f, 0xade682d1), new X64Word.init(0x9b05688c, 0x2b3e6c1f),
			                new X64Word.init(0x1f83d9ab, 0xfb41bd6b), new X64Word.init(0x5be0cd19, 0x137e2179)
			            ]);
			        },

			        _doProcessBlock: function (M, offset) {
			            // Shortcuts
			            var H = this._hash.words;

			            var H0 = H[0];
			            var H1 = H[1];
			            var H2 = H[2];
			            var H3 = H[3];
			            var H4 = H[4];
			            var H5 = H[5];
			            var H6 = H[6];
			            var H7 = H[7];

			            var H0h = H0.high;
			            var H0l = H0.low;
			            var H1h = H1.high;
			            var H1l = H1.low;
			            var H2h = H2.high;
			            var H2l = H2.low;
			            var H3h = H3.high;
			            var H3l = H3.low;
			            var H4h = H4.high;
			            var H4l = H4.low;
			            var H5h = H5.high;
			            var H5l = H5.low;
			            var H6h = H6.high;
			            var H6l = H6.low;
			            var H7h = H7.high;
			            var H7l = H7.low;

			            // Working variables
			            var ah = H0h;
			            var al = H0l;
			            var bh = H1h;
			            var bl = H1l;
			            var ch = H2h;
			            var cl = H2l;
			            var dh = H3h;
			            var dl = H3l;
			            var eh = H4h;
			            var el = H4l;
			            var fh = H5h;
			            var fl = H5l;
			            var gh = H6h;
			            var gl = H6l;
			            var hh = H7h;
			            var hl = H7l;

			            // Rounds
			            for (var i = 0; i < 80; i++) {
			                var Wil;
			                var Wih;

			                // Shortcut
			                var Wi = W[i];

			                // Extend message
			                if (i < 16) {
			                    Wih = Wi.high = M[offset + i * 2]     | 0;
			                    Wil = Wi.low  = M[offset + i * 2 + 1] | 0;
			                } else {
			                    // Gamma0
			                    var gamma0x  = W[i - 15];
			                    var gamma0xh = gamma0x.high;
			                    var gamma0xl = gamma0x.low;
			                    var gamma0h  = ((gamma0xh >>> 1) | (gamma0xl << 31)) ^ ((gamma0xh >>> 8) | (gamma0xl << 24)) ^ (gamma0xh >>> 7);
			                    var gamma0l  = ((gamma0xl >>> 1) | (gamma0xh << 31)) ^ ((gamma0xl >>> 8) | (gamma0xh << 24)) ^ ((gamma0xl >>> 7) | (gamma0xh << 25));

			                    // Gamma1
			                    var gamma1x  = W[i - 2];
			                    var gamma1xh = gamma1x.high;
			                    var gamma1xl = gamma1x.low;
			                    var gamma1h  = ((gamma1xh >>> 19) | (gamma1xl << 13)) ^ ((gamma1xh << 3) | (gamma1xl >>> 29)) ^ (gamma1xh >>> 6);
			                    var gamma1l  = ((gamma1xl >>> 19) | (gamma1xh << 13)) ^ ((gamma1xl << 3) | (gamma1xh >>> 29)) ^ ((gamma1xl >>> 6) | (gamma1xh << 26));

			                    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
			                    var Wi7  = W[i - 7];
			                    var Wi7h = Wi7.high;
			                    var Wi7l = Wi7.low;

			                    var Wi16  = W[i - 16];
			                    var Wi16h = Wi16.high;
			                    var Wi16l = Wi16.low;

			                    Wil = gamma0l + Wi7l;
			                    Wih = gamma0h + Wi7h + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0);
			                    Wil = Wil + gamma1l;
			                    Wih = Wih + gamma1h + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0);
			                    Wil = Wil + Wi16l;
			                    Wih = Wih + Wi16h + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0);

			                    Wi.high = Wih;
			                    Wi.low  = Wil;
			                }

			                var chh  = (eh & fh) ^ (~eh & gh);
			                var chl  = (el & fl) ^ (~el & gl);
			                var majh = (ah & bh) ^ (ah & ch) ^ (bh & ch);
			                var majl = (al & bl) ^ (al & cl) ^ (bl & cl);

			                var sigma0h = ((ah >>> 28) | (al << 4))  ^ ((ah << 30)  | (al >>> 2)) ^ ((ah << 25) | (al >>> 7));
			                var sigma0l = ((al >>> 28) | (ah << 4))  ^ ((al << 30)  | (ah >>> 2)) ^ ((al << 25) | (ah >>> 7));
			                var sigma1h = ((eh >>> 14) | (el << 18)) ^ ((eh >>> 18) | (el << 14)) ^ ((eh << 23) | (el >>> 9));
			                var sigma1l = ((el >>> 14) | (eh << 18)) ^ ((el >>> 18) | (eh << 14)) ^ ((el << 23) | (eh >>> 9));

			                // t1 = h + sigma1 + ch + K[i] + W[i]
			                var Ki  = K[i];
			                var Kih = Ki.high;
			                var Kil = Ki.low;

			                var t1l = hl + sigma1l;
			                var t1h = hh + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0);
			                var t1l = t1l + chl;
			                var t1h = t1h + chh + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0);
			                var t1l = t1l + Kil;
			                var t1h = t1h + Kih + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0);
			                var t1l = t1l + Wil;
			                var t1h = t1h + Wih + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0);

			                // t2 = sigma0 + maj
			                var t2l = sigma0l + majl;
			                var t2h = sigma0h + majh + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0);

			                // Update working variables
			                hh = gh;
			                hl = gl;
			                gh = fh;
			                gl = fl;
			                fh = eh;
			                fl = el;
			                el = (dl + t1l) | 0;
			                eh = (dh + t1h + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;
			                dh = ch;
			                dl = cl;
			                ch = bh;
			                cl = bl;
			                bh = ah;
			                bl = al;
			                al = (t1l + t2l) | 0;
			                ah = (t1h + t2h + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0;
			            }

			            // Intermediate hash value
			            H0l = H0.low  = (H0l + al);
			            H0.high = (H0h + ah + ((H0l >>> 0) < (al >>> 0) ? 1 : 0));
			            H1l = H1.low  = (H1l + bl);
			            H1.high = (H1h + bh + ((H1l >>> 0) < (bl >>> 0) ? 1 : 0));
			            H2l = H2.low  = (H2l + cl);
			            H2.high = (H2h + ch + ((H2l >>> 0) < (cl >>> 0) ? 1 : 0));
			            H3l = H3.low  = (H3l + dl);
			            H3.high = (H3h + dh + ((H3l >>> 0) < (dl >>> 0) ? 1 : 0));
			            H4l = H4.low  = (H4l + el);
			            H4.high = (H4h + eh + ((H4l >>> 0) < (el >>> 0) ? 1 : 0));
			            H5l = H5.low  = (H5l + fl);
			            H5.high = (H5h + fh + ((H5l >>> 0) < (fl >>> 0) ? 1 : 0));
			            H6l = H6.low  = (H6l + gl);
			            H6.high = (H6h + gh + ((H6l >>> 0) < (gl >>> 0) ? 1 : 0));
			            H7l = H7.low  = (H7l + hl);
			            H7.high = (H7h + hh + ((H7l >>> 0) < (hl >>> 0) ? 1 : 0));
			        },

			        _doFinalize: function () {
			            // Shortcuts
			            var data = this._data;
			            var dataWords = data.words;

			            var nBitsTotal = this._nDataBytes * 8;
			            var nBitsLeft = data.sigBytes * 8;

			            // Add padding
			            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
			            dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 30] = Math.floor(nBitsTotal / 0x100000000);
			            dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 31] = nBitsTotal;
			            data.sigBytes = dataWords.length * 4;

			            // Hash final blocks
			            this._process();

			            // Convert hash to 32-bit word array before returning
			            var hash = this._hash.toX32();

			            // Return final computed hash
			            return hash;
			        },

			        clone: function () {
			            var clone = Hasher.clone.call(this);
			            clone._hash = this._hash.clone();

			            return clone;
			        },

			        blockSize: 1024/32
			    });

			    /**
			     * Shortcut function to the hasher's object interface.
			     *
			     * @param {WordArray|string} message The message to hash.
			     *
			     * @return {WordArray} The hash.
			     *
			     * @static
			     *
			     * @example
			     *
			     *     var hash = CryptoJS.SHA512('message');
			     *     var hash = CryptoJS.SHA512(wordArray);
			     */
			    C.SHA512 = Hasher._createHelper(SHA512);

			    /**
			     * Shortcut function to the HMAC's object interface.
			     *
			     * @param {WordArray|string} message The message to hash.
			     * @param {WordArray|string} key The secret key.
			     *
			     * @return {WordArray} The HMAC.
			     *
			     * @static
			     *
			     * @example
			     *
			     *     var hmac = CryptoJS.HmacSHA512(message, key);
			     */
			    C.HmacSHA512 = Hasher._createHmacHelper(SHA512);
			}());


			return CryptoJS.SHA512;

		})); 
	} (sha512));
	return sha512.exports;
}

var sha384 = {exports: {}};

var hasRequiredSha384;

function requireSha384 () {
	if (hasRequiredSha384) return sha384.exports;
	hasRequiredSha384 = 1;
	(function (module, exports) {
(function (root, factory, undef) {
			{
				// CommonJS
				module.exports = factory(requireCore(), requireX64Core(), requireSha512());
			}
		}(commonjsGlobal, function (CryptoJS) {

			(function () {
			    // Shortcuts
			    var C = CryptoJS;
			    var C_x64 = C.x64;
			    var X64Word = C_x64.Word;
			    var X64WordArray = C_x64.WordArray;
			    var C_algo = C.algo;
			    var SHA512 = C_algo.SHA512;

			    /**
			     * SHA-384 hash algorithm.
			     */
			    var SHA384 = C_algo.SHA384 = SHA512.extend({
			        _doReset: function () {
			            this._hash = new X64WordArray.init([
			                new X64Word.init(0xcbbb9d5d, 0xc1059ed8), new X64Word.init(0x629a292a, 0x367cd507),
			                new X64Word.init(0x9159015a, 0x3070dd17), new X64Word.init(0x152fecd8, 0xf70e5939),
			                new X64Word.init(0x67332667, 0xffc00b31), new X64Word.init(0x8eb44a87, 0x68581511),
			                new X64Word.init(0xdb0c2e0d, 0x64f98fa7), new X64Word.init(0x47b5481d, 0xbefa4fa4)
			            ]);
			        },

			        _doFinalize: function () {
			            var hash = SHA512._doFinalize.call(this);

			            hash.sigBytes -= 16;

			            return hash;
			        }
			    });

			    /**
			     * Shortcut function to the hasher's object interface.
			     *
			     * @param {WordArray|string} message The message to hash.
			     *
			     * @return {WordArray} The hash.
			     *
			     * @static
			     *
			     * @example
			     *
			     *     var hash = CryptoJS.SHA384('message');
			     *     var hash = CryptoJS.SHA384(wordArray);
			     */
			    C.SHA384 = SHA512._createHelper(SHA384);

			    /**
			     * Shortcut function to the HMAC's object interface.
			     *
			     * @param {WordArray|string} message The message to hash.
			     * @param {WordArray|string} key The secret key.
			     *
			     * @return {WordArray} The HMAC.
			     *
			     * @static
			     *
			     * @example
			     *
			     *     var hmac = CryptoJS.HmacSHA384(message, key);
			     */
			    C.HmacSHA384 = SHA512._createHmacHelper(SHA384);
			}());


			return CryptoJS.SHA384;

		})); 
	} (sha384));
	return sha384.exports;
}

var sha3 = {exports: {}};

var hasRequiredSha3;

function requireSha3 () {
	if (hasRequiredSha3) return sha3.exports;
	hasRequiredSha3 = 1;
	(function (module, exports) {
(function (root, factory, undef) {
			{
				// CommonJS
				module.exports = factory(requireCore(), requireX64Core());
			}
		}(commonjsGlobal, function (CryptoJS) {

			(function (Math) {
			    // Shortcuts
			    var C = CryptoJS;
			    var C_lib = C.lib;
			    var WordArray = C_lib.WordArray;
			    var Hasher = C_lib.Hasher;
			    var C_x64 = C.x64;
			    var X64Word = C_x64.Word;
			    var C_algo = C.algo;

			    // Constants tables
			    var RHO_OFFSETS = [];
			    var PI_INDEXES  = [];
			    var ROUND_CONSTANTS = [];

			    // Compute Constants
			    (function () {
			        // Compute rho offset constants
			        var x = 1, y = 0;
			        for (var t = 0; t < 24; t++) {
			            RHO_OFFSETS[x + 5 * y] = ((t + 1) * (t + 2) / 2) % 64;

			            var newX = y % 5;
			            var newY = (2 * x + 3 * y) % 5;
			            x = newX;
			            y = newY;
			        }

			        // Compute pi index constants
			        for (var x = 0; x < 5; x++) {
			            for (var y = 0; y < 5; y++) {
			                PI_INDEXES[x + 5 * y] = y + ((2 * x + 3 * y) % 5) * 5;
			            }
			        }

			        // Compute round constants
			        var LFSR = 0x01;
			        for (var i = 0; i < 24; i++) {
			            var roundConstantMsw = 0;
			            var roundConstantLsw = 0;

			            for (var j = 0; j < 7; j++) {
			                if (LFSR & 0x01) {
			                    var bitPosition = (1 << j) - 1;
			                    if (bitPosition < 32) {
			                        roundConstantLsw ^= 1 << bitPosition;
			                    } else /* if (bitPosition >= 32) */ {
			                        roundConstantMsw ^= 1 << (bitPosition - 32);
			                    }
			                }

			                // Compute next LFSR
			                if (LFSR & 0x80) {
			                    // Primitive polynomial over GF(2): x^8 + x^6 + x^5 + x^4 + 1
			                    LFSR = (LFSR << 1) ^ 0x71;
			                } else {
			                    LFSR <<= 1;
			                }
			            }

			            ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);
			        }
			    }());

			    // Reusable objects for temporary values
			    var T = [];
			    (function () {
			        for (var i = 0; i < 25; i++) {
			            T[i] = X64Word.create();
			        }
			    }());

			    /**
			     * SHA-3 hash algorithm.
			     */
			    var SHA3 = C_algo.SHA3 = Hasher.extend({
			        /**
			         * Configuration options.
			         *
			         * @property {number} outputLength
			         *   The desired number of bits in the output hash.
			         *   Only values permitted are: 224, 256, 384, 512.
			         *   Default: 512
			         */
			        cfg: Hasher.cfg.extend({
			            outputLength: 512
			        }),

			        _doReset: function () {
			            var state = this._state = [];
			            for (var i = 0; i < 25; i++) {
			                state[i] = new X64Word.init();
			            }

			            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
			        },

			        _doProcessBlock: function (M, offset) {
			            // Shortcuts
			            var state = this._state;
			            var nBlockSizeLanes = this.blockSize / 2;

			            // Absorb
			            for (var i = 0; i < nBlockSizeLanes; i++) {
			                // Shortcuts
			                var M2i  = M[offset + 2 * i];
			                var M2i1 = M[offset + 2 * i + 1];

			                // Swap endian
			                M2i = (
			                    (((M2i << 8)  | (M2i >>> 24)) & 0x00ff00ff) |
			                    (((M2i << 24) | (M2i >>> 8))  & 0xff00ff00)
			                );
			                M2i1 = (
			                    (((M2i1 << 8)  | (M2i1 >>> 24)) & 0x00ff00ff) |
			                    (((M2i1 << 24) | (M2i1 >>> 8))  & 0xff00ff00)
			                );

			                // Absorb message into state
			                var lane = state[i];
			                lane.high ^= M2i1;
			                lane.low  ^= M2i;
			            }

			            // Rounds
			            for (var round = 0; round < 24; round++) {
			                // Theta
			                for (var x = 0; x < 5; x++) {
			                    // Mix column lanes
			                    var tMsw = 0, tLsw = 0;
			                    for (var y = 0; y < 5; y++) {
			                        var lane = state[x + 5 * y];
			                        tMsw ^= lane.high;
			                        tLsw ^= lane.low;
			                    }

			                    // Temporary values
			                    var Tx = T[x];
			                    Tx.high = tMsw;
			                    Tx.low  = tLsw;
			                }
			                for (var x = 0; x < 5; x++) {
			                    // Shortcuts
			                    var Tx4 = T[(x + 4) % 5];
			                    var Tx1 = T[(x + 1) % 5];
			                    var Tx1Msw = Tx1.high;
			                    var Tx1Lsw = Tx1.low;

			                    // Mix surrounding columns
			                    var tMsw = Tx4.high ^ ((Tx1Msw << 1) | (Tx1Lsw >>> 31));
			                    var tLsw = Tx4.low  ^ ((Tx1Lsw << 1) | (Tx1Msw >>> 31));
			                    for (var y = 0; y < 5; y++) {
			                        var lane = state[x + 5 * y];
			                        lane.high ^= tMsw;
			                        lane.low  ^= tLsw;
			                    }
			                }

			                // Rho Pi
			                for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
			                    var tMsw;
			                    var tLsw;

			                    // Shortcuts
			                    var lane = state[laneIndex];
			                    var laneMsw = lane.high;
			                    var laneLsw = lane.low;
			                    var rhoOffset = RHO_OFFSETS[laneIndex];

			                    // Rotate lanes
			                    if (rhoOffset < 32) {
			                        tMsw = (laneMsw << rhoOffset) | (laneLsw >>> (32 - rhoOffset));
			                        tLsw = (laneLsw << rhoOffset) | (laneMsw >>> (32 - rhoOffset));
			                    } else /* if (rhoOffset >= 32) */ {
			                        tMsw = (laneLsw << (rhoOffset - 32)) | (laneMsw >>> (64 - rhoOffset));
			                        tLsw = (laneMsw << (rhoOffset - 32)) | (laneLsw >>> (64 - rhoOffset));
			                    }

			                    // Transpose lanes
			                    var TPiLane = T[PI_INDEXES[laneIndex]];
			                    TPiLane.high = tMsw;
			                    TPiLane.low  = tLsw;
			                }

			                // Rho pi at x = y = 0
			                var T0 = T[0];
			                var state0 = state[0];
			                T0.high = state0.high;
			                T0.low  = state0.low;

			                // Chi
			                for (var x = 0; x < 5; x++) {
			                    for (var y = 0; y < 5; y++) {
			                        // Shortcuts
			                        var laneIndex = x + 5 * y;
			                        var lane = state[laneIndex];
			                        var TLane = T[laneIndex];
			                        var Tx1Lane = T[((x + 1) % 5) + 5 * y];
			                        var Tx2Lane = T[((x + 2) % 5) + 5 * y];

			                        // Mix rows
			                        lane.high = TLane.high ^ (~Tx1Lane.high & Tx2Lane.high);
			                        lane.low  = TLane.low  ^ (~Tx1Lane.low  & Tx2Lane.low);
			                    }
			                }

			                // Iota
			                var lane = state[0];
			                var roundConstant = ROUND_CONSTANTS[round];
			                lane.high ^= roundConstant.high;
			                lane.low  ^= roundConstant.low;
			            }
			        },

			        _doFinalize: function () {
			            // Shortcuts
			            var data = this._data;
			            var dataWords = data.words;
			            this._nDataBytes * 8;
			            var nBitsLeft = data.sigBytes * 8;
			            var blockSizeBits = this.blockSize * 32;

			            // Add padding
			            dataWords[nBitsLeft >>> 5] |= 0x1 << (24 - nBitsLeft % 32);
			            dataWords[((Math.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits) >>> 5) - 1] |= 0x80;
			            data.sigBytes = dataWords.length * 4;

			            // Hash final blocks
			            this._process();

			            // Shortcuts
			            var state = this._state;
			            var outputLengthBytes = this.cfg.outputLength / 8;
			            var outputLengthLanes = outputLengthBytes / 8;

			            // Squeeze
			            var hashWords = [];
			            for (var i = 0; i < outputLengthLanes; i++) {
			                // Shortcuts
			                var lane = state[i];
			                var laneMsw = lane.high;
			                var laneLsw = lane.low;

			                // Swap endian
			                laneMsw = (
			                    (((laneMsw << 8)  | (laneMsw >>> 24)) & 0x00ff00ff) |
			                    (((laneMsw << 24) | (laneMsw >>> 8))  & 0xff00ff00)
			                );
			                laneLsw = (
			                    (((laneLsw << 8)  | (laneLsw >>> 24)) & 0x00ff00ff) |
			                    (((laneLsw << 24) | (laneLsw >>> 8))  & 0xff00ff00)
			                );

			                // Squeeze state to retrieve hash
			                hashWords.push(laneLsw);
			                hashWords.push(laneMsw);
			            }

			            // Return final computed hash
			            return new WordArray.init(hashWords, outputLengthBytes);
			        },

			        clone: function () {
			            var clone = Hasher.clone.call(this);

			            var state = clone._state = this._state.slice(0);
			            for (var i = 0; i < 25; i++) {
			                state[i] = state[i].clone();
			            }

			            return clone;
			        }
			    });

			    /**
			     * Shortcut function to the hasher's object interface.
			     *
			     * @param {WordArray|string} message The message to hash.
			     *
			     * @return {WordArray} The hash.
			     *
			     * @static
			     *
			     * @example
			     *
			     *     var hash = CryptoJS.SHA3('message');
			     *     var hash = CryptoJS.SHA3(wordArray);
			     */
			    C.SHA3 = Hasher._createHelper(SHA3);

			    /**
			     * Shortcut function to the HMAC's object interface.
			     *
			     * @param {WordArray|string} message The message to hash.
			     * @param {WordArray|string} key The secret key.
			     *
			     * @return {WordArray} The HMAC.
			     *
			     * @static
			     *
			     * @example
			     *
			     *     var hmac = CryptoJS.HmacSHA3(message, key);
			     */
			    C.HmacSHA3 = Hasher._createHmacHelper(SHA3);
			}(Math));


			return CryptoJS.SHA3;

		})); 
	} (sha3));
	return sha3.exports;
}

var ripemd160 = {exports: {}};

var hasRequiredRipemd160;

function requireRipemd160 () {
	if (hasRequiredRipemd160) return ripemd160.exports;
	hasRequiredRipemd160 = 1;
	(function (module, exports) {
(function (root, factory) {
			{
				// CommonJS
				module.exports = factory(requireCore());
			}
		}(commonjsGlobal, function (CryptoJS) {

			/** @preserve
			(c) 2012 by Cdric Mesnil. All rights reserved.

			Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

			    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
			    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

			THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
			*/

			(function (Math) {
			    // Shortcuts
			    var C = CryptoJS;
			    var C_lib = C.lib;
			    var WordArray = C_lib.WordArray;
			    var Hasher = C_lib.Hasher;
			    var C_algo = C.algo;

			    // Constants table
			    var _zl = WordArray.create([
			        0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
			        7,  4, 13,  1, 10,  6, 15,  3, 12,  0,  9,  5,  2, 14, 11,  8,
			        3, 10, 14,  4,  9, 15,  8,  1,  2,  7,  0,  6, 13, 11,  5, 12,
			        1,  9, 11, 10,  0,  8, 12,  4, 13,  3,  7, 15, 14,  5,  6,  2,
			        4,  0,  5,  9,  7, 12,  2, 10, 14,  1,  3,  8, 11,  6, 15, 13]);
			    var _zr = WordArray.create([
			        5, 14,  7,  0,  9,  2, 11,  4, 13,  6, 15,  8,  1, 10,  3, 12,
			        6, 11,  3,  7,  0, 13,  5, 10, 14, 15,  8, 12,  4,  9,  1,  2,
			        15,  5,  1,  3,  7, 14,  6,  9, 11,  8, 12,  2, 10,  0,  4, 13,
			        8,  6,  4,  1,  3, 11, 15,  0,  5, 12,  2, 13,  9,  7, 10, 14,
			        12, 15, 10,  4,  1,  5,  8,  7,  6,  2, 13, 14,  0,  3,  9, 11]);
			    var _sl = WordArray.create([
			         11, 14, 15, 12,  5,  8,  7,  9, 11, 13, 14, 15,  6,  7,  9,  8,
			        7, 6,   8, 13, 11,  9,  7, 15,  7, 12, 15,  9, 11,  7, 13, 12,
			        11, 13,  6,  7, 14,  9, 13, 15, 14,  8, 13,  6,  5, 12,  7,  5,
			          11, 12, 14, 15, 14, 15,  9,  8,  9, 14,  5,  6,  8,  6,  5, 12,
			        9, 15,  5, 11,  6,  8, 13, 12,  5, 12, 13, 14, 11,  8,  5,  6 ]);
			    var _sr = WordArray.create([
			        8,  9,  9, 11, 13, 15, 15,  5,  7,  7,  8, 11, 14, 14, 12,  6,
			        9, 13, 15,  7, 12,  8,  9, 11,  7,  7, 12,  7,  6, 15, 13, 11,
			        9,  7, 15, 11,  8,  6,  6, 14, 12, 13,  5, 14, 13, 13,  7,  5,
			        15,  5,  8, 11, 14, 14,  6, 14,  6,  9, 12,  9, 12,  5, 15,  8,
			        8,  5, 12,  9, 12,  5, 14,  6,  8, 13,  6,  5, 15, 13, 11, 11 ]);

			    var _hl =  WordArray.create([ 0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E]);
			    var _hr =  WordArray.create([ 0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000]);

			    /**
			     * RIPEMD160 hash algorithm.
			     */
			    var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({
			        _doReset: function () {
			            this._hash  = WordArray.create([0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]);
			        },

			        _doProcessBlock: function (M, offset) {

			            // Swap endian
			            for (var i = 0; i < 16; i++) {
			                // Shortcuts
			                var offset_i = offset + i;
			                var M_offset_i = M[offset_i];

			                // Swap
			                M[offset_i] = (
			                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
			                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
			                );
			            }
			            // Shortcut
			            var H  = this._hash.words;
			            var hl = _hl.words;
			            var hr = _hr.words;
			            var zl = _zl.words;
			            var zr = _zr.words;
			            var sl = _sl.words;
			            var sr = _sr.words;

			            // Working variables
			            var al, bl, cl, dl, el;
			            var ar, br, cr, dr, er;

			            ar = al = H[0];
			            br = bl = H[1];
			            cr = cl = H[2];
			            dr = dl = H[3];
			            er = el = H[4];
			            // Computation
			            var t;
			            for (var i = 0; i < 80; i += 1) {
			                t = (al +  M[offset+zl[i]])|0;
			                if (i<16){
				            t +=  f1(bl,cl,dl) + hl[0];
			                } else if (i<32) {
				            t +=  f2(bl,cl,dl) + hl[1];
			                } else if (i<48) {
				            t +=  f3(bl,cl,dl) + hl[2];
			                } else if (i<64) {
				            t +=  f4(bl,cl,dl) + hl[3];
			                } else {// if (i<80) {
				            t +=  f5(bl,cl,dl) + hl[4];
			                }
			                t = t|0;
			                t =  rotl(t,sl[i]);
			                t = (t+el)|0;
			                al = el;
			                el = dl;
			                dl = rotl(cl, 10);
			                cl = bl;
			                bl = t;

			                t = (ar + M[offset+zr[i]])|0;
			                if (i<16){
				            t +=  f5(br,cr,dr) + hr[0];
			                } else if (i<32) {
				            t +=  f4(br,cr,dr) + hr[1];
			                } else if (i<48) {
				            t +=  f3(br,cr,dr) + hr[2];
			                } else if (i<64) {
				            t +=  f2(br,cr,dr) + hr[3];
			                } else {// if (i<80) {
				            t +=  f1(br,cr,dr) + hr[4];
			                }
			                t = t|0;
			                t =  rotl(t,sr[i]) ;
			                t = (t+er)|0;
			                ar = er;
			                er = dr;
			                dr = rotl(cr, 10);
			                cr = br;
			                br = t;
			            }
			            // Intermediate hash value
			            t    = (H[1] + cl + dr)|0;
			            H[1] = (H[2] + dl + er)|0;
			            H[2] = (H[3] + el + ar)|0;
			            H[3] = (H[4] + al + br)|0;
			            H[4] = (H[0] + bl + cr)|0;
			            H[0] =  t;
			        },

			        _doFinalize: function () {
			            // Shortcuts
			            var data = this._data;
			            var dataWords = data.words;

			            var nBitsTotal = this._nDataBytes * 8;
			            var nBitsLeft = data.sigBytes * 8;

			            // Add padding
			            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
			            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
			                (((nBitsTotal << 8)  | (nBitsTotal >>> 24)) & 0x00ff00ff) |
			                (((nBitsTotal << 24) | (nBitsTotal >>> 8))  & 0xff00ff00)
			            );
			            data.sigBytes = (dataWords.length + 1) * 4;

			            // Hash final blocks
			            this._process();

			            // Shortcuts
			            var hash = this._hash;
			            var H = hash.words;

			            // Swap endian
			            for (var i = 0; i < 5; i++) {
			                // Shortcut
			                var H_i = H[i];

			                // Swap
			                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
			                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
			            }

			            // Return final computed hash
			            return hash;
			        },

			        clone: function () {
			            var clone = Hasher.clone.call(this);
			            clone._hash = this._hash.clone();

			            return clone;
			        }
			    });


			    function f1(x, y, z) {
			        return ((x) ^ (y) ^ (z));

			    }

			    function f2(x, y, z) {
			        return (((x)&(y)) | ((~x)&(z)));
			    }

			    function f3(x, y, z) {
			        return (((x) | (~(y))) ^ (z));
			    }

			    function f4(x, y, z) {
			        return (((x) & (z)) | ((y)&(~(z))));
			    }

			    function f5(x, y, z) {
			        return ((x) ^ ((y) |(~(z))));

			    }

			    function rotl(x,n) {
			        return (x<<n) | (x>>>(32-n));
			    }


			    /**
			     * Shortcut function to the hasher's object interface.
			     *
			     * @param {WordArray|string} message The message to hash.
			     *
			     * @return {WordArray} The hash.
			     *
			     * @static
			     *
			     * @example
			     *
			     *     var hash = CryptoJS.RIPEMD160('message');
			     *     var hash = CryptoJS.RIPEMD160(wordArray);
			     */
			    C.RIPEMD160 = Hasher._createHelper(RIPEMD160);

			    /**
			     * Shortcut function to the HMAC's object interface.
			     *
			     * @param {WordArray|string} message The message to hash.
			     * @param {WordArray|string} key The secret key.
			     *
			     * @return {WordArray} The HMAC.
			     *
			     * @static
			     *
			     * @example
			     *
			     *     var hmac = CryptoJS.HmacRIPEMD160(message, key);
			     */
			    C.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);
			}());


			return CryptoJS.RIPEMD160;

		})); 
	} (ripemd160));
	return ripemd160.exports;
}

var hmac = {exports: {}};

var hasRequiredHmac;

function requireHmac () {
	if (hasRequiredHmac) return hmac.exports;
	hasRequiredHmac = 1;
	(function (module, exports) {
(function (root, factory) {
			{
				// CommonJS
				module.exports = factory(requireCore());
			}
		}(commonjsGlobal, function (CryptoJS) {

			(function () {
			    // Shortcuts
			    var C = CryptoJS;
			    var C_lib = C.lib;
			    var Base = C_lib.Base;
			    var C_enc = C.enc;
			    var Utf8 = C_enc.Utf8;
			    var C_algo = C.algo;

			    /**
			     * HMAC algorithm.
			     */
			    C_algo.HMAC = Base.extend({
			        /**
			         * Initializes a newly created HMAC.
			         *
			         * @param {Hasher} hasher The hash algorithm to use.
			         * @param {WordArray|string} key The secret key.
			         *
			         * @example
			         *
			         *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
			         */
			        init: function (hasher, key) {
			            // Init hasher
			            hasher = this._hasher = new hasher.init();

			            // Convert string to WordArray, else assume WordArray already
			            if (typeof key == 'string') {
			                key = Utf8.parse(key);
			            }

			            // Shortcuts
			            var hasherBlockSize = hasher.blockSize;
			            var hasherBlockSizeBytes = hasherBlockSize * 4;

			            // Allow arbitrary length keys
			            if (key.sigBytes > hasherBlockSizeBytes) {
			                key = hasher.finalize(key);
			            }

			            // Clamp excess bits
			            key.clamp();

			            // Clone key for inner and outer pads
			            var oKey = this._oKey = key.clone();
			            var iKey = this._iKey = key.clone();

			            // Shortcuts
			            var oKeyWords = oKey.words;
			            var iKeyWords = iKey.words;

			            // XOR keys with pad constants
			            for (var i = 0; i < hasherBlockSize; i++) {
			                oKeyWords[i] ^= 0x5c5c5c5c;
			                iKeyWords[i] ^= 0x36363636;
			            }
			            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;

			            // Set initial values
			            this.reset();
			        },

			        /**
			         * Resets this HMAC to its initial state.
			         *
			         * @example
			         *
			         *     hmacHasher.reset();
			         */
			        reset: function () {
			            // Shortcut
			            var hasher = this._hasher;

			            // Reset
			            hasher.reset();
			            hasher.update(this._iKey);
			        },

			        /**
			         * Updates this HMAC with a message.
			         *
			         * @param {WordArray|string} messageUpdate The message to append.
			         *
			         * @return {HMAC} This HMAC instance.
			         *
			         * @example
			         *
			         *     hmacHasher.update('message');
			         *     hmacHasher.update(wordArray);
			         */
			        update: function (messageUpdate) {
			            this._hasher.update(messageUpdate);

			            // Chainable
			            return this;
			        },

			        /**
			         * Finalizes the HMAC computation.
			         * Note that the finalize operation is effectively a destructive, read-once operation.
			         *
			         * @param {WordArray|string} messageUpdate (Optional) A final message update.
			         *
			         * @return {WordArray} The HMAC.
			         *
			         * @example
			         *
			         *     var hmac = hmacHasher.finalize();
			         *     var hmac = hmacHasher.finalize('message');
			         *     var hmac = hmacHasher.finalize(wordArray);
			         */
			        finalize: function (messageUpdate) {
			            // Shortcut
			            var hasher = this._hasher;

			            // Compute HMAC
			            var innerHash = hasher.finalize(messageUpdate);
			            hasher.reset();
			            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));

			            return hmac;
			        }
			    });
			}());


		})); 
	} (hmac));
	return hmac.exports;
}

var pbkdf2 = {exports: {}};

var hasRequiredPbkdf2;

function requirePbkdf2 () {
	if (hasRequiredPbkdf2) return pbkdf2.exports;
	hasRequiredPbkdf2 = 1;
	(function (module, exports) {
(function (root, factory, undef) {
			{
				// CommonJS
				module.exports = factory(requireCore(), requireSha1(), requireHmac());
			}
		}(commonjsGlobal, function (CryptoJS) {

			(function () {
			    // Shortcuts
			    var C = CryptoJS;
			    var C_lib = C.lib;
			    var Base = C_lib.Base;
			    var WordArray = C_lib.WordArray;
			    var C_algo = C.algo;
			    var SHA1 = C_algo.SHA1;
			    var HMAC = C_algo.HMAC;

			    /**
			     * Password-Based Key Derivation Function 2 algorithm.
			     */
			    var PBKDF2 = C_algo.PBKDF2 = Base.extend({
			        /**
			         * Configuration options.
			         *
			         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
			         * @property {Hasher} hasher The hasher to use. Default: SHA1
			         * @property {number} iterations The number of iterations to perform. Default: 1
			         */
			        cfg: Base.extend({
			            keySize: 128/32,
			            hasher: SHA1,
			            iterations: 1
			        }),

			        /**
			         * Initializes a newly created key derivation function.
			         *
			         * @param {Object} cfg (Optional) The configuration options to use for the derivation.
			         *
			         * @example
			         *
			         *     var kdf = CryptoJS.algo.PBKDF2.create();
			         *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });
			         *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });
			         */
			        init: function (cfg) {
			            this.cfg = this.cfg.extend(cfg);
			        },

			        /**
			         * Computes the Password-Based Key Derivation Function 2.
			         *
			         * @param {WordArray|string} password The password.
			         * @param {WordArray|string} salt A salt.
			         *
			         * @return {WordArray} The derived key.
			         *
			         * @example
			         *
			         *     var key = kdf.compute(password, salt);
			         */
			        compute: function (password, salt) {
			            // Shortcut
			            var cfg = this.cfg;

			            // Init HMAC
			            var hmac = HMAC.create(cfg.hasher, password);

			            // Initial values
			            var derivedKey = WordArray.create();
			            var blockIndex = WordArray.create([0x00000001]);

			            // Shortcuts
			            var derivedKeyWords = derivedKey.words;
			            var blockIndexWords = blockIndex.words;
			            var keySize = cfg.keySize;
			            var iterations = cfg.iterations;

			            // Generate key
			            while (derivedKeyWords.length < keySize) {
			                var block = hmac.update(salt).finalize(blockIndex);
			                hmac.reset();

			                // Shortcuts
			                var blockWords = block.words;
			                var blockWordsLength = blockWords.length;

			                // Iterations
			                var intermediate = block;
			                for (var i = 1; i < iterations; i++) {
			                    intermediate = hmac.finalize(intermediate);
			                    hmac.reset();

			                    // Shortcut
			                    var intermediateWords = intermediate.words;

			                    // XOR intermediate with block
			                    for (var j = 0; j < blockWordsLength; j++) {
			                        blockWords[j] ^= intermediateWords[j];
			                    }
			                }

			                derivedKey.concat(block);
			                blockIndexWords[0]++;
			            }
			            derivedKey.sigBytes = keySize * 4;

			            return derivedKey;
			        }
			    });

			    /**
			     * Computes the Password-Based Key Derivation Function 2.
			     *
			     * @param {WordArray|string} password The password.
			     * @param {WordArray|string} salt A salt.
			     * @param {Object} cfg (Optional) The configuration options to use for this computation.
			     *
			     * @return {WordArray} The derived key.
			     *
			     * @static
			     *
			     * @example
			     *
			     *     var key = CryptoJS.PBKDF2(password, salt);
			     *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8 });
			     *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8, iterations: 1000 });
			     */
			    C.PBKDF2 = function (password, salt, cfg) {
			        return PBKDF2.create(cfg).compute(password, salt);
			    };
			}());


			return CryptoJS.PBKDF2;

		})); 
	} (pbkdf2));
	return pbkdf2.exports;
}

var evpkdf = {exports: {}};

var hasRequiredEvpkdf;

function requireEvpkdf () {
	if (hasRequiredEvpkdf) return evpkdf.exports;
	hasRequiredEvpkdf = 1;
	(function (module, exports) {
(function (root, factory, undef) {
			{
				// CommonJS
				module.exports = factory(requireCore(), requireSha1(), requireHmac());
			}
		}(commonjsGlobal, function (CryptoJS) {

			(function () {
			    // Shortcuts
			    var C = CryptoJS;
			    var C_lib = C.lib;
			    var Base = C_lib.Base;
			    var WordArray = C_lib.WordArray;
			    var C_algo = C.algo;
			    var MD5 = C_algo.MD5;

			    /**
			     * This key derivation function is meant to conform with EVP_BytesToKey.
			     * www.openssl.org/docs/crypto/EVP_BytesToKey.html
			     */
			    var EvpKDF = C_algo.EvpKDF = Base.extend({
			        /**
			         * Configuration options.
			         *
			         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
			         * @property {Hasher} hasher The hash algorithm to use. Default: MD5
			         * @property {number} iterations The number of iterations to perform. Default: 1
			         */
			        cfg: Base.extend({
			            keySize: 128/32,
			            hasher: MD5,
			            iterations: 1
			        }),

			        /**
			         * Initializes a newly created key derivation function.
			         *
			         * @param {Object} cfg (Optional) The configuration options to use for the derivation.
			         *
			         * @example
			         *
			         *     var kdf = CryptoJS.algo.EvpKDF.create();
			         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
			         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
			         */
			        init: function (cfg) {
			            this.cfg = this.cfg.extend(cfg);
			        },

			        /**
			         * Derives a key from a password.
			         *
			         * @param {WordArray|string} password The password.
			         * @param {WordArray|string} salt A salt.
			         *
			         * @return {WordArray} The derived key.
			         *
			         * @example
			         *
			         *     var key = kdf.compute(password, salt);
			         */
			        compute: function (password, salt) {
			            var block;

			            // Shortcut
			            var cfg = this.cfg;

			            // Init hasher
			            var hasher = cfg.hasher.create();

			            // Initial values
			            var derivedKey = WordArray.create();

			            // Shortcuts
			            var derivedKeyWords = derivedKey.words;
			            var keySize = cfg.keySize;
			            var iterations = cfg.iterations;

			            // Generate key
			            while (derivedKeyWords.length < keySize) {
			                if (block) {
			                    hasher.update(block);
			                }
			                block = hasher.update(password).finalize(salt);
			                hasher.reset();

			                // Iterations
			                for (var i = 1; i < iterations; i++) {
			                    block = hasher.finalize(block);
			                    hasher.reset();
			                }

			                derivedKey.concat(block);
			            }
			            derivedKey.sigBytes = keySize * 4;

			            return derivedKey;
			        }
			    });

			    /**
			     * Derives a key from a password.
			     *
			     * @param {WordArray|string} password The password.
			     * @param {WordArray|string} salt A salt.
			     * @param {Object} cfg (Optional) The configuration options to use for this computation.
			     *
			     * @return {WordArray} The derived key.
			     *
			     * @static
			     *
			     * @example
			     *
			     *     var key = CryptoJS.EvpKDF(password, salt);
			     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8 });
			     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8, iterations: 1000 });
			     */
			    C.EvpKDF = function (password, salt, cfg) {
			        return EvpKDF.create(cfg).compute(password, salt);
			    };
			}());


			return CryptoJS.EvpKDF;

		})); 
	} (evpkdf));
	return evpkdf.exports;
}

var cipherCore = {exports: {}};

var hasRequiredCipherCore;

function requireCipherCore () {
	if (hasRequiredCipherCore) return cipherCore.exports;
	hasRequiredCipherCore = 1;
	(function (module, exports) {
(function (root, factory, undef) {
			{
				// CommonJS
				module.exports = factory(requireCore(), requireEvpkdf());
			}
		}(commonjsGlobal, function (CryptoJS) {

			/**
			 * Cipher core components.
			 */
			CryptoJS.lib.Cipher || (function (undefined$1) {
			    // Shortcuts
			    var C = CryptoJS;
			    var C_lib = C.lib;
			    var Base = C_lib.Base;
			    var WordArray = C_lib.WordArray;
			    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
			    var C_enc = C.enc;
			    C_enc.Utf8;
			    var Base64 = C_enc.Base64;
			    var C_algo = C.algo;
			    var EvpKDF = C_algo.EvpKDF;

			    /**
			     * Abstract base cipher template.
			     *
			     * @property {number} keySize This cipher's key size. Default: 4 (128 bits)
			     * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)
			     * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.
			     * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.
			     */
			    var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
			        /**
			         * Configuration options.
			         *
			         * @property {WordArray} iv The IV to use for this operation.
			         */
			        cfg: Base.extend(),

			        /**
			         * Creates this cipher in encryption mode.
			         *
			         * @param {WordArray} key The key.
			         * @param {Object} cfg (Optional) The configuration options to use for this operation.
			         *
			         * @return {Cipher} A cipher instance.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
			         */
			        createEncryptor: function (key, cfg) {
			            return this.create(this._ENC_XFORM_MODE, key, cfg);
			        },

			        /**
			         * Creates this cipher in decryption mode.
			         *
			         * @param {WordArray} key The key.
			         * @param {Object} cfg (Optional) The configuration options to use for this operation.
			         *
			         * @return {Cipher} A cipher instance.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
			         */
			        createDecryptor: function (key, cfg) {
			            return this.create(this._DEC_XFORM_MODE, key, cfg);
			        },

			        /**
			         * Initializes a newly created cipher.
			         *
			         * @param {number} xformMode Either the encryption or decryption transormation mode constant.
			         * @param {WordArray} key The key.
			         * @param {Object} cfg (Optional) The configuration options to use for this operation.
			         *
			         * @example
			         *
			         *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
			         */
			        init: function (xformMode, key, cfg) {
			            // Apply config defaults
			            this.cfg = this.cfg.extend(cfg);

			            // Store transform mode and key
			            this._xformMode = xformMode;
			            this._key = key;

			            // Set initial values
			            this.reset();
			        },

			        /**
			         * Resets this cipher to its initial state.
			         *
			         * @example
			         *
			         *     cipher.reset();
			         */
			        reset: function () {
			            // Reset data buffer
			            BufferedBlockAlgorithm.reset.call(this);

			            // Perform concrete-cipher logic
			            this._doReset();
			        },

			        /**
			         * Adds data to be encrypted or decrypted.
			         *
			         * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
			         *
			         * @return {WordArray} The data after processing.
			         *
			         * @example
			         *
			         *     var encrypted = cipher.process('data');
			         *     var encrypted = cipher.process(wordArray);
			         */
			        process: function (dataUpdate) {
			            // Append
			            this._append(dataUpdate);

			            // Process available blocks
			            return this._process();
			        },

			        /**
			         * Finalizes the encryption or decryption process.
			         * Note that the finalize operation is effectively a destructive, read-once operation.
			         *
			         * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
			         *
			         * @return {WordArray} The data after final processing.
			         *
			         * @example
			         *
			         *     var encrypted = cipher.finalize();
			         *     var encrypted = cipher.finalize('data');
			         *     var encrypted = cipher.finalize(wordArray);
			         */
			        finalize: function (dataUpdate) {
			            // Final data update
			            if (dataUpdate) {
			                this._append(dataUpdate);
			            }

			            // Perform concrete-cipher logic
			            var finalProcessedData = this._doFinalize();

			            return finalProcessedData;
			        },

			        keySize: 128/32,

			        ivSize: 128/32,

			        _ENC_XFORM_MODE: 1,

			        _DEC_XFORM_MODE: 2,

			        /**
			         * Creates shortcut functions to a cipher's object interface.
			         *
			         * @param {Cipher} cipher The cipher to create a helper for.
			         *
			         * @return {Object} An object with encrypt and decrypt shortcut functions.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
			         */
			        _createHelper: (function () {
			            function selectCipherStrategy(key) {
			                if (typeof key == 'string') {
			                    return PasswordBasedCipher;
			                } else {
			                    return SerializableCipher;
			                }
			            }

			            return function (cipher) {
			                return {
			                    encrypt: function (message, key, cfg) {
			                        return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
			                    },

			                    decrypt: function (ciphertext, key, cfg) {
			                        return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
			                    }
			                };
			            };
			        }())
			    });

			    /**
			     * Abstract base stream cipher template.
			     *
			     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 1 (32 bits)
			     */
			    C_lib.StreamCipher = Cipher.extend({
			        _doFinalize: function () {
			            // Process partial blocks
			            var finalProcessedBlocks = this._process(!!'flush');

			            return finalProcessedBlocks;
			        },

			        blockSize: 1
			    });

			    /**
			     * Mode namespace.
			     */
			    var C_mode = C.mode = {};

			    /**
			     * Abstract base block cipher mode template.
			     */
			    var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
			        /**
			         * Creates this mode for encryption.
			         *
			         * @param {Cipher} cipher A block cipher instance.
			         * @param {Array} iv The IV words.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
			         */
			        createEncryptor: function (cipher, iv) {
			            return this.Encryptor.create(cipher, iv);
			        },

			        /**
			         * Creates this mode for decryption.
			         *
			         * @param {Cipher} cipher A block cipher instance.
			         * @param {Array} iv The IV words.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
			         */
			        createDecryptor: function (cipher, iv) {
			            return this.Decryptor.create(cipher, iv);
			        },

			        /**
			         * Initializes a newly created mode.
			         *
			         * @param {Cipher} cipher A block cipher instance.
			         * @param {Array} iv The IV words.
			         *
			         * @example
			         *
			         *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
			         */
			        init: function (cipher, iv) {
			            this._cipher = cipher;
			            this._iv = iv;
			        }
			    });

			    /**
			     * Cipher Block Chaining mode.
			     */
			    var CBC = C_mode.CBC = (function () {
			        /**
			         * Abstract base CBC mode.
			         */
			        var CBC = BlockCipherMode.extend();

			        /**
			         * CBC encryptor.
			         */
			        CBC.Encryptor = CBC.extend({
			            /**
			             * Processes the data block at offset.
			             *
			             * @param {Array} words The data words to operate on.
			             * @param {number} offset The offset where the block starts.
			             *
			             * @example
			             *
			             *     mode.processBlock(data.words, offset);
			             */
			            processBlock: function (words, offset) {
			                // Shortcuts
			                var cipher = this._cipher;
			                var blockSize = cipher.blockSize;

			                // XOR and encrypt
			                xorBlock.call(this, words, offset, blockSize);
			                cipher.encryptBlock(words, offset);

			                // Remember this block to use with next block
			                this._prevBlock = words.slice(offset, offset + blockSize);
			            }
			        });

			        /**
			         * CBC decryptor.
			         */
			        CBC.Decryptor = CBC.extend({
			            /**
			             * Processes the data block at offset.
			             *
			             * @param {Array} words The data words to operate on.
			             * @param {number} offset The offset where the block starts.
			             *
			             * @example
			             *
			             *     mode.processBlock(data.words, offset);
			             */
			            processBlock: function (words, offset) {
			                // Shortcuts
			                var cipher = this._cipher;
			                var blockSize = cipher.blockSize;

			                // Remember this block to use with next block
			                var thisBlock = words.slice(offset, offset + blockSize);

			                // Decrypt and XOR
			                cipher.decryptBlock(words, offset);
			                xorBlock.call(this, words, offset, blockSize);

			                // This block becomes the previous block
			                this._prevBlock = thisBlock;
			            }
			        });

			        function xorBlock(words, offset, blockSize) {
			            var block;

			            // Shortcut
			            var iv = this._iv;

			            // Choose mixing block
			            if (iv) {
			                block = iv;

			                // Remove IV for subsequent blocks
			                this._iv = undefined$1;
			            } else {
			                block = this._prevBlock;
			            }

			            // XOR blocks
			            for (var i = 0; i < blockSize; i++) {
			                words[offset + i] ^= block[i];
			            }
			        }

			        return CBC;
			    }());

			    /**
			     * Padding namespace.
			     */
			    var C_pad = C.pad = {};

			    /**
			     * PKCS #5/7 padding strategy.
			     */
			    var Pkcs7 = C_pad.Pkcs7 = {
			        /**
			         * Pads data using the algorithm defined in PKCS #5/7.
			         *
			         * @param {WordArray} data The data to pad.
			         * @param {number} blockSize The multiple that the data should be padded to.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
			         */
			        pad: function (data, blockSize) {
			            // Shortcut
			            var blockSizeBytes = blockSize * 4;

			            // Count padding bytes
			            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;

			            // Create padding word
			            var paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes;

			            // Create padding
			            var paddingWords = [];
			            for (var i = 0; i < nPaddingBytes; i += 4) {
			                paddingWords.push(paddingWord);
			            }
			            var padding = WordArray.create(paddingWords, nPaddingBytes);

			            // Add padding
			            data.concat(padding);
			        },

			        /**
			         * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
			         *
			         * @param {WordArray} data The data to unpad.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     CryptoJS.pad.Pkcs7.unpad(wordArray);
			         */
			        unpad: function (data) {
			            // Get number of padding bytes from last byte
			            var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

			            // Remove padding
			            data.sigBytes -= nPaddingBytes;
			        }
			    };

			    /**
			     * Abstract base block cipher template.
			     *
			     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 4 (128 bits)
			     */
			    C_lib.BlockCipher = Cipher.extend({
			        /**
			         * Configuration options.
			         *
			         * @property {Mode} mode The block mode to use. Default: CBC
			         * @property {Padding} padding The padding strategy to use. Default: Pkcs7
			         */
			        cfg: Cipher.cfg.extend({
			            mode: CBC,
			            padding: Pkcs7
			        }),

			        reset: function () {
			            var modeCreator;

			            // Reset cipher
			            Cipher.reset.call(this);

			            // Shortcuts
			            var cfg = this.cfg;
			            var iv = cfg.iv;
			            var mode = cfg.mode;

			            // Reset block mode
			            if (this._xformMode == this._ENC_XFORM_MODE) {
			                modeCreator = mode.createEncryptor;
			            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
			                modeCreator = mode.createDecryptor;
			                // Keep at least one block in the buffer for unpadding
			                this._minBufferSize = 1;
			            }

			            if (this._mode && this._mode.__creator == modeCreator) {
			                this._mode.init(this, iv && iv.words);
			            } else {
			                this._mode = modeCreator.call(mode, this, iv && iv.words);
			                this._mode.__creator = modeCreator;
			            }
			        },

			        _doProcessBlock: function (words, offset) {
			            this._mode.processBlock(words, offset);
			        },

			        _doFinalize: function () {
			            var finalProcessedBlocks;

			            // Shortcut
			            var padding = this.cfg.padding;

			            // Finalize
			            if (this._xformMode == this._ENC_XFORM_MODE) {
			                // Pad data
			                padding.pad(this._data, this.blockSize);

			                // Process final blocks
			                finalProcessedBlocks = this._process(!!'flush');
			            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
			                // Process final blocks
			                finalProcessedBlocks = this._process(!!'flush');

			                // Unpad data
			                padding.unpad(finalProcessedBlocks);
			            }

			            return finalProcessedBlocks;
			        },

			        blockSize: 128/32
			    });

			    /**
			     * A collection of cipher parameters.
			     *
			     * @property {WordArray} ciphertext The raw ciphertext.
			     * @property {WordArray} key The key to this ciphertext.
			     * @property {WordArray} iv The IV used in the ciphering operation.
			     * @property {WordArray} salt The salt used with a key derivation function.
			     * @property {Cipher} algorithm The cipher algorithm.
			     * @property {Mode} mode The block mode used in the ciphering operation.
			     * @property {Padding} padding The padding scheme used in the ciphering operation.
			     * @property {number} blockSize The block size of the cipher.
			     * @property {Format} formatter The default formatting strategy to convert this cipher params object to a string.
			     */
			    var CipherParams = C_lib.CipherParams = Base.extend({
			        /**
			         * Initializes a newly created cipher params object.
			         *
			         * @param {Object} cipherParams An object with any of the possible cipher parameters.
			         *
			         * @example
			         *
			         *     var cipherParams = CryptoJS.lib.CipherParams.create({
			         *         ciphertext: ciphertextWordArray,
			         *         key: keyWordArray,
			         *         iv: ivWordArray,
			         *         salt: saltWordArray,
			         *         algorithm: CryptoJS.algo.AES,
			         *         mode: CryptoJS.mode.CBC,
			         *         padding: CryptoJS.pad.PKCS7,
			         *         blockSize: 4,
			         *         formatter: CryptoJS.format.OpenSSL
			         *     });
			         */
			        init: function (cipherParams) {
			            this.mixIn(cipherParams);
			        },

			        /**
			         * Converts this cipher params object to a string.
			         *
			         * @param {Format} formatter (Optional) The formatting strategy to use.
			         *
			         * @return {string} The stringified cipher params.
			         *
			         * @throws Error If neither the formatter nor the default formatter is set.
			         *
			         * @example
			         *
			         *     var string = cipherParams + '';
			         *     var string = cipherParams.toString();
			         *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
			         */
			        toString: function (formatter) {
			            return (formatter || this.formatter).stringify(this);
			        }
			    });

			    /**
			     * Format namespace.
			     */
			    var C_format = C.format = {};

			    /**
			     * OpenSSL formatting strategy.
			     */
			    var OpenSSLFormatter = C_format.OpenSSL = {
			        /**
			         * Converts a cipher params object to an OpenSSL-compatible string.
			         *
			         * @param {CipherParams} cipherParams The cipher params object.
			         *
			         * @return {string} The OpenSSL-compatible string.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
			         */
			        stringify: function (cipherParams) {
			            var wordArray;

			            // Shortcuts
			            var ciphertext = cipherParams.ciphertext;
			            var salt = cipherParams.salt;

			            // Format
			            if (salt) {
			                wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);
			            } else {
			                wordArray = ciphertext;
			            }

			            return wordArray.toString(Base64);
			        },

			        /**
			         * Converts an OpenSSL-compatible string to a cipher params object.
			         *
			         * @param {string} openSSLStr The OpenSSL-compatible string.
			         *
			         * @return {CipherParams} The cipher params object.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
			         */
			        parse: function (openSSLStr) {
			            var salt;

			            // Parse base64
			            var ciphertext = Base64.parse(openSSLStr);

			            // Shortcut
			            var ciphertextWords = ciphertext.words;

			            // Test for salt
			            if (ciphertextWords[0] == 0x53616c74 && ciphertextWords[1] == 0x65645f5f) {
			                // Extract salt
			                salt = WordArray.create(ciphertextWords.slice(2, 4));

			                // Remove salt from ciphertext
			                ciphertextWords.splice(0, 4);
			                ciphertext.sigBytes -= 16;
			            }

			            return CipherParams.create({ ciphertext: ciphertext, salt: salt });
			        }
			    };

			    /**
			     * A cipher wrapper that returns ciphertext as a serializable cipher params object.
			     */
			    var SerializableCipher = C_lib.SerializableCipher = Base.extend({
			        /**
			         * Configuration options.
			         *
			         * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
			         */
			        cfg: Base.extend({
			            format: OpenSSLFormatter
			        }),

			        /**
			         * Encrypts a message.
			         *
			         * @param {Cipher} cipher The cipher algorithm to use.
			         * @param {WordArray|string} message The message to encrypt.
			         * @param {WordArray} key The key.
			         * @param {Object} cfg (Optional) The configuration options to use for this operation.
			         *
			         * @return {CipherParams} A cipher params object.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
			         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
			         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
			         */
			        encrypt: function (cipher, message, key, cfg) {
			            // Apply config defaults
			            cfg = this.cfg.extend(cfg);

			            // Encrypt
			            var encryptor = cipher.createEncryptor(key, cfg);
			            var ciphertext = encryptor.finalize(message);

			            // Shortcut
			            var cipherCfg = encryptor.cfg;

			            // Create and return serializable cipher params
			            return CipherParams.create({
			                ciphertext: ciphertext,
			                key: key,
			                iv: cipherCfg.iv,
			                algorithm: cipher,
			                mode: cipherCfg.mode,
			                padding: cipherCfg.padding,
			                blockSize: cipher.blockSize,
			                formatter: cfg.format
			            });
			        },

			        /**
			         * Decrypts serialized ciphertext.
			         *
			         * @param {Cipher} cipher The cipher algorithm to use.
			         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
			         * @param {WordArray} key The key.
			         * @param {Object} cfg (Optional) The configuration options to use for this operation.
			         *
			         * @return {WordArray} The plaintext.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
			         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
			         */
			        decrypt: function (cipher, ciphertext, key, cfg) {
			            // Apply config defaults
			            cfg = this.cfg.extend(cfg);

			            // Convert string to CipherParams
			            ciphertext = this._parse(ciphertext, cfg.format);

			            // Decrypt
			            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);

			            return plaintext;
			        },

			        /**
			         * Converts serialized ciphertext to CipherParams,
			         * else assumed CipherParams already and returns ciphertext unchanged.
			         *
			         * @param {CipherParams|string} ciphertext The ciphertext.
			         * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
			         *
			         * @return {CipherParams} The unserialized ciphertext.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
			         */
			        _parse: function (ciphertext, format) {
			            if (typeof ciphertext == 'string') {
			                return format.parse(ciphertext, this);
			            } else {
			                return ciphertext;
			            }
			        }
			    });

			    /**
			     * Key derivation function namespace.
			     */
			    var C_kdf = C.kdf = {};

			    /**
			     * OpenSSL key derivation function.
			     */
			    var OpenSSLKdf = C_kdf.OpenSSL = {
			        /**
			         * Derives a key and IV from a password.
			         *
			         * @param {string} password The password to derive from.
			         * @param {number} keySize The size in words of the key to generate.
			         * @param {number} ivSize The size in words of the IV to generate.
			         * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
			         *
			         * @return {CipherParams} A cipher params object with the key, IV, and salt.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
			         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
			         */
			        execute: function (password, keySize, ivSize, salt) {
			            // Generate random salt
			            if (!salt) {
			                salt = WordArray.random(64/8);
			            }

			            // Derive key and IV
			            var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);

			            // Separate key and IV
			            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
			            key.sigBytes = keySize * 4;

			            // Return params
			            return CipherParams.create({ key: key, iv: iv, salt: salt });
			        }
			    };

			    /**
			     * A serializable cipher wrapper that derives the key from a password,
			     * and returns ciphertext as a serializable cipher params object.
			     */
			    var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
			        /**
			         * Configuration options.
			         *
			         * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
			         */
			        cfg: SerializableCipher.cfg.extend({
			            kdf: OpenSSLKdf
			        }),

			        /**
			         * Encrypts a message using a password.
			         *
			         * @param {Cipher} cipher The cipher algorithm to use.
			         * @param {WordArray|string} message The message to encrypt.
			         * @param {string} password The password.
			         * @param {Object} cfg (Optional) The configuration options to use for this operation.
			         *
			         * @return {CipherParams} A cipher params object.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
			         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
			         */
			        encrypt: function (cipher, message, password, cfg) {
			            // Apply config defaults
			            cfg = this.cfg.extend(cfg);

			            // Derive key and other params
			            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);

			            // Add IV to config
			            cfg.iv = derivedParams.iv;

			            // Encrypt
			            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);

			            // Mix in derived params
			            ciphertext.mixIn(derivedParams);

			            return ciphertext;
			        },

			        /**
			         * Decrypts serialized ciphertext using a password.
			         *
			         * @param {Cipher} cipher The cipher algorithm to use.
			         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
			         * @param {string} password The password.
			         * @param {Object} cfg (Optional) The configuration options to use for this operation.
			         *
			         * @return {WordArray} The plaintext.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
			         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
			         */
			        decrypt: function (cipher, ciphertext, password, cfg) {
			            // Apply config defaults
			            cfg = this.cfg.extend(cfg);

			            // Convert string to CipherParams
			            ciphertext = this._parse(ciphertext, cfg.format);

			            // Derive key and other params
			            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);

			            // Add IV to config
			            cfg.iv = derivedParams.iv;

			            // Decrypt
			            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);

			            return plaintext;
			        }
			    });
			}());


		})); 
	} (cipherCore));
	return cipherCore.exports;
}

var modeCfb = {exports: {}};

var hasRequiredModeCfb;

function requireModeCfb () {
	if (hasRequiredModeCfb) return modeCfb.exports;
	hasRequiredModeCfb = 1;
	(function (module, exports) {
(function (root, factory, undef) {
			{
				// CommonJS
				module.exports = factory(requireCore(), requireCipherCore());
			}
		}(commonjsGlobal, function (CryptoJS) {

			/**
			 * Cipher Feedback block mode.
			 */
			CryptoJS.mode.CFB = (function () {
			    var CFB = CryptoJS.lib.BlockCipherMode.extend();

			    CFB.Encryptor = CFB.extend({
			        processBlock: function (words, offset) {
			            // Shortcuts
			            var cipher = this._cipher;
			            var blockSize = cipher.blockSize;

			            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);

			            // Remember this block to use with next block
			            this._prevBlock = words.slice(offset, offset + blockSize);
			        }
			    });

			    CFB.Decryptor = CFB.extend({
			        processBlock: function (words, offset) {
			            // Shortcuts
			            var cipher = this._cipher;
			            var blockSize = cipher.blockSize;

			            // Remember this block to use with next block
			            var thisBlock = words.slice(offset, offset + blockSize);

			            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);

			            // This block becomes the previous block
			            this._prevBlock = thisBlock;
			        }
			    });

			    function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {
			        var keystream;

			        // Shortcut
			        var iv = this._iv;

			        // Generate keystream
			        if (iv) {
			            keystream = iv.slice(0);

			            // Remove IV for subsequent blocks
			            this._iv = undefined;
			        } else {
			            keystream = this._prevBlock;
			        }
			        cipher.encryptBlock(keystream, 0);

			        // Encrypt
			        for (var i = 0; i < blockSize; i++) {
			            words[offset + i] ^= keystream[i];
			        }
			    }

			    return CFB;
			}());


			return CryptoJS.mode.CFB;

		})); 
	} (modeCfb));
	return modeCfb.exports;
}

var modeCtr = {exports: {}};

var hasRequiredModeCtr;

function requireModeCtr () {
	if (hasRequiredModeCtr) return modeCtr.exports;
	hasRequiredModeCtr = 1;
	(function (module, exports) {
(function (root, factory, undef) {
			{
				// CommonJS
				module.exports = factory(requireCore(), requireCipherCore());
			}
		}(commonjsGlobal, function (CryptoJS) {

			/**
			 * Counter block mode.
			 */
			CryptoJS.mode.CTR = (function () {
			    var CTR = CryptoJS.lib.BlockCipherMode.extend();

			    var Encryptor = CTR.Encryptor = CTR.extend({
			        processBlock: function (words, offset) {
			            // Shortcuts
			            var cipher = this._cipher;
			            var blockSize = cipher.blockSize;
			            var iv = this._iv;
			            var counter = this._counter;

			            // Generate keystream
			            if (iv) {
			                counter = this._counter = iv.slice(0);

			                // Remove IV for subsequent blocks
			                this._iv = undefined;
			            }
			            var keystream = counter.slice(0);
			            cipher.encryptBlock(keystream, 0);

			            // Increment counter
			            counter[blockSize - 1] = (counter[blockSize - 1] + 1) | 0;

			            // Encrypt
			            for (var i = 0; i < blockSize; i++) {
			                words[offset + i] ^= keystream[i];
			            }
			        }
			    });

			    CTR.Decryptor = Encryptor;

			    return CTR;
			}());


			return CryptoJS.mode.CTR;

		})); 
	} (modeCtr));
	return modeCtr.exports;
}

var modeCtrGladman = {exports: {}};

var hasRequiredModeCtrGladman;

function requireModeCtrGladman () {
	if (hasRequiredModeCtrGladman) return modeCtrGladman.exports;
	hasRequiredModeCtrGladman = 1;
	(function (module, exports) {
(function (root, factory, undef) {
			{
				// CommonJS
				module.exports = factory(requireCore(), requireCipherCore());
			}
		}(commonjsGlobal, function (CryptoJS) {

			/** @preserve
			 * Counter block mode compatible with  Dr Brian Gladman fileenc.c
			 * derived from CryptoJS.mode.CTR
			 * Jan Hruby jhruby.web@gmail.com
			 */
			CryptoJS.mode.CTRGladman = (function () {
			    var CTRGladman = CryptoJS.lib.BlockCipherMode.extend();

				function incWord(word)
				{
					if (((word >> 24) & 0xff) === 0xff) { //overflow
					var b1 = (word >> 16)&0xff;
					var b2 = (word >> 8)&0xff;
					var b3 = word & 0xff;

					if (b1 === 0xff) // overflow b1
					{
					b1 = 0;
					if (b2 === 0xff)
					{
						b2 = 0;
						if (b3 === 0xff)
						{
							b3 = 0;
						}
						else
						{
							++b3;
						}
					}
					else
					{
						++b2;
					}
					}
					else
					{
					++b1;
					}

					word = 0;
					word += (b1 << 16);
					word += (b2 << 8);
					word += b3;
					}
					else
					{
					word += (0x01 << 24);
					}
					return word;
				}

				function incCounter(counter)
				{
					if ((counter[0] = incWord(counter[0])) === 0)
					{
						// encr_data in fileenc.c from  Dr Brian Gladman's counts only with DWORD j < 8
						counter[1] = incWord(counter[1]);
					}
					return counter;
				}

			    var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
			        processBlock: function (words, offset) {
			            // Shortcuts
			            var cipher = this._cipher;
			            var blockSize = cipher.blockSize;
			            var iv = this._iv;
			            var counter = this._counter;

			            // Generate keystream
			            if (iv) {
			                counter = this._counter = iv.slice(0);

			                // Remove IV for subsequent blocks
			                this._iv = undefined;
			            }

						incCounter(counter);

						var keystream = counter.slice(0);
			            cipher.encryptBlock(keystream, 0);

			            // Encrypt
			            for (var i = 0; i < blockSize; i++) {
			                words[offset + i] ^= keystream[i];
			            }
			        }
			    });

			    CTRGladman.Decryptor = Encryptor;

			    return CTRGladman;
			}());




			return CryptoJS.mode.CTRGladman;

		})); 
	} (modeCtrGladman));
	return modeCtrGladman.exports;
}

var modeOfb = {exports: {}};

var hasRequiredModeOfb;

function requireModeOfb () {
	if (hasRequiredModeOfb) return modeOfb.exports;
	hasRequiredModeOfb = 1;
	(function (module, exports) {
(function (root, factory, undef) {
			{
				// CommonJS
				module.exports = factory(requireCore(), requireCipherCore());
			}
		}(commonjsGlobal, function (CryptoJS) {

			/**
			 * Output Feedback block mode.
			 */
			CryptoJS.mode.OFB = (function () {
			    var OFB = CryptoJS.lib.BlockCipherMode.extend();

			    var Encryptor = OFB.Encryptor = OFB.extend({
			        processBlock: function (words, offset) {
			            // Shortcuts
			            var cipher = this._cipher;
			            var blockSize = cipher.blockSize;
			            var iv = this._iv;
			            var keystream = this._keystream;

			            // Generate keystream
			            if (iv) {
			                keystream = this._keystream = iv.slice(0);

			                // Remove IV for subsequent blocks
			                this._iv = undefined;
			            }
			            cipher.encryptBlock(keystream, 0);

			            // Encrypt
			            for (var i = 0; i < blockSize; i++) {
			                words[offset + i] ^= keystream[i];
			            }
			        }
			    });

			    OFB.Decryptor = Encryptor;

			    return OFB;
			}());


			return CryptoJS.mode.OFB;

		})); 
	} (modeOfb));
	return modeOfb.exports;
}

var modeEcb = {exports: {}};

var hasRequiredModeEcb;

function requireModeEcb () {
	if (hasRequiredModeEcb) return modeEcb.exports;
	hasRequiredModeEcb = 1;
	(function (module, exports) {
(function (root, factory, undef) {
			{
				// CommonJS
				module.exports = factory(requireCore(), requireCipherCore());
			}
		}(commonjsGlobal, function (CryptoJS) {

			/**
			 * Electronic Codebook block mode.
			 */
			CryptoJS.mode.ECB = (function () {
			    var ECB = CryptoJS.lib.BlockCipherMode.extend();

			    ECB.Encryptor = ECB.extend({
			        processBlock: function (words, offset) {
			            this._cipher.encryptBlock(words, offset);
			        }
			    });

			    ECB.Decryptor = ECB.extend({
			        processBlock: function (words, offset) {
			            this._cipher.decryptBlock(words, offset);
			        }
			    });

			    return ECB;
			}());


			return CryptoJS.mode.ECB;

		})); 
	} (modeEcb));
	return modeEcb.exports;
}

var padAnsix923 = {exports: {}};

var hasRequiredPadAnsix923;

function requirePadAnsix923 () {
	if (hasRequiredPadAnsix923) return padAnsix923.exports;
	hasRequiredPadAnsix923 = 1;
	(function (module, exports) {
(function (root, factory, undef) {
			{
				// CommonJS
				module.exports = factory(requireCore(), requireCipherCore());
			}
		}(commonjsGlobal, function (CryptoJS) {

			/**
			 * ANSI X.923 padding strategy.
			 */
			CryptoJS.pad.AnsiX923 = {
			    pad: function (data, blockSize) {
			        // Shortcuts
			        var dataSigBytes = data.sigBytes;
			        var blockSizeBytes = blockSize * 4;

			        // Count padding bytes
			        var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;

			        // Compute last byte position
			        var lastBytePos = dataSigBytes + nPaddingBytes - 1;

			        // Pad
			        data.clamp();
			        data.words[lastBytePos >>> 2] |= nPaddingBytes << (24 - (lastBytePos % 4) * 8);
			        data.sigBytes += nPaddingBytes;
			    },

			    unpad: function (data) {
			        // Get number of padding bytes from last byte
			        var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

			        // Remove padding
			        data.sigBytes -= nPaddingBytes;
			    }
			};


			return CryptoJS.pad.Ansix923;

		})); 
	} (padAnsix923));
	return padAnsix923.exports;
}

var padIso10126 = {exports: {}};

var hasRequiredPadIso10126;

function requirePadIso10126 () {
	if (hasRequiredPadIso10126) return padIso10126.exports;
	hasRequiredPadIso10126 = 1;
	(function (module, exports) {
(function (root, factory, undef) {
			{
				// CommonJS
				module.exports = factory(requireCore(), requireCipherCore());
			}
		}(commonjsGlobal, function (CryptoJS) {

			/**
			 * ISO 10126 padding strategy.
			 */
			CryptoJS.pad.Iso10126 = {
			    pad: function (data, blockSize) {
			        // Shortcut
			        var blockSizeBytes = blockSize * 4;

			        // Count padding bytes
			        var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;

			        // Pad
			        data.concat(CryptoJS.lib.WordArray.random(nPaddingBytes - 1)).
			             concat(CryptoJS.lib.WordArray.create([nPaddingBytes << 24], 1));
			    },

			    unpad: function (data) {
			        // Get number of padding bytes from last byte
			        var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

			        // Remove padding
			        data.sigBytes -= nPaddingBytes;
			    }
			};


			return CryptoJS.pad.Iso10126;

		})); 
	} (padIso10126));
	return padIso10126.exports;
}

var padIso97971 = {exports: {}};

var hasRequiredPadIso97971;

function requirePadIso97971 () {
	if (hasRequiredPadIso97971) return padIso97971.exports;
	hasRequiredPadIso97971 = 1;
	(function (module, exports) {
(function (root, factory, undef) {
			{
				// CommonJS
				module.exports = factory(requireCore(), requireCipherCore());
			}
		}(commonjsGlobal, function (CryptoJS) {

			/**
			 * ISO/IEC 9797-1 Padding Method 2.
			 */
			CryptoJS.pad.Iso97971 = {
			    pad: function (data, blockSize) {
			        // Add 0x80 byte
			        data.concat(CryptoJS.lib.WordArray.create([0x80000000], 1));

			        // Zero pad the rest
			        CryptoJS.pad.ZeroPadding.pad(data, blockSize);
			    },

			    unpad: function (data) {
			        // Remove zero padding
			        CryptoJS.pad.ZeroPadding.unpad(data);

			        // Remove one more byte -- the 0x80 byte
			        data.sigBytes--;
			    }
			};


			return CryptoJS.pad.Iso97971;

		})); 
	} (padIso97971));
	return padIso97971.exports;
}

var padZeropadding = {exports: {}};

var hasRequiredPadZeropadding;

function requirePadZeropadding () {
	if (hasRequiredPadZeropadding) return padZeropadding.exports;
	hasRequiredPadZeropadding = 1;
	(function (module, exports) {
(function (root, factory, undef) {
			{
				// CommonJS
				module.exports = factory(requireCore(), requireCipherCore());
			}
		}(commonjsGlobal, function (CryptoJS) {

			/**
			 * Zero padding strategy.
			 */
			CryptoJS.pad.ZeroPadding = {
			    pad: function (data, blockSize) {
			        // Shortcut
			        var blockSizeBytes = blockSize * 4;

			        // Pad
			        data.clamp();
			        data.sigBytes += blockSizeBytes - ((data.sigBytes % blockSizeBytes) || blockSizeBytes);
			    },

			    unpad: function (data) {
			        // Shortcut
			        var dataWords = data.words;

			        // Unpad
			        var i = data.sigBytes - 1;
			        for (var i = data.sigBytes - 1; i >= 0; i--) {
			            if (((dataWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff)) {
			                data.sigBytes = i + 1;
			                break;
			            }
			        }
			    }
			};


			return CryptoJS.pad.ZeroPadding;

		})); 
	} (padZeropadding));
	return padZeropadding.exports;
}

var padNopadding = {exports: {}};

var hasRequiredPadNopadding;

function requirePadNopadding () {
	if (hasRequiredPadNopadding) return padNopadding.exports;
	hasRequiredPadNopadding = 1;
	(function (module, exports) {
(function (root, factory, undef) {
			{
				// CommonJS
				module.exports = factory(requireCore(), requireCipherCore());
			}
		}(commonjsGlobal, function (CryptoJS) {

			/**
			 * A noop padding strategy.
			 */
			CryptoJS.pad.NoPadding = {
			    pad: function () {
			    },

			    unpad: function () {
			    }
			};


			return CryptoJS.pad.NoPadding;

		})); 
	} (padNopadding));
	return padNopadding.exports;
}

var formatHex = {exports: {}};

var hasRequiredFormatHex;

function requireFormatHex () {
	if (hasRequiredFormatHex) return formatHex.exports;
	hasRequiredFormatHex = 1;
	(function (module, exports) {
(function (root, factory, undef) {
			{
				// CommonJS
				module.exports = factory(requireCore(), requireCipherCore());
			}
		}(commonjsGlobal, function (CryptoJS) {

			(function (undefined$1) {
			    // Shortcuts
			    var C = CryptoJS;
			    var C_lib = C.lib;
			    var CipherParams = C_lib.CipherParams;
			    var C_enc = C.enc;
			    var Hex = C_enc.Hex;
			    var C_format = C.format;

			    C_format.Hex = {
			        /**
			         * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
			         *
			         * @param {CipherParams} cipherParams The cipher params object.
			         *
			         * @return {string} The hexadecimally encoded string.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
			         */
			        stringify: function (cipherParams) {
			            return cipherParams.ciphertext.toString(Hex);
			        },

			        /**
			         * Converts a hexadecimally encoded ciphertext string to a cipher params object.
			         *
			         * @param {string} input The hexadecimally encoded string.
			         *
			         * @return {CipherParams} The cipher params object.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
			         */
			        parse: function (input) {
			            var ciphertext = Hex.parse(input);
			            return CipherParams.create({ ciphertext: ciphertext });
			        }
			    };
			}());


			return CryptoJS.format.Hex;

		})); 
	} (formatHex));
	return formatHex.exports;
}

var aes = {exports: {}};

var hasRequiredAes;

function requireAes () {
	if (hasRequiredAes) return aes.exports;
	hasRequiredAes = 1;
	(function (module, exports) {
(function (root, factory, undef) {
			{
				// CommonJS
				module.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
			}
		}(commonjsGlobal, function (CryptoJS) {

			(function () {
			    // Shortcuts
			    var C = CryptoJS;
			    var C_lib = C.lib;
			    var BlockCipher = C_lib.BlockCipher;
			    var C_algo = C.algo;

			    // Lookup tables
			    var SBOX = [];
			    var INV_SBOX = [];
			    var SUB_MIX_0 = [];
			    var SUB_MIX_1 = [];
			    var SUB_MIX_2 = [];
			    var SUB_MIX_3 = [];
			    var INV_SUB_MIX_0 = [];
			    var INV_SUB_MIX_1 = [];
			    var INV_SUB_MIX_2 = [];
			    var INV_SUB_MIX_3 = [];

			    // Compute lookup tables
			    (function () {
			        // Compute double table
			        var d = [];
			        for (var i = 0; i < 256; i++) {
			            if (i < 128) {
			                d[i] = i << 1;
			            } else {
			                d[i] = (i << 1) ^ 0x11b;
			            }
			        }

			        // Walk GF(2^8)
			        var x = 0;
			        var xi = 0;
			        for (var i = 0; i < 256; i++) {
			            // Compute sbox
			            var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
			            sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
			            SBOX[x] = sx;
			            INV_SBOX[sx] = x;

			            // Compute multiplication
			            var x2 = d[x];
			            var x4 = d[x2];
			            var x8 = d[x4];

			            // Compute sub bytes, mix columns tables
			            var t = (d[sx] * 0x101) ^ (sx * 0x1010100);
			            SUB_MIX_0[x] = (t << 24) | (t >>> 8);
			            SUB_MIX_1[x] = (t << 16) | (t >>> 16);
			            SUB_MIX_2[x] = (t << 8)  | (t >>> 24);
			            SUB_MIX_3[x] = t;

			            // Compute inv sub bytes, inv mix columns tables
			            var t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
			            INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);
			            INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);
			            INV_SUB_MIX_2[sx] = (t << 8)  | (t >>> 24);
			            INV_SUB_MIX_3[sx] = t;

			            // Compute next counter
			            if (!x) {
			                x = xi = 1;
			            } else {
			                x = x2 ^ d[d[d[x8 ^ x2]]];
			                xi ^= d[d[xi]];
			            }
			        }
			    }());

			    // Precomputed Rcon lookup
			    var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];

			    /**
			     * AES block cipher algorithm.
			     */
			    var AES = C_algo.AES = BlockCipher.extend({
			        _doReset: function () {
			            var t;

			            // Skip reset of nRounds has been set before and key did not change
			            if (this._nRounds && this._keyPriorReset === this._key) {
			                return;
			            }

			            // Shortcuts
			            var key = this._keyPriorReset = this._key;
			            var keyWords = key.words;
			            var keySize = key.sigBytes / 4;

			            // Compute number of rounds
			            var nRounds = this._nRounds = keySize + 6;

			            // Compute number of key schedule rows
			            var ksRows = (nRounds + 1) * 4;

			            // Compute key schedule
			            var keySchedule = this._keySchedule = [];
			            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
			                if (ksRow < keySize) {
			                    keySchedule[ksRow] = keyWords[ksRow];
			                } else {
			                    t = keySchedule[ksRow - 1];

			                    if (!(ksRow % keySize)) {
			                        // Rot word
			                        t = (t << 8) | (t >>> 24);

			                        // Sub word
			                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];

			                        // Mix Rcon
			                        t ^= RCON[(ksRow / keySize) | 0] << 24;
			                    } else if (keySize > 6 && ksRow % keySize == 4) {
			                        // Sub word
			                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];
			                    }

			                    keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
			                }
			            }

			            // Compute inv key schedule
			            var invKeySchedule = this._invKeySchedule = [];
			            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
			                var ksRow = ksRows - invKsRow;

			                if (invKsRow % 4) {
			                    var t = keySchedule[ksRow];
			                } else {
			                    var t = keySchedule[ksRow - 4];
			                }

			                if (invKsRow < 4 || ksRow <= 4) {
			                    invKeySchedule[invKsRow] = t;
			                } else {
			                    invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 0xff]] ^
			                                               INV_SUB_MIX_2[SBOX[(t >>> 8) & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];
			                }
			            }
			        },

			        encryptBlock: function (M, offset) {
			            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
			        },

			        decryptBlock: function (M, offset) {
			            // Swap 2nd and 4th rows
			            var t = M[offset + 1];
			            M[offset + 1] = M[offset + 3];
			            M[offset + 3] = t;

			            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);

			            // Inv swap 2nd and 4th rows
			            var t = M[offset + 1];
			            M[offset + 1] = M[offset + 3];
			            M[offset + 3] = t;
			        },

			        _doCryptBlock: function (M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
			            // Shortcut
			            var nRounds = this._nRounds;

			            // Get input, add round key
			            var s0 = M[offset]     ^ keySchedule[0];
			            var s1 = M[offset + 1] ^ keySchedule[1];
			            var s2 = M[offset + 2] ^ keySchedule[2];
			            var s3 = M[offset + 3] ^ keySchedule[3];

			            // Key schedule row counter
			            var ksRow = 4;

			            // Rounds
			            for (var round = 1; round < nRounds; round++) {
			                // Shift rows, sub bytes, mix columns, add round key
			                var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[(s1 >>> 16) & 0xff] ^ SUB_MIX_2[(s2 >>> 8) & 0xff] ^ SUB_MIX_3[s3 & 0xff] ^ keySchedule[ksRow++];
			                var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[(s2 >>> 16) & 0xff] ^ SUB_MIX_2[(s3 >>> 8) & 0xff] ^ SUB_MIX_3[s0 & 0xff] ^ keySchedule[ksRow++];
			                var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[(s3 >>> 16) & 0xff] ^ SUB_MIX_2[(s0 >>> 8) & 0xff] ^ SUB_MIX_3[s1 & 0xff] ^ keySchedule[ksRow++];
			                var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[(s0 >>> 16) & 0xff] ^ SUB_MIX_2[(s1 >>> 8) & 0xff] ^ SUB_MIX_3[s2 & 0xff] ^ keySchedule[ksRow++];

			                // Update state
			                s0 = t0;
			                s1 = t1;
			                s2 = t2;
			                s3 = t3;
			            }

			            // Shift rows, sub bytes, add round key
			            var t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
			            var t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
			            var t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
			            var t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];

			            // Set output
			            M[offset]     = t0;
			            M[offset + 1] = t1;
			            M[offset + 2] = t2;
			            M[offset + 3] = t3;
			        },

			        keySize: 256/32
			    });

			    /**
			     * Shortcut functions to the cipher's object interface.
			     *
			     * @example
			     *
			     *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);
			     *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);
			     */
			    C.AES = BlockCipher._createHelper(AES);
			}());


			return CryptoJS.AES;

		})); 
	} (aes));
	return aes.exports;
}

var tripledes = {exports: {}};

var hasRequiredTripledes;

function requireTripledes () {
	if (hasRequiredTripledes) return tripledes.exports;
	hasRequiredTripledes = 1;
	(function (module, exports) {
(function (root, factory, undef) {
			{
				// CommonJS
				module.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
			}
		}(commonjsGlobal, function (CryptoJS) {

			(function () {
			    // Shortcuts
			    var C = CryptoJS;
			    var C_lib = C.lib;
			    var WordArray = C_lib.WordArray;
			    var BlockCipher = C_lib.BlockCipher;
			    var C_algo = C.algo;

			    // Permuted Choice 1 constants
			    var PC1 = [
			        57, 49, 41, 33, 25, 17, 9,  1,
			        58, 50, 42, 34, 26, 18, 10, 2,
			        59, 51, 43, 35, 27, 19, 11, 3,
			        60, 52, 44, 36, 63, 55, 47, 39,
			        31, 23, 15, 7,  62, 54, 46, 38,
			        30, 22, 14, 6,  61, 53, 45, 37,
			        29, 21, 13, 5,  28, 20, 12, 4
			    ];

			    // Permuted Choice 2 constants
			    var PC2 = [
			        14, 17, 11, 24, 1,  5,
			        3,  28, 15, 6,  21, 10,
			        23, 19, 12, 4,  26, 8,
			        16, 7,  27, 20, 13, 2,
			        41, 52, 31, 37, 47, 55,
			        30, 40, 51, 45, 33, 48,
			        44, 49, 39, 56, 34, 53,
			        46, 42, 50, 36, 29, 32
			    ];

			    // Cumulative bit shift constants
			    var BIT_SHIFTS = [1,  2,  4,  6,  8,  10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];

			    // SBOXes and round permutation constants
			    var SBOX_P = [
			        {
			            0x0: 0x808200,
			            0x10000000: 0x8000,
			            0x20000000: 0x808002,
			            0x30000000: 0x2,
			            0x40000000: 0x200,
			            0x50000000: 0x808202,
			            0x60000000: 0x800202,
			            0x70000000: 0x800000,
			            0x80000000: 0x202,
			            0x90000000: 0x800200,
			            0xa0000000: 0x8200,
			            0xb0000000: 0x808000,
			            0xc0000000: 0x8002,
			            0xd0000000: 0x800002,
			            0xe0000000: 0x0,
			            0xf0000000: 0x8202,
			            0x8000000: 0x0,
			            0x18000000: 0x808202,
			            0x28000000: 0x8202,
			            0x38000000: 0x8000,
			            0x48000000: 0x808200,
			            0x58000000: 0x200,
			            0x68000000: 0x808002,
			            0x78000000: 0x2,
			            0x88000000: 0x800200,
			            0x98000000: 0x8200,
			            0xa8000000: 0x808000,
			            0xb8000000: 0x800202,
			            0xc8000000: 0x800002,
			            0xd8000000: 0x8002,
			            0xe8000000: 0x202,
			            0xf8000000: 0x800000,
			            0x1: 0x8000,
			            0x10000001: 0x2,
			            0x20000001: 0x808200,
			            0x30000001: 0x800000,
			            0x40000001: 0x808002,
			            0x50000001: 0x8200,
			            0x60000001: 0x200,
			            0x70000001: 0x800202,
			            0x80000001: 0x808202,
			            0x90000001: 0x808000,
			            0xa0000001: 0x800002,
			            0xb0000001: 0x8202,
			            0xc0000001: 0x202,
			            0xd0000001: 0x800200,
			            0xe0000001: 0x8002,
			            0xf0000001: 0x0,
			            0x8000001: 0x808202,
			            0x18000001: 0x808000,
			            0x28000001: 0x800000,
			            0x38000001: 0x200,
			            0x48000001: 0x8000,
			            0x58000001: 0x800002,
			            0x68000001: 0x2,
			            0x78000001: 0x8202,
			            0x88000001: 0x8002,
			            0x98000001: 0x800202,
			            0xa8000001: 0x202,
			            0xb8000001: 0x808200,
			            0xc8000001: 0x800200,
			            0xd8000001: 0x0,
			            0xe8000001: 0x8200,
			            0xf8000001: 0x808002
			        },
			        {
			            0x0: 0x40084010,
			            0x1000000: 0x4000,
			            0x2000000: 0x80000,
			            0x3000000: 0x40080010,
			            0x4000000: 0x40000010,
			            0x5000000: 0x40084000,
			            0x6000000: 0x40004000,
			            0x7000000: 0x10,
			            0x8000000: 0x84000,
			            0x9000000: 0x40004010,
			            0xa000000: 0x40000000,
			            0xb000000: 0x84010,
			            0xc000000: 0x80010,
			            0xd000000: 0x0,
			            0xe000000: 0x4010,
			            0xf000000: 0x40080000,
			            0x800000: 0x40004000,
			            0x1800000: 0x84010,
			            0x2800000: 0x10,
			            0x3800000: 0x40004010,
			            0x4800000: 0x40084010,
			            0x5800000: 0x40000000,
			            0x6800000: 0x80000,
			            0x7800000: 0x40080010,
			            0x8800000: 0x80010,
			            0x9800000: 0x0,
			            0xa800000: 0x4000,
			            0xb800000: 0x40080000,
			            0xc800000: 0x40000010,
			            0xd800000: 0x84000,
			            0xe800000: 0x40084000,
			            0xf800000: 0x4010,
			            0x10000000: 0x0,
			            0x11000000: 0x40080010,
			            0x12000000: 0x40004010,
			            0x13000000: 0x40084000,
			            0x14000000: 0x40080000,
			            0x15000000: 0x10,
			            0x16000000: 0x84010,
			            0x17000000: 0x4000,
			            0x18000000: 0x4010,
			            0x19000000: 0x80000,
			            0x1a000000: 0x80010,
			            0x1b000000: 0x40000010,
			            0x1c000000: 0x84000,
			            0x1d000000: 0x40004000,
			            0x1e000000: 0x40000000,
			            0x1f000000: 0x40084010,
			            0x10800000: 0x84010,
			            0x11800000: 0x80000,
			            0x12800000: 0x40080000,
			            0x13800000: 0x4000,
			            0x14800000: 0x40004000,
			            0x15800000: 0x40084010,
			            0x16800000: 0x10,
			            0x17800000: 0x40000000,
			            0x18800000: 0x40084000,
			            0x19800000: 0x40000010,
			            0x1a800000: 0x40004010,
			            0x1b800000: 0x80010,
			            0x1c800000: 0x0,
			            0x1d800000: 0x4010,
			            0x1e800000: 0x40080010,
			            0x1f800000: 0x84000
			        },
			        {
			            0x0: 0x104,
			            0x100000: 0x0,
			            0x200000: 0x4000100,
			            0x300000: 0x10104,
			            0x400000: 0x10004,
			            0x500000: 0x4000004,
			            0x600000: 0x4010104,
			            0x700000: 0x4010000,
			            0x800000: 0x4000000,
			            0x900000: 0x4010100,
			            0xa00000: 0x10100,
			            0xb00000: 0x4010004,
			            0xc00000: 0x4000104,
			            0xd00000: 0x10000,
			            0xe00000: 0x4,
			            0xf00000: 0x100,
			            0x80000: 0x4010100,
			            0x180000: 0x4010004,
			            0x280000: 0x0,
			            0x380000: 0x4000100,
			            0x480000: 0x4000004,
			            0x580000: 0x10000,
			            0x680000: 0x10004,
			            0x780000: 0x104,
			            0x880000: 0x4,
			            0x980000: 0x100,
			            0xa80000: 0x4010000,
			            0xb80000: 0x10104,
			            0xc80000: 0x10100,
			            0xd80000: 0x4000104,
			            0xe80000: 0x4010104,
			            0xf80000: 0x4000000,
			            0x1000000: 0x4010100,
			            0x1100000: 0x10004,
			            0x1200000: 0x10000,
			            0x1300000: 0x4000100,
			            0x1400000: 0x100,
			            0x1500000: 0x4010104,
			            0x1600000: 0x4000004,
			            0x1700000: 0x0,
			            0x1800000: 0x4000104,
			            0x1900000: 0x4000000,
			            0x1a00000: 0x4,
			            0x1b00000: 0x10100,
			            0x1c00000: 0x4010000,
			            0x1d00000: 0x104,
			            0x1e00000: 0x10104,
			            0x1f00000: 0x4010004,
			            0x1080000: 0x4000000,
			            0x1180000: 0x104,
			            0x1280000: 0x4010100,
			            0x1380000: 0x0,
			            0x1480000: 0x10004,
			            0x1580000: 0x4000100,
			            0x1680000: 0x100,
			            0x1780000: 0x4010004,
			            0x1880000: 0x10000,
			            0x1980000: 0x4010104,
			            0x1a80000: 0x10104,
			            0x1b80000: 0x4000004,
			            0x1c80000: 0x4000104,
			            0x1d80000: 0x4010000,
			            0x1e80000: 0x4,
			            0x1f80000: 0x10100
			        },
			        {
			            0x0: 0x80401000,
			            0x10000: 0x80001040,
			            0x20000: 0x401040,
			            0x30000: 0x80400000,
			            0x40000: 0x0,
			            0x50000: 0x401000,
			            0x60000: 0x80000040,
			            0x70000: 0x400040,
			            0x80000: 0x80000000,
			            0x90000: 0x400000,
			            0xa0000: 0x40,
			            0xb0000: 0x80001000,
			            0xc0000: 0x80400040,
			            0xd0000: 0x1040,
			            0xe0000: 0x1000,
			            0xf0000: 0x80401040,
			            0x8000: 0x80001040,
			            0x18000: 0x40,
			            0x28000: 0x80400040,
			            0x38000: 0x80001000,
			            0x48000: 0x401000,
			            0x58000: 0x80401040,
			            0x68000: 0x0,
			            0x78000: 0x80400000,
			            0x88000: 0x1000,
			            0x98000: 0x80401000,
			            0xa8000: 0x400000,
			            0xb8000: 0x1040,
			            0xc8000: 0x80000000,
			            0xd8000: 0x400040,
			            0xe8000: 0x401040,
			            0xf8000: 0x80000040,
			            0x100000: 0x400040,
			            0x110000: 0x401000,
			            0x120000: 0x80000040,
			            0x130000: 0x0,
			            0x140000: 0x1040,
			            0x150000: 0x80400040,
			            0x160000: 0x80401000,
			            0x170000: 0x80001040,
			            0x180000: 0x80401040,
			            0x190000: 0x80000000,
			            0x1a0000: 0x80400000,
			            0x1b0000: 0x401040,
			            0x1c0000: 0x80001000,
			            0x1d0000: 0x400000,
			            0x1e0000: 0x40,
			            0x1f0000: 0x1000,
			            0x108000: 0x80400000,
			            0x118000: 0x80401040,
			            0x128000: 0x0,
			            0x138000: 0x401000,
			            0x148000: 0x400040,
			            0x158000: 0x80000000,
			            0x168000: 0x80001040,
			            0x178000: 0x40,
			            0x188000: 0x80000040,
			            0x198000: 0x1000,
			            0x1a8000: 0x80001000,
			            0x1b8000: 0x80400040,
			            0x1c8000: 0x1040,
			            0x1d8000: 0x80401000,
			            0x1e8000: 0x400000,
			            0x1f8000: 0x401040
			        },
			        {
			            0x0: 0x80,
			            0x1000: 0x1040000,
			            0x2000: 0x40000,
			            0x3000: 0x20000000,
			            0x4000: 0x20040080,
			            0x5000: 0x1000080,
			            0x6000: 0x21000080,
			            0x7000: 0x40080,
			            0x8000: 0x1000000,
			            0x9000: 0x20040000,
			            0xa000: 0x20000080,
			            0xb000: 0x21040080,
			            0xc000: 0x21040000,
			            0xd000: 0x0,
			            0xe000: 0x1040080,
			            0xf000: 0x21000000,
			            0x800: 0x1040080,
			            0x1800: 0x21000080,
			            0x2800: 0x80,
			            0x3800: 0x1040000,
			            0x4800: 0x40000,
			            0x5800: 0x20040080,
			            0x6800: 0x21040000,
			            0x7800: 0x20000000,
			            0x8800: 0x20040000,
			            0x9800: 0x0,
			            0xa800: 0x21040080,
			            0xb800: 0x1000080,
			            0xc800: 0x20000080,
			            0xd800: 0x21000000,
			            0xe800: 0x1000000,
			            0xf800: 0x40080,
			            0x10000: 0x40000,
			            0x11000: 0x80,
			            0x12000: 0x20000000,
			            0x13000: 0x21000080,
			            0x14000: 0x1000080,
			            0x15000: 0x21040000,
			            0x16000: 0x20040080,
			            0x17000: 0x1000000,
			            0x18000: 0x21040080,
			            0x19000: 0x21000000,
			            0x1a000: 0x1040000,
			            0x1b000: 0x20040000,
			            0x1c000: 0x40080,
			            0x1d000: 0x20000080,
			            0x1e000: 0x0,
			            0x1f000: 0x1040080,
			            0x10800: 0x21000080,
			            0x11800: 0x1000000,
			            0x12800: 0x1040000,
			            0x13800: 0x20040080,
			            0x14800: 0x20000000,
			            0x15800: 0x1040080,
			            0x16800: 0x80,
			            0x17800: 0x21040000,
			            0x18800: 0x40080,
			            0x19800: 0x21040080,
			            0x1a800: 0x0,
			            0x1b800: 0x21000000,
			            0x1c800: 0x1000080,
			            0x1d800: 0x40000,
			            0x1e800: 0x20040000,
			            0x1f800: 0x20000080
			        },
			        {
			            0x0: 0x10000008,
			            0x100: 0x2000,
			            0x200: 0x10200000,
			            0x300: 0x10202008,
			            0x400: 0x10002000,
			            0x500: 0x200000,
			            0x600: 0x200008,
			            0x700: 0x10000000,
			            0x800: 0x0,
			            0x900: 0x10002008,
			            0xa00: 0x202000,
			            0xb00: 0x8,
			            0xc00: 0x10200008,
			            0xd00: 0x202008,
			            0xe00: 0x2008,
			            0xf00: 0x10202000,
			            0x80: 0x10200000,
			            0x180: 0x10202008,
			            0x280: 0x8,
			            0x380: 0x200000,
			            0x480: 0x202008,
			            0x580: 0x10000008,
			            0x680: 0x10002000,
			            0x780: 0x2008,
			            0x880: 0x200008,
			            0x980: 0x2000,
			            0xa80: 0x10002008,
			            0xb80: 0x10200008,
			            0xc80: 0x0,
			            0xd80: 0x10202000,
			            0xe80: 0x202000,
			            0xf80: 0x10000000,
			            0x1000: 0x10002000,
			            0x1100: 0x10200008,
			            0x1200: 0x10202008,
			            0x1300: 0x2008,
			            0x1400: 0x200000,
			            0x1500: 0x10000000,
			            0x1600: 0x10000008,
			            0x1700: 0x202000,
			            0x1800: 0x202008,
			            0x1900: 0x0,
			            0x1a00: 0x8,
			            0x1b00: 0x10200000,
			            0x1c00: 0x2000,
			            0x1d00: 0x10002008,
			            0x1e00: 0x10202000,
			            0x1f00: 0x200008,
			            0x1080: 0x8,
			            0x1180: 0x202000,
			            0x1280: 0x200000,
			            0x1380: 0x10000008,
			            0x1480: 0x10002000,
			            0x1580: 0x2008,
			            0x1680: 0x10202008,
			            0x1780: 0x10200000,
			            0x1880: 0x10202000,
			            0x1980: 0x10200008,
			            0x1a80: 0x2000,
			            0x1b80: 0x202008,
			            0x1c80: 0x200008,
			            0x1d80: 0x0,
			            0x1e80: 0x10000000,
			            0x1f80: 0x10002008
			        },
			        {
			            0x0: 0x100000,
			            0x10: 0x2000401,
			            0x20: 0x400,
			            0x30: 0x100401,
			            0x40: 0x2100401,
			            0x50: 0x0,
			            0x60: 0x1,
			            0x70: 0x2100001,
			            0x80: 0x2000400,
			            0x90: 0x100001,
			            0xa0: 0x2000001,
			            0xb0: 0x2100400,
			            0xc0: 0x2100000,
			            0xd0: 0x401,
			            0xe0: 0x100400,
			            0xf0: 0x2000000,
			            0x8: 0x2100001,
			            0x18: 0x0,
			            0x28: 0x2000401,
			            0x38: 0x2100400,
			            0x48: 0x100000,
			            0x58: 0x2000001,
			            0x68: 0x2000000,
			            0x78: 0x401,
			            0x88: 0x100401,
			            0x98: 0x2000400,
			            0xa8: 0x2100000,
			            0xb8: 0x100001,
			            0xc8: 0x400,
			            0xd8: 0x2100401,
			            0xe8: 0x1,
			            0xf8: 0x100400,
			            0x100: 0x2000000,
			            0x110: 0x100000,
			            0x120: 0x2000401,
			            0x130: 0x2100001,
			            0x140: 0x100001,
			            0x150: 0x2000400,
			            0x160: 0x2100400,
			            0x170: 0x100401,
			            0x180: 0x401,
			            0x190: 0x2100401,
			            0x1a0: 0x100400,
			            0x1b0: 0x1,
			            0x1c0: 0x0,
			            0x1d0: 0x2100000,
			            0x1e0: 0x2000001,
			            0x1f0: 0x400,
			            0x108: 0x100400,
			            0x118: 0x2000401,
			            0x128: 0x2100001,
			            0x138: 0x1,
			            0x148: 0x2000000,
			            0x158: 0x100000,
			            0x168: 0x401,
			            0x178: 0x2100400,
			            0x188: 0x2000001,
			            0x198: 0x2100000,
			            0x1a8: 0x0,
			            0x1b8: 0x2100401,
			            0x1c8: 0x100401,
			            0x1d8: 0x400,
			            0x1e8: 0x2000400,
			            0x1f8: 0x100001
			        },
			        {
			            0x0: 0x8000820,
			            0x1: 0x20000,
			            0x2: 0x8000000,
			            0x3: 0x20,
			            0x4: 0x20020,
			            0x5: 0x8020820,
			            0x6: 0x8020800,
			            0x7: 0x800,
			            0x8: 0x8020000,
			            0x9: 0x8000800,
			            0xa: 0x20800,
			            0xb: 0x8020020,
			            0xc: 0x820,
			            0xd: 0x0,
			            0xe: 0x8000020,
			            0xf: 0x20820,
			            0x80000000: 0x800,
			            0x80000001: 0x8020820,
			            0x80000002: 0x8000820,
			            0x80000003: 0x8000000,
			            0x80000004: 0x8020000,
			            0x80000005: 0x20800,
			            0x80000006: 0x20820,
			            0x80000007: 0x20,
			            0x80000008: 0x8000020,
			            0x80000009: 0x820,
			            0x8000000a: 0x20020,
			            0x8000000b: 0x8020800,
			            0x8000000c: 0x0,
			            0x8000000d: 0x8020020,
			            0x8000000e: 0x8000800,
			            0x8000000f: 0x20000,
			            0x10: 0x20820,
			            0x11: 0x8020800,
			            0x12: 0x20,
			            0x13: 0x800,
			            0x14: 0x8000800,
			            0x15: 0x8000020,
			            0x16: 0x8020020,
			            0x17: 0x20000,
			            0x18: 0x0,
			            0x19: 0x20020,
			            0x1a: 0x8020000,
			            0x1b: 0x8000820,
			            0x1c: 0x8020820,
			            0x1d: 0x20800,
			            0x1e: 0x820,
			            0x1f: 0x8000000,
			            0x80000010: 0x20000,
			            0x80000011: 0x800,
			            0x80000012: 0x8020020,
			            0x80000013: 0x20820,
			            0x80000014: 0x20,
			            0x80000015: 0x8020000,
			            0x80000016: 0x8000000,
			            0x80000017: 0x8000820,
			            0x80000018: 0x8020820,
			            0x80000019: 0x8000020,
			            0x8000001a: 0x8000800,
			            0x8000001b: 0x0,
			            0x8000001c: 0x20800,
			            0x8000001d: 0x820,
			            0x8000001e: 0x20020,
			            0x8000001f: 0x8020800
			        }
			    ];

			    // Masks that select the SBOX input
			    var SBOX_MASK = [
			        0xf8000001, 0x1f800000, 0x01f80000, 0x001f8000,
			        0x0001f800, 0x00001f80, 0x000001f8, 0x8000001f
			    ];

			    /**
			     * DES block cipher algorithm.
			     */
			    var DES = C_algo.DES = BlockCipher.extend({
			        _doReset: function () {
			            // Shortcuts
			            var key = this._key;
			            var keyWords = key.words;

			            // Select 56 bits according to PC1
			            var keyBits = [];
			            for (var i = 0; i < 56; i++) {
			                var keyBitPos = PC1[i] - 1;
			                keyBits[i] = (keyWords[keyBitPos >>> 5] >>> (31 - keyBitPos % 32)) & 1;
			            }

			            // Assemble 16 subkeys
			            var subKeys = this._subKeys = [];
			            for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
			                // Create subkey
			                var subKey = subKeys[nSubKey] = [];

			                // Shortcut
			                var bitShift = BIT_SHIFTS[nSubKey];

			                // Select 48 bits according to PC2
			                for (var i = 0; i < 24; i++) {
			                    // Select from the left 28 key bits
			                    subKey[(i / 6) | 0] |= keyBits[((PC2[i] - 1) + bitShift) % 28] << (31 - i % 6);

			                    // Select from the right 28 key bits
			                    subKey[4 + ((i / 6) | 0)] |= keyBits[28 + (((PC2[i + 24] - 1) + bitShift) % 28)] << (31 - i % 6);
			                }

			                // Since each subkey is applied to an expanded 32-bit input,
			                // the subkey can be broken into 8 values scaled to 32-bits,
			                // which allows the key to be used without expansion
			                subKey[0] = (subKey[0] << 1) | (subKey[0] >>> 31);
			                for (var i = 1; i < 7; i++) {
			                    subKey[i] = subKey[i] >>> ((i - 1) * 4 + 3);
			                }
			                subKey[7] = (subKey[7] << 5) | (subKey[7] >>> 27);
			            }

			            // Compute inverse subkeys
			            var invSubKeys = this._invSubKeys = [];
			            for (var i = 0; i < 16; i++) {
			                invSubKeys[i] = subKeys[15 - i];
			            }
			        },

			        encryptBlock: function (M, offset) {
			            this._doCryptBlock(M, offset, this._subKeys);
			        },

			        decryptBlock: function (M, offset) {
			            this._doCryptBlock(M, offset, this._invSubKeys);
			        },

			        _doCryptBlock: function (M, offset, subKeys) {
			            // Get input
			            this._lBlock = M[offset];
			            this._rBlock = M[offset + 1];

			            // Initial permutation
			            exchangeLR.call(this, 4,  0x0f0f0f0f);
			            exchangeLR.call(this, 16, 0x0000ffff);
			            exchangeRL.call(this, 2,  0x33333333);
			            exchangeRL.call(this, 8,  0x00ff00ff);
			            exchangeLR.call(this, 1,  0x55555555);

			            // Rounds
			            for (var round = 0; round < 16; round++) {
			                // Shortcuts
			                var subKey = subKeys[round];
			                var lBlock = this._lBlock;
			                var rBlock = this._rBlock;

			                // Feistel function
			                var f = 0;
			                for (var i = 0; i < 8; i++) {
			                    f |= SBOX_P[i][((rBlock ^ subKey[i]) & SBOX_MASK[i]) >>> 0];
			                }
			                this._lBlock = rBlock;
			                this._rBlock = lBlock ^ f;
			            }

			            // Undo swap from last round
			            var t = this._lBlock;
			            this._lBlock = this._rBlock;
			            this._rBlock = t;

			            // Final permutation
			            exchangeLR.call(this, 1,  0x55555555);
			            exchangeRL.call(this, 8,  0x00ff00ff);
			            exchangeRL.call(this, 2,  0x33333333);
			            exchangeLR.call(this, 16, 0x0000ffff);
			            exchangeLR.call(this, 4,  0x0f0f0f0f);

			            // Set output
			            M[offset] = this._lBlock;
			            M[offset + 1] = this._rBlock;
			        },

			        keySize: 64/32,

			        ivSize: 64/32,

			        blockSize: 64/32
			    });

			    // Swap bits across the left and right words
			    function exchangeLR(offset, mask) {
			        var t = ((this._lBlock >>> offset) ^ this._rBlock) & mask;
			        this._rBlock ^= t;
			        this._lBlock ^= t << offset;
			    }

			    function exchangeRL(offset, mask) {
			        var t = ((this._rBlock >>> offset) ^ this._lBlock) & mask;
			        this._lBlock ^= t;
			        this._rBlock ^= t << offset;
			    }

			    /**
			     * Shortcut functions to the cipher's object interface.
			     *
			     * @example
			     *
			     *     var ciphertext = CryptoJS.DES.encrypt(message, key, cfg);
			     *     var plaintext  = CryptoJS.DES.decrypt(ciphertext, key, cfg);
			     */
			    C.DES = BlockCipher._createHelper(DES);

			    /**
			     * Triple-DES block cipher algorithm.
			     */
			    var TripleDES = C_algo.TripleDES = BlockCipher.extend({
			        _doReset: function () {
			            // Shortcuts
			            var key = this._key;
			            var keyWords = key.words;
			            // Make sure the key length is valid (64, 128 or >= 192 bit)
			            if (keyWords.length !== 2 && keyWords.length !== 4 && keyWords.length < 6) {
			                throw new Error('Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.');
			            }

			            // Extend the key according to the keying options defined in 3DES standard
			            var key1 = keyWords.slice(0, 2);
			            var key2 = keyWords.length < 4 ? keyWords.slice(0, 2) : keyWords.slice(2, 4);
			            var key3 = keyWords.length < 6 ? keyWords.slice(0, 2) : keyWords.slice(4, 6);

			            // Create DES instances
			            this._des1 = DES.createEncryptor(WordArray.create(key1));
			            this._des2 = DES.createEncryptor(WordArray.create(key2));
			            this._des3 = DES.createEncryptor(WordArray.create(key3));
			        },

			        encryptBlock: function (M, offset) {
			            this._des1.encryptBlock(M, offset);
			            this._des2.decryptBlock(M, offset);
			            this._des3.encryptBlock(M, offset);
			        },

			        decryptBlock: function (M, offset) {
			            this._des3.decryptBlock(M, offset);
			            this._des2.encryptBlock(M, offset);
			            this._des1.decryptBlock(M, offset);
			        },

			        keySize: 192/32,

			        ivSize: 64/32,

			        blockSize: 64/32
			    });

			    /**
			     * Shortcut functions to the cipher's object interface.
			     *
			     * @example
			     *
			     *     var ciphertext = CryptoJS.TripleDES.encrypt(message, key, cfg);
			     *     var plaintext  = CryptoJS.TripleDES.decrypt(ciphertext, key, cfg);
			     */
			    C.TripleDES = BlockCipher._createHelper(TripleDES);
			}());


			return CryptoJS.TripleDES;

		})); 
	} (tripledes));
	return tripledes.exports;
}

var rc4 = {exports: {}};

var hasRequiredRc4;

function requireRc4 () {
	if (hasRequiredRc4) return rc4.exports;
	hasRequiredRc4 = 1;
	(function (module, exports) {
(function (root, factory, undef) {
			{
				// CommonJS
				module.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
			}
		}(commonjsGlobal, function (CryptoJS) {

			(function () {
			    // Shortcuts
			    var C = CryptoJS;
			    var C_lib = C.lib;
			    var StreamCipher = C_lib.StreamCipher;
			    var C_algo = C.algo;

			    /**
			     * RC4 stream cipher algorithm.
			     */
			    var RC4 = C_algo.RC4 = StreamCipher.extend({
			        _doReset: function () {
			            // Shortcuts
			            var key = this._key;
			            var keyWords = key.words;
			            var keySigBytes = key.sigBytes;

			            // Init sbox
			            var S = this._S = [];
			            for (var i = 0; i < 256; i++) {
			                S[i] = i;
			            }

			            // Key setup
			            for (var i = 0, j = 0; i < 256; i++) {
			                var keyByteIndex = i % keySigBytes;
			                var keyByte = (keyWords[keyByteIndex >>> 2] >>> (24 - (keyByteIndex % 4) * 8)) & 0xff;

			                j = (j + S[i] + keyByte) % 256;

			                // Swap
			                var t = S[i];
			                S[i] = S[j];
			                S[j] = t;
			            }

			            // Counters
			            this._i = this._j = 0;
			        },

			        _doProcessBlock: function (M, offset) {
			            M[offset] ^= generateKeystreamWord.call(this);
			        },

			        keySize: 256/32,

			        ivSize: 0
			    });

			    function generateKeystreamWord() {
			        // Shortcuts
			        var S = this._S;
			        var i = this._i;
			        var j = this._j;

			        // Generate keystream word
			        var keystreamWord = 0;
			        for (var n = 0; n < 4; n++) {
			            i = (i + 1) % 256;
			            j = (j + S[i]) % 256;

			            // Swap
			            var t = S[i];
			            S[i] = S[j];
			            S[j] = t;

			            keystreamWord |= S[(S[i] + S[j]) % 256] << (24 - n * 8);
			        }

			        // Update counters
			        this._i = i;
			        this._j = j;

			        return keystreamWord;
			    }

			    /**
			     * Shortcut functions to the cipher's object interface.
			     *
			     * @example
			     *
			     *     var ciphertext = CryptoJS.RC4.encrypt(message, key, cfg);
			     *     var plaintext  = CryptoJS.RC4.decrypt(ciphertext, key, cfg);
			     */
			    C.RC4 = StreamCipher._createHelper(RC4);

			    /**
			     * Modified RC4 stream cipher algorithm.
			     */
			    var RC4Drop = C_algo.RC4Drop = RC4.extend({
			        /**
			         * Configuration options.
			         *
			         * @property {number} drop The number of keystream words to drop. Default 192
			         */
			        cfg: RC4.cfg.extend({
			            drop: 192
			        }),

			        _doReset: function () {
			            RC4._doReset.call(this);

			            // Drop
			            for (var i = this.cfg.drop; i > 0; i--) {
			                generateKeystreamWord.call(this);
			            }
			        }
			    });

			    /**
			     * Shortcut functions to the cipher's object interface.
			     *
			     * @example
			     *
			     *     var ciphertext = CryptoJS.RC4Drop.encrypt(message, key, cfg);
			     *     var plaintext  = CryptoJS.RC4Drop.decrypt(ciphertext, key, cfg);
			     */
			    C.RC4Drop = StreamCipher._createHelper(RC4Drop);
			}());


			return CryptoJS.RC4;

		})); 
	} (rc4));
	return rc4.exports;
}

var rabbit = {exports: {}};

var hasRequiredRabbit;

function requireRabbit () {
	if (hasRequiredRabbit) return rabbit.exports;
	hasRequiredRabbit = 1;
	(function (module, exports) {
(function (root, factory, undef) {
			{
				// CommonJS
				module.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
			}
		}(commonjsGlobal, function (CryptoJS) {

			(function () {
			    // Shortcuts
			    var C = CryptoJS;
			    var C_lib = C.lib;
			    var StreamCipher = C_lib.StreamCipher;
			    var C_algo = C.algo;

			    // Reusable objects
			    var S  = [];
			    var C_ = [];
			    var G  = [];

			    /**
			     * Rabbit stream cipher algorithm
			     */
			    var Rabbit = C_algo.Rabbit = StreamCipher.extend({
			        _doReset: function () {
			            // Shortcuts
			            var K = this._key.words;
			            var iv = this.cfg.iv;

			            // Swap endian
			            for (var i = 0; i < 4; i++) {
			                K[i] = (((K[i] << 8)  | (K[i] >>> 24)) & 0x00ff00ff) |
			                       (((K[i] << 24) | (K[i] >>> 8))  & 0xff00ff00);
			            }

			            // Generate initial state values
			            var X = this._X = [
			                K[0], (K[3] << 16) | (K[2] >>> 16),
			                K[1], (K[0] << 16) | (K[3] >>> 16),
			                K[2], (K[1] << 16) | (K[0] >>> 16),
			                K[3], (K[2] << 16) | (K[1] >>> 16)
			            ];

			            // Generate initial counter values
			            var C = this._C = [
			                (K[2] << 16) | (K[2] >>> 16), (K[0] & 0xffff0000) | (K[1] & 0x0000ffff),
			                (K[3] << 16) | (K[3] >>> 16), (K[1] & 0xffff0000) | (K[2] & 0x0000ffff),
			                (K[0] << 16) | (K[0] >>> 16), (K[2] & 0xffff0000) | (K[3] & 0x0000ffff),
			                (K[1] << 16) | (K[1] >>> 16), (K[3] & 0xffff0000) | (K[0] & 0x0000ffff)
			            ];

			            // Carry bit
			            this._b = 0;

			            // Iterate the system four times
			            for (var i = 0; i < 4; i++) {
			                nextState.call(this);
			            }

			            // Modify the counters
			            for (var i = 0; i < 8; i++) {
			                C[i] ^= X[(i + 4) & 7];
			            }

			            // IV setup
			            if (iv) {
			                // Shortcuts
			                var IV = iv.words;
			                var IV_0 = IV[0];
			                var IV_1 = IV[1];

			                // Generate four subvectors
			                var i0 = (((IV_0 << 8) | (IV_0 >>> 24)) & 0x00ff00ff) | (((IV_0 << 24) | (IV_0 >>> 8)) & 0xff00ff00);
			                var i2 = (((IV_1 << 8) | (IV_1 >>> 24)) & 0x00ff00ff) | (((IV_1 << 24) | (IV_1 >>> 8)) & 0xff00ff00);
			                var i1 = (i0 >>> 16) | (i2 & 0xffff0000);
			                var i3 = (i2 << 16)  | (i0 & 0x0000ffff);

			                // Modify counter values
			                C[0] ^= i0;
			                C[1] ^= i1;
			                C[2] ^= i2;
			                C[3] ^= i3;
			                C[4] ^= i0;
			                C[5] ^= i1;
			                C[6] ^= i2;
			                C[7] ^= i3;

			                // Iterate the system four times
			                for (var i = 0; i < 4; i++) {
			                    nextState.call(this);
			                }
			            }
			        },

			        _doProcessBlock: function (M, offset) {
			            // Shortcut
			            var X = this._X;

			            // Iterate the system
			            nextState.call(this);

			            // Generate four keystream words
			            S[0] = X[0] ^ (X[5] >>> 16) ^ (X[3] << 16);
			            S[1] = X[2] ^ (X[7] >>> 16) ^ (X[5] << 16);
			            S[2] = X[4] ^ (X[1] >>> 16) ^ (X[7] << 16);
			            S[3] = X[6] ^ (X[3] >>> 16) ^ (X[1] << 16);

			            for (var i = 0; i < 4; i++) {
			                // Swap endian
			                S[i] = (((S[i] << 8)  | (S[i] >>> 24)) & 0x00ff00ff) |
			                       (((S[i] << 24) | (S[i] >>> 8))  & 0xff00ff00);

			                // Encrypt
			                M[offset + i] ^= S[i];
			            }
			        },

			        blockSize: 128/32,

			        ivSize: 64/32
			    });

			    function nextState() {
			        // Shortcuts
			        var X = this._X;
			        var C = this._C;

			        // Save old counter values
			        for (var i = 0; i < 8; i++) {
			            C_[i] = C[i];
			        }

			        // Calculate new counter values
			        C[0] = (C[0] + 0x4d34d34d + this._b) | 0;
			        C[1] = (C[1] + 0xd34d34d3 + ((C[0] >>> 0) < (C_[0] >>> 0) ? 1 : 0)) | 0;
			        C[2] = (C[2] + 0x34d34d34 + ((C[1] >>> 0) < (C_[1] >>> 0) ? 1 : 0)) | 0;
			        C[3] = (C[3] + 0x4d34d34d + ((C[2] >>> 0) < (C_[2] >>> 0) ? 1 : 0)) | 0;
			        C[4] = (C[4] + 0xd34d34d3 + ((C[3] >>> 0) < (C_[3] >>> 0) ? 1 : 0)) | 0;
			        C[5] = (C[5] + 0x34d34d34 + ((C[4] >>> 0) < (C_[4] >>> 0) ? 1 : 0)) | 0;
			        C[6] = (C[6] + 0x4d34d34d + ((C[5] >>> 0) < (C_[5] >>> 0) ? 1 : 0)) | 0;
			        C[7] = (C[7] + 0xd34d34d3 + ((C[6] >>> 0) < (C_[6] >>> 0) ? 1 : 0)) | 0;
			        this._b = (C[7] >>> 0) < (C_[7] >>> 0) ? 1 : 0;

			        // Calculate the g-values
			        for (var i = 0; i < 8; i++) {
			            var gx = X[i] + C[i];

			            // Construct high and low argument for squaring
			            var ga = gx & 0xffff;
			            var gb = gx >>> 16;

			            // Calculate high and low result of squaring
			            var gh = ((((ga * ga) >>> 17) + ga * gb) >>> 15) + gb * gb;
			            var gl = (((gx & 0xffff0000) * gx) | 0) + (((gx & 0x0000ffff) * gx) | 0);

			            // High XOR low
			            G[i] = gh ^ gl;
			        }

			        // Calculate new state values
			        X[0] = (G[0] + ((G[7] << 16) | (G[7] >>> 16)) + ((G[6] << 16) | (G[6] >>> 16))) | 0;
			        X[1] = (G[1] + ((G[0] << 8)  | (G[0] >>> 24)) + G[7]) | 0;
			        X[2] = (G[2] + ((G[1] << 16) | (G[1] >>> 16)) + ((G[0] << 16) | (G[0] >>> 16))) | 0;
			        X[3] = (G[3] + ((G[2] << 8)  | (G[2] >>> 24)) + G[1]) | 0;
			        X[4] = (G[4] + ((G[3] << 16) | (G[3] >>> 16)) + ((G[2] << 16) | (G[2] >>> 16))) | 0;
			        X[5] = (G[5] + ((G[4] << 8)  | (G[4] >>> 24)) + G[3]) | 0;
			        X[6] = (G[6] + ((G[5] << 16) | (G[5] >>> 16)) + ((G[4] << 16) | (G[4] >>> 16))) | 0;
			        X[7] = (G[7] + ((G[6] << 8)  | (G[6] >>> 24)) + G[5]) | 0;
			    }

			    /**
			     * Shortcut functions to the cipher's object interface.
			     *
			     * @example
			     *
			     *     var ciphertext = CryptoJS.Rabbit.encrypt(message, key, cfg);
			     *     var plaintext  = CryptoJS.Rabbit.decrypt(ciphertext, key, cfg);
			     */
			    C.Rabbit = StreamCipher._createHelper(Rabbit);
			}());


			return CryptoJS.Rabbit;

		})); 
	} (rabbit));
	return rabbit.exports;
}

var rabbitLegacy = {exports: {}};

var hasRequiredRabbitLegacy;

function requireRabbitLegacy () {
	if (hasRequiredRabbitLegacy) return rabbitLegacy.exports;
	hasRequiredRabbitLegacy = 1;
	(function (module, exports) {
(function (root, factory, undef) {
			{
				// CommonJS
				module.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
			}
		}(commonjsGlobal, function (CryptoJS) {

			(function () {
			    // Shortcuts
			    var C = CryptoJS;
			    var C_lib = C.lib;
			    var StreamCipher = C_lib.StreamCipher;
			    var C_algo = C.algo;

			    // Reusable objects
			    var S  = [];
			    var C_ = [];
			    var G  = [];

			    /**
			     * Rabbit stream cipher algorithm.
			     *
			     * This is a legacy version that neglected to convert the key to little-endian.
			     * This error doesn't affect the cipher's security,
			     * but it does affect its compatibility with other implementations.
			     */
			    var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
			        _doReset: function () {
			            // Shortcuts
			            var K = this._key.words;
			            var iv = this.cfg.iv;

			            // Generate initial state values
			            var X = this._X = [
			                K[0], (K[3] << 16) | (K[2] >>> 16),
			                K[1], (K[0] << 16) | (K[3] >>> 16),
			                K[2], (K[1] << 16) | (K[0] >>> 16),
			                K[3], (K[2] << 16) | (K[1] >>> 16)
			            ];

			            // Generate initial counter values
			            var C = this._C = [
			                (K[2] << 16) | (K[2] >>> 16), (K[0] & 0xffff0000) | (K[1] & 0x0000ffff),
			                (K[3] << 16) | (K[3] >>> 16), (K[1] & 0xffff0000) | (K[2] & 0x0000ffff),
			                (K[0] << 16) | (K[0] >>> 16), (K[2] & 0xffff0000) | (K[3] & 0x0000ffff),
			                (K[1] << 16) | (K[1] >>> 16), (K[3] & 0xffff0000) | (K[0] & 0x0000ffff)
			            ];

			            // Carry bit
			            this._b = 0;

			            // Iterate the system four times
			            for (var i = 0; i < 4; i++) {
			                nextState.call(this);
			            }

			            // Modify the counters
			            for (var i = 0; i < 8; i++) {
			                C[i] ^= X[(i + 4) & 7];
			            }

			            // IV setup
			            if (iv) {
			                // Shortcuts
			                var IV = iv.words;
			                var IV_0 = IV[0];
			                var IV_1 = IV[1];

			                // Generate four subvectors
			                var i0 = (((IV_0 << 8) | (IV_0 >>> 24)) & 0x00ff00ff) | (((IV_0 << 24) | (IV_0 >>> 8)) & 0xff00ff00);
			                var i2 = (((IV_1 << 8) | (IV_1 >>> 24)) & 0x00ff00ff) | (((IV_1 << 24) | (IV_1 >>> 8)) & 0xff00ff00);
			                var i1 = (i0 >>> 16) | (i2 & 0xffff0000);
			                var i3 = (i2 << 16)  | (i0 & 0x0000ffff);

			                // Modify counter values
			                C[0] ^= i0;
			                C[1] ^= i1;
			                C[2] ^= i2;
			                C[3] ^= i3;
			                C[4] ^= i0;
			                C[5] ^= i1;
			                C[6] ^= i2;
			                C[7] ^= i3;

			                // Iterate the system four times
			                for (var i = 0; i < 4; i++) {
			                    nextState.call(this);
			                }
			            }
			        },

			        _doProcessBlock: function (M, offset) {
			            // Shortcut
			            var X = this._X;

			            // Iterate the system
			            nextState.call(this);

			            // Generate four keystream words
			            S[0] = X[0] ^ (X[5] >>> 16) ^ (X[3] << 16);
			            S[1] = X[2] ^ (X[7] >>> 16) ^ (X[5] << 16);
			            S[2] = X[4] ^ (X[1] >>> 16) ^ (X[7] << 16);
			            S[3] = X[6] ^ (X[3] >>> 16) ^ (X[1] << 16);

			            for (var i = 0; i < 4; i++) {
			                // Swap endian
			                S[i] = (((S[i] << 8)  | (S[i] >>> 24)) & 0x00ff00ff) |
			                       (((S[i] << 24) | (S[i] >>> 8))  & 0xff00ff00);

			                // Encrypt
			                M[offset + i] ^= S[i];
			            }
			        },

			        blockSize: 128/32,

			        ivSize: 64/32
			    });

			    function nextState() {
			        // Shortcuts
			        var X = this._X;
			        var C = this._C;

			        // Save old counter values
			        for (var i = 0; i < 8; i++) {
			            C_[i] = C[i];
			        }

			        // Calculate new counter values
			        C[0] = (C[0] + 0x4d34d34d + this._b) | 0;
			        C[1] = (C[1] + 0xd34d34d3 + ((C[0] >>> 0) < (C_[0] >>> 0) ? 1 : 0)) | 0;
			        C[2] = (C[2] + 0x34d34d34 + ((C[1] >>> 0) < (C_[1] >>> 0) ? 1 : 0)) | 0;
			        C[3] = (C[3] + 0x4d34d34d + ((C[2] >>> 0) < (C_[2] >>> 0) ? 1 : 0)) | 0;
			        C[4] = (C[4] + 0xd34d34d3 + ((C[3] >>> 0) < (C_[3] >>> 0) ? 1 : 0)) | 0;
			        C[5] = (C[5] + 0x34d34d34 + ((C[4] >>> 0) < (C_[4] >>> 0) ? 1 : 0)) | 0;
			        C[6] = (C[6] + 0x4d34d34d + ((C[5] >>> 0) < (C_[5] >>> 0) ? 1 : 0)) | 0;
			        C[7] = (C[7] + 0xd34d34d3 + ((C[6] >>> 0) < (C_[6] >>> 0) ? 1 : 0)) | 0;
			        this._b = (C[7] >>> 0) < (C_[7] >>> 0) ? 1 : 0;

			        // Calculate the g-values
			        for (var i = 0; i < 8; i++) {
			            var gx = X[i] + C[i];

			            // Construct high and low argument for squaring
			            var ga = gx & 0xffff;
			            var gb = gx >>> 16;

			            // Calculate high and low result of squaring
			            var gh = ((((ga * ga) >>> 17) + ga * gb) >>> 15) + gb * gb;
			            var gl = (((gx & 0xffff0000) * gx) | 0) + (((gx & 0x0000ffff) * gx) | 0);

			            // High XOR low
			            G[i] = gh ^ gl;
			        }

			        // Calculate new state values
			        X[0] = (G[0] + ((G[7] << 16) | (G[7] >>> 16)) + ((G[6] << 16) | (G[6] >>> 16))) | 0;
			        X[1] = (G[1] + ((G[0] << 8)  | (G[0] >>> 24)) + G[7]) | 0;
			        X[2] = (G[2] + ((G[1] << 16) | (G[1] >>> 16)) + ((G[0] << 16) | (G[0] >>> 16))) | 0;
			        X[3] = (G[3] + ((G[2] << 8)  | (G[2] >>> 24)) + G[1]) | 0;
			        X[4] = (G[4] + ((G[3] << 16) | (G[3] >>> 16)) + ((G[2] << 16) | (G[2] >>> 16))) | 0;
			        X[5] = (G[5] + ((G[4] << 8)  | (G[4] >>> 24)) + G[3]) | 0;
			        X[6] = (G[6] + ((G[5] << 16) | (G[5] >>> 16)) + ((G[4] << 16) | (G[4] >>> 16))) | 0;
			        X[7] = (G[7] + ((G[6] << 8)  | (G[6] >>> 24)) + G[5]) | 0;
			    }

			    /**
			     * Shortcut functions to the cipher's object interface.
			     *
			     * @example
			     *
			     *     var ciphertext = CryptoJS.RabbitLegacy.encrypt(message, key, cfg);
			     *     var plaintext  = CryptoJS.RabbitLegacy.decrypt(ciphertext, key, cfg);
			     */
			    C.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
			}());


			return CryptoJS.RabbitLegacy;

		})); 
	} (rabbitLegacy));
	return rabbitLegacy.exports;
}

(function (module, exports) {
(function (root, factory, undef) {
		{
			// CommonJS
			module.exports = factory(requireCore(), requireX64Core(), requireLibTypedarrays(), requireEncUtf16(), requireEncBase64(), requireEncBase64url(), requireMd5(), requireSha1(), requireSha256(), requireSha224(), requireSha512(), requireSha384(), requireSha3(), requireRipemd160(), requireHmac(), requirePbkdf2(), requireEvpkdf(), requireCipherCore(), requireModeCfb(), requireModeCtr(), requireModeCtrGladman(), requireModeOfb(), requireModeEcb(), requirePadAnsix923(), requirePadIso10126(), requirePadIso97971(), requirePadZeropadding(), requirePadNopadding(), requireFormatHex(), requireAes(), requireTripledes(), requireRc4(), requireRabbit(), requireRabbitLegacy());
		}
	}(commonjsGlobal, function (CryptoJS) {

		return CryptoJS;

	})); 
} (cryptoJs));

var encHex = {exports: {}};

(function (module, exports) {
(function (root, factory) {
		{
			// CommonJS
			module.exports = factory(requireCore());
		}
	}(commonjsGlobal, function (CryptoJS) {

		return CryptoJS.enc.Hex;

	})); 
} (encHex));

var metaidProviderSdk_min = {exports: {}};

(function (module, exports) {
	(function (global, factory) {
	    factory(exports, require$$0$6, require$$1$1, require$$2$2, require$$3$1, require$$0$4, require$$5$1, require$$1$2, require$$7$1, require$$8$1, require$$9$1, require$$10, mvcLibExports) ;
	})(commonjsGlobal, (function (exports, require$$1$1, require$$2, require$$0$3, require$$3, require$$4, require$$0$2, require$$1, require$$0$1, require$$8, require$$1$2, require$$6, mvc) {
	    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

	    var require$$1__default$1 = /*#__PURE__*/_interopDefaultLegacy(require$$1$1);
	    var require$$2__default = /*#__PURE__*/_interopDefaultLegacy(require$$2);
	    var require$$0__default$2 = /*#__PURE__*/_interopDefaultLegacy(require$$0$3);
	    var require$$3__default = /*#__PURE__*/_interopDefaultLegacy(require$$3);
	    var require$$4__default = /*#__PURE__*/_interopDefaultLegacy(require$$4);
	    var require$$0__default$1 = /*#__PURE__*/_interopDefaultLegacy(require$$0$2);
	    var require$$1__default = /*#__PURE__*/_interopDefaultLegacy(require$$1);
	    var require$$0__default = /*#__PURE__*/_interopDefaultLegacy(require$$0$1);
	    var require$$8__default = /*#__PURE__*/_interopDefaultLegacy(require$$8);
	    var require$$1__default$2 = /*#__PURE__*/_interopDefaultLegacy(require$$1$2);
	    var require$$6__default = /*#__PURE__*/_interopDefaultLegacy(require$$6);
	    var mvc__default = /*#__PURE__*/_interopDefaultLegacy(mvc);

	    /******************************************************************************
	    Copyright (c) Microsoft Corporation.

	    Permission to use, copy, modify, and/or distribute this software for any
	    purpose with or without fee is hereby granted.

	    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
	    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
	    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
	    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
	    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
	    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
	    PERFORMANCE OF THIS SOFTWARE.
	    ***************************************************************************** */

	    function __rest(s, e) {
	        var t = {};
	        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	            t[p] = s[p];
	        if (s != null && typeof Object.getOwnPropertySymbols === "function")
	            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                    t[p[i]] = s[p[i]];
	            }
	        return t;
	    }

	    function __awaiter(thisArg, _arguments, P, generator) {
	        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	        return new (P || (P = Promise))(function (resolve, reject) {
	            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	            step((generator = generator.apply(thisArg, _arguments || [])).next());
	        });
	    }

	    var commonjsGlobal$1 = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof self !== 'undefined' ? self : {};

	    function getDefaultExportFromCjs (x) {
	    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	    }

	    var requestSdk_min = {exports: {}};

	    var axios$1 = {exports: {}};

	    var bind;
	    var hasRequiredBind;

	    function requireBind () {
	    	if (hasRequiredBind) return bind;
	    	hasRequiredBind = 1;

	    	bind = function bind(fn, thisArg) {
	    	  return function wrap() {
	    	    var args = new Array(arguments.length);
	    	    for (var i = 0; i < args.length; i++) {
	    	      args[i] = arguments[i];
	    	    }
	    	    return fn.apply(thisArg, args);
	    	  };
	    	};
	    	return bind;
	    }

	    var utils;
	    var hasRequiredUtils;

	    function requireUtils () {
	    	if (hasRequiredUtils) return utils;
	    	hasRequiredUtils = 1;

	    	var bind = requireBind();

	    	// utils is a library of generic helper functions non-specific to axios

	    	var toString = Object.prototype.toString;

	    	// eslint-disable-next-line func-names
	    	var kindOf = (function(cache) {
	    	  // eslint-disable-next-line func-names
	    	  return function(thing) {
	    	    var str = toString.call(thing);
	    	    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
	    	  };
	    	})(Object.create(null));

	    	function kindOfTest(type) {
	    	  type = type.toLowerCase();
	    	  return function isKindOf(thing) {
	    	    return kindOf(thing) === type;
	    	  };
	    	}

	    	/**
	    	 * Determine if a value is an Array
	    	 *
	    	 * @param {Object} val The value to test
	    	 * @returns {boolean} True if value is an Array, otherwise false
	    	 */
	    	function isArray(val) {
	    	  return Array.isArray(val);
	    	}

	    	/**
	    	 * Determine if a value is undefined
	    	 *
	    	 * @param {Object} val The value to test
	    	 * @returns {boolean} True if the value is undefined, otherwise false
	    	 */
	    	function isUndefined(val) {
	    	  return typeof val === 'undefined';
	    	}

	    	/**
	    	 * Determine if a value is a Buffer
	    	 *
	    	 * @param {Object} val The value to test
	    	 * @returns {boolean} True if value is a Buffer, otherwise false
	    	 */
	    	function isBuffer(val) {
	    	  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
	    	    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
	    	}

	    	/**
	    	 * Determine if a value is an ArrayBuffer
	    	 *
	    	 * @function
	    	 * @param {Object} val The value to test
	    	 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
	    	 */
	    	var isArrayBuffer = kindOfTest('ArrayBuffer');


	    	/**
	    	 * Determine if a value is a view on an ArrayBuffer
	    	 *
	    	 * @param {Object} val The value to test
	    	 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
	    	 */
	    	function isArrayBufferView(val) {
	    	  var result;
	    	  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
	    	    result = ArrayBuffer.isView(val);
	    	  } else {
	    	    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));
	    	  }
	    	  return result;
	    	}

	    	/**
	    	 * Determine if a value is a String
	    	 *
	    	 * @param {Object} val The value to test
	    	 * @returns {boolean} True if value is a String, otherwise false
	    	 */
	    	function isString(val) {
	    	  return typeof val === 'string';
	    	}

	    	/**
	    	 * Determine if a value is a Number
	    	 *
	    	 * @param {Object} val The value to test
	    	 * @returns {boolean} True if value is a Number, otherwise false
	    	 */
	    	function isNumber(val) {
	    	  return typeof val === 'number';
	    	}

	    	/**
	    	 * Determine if a value is an Object
	    	 *
	    	 * @param {Object} val The value to test
	    	 * @returns {boolean} True if value is an Object, otherwise false
	    	 */
	    	function isObject(val) {
	    	  return val !== null && typeof val === 'object';
	    	}

	    	/**
	    	 * Determine if a value is a plain Object
	    	 *
	    	 * @param {Object} val The value to test
	    	 * @return {boolean} True if value is a plain Object, otherwise false
	    	 */
	    	function isPlainObject(val) {
	    	  if (kindOf(val) !== 'object') {
	    	    return false;
	    	  }

	    	  var prototype = Object.getPrototypeOf(val);
	    	  return prototype === null || prototype === Object.prototype;
	    	}

	    	/**
	    	 * Determine if a value is a Date
	    	 *
	    	 * @function
	    	 * @param {Object} val The value to test
	    	 * @returns {boolean} True if value is a Date, otherwise false
	    	 */
	    	var isDate = kindOfTest('Date');

	    	/**
	    	 * Determine if a value is a File
	    	 *
	    	 * @function
	    	 * @param {Object} val The value to test
	    	 * @returns {boolean} True if value is a File, otherwise false
	    	 */
	    	var isFile = kindOfTest('File');

	    	/**
	    	 * Determine if a value is a Blob
	    	 *
	    	 * @function
	    	 * @param {Object} val The value to test
	    	 * @returns {boolean} True if value is a Blob, otherwise false
	    	 */
	    	var isBlob = kindOfTest('Blob');

	    	/**
	    	 * Determine if a value is a FileList
	    	 *
	    	 * @function
	    	 * @param {Object} val The value to test
	    	 * @returns {boolean} True if value is a File, otherwise false
	    	 */
	    	var isFileList = kindOfTest('FileList');

	    	/**
	    	 * Determine if a value is a Function
	    	 *
	    	 * @param {Object} val The value to test
	    	 * @returns {boolean} True if value is a Function, otherwise false
	    	 */
	    	function isFunction(val) {
	    	  return toString.call(val) === '[object Function]';
	    	}

	    	/**
	    	 * Determine if a value is a Stream
	    	 *
	    	 * @param {Object} val The value to test
	    	 * @returns {boolean} True if value is a Stream, otherwise false
	    	 */
	    	function isStream(val) {
	    	  return isObject(val) && isFunction(val.pipe);
	    	}

	    	/**
	    	 * Determine if a value is a FormData
	    	 *
	    	 * @param {Object} thing The value to test
	    	 * @returns {boolean} True if value is an FormData, otherwise false
	    	 */
	    	function isFormData(thing) {
	    	  var pattern = '[object FormData]';
	    	  return thing && (
	    	    (typeof FormData === 'function' && thing instanceof FormData) ||
	    	    toString.call(thing) === pattern ||
	    	    (isFunction(thing.toString) && thing.toString() === pattern)
	    	  );
	    	}

	    	/**
	    	 * Determine if a value is a URLSearchParams object
	    	 * @function
	    	 * @param {Object} val The value to test
	    	 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
	    	 */
	    	var isURLSearchParams = kindOfTest('URLSearchParams');

	    	/**
	    	 * Trim excess whitespace off the beginning and end of a string
	    	 *
	    	 * @param {String} str The String to trim
	    	 * @returns {String} The String freed of excess whitespace
	    	 */
	    	function trim(str) {
	    	  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
	    	}

	    	/**
	    	 * Determine if we're running in a standard browser environment
	    	 *
	    	 * This allows axios to run in a web worker, and react-native.
	    	 * Both environments support XMLHttpRequest, but not fully standard globals.
	    	 *
	    	 * web workers:
	    	 *  typeof window -> undefined
	    	 *  typeof document -> undefined
	    	 *
	    	 * react-native:
	    	 *  navigator.product -> 'ReactNative'
	    	 * nativescript
	    	 *  navigator.product -> 'NativeScript' or 'NS'
	    	 */
	    	function isStandardBrowserEnv() {
	    	  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
	    	                                           navigator.product === 'NativeScript' ||
	    	                                           navigator.product === 'NS')) {
	    	    return false;
	    	  }
	    	  return (
	    	    typeof window !== 'undefined' &&
	    	    typeof document !== 'undefined'
	    	  );
	    	}

	    	/**
	    	 * Iterate over an Array or an Object invoking a function for each item.
	    	 *
	    	 * If `obj` is an Array callback will be called passing
	    	 * the value, index, and complete array for each item.
	    	 *
	    	 * If 'obj' is an Object callback will be called passing
	    	 * the value, key, and complete object for each property.
	    	 *
	    	 * @param {Object|Array} obj The object to iterate
	    	 * @param {Function} fn The callback to invoke for each item
	    	 */
	    	function forEach(obj, fn) {
	    	  // Don't bother if no value provided
	    	  if (obj === null || typeof obj === 'undefined') {
	    	    return;
	    	  }

	    	  // Force an array if not already something iterable
	    	  if (typeof obj !== 'object') {
	    	    /*eslint no-param-reassign:0*/
	    	    obj = [obj];
	    	  }

	    	  if (isArray(obj)) {
	    	    // Iterate over array values
	    	    for (var i = 0, l = obj.length; i < l; i++) {
	    	      fn.call(null, obj[i], i, obj);
	    	    }
	    	  } else {
	    	    // Iterate over object keys
	    	    for (var key in obj) {
	    	      if (Object.prototype.hasOwnProperty.call(obj, key)) {
	    	        fn.call(null, obj[key], key, obj);
	    	      }
	    	    }
	    	  }
	    	}

	    	/**
	    	 * Accepts varargs expecting each argument to be an object, then
	    	 * immutably merges the properties of each object and returns result.
	    	 *
	    	 * When multiple objects contain the same key the later object in
	    	 * the arguments list will take precedence.
	    	 *
	    	 * Example:
	    	 *
	    	 * ```js
	    	 * var result = merge({foo: 123}, {foo: 456});
	    	 * console.log(result.foo); // outputs 456
	    	 * ```
	    	 *
	    	 * @param {Object} obj1 Object to merge
	    	 * @returns {Object} Result of all merge properties
	    	 */
	    	function merge(/* obj1, obj2, obj3, ... */) {
	    	  var result = {};
	    	  function assignValue(val, key) {
	    	    if (isPlainObject(result[key]) && isPlainObject(val)) {
	    	      result[key] = merge(result[key], val);
	    	    } else if (isPlainObject(val)) {
	    	      result[key] = merge({}, val);
	    	    } else if (isArray(val)) {
	    	      result[key] = val.slice();
	    	    } else {
	    	      result[key] = val;
	    	    }
	    	  }

	    	  for (var i = 0, l = arguments.length; i < l; i++) {
	    	    forEach(arguments[i], assignValue);
	    	  }
	    	  return result;
	    	}

	    	/**
	    	 * Extends object a by mutably adding to it the properties of object b.
	    	 *
	    	 * @param {Object} a The object to be extended
	    	 * @param {Object} b The object to copy properties from
	    	 * @param {Object} thisArg The object to bind function to
	    	 * @return {Object} The resulting value of object a
	    	 */
	    	function extend(a, b, thisArg) {
	    	  forEach(b, function assignValue(val, key) {
	    	    if (thisArg && typeof val === 'function') {
	    	      a[key] = bind(val, thisArg);
	    	    } else {
	    	      a[key] = val;
	    	    }
	    	  });
	    	  return a;
	    	}

	    	/**
	    	 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
	    	 *
	    	 * @param {string} content with BOM
	    	 * @return {string} content value without BOM
	    	 */
	    	function stripBOM(content) {
	    	  if (content.charCodeAt(0) === 0xFEFF) {
	    	    content = content.slice(1);
	    	  }
	    	  return content;
	    	}

	    	/**
	    	 * Inherit the prototype methods from one constructor into another
	    	 * @param {function} constructor
	    	 * @param {function} superConstructor
	    	 * @param {object} [props]
	    	 * @param {object} [descriptors]
	    	 */

	    	function inherits(constructor, superConstructor, props, descriptors) {
	    	  constructor.prototype = Object.create(superConstructor.prototype, descriptors);
	    	  constructor.prototype.constructor = constructor;
	    	  props && Object.assign(constructor.prototype, props);
	    	}

	    	/**
	    	 * Resolve object with deep prototype chain to a flat object
	    	 * @param {Object} sourceObj source object
	    	 * @param {Object} [destObj]
	    	 * @param {Function} [filter]
	    	 * @returns {Object}
	    	 */

	    	function toFlatObject(sourceObj, destObj, filter) {
	    	  var props;
	    	  var i;
	    	  var prop;
	    	  var merged = {};

	    	  destObj = destObj || {};

	    	  do {
	    	    props = Object.getOwnPropertyNames(sourceObj);
	    	    i = props.length;
	    	    while (i-- > 0) {
	    	      prop = props[i];
	    	      if (!merged[prop]) {
	    	        destObj[prop] = sourceObj[prop];
	    	        merged[prop] = true;
	    	      }
	    	    }
	    	    sourceObj = Object.getPrototypeOf(sourceObj);
	    	  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);

	    	  return destObj;
	    	}

	    	/*
	    	 * determines whether a string ends with the characters of a specified string
	    	 * @param {String} str
	    	 * @param {String} searchString
	    	 * @param {Number} [position= 0]
	    	 * @returns {boolean}
	    	 */
	    	function endsWith(str, searchString, position) {
	    	  str = String(str);
	    	  if (position === undefined || position > str.length) {
	    	    position = str.length;
	    	  }
	    	  position -= searchString.length;
	    	  var lastIndex = str.indexOf(searchString, position);
	    	  return lastIndex !== -1 && lastIndex === position;
	    	}


	    	/**
	    	 * Returns new array from array like object
	    	 * @param {*} [thing]
	    	 * @returns {Array}
	    	 */
	    	function toArray(thing) {
	    	  if (!thing) return null;
	    	  var i = thing.length;
	    	  if (isUndefined(i)) return null;
	    	  var arr = new Array(i);
	    	  while (i-- > 0) {
	    	    arr[i] = thing[i];
	    	  }
	    	  return arr;
	    	}

	    	// eslint-disable-next-line func-names
	    	var isTypedArray = (function(TypedArray) {
	    	  // eslint-disable-next-line func-names
	    	  return function(thing) {
	    	    return TypedArray && thing instanceof TypedArray;
	    	  };
	    	})(typeof Uint8Array !== 'undefined' && Object.getPrototypeOf(Uint8Array));

	    	utils = {
	    	  isArray: isArray,
	    	  isArrayBuffer: isArrayBuffer,
	    	  isBuffer: isBuffer,
	    	  isFormData: isFormData,
	    	  isArrayBufferView: isArrayBufferView,
	    	  isString: isString,
	    	  isNumber: isNumber,
	    	  isObject: isObject,
	    	  isPlainObject: isPlainObject,
	    	  isUndefined: isUndefined,
	    	  isDate: isDate,
	    	  isFile: isFile,
	    	  isBlob: isBlob,
	    	  isFunction: isFunction,
	    	  isStream: isStream,
	    	  isURLSearchParams: isURLSearchParams,
	    	  isStandardBrowserEnv: isStandardBrowserEnv,
	    	  forEach: forEach,
	    	  merge: merge,
	    	  extend: extend,
	    	  trim: trim,
	    	  stripBOM: stripBOM,
	    	  inherits: inherits,
	    	  toFlatObject: toFlatObject,
	    	  kindOf: kindOf,
	    	  kindOfTest: kindOfTest,
	    	  endsWith: endsWith,
	    	  toArray: toArray,
	    	  isTypedArray: isTypedArray,
	    	  isFileList: isFileList
	    	};
	    	return utils;
	    }

	    var buildURL;
	    var hasRequiredBuildURL;

	    function requireBuildURL () {
	    	if (hasRequiredBuildURL) return buildURL;
	    	hasRequiredBuildURL = 1;

	    	var utils = requireUtils();

	    	function encode(val) {
	    	  return encodeURIComponent(val).
	    	    replace(/%3A/gi, ':').
	    	    replace(/%24/g, '$').
	    	    replace(/%2C/gi, ',').
	    	    replace(/%20/g, '+').
	    	    replace(/%5B/gi, '[').
	    	    replace(/%5D/gi, ']');
	    	}

	    	/**
	    	 * Build a URL by appending params to the end
	    	 *
	    	 * @param {string} url The base of the url (e.g., http://www.google.com)
	    	 * @param {object} [params] The params to be appended
	    	 * @returns {string} The formatted url
	    	 */
	    	buildURL = function buildURL(url, params, paramsSerializer) {
	    	  /*eslint no-param-reassign:0*/
	    	  if (!params) {
	    	    return url;
	    	  }

	    	  var serializedParams;
	    	  if (paramsSerializer) {
	    	    serializedParams = paramsSerializer(params);
	    	  } else if (utils.isURLSearchParams(params)) {
	    	    serializedParams = params.toString();
	    	  } else {
	    	    var parts = [];

	    	    utils.forEach(params, function serialize(val, key) {
	    	      if (val === null || typeof val === 'undefined') {
	    	        return;
	    	      }

	    	      if (utils.isArray(val)) {
	    	        key = key + '[]';
	    	      } else {
	    	        val = [val];
	    	      }

	    	      utils.forEach(val, function parseValue(v) {
	    	        if (utils.isDate(v)) {
	    	          v = v.toISOString();
	    	        } else if (utils.isObject(v)) {
	    	          v = JSON.stringify(v);
	    	        }
	    	        parts.push(encode(key) + '=' + encode(v));
	    	      });
	    	    });

	    	    serializedParams = parts.join('&');
	    	  }

	    	  if (serializedParams) {
	    	    var hashmarkIndex = url.indexOf('#');
	    	    if (hashmarkIndex !== -1) {
	    	      url = url.slice(0, hashmarkIndex);
	    	    }

	    	    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
	    	  }

	    	  return url;
	    	};
	    	return buildURL;
	    }

	    var InterceptorManager_1;
	    var hasRequiredInterceptorManager;

	    function requireInterceptorManager () {
	    	if (hasRequiredInterceptorManager) return InterceptorManager_1;
	    	hasRequiredInterceptorManager = 1;

	    	var utils = requireUtils();

	    	function InterceptorManager() {
	    	  this.handlers = [];
	    	}

	    	/**
	    	 * Add a new interceptor to the stack
	    	 *
	    	 * @param {Function} fulfilled The function to handle `then` for a `Promise`
	    	 * @param {Function} rejected The function to handle `reject` for a `Promise`
	    	 *
	    	 * @return {Number} An ID used to remove interceptor later
	    	 */
	    	InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
	    	  this.handlers.push({
	    	    fulfilled: fulfilled,
	    	    rejected: rejected,
	    	    synchronous: options ? options.synchronous : false,
	    	    runWhen: options ? options.runWhen : null
	    	  });
	    	  return this.handlers.length - 1;
	    	};

	    	/**
	    	 * Remove an interceptor from the stack
	    	 *
	    	 * @param {Number} id The ID that was returned by `use`
	    	 */
	    	InterceptorManager.prototype.eject = function eject(id) {
	    	  if (this.handlers[id]) {
	    	    this.handlers[id] = null;
	    	  }
	    	};

	    	/**
	    	 * Iterate over all the registered interceptors
	    	 *
	    	 * This method is particularly useful for skipping over any
	    	 * interceptors that may have become `null` calling `eject`.
	    	 *
	    	 * @param {Function} fn The function to call for each interceptor
	    	 */
	    	InterceptorManager.prototype.forEach = function forEach(fn) {
	    	  utils.forEach(this.handlers, function forEachHandler(h) {
	    	    if (h !== null) {
	    	      fn(h);
	    	    }
	    	  });
	    	};

	    	InterceptorManager_1 = InterceptorManager;
	    	return InterceptorManager_1;
	    }

	    var global$1 = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal :
	                typeof self !== "undefined" ? self :
	                typeof window !== "undefined" ? window : {});

	    // shim for using process in browser
	    // based off https://github.com/defunctzombie/node-process/blob/master/browser.js

	    function defaultSetTimout() {
	        throw new Error('setTimeout has not been defined');
	    }
	    function defaultClearTimeout () {
	        throw new Error('clearTimeout has not been defined');
	    }
	    var cachedSetTimeout = defaultSetTimout;
	    var cachedClearTimeout = defaultClearTimeout;
	    if (typeof global$1.setTimeout === 'function') {
	        cachedSetTimeout = setTimeout;
	    }
	    if (typeof global$1.clearTimeout === 'function') {
	        cachedClearTimeout = clearTimeout;
	    }

	    function runTimeout(fun) {
	        if (cachedSetTimeout === setTimeout) {
	            //normal enviroments in sane situations
	            return setTimeout(fun, 0);
	        }
	        // if setTimeout wasn't available but was latter defined
	        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	            cachedSetTimeout = setTimeout;
	            return setTimeout(fun, 0);
	        }
	        try {
	            // when when somebody has screwed with setTimeout but no I.E. maddness
	            return cachedSetTimeout(fun, 0);
	        } catch(e){
	            try {
	                // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	                return cachedSetTimeout.call(null, fun, 0);
	            } catch(e){
	                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	                return cachedSetTimeout.call(this, fun, 0);
	            }
	        }


	    }
	    function runClearTimeout(marker) {
	        if (cachedClearTimeout === clearTimeout) {
	            //normal enviroments in sane situations
	            return clearTimeout(marker);
	        }
	        // if clearTimeout wasn't available but was latter defined
	        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	            cachedClearTimeout = clearTimeout;
	            return clearTimeout(marker);
	        }
	        try {
	            // when when somebody has screwed with setTimeout but no I.E. maddness
	            return cachedClearTimeout(marker);
	        } catch (e){
	            try {
	                // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	                return cachedClearTimeout.call(null, marker);
	            } catch (e){
	                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	                // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	                return cachedClearTimeout.call(this, marker);
	            }
	        }



	    }
	    var queue = [];
	    var draining = false;
	    var currentQueue;
	    var queueIndex = -1;

	    function cleanUpNextTick() {
	        if (!draining || !currentQueue) {
	            return;
	        }
	        draining = false;
	        if (currentQueue.length) {
	            queue = currentQueue.concat(queue);
	        } else {
	            queueIndex = -1;
	        }
	        if (queue.length) {
	            drainQueue();
	        }
	    }

	    function drainQueue() {
	        if (draining) {
	            return;
	        }
	        var timeout = runTimeout(cleanUpNextTick);
	        draining = true;

	        var len = queue.length;
	        while(len) {
	            currentQueue = queue;
	            queue = [];
	            while (++queueIndex < len) {
	                if (currentQueue) {
	                    currentQueue[queueIndex].run();
	                }
	            }
	            queueIndex = -1;
	            len = queue.length;
	        }
	        currentQueue = null;
	        draining = false;
	        runClearTimeout(timeout);
	    }
	    function nextTick(fun) {
	        var args = new Array(arguments.length - 1);
	        if (arguments.length > 1) {
	            for (var i = 1; i < arguments.length; i++) {
	                args[i - 1] = arguments[i];
	            }
	        }
	        queue.push(new Item(fun, args));
	        if (queue.length === 1 && !draining) {
	            runTimeout(drainQueue);
	        }
	    }
	    // v8 likes predictible objects
	    function Item(fun, array) {
	        this.fun = fun;
	        this.array = array;
	    }
	    Item.prototype.run = function () {
	        this.fun.apply(null, this.array);
	    };
	    var title = 'browser';
	    var platform = 'browser';
	    var browser$2 = true;
	    var env = {};
	    var argv = [];
	    var version = ''; // empty string to avoid regexp issues
	    var versions = {};
	    var release = {};
	    var config = {};

	    function noop() {}

	    var on = noop;
	    var addListener = noop;
	    var once = noop;
	    var off = noop;
	    var removeListener = noop;
	    var removeAllListeners = noop;
	    var emit = noop;

	    function binding(name) {
	        throw new Error('process.binding is not supported');
	    }

	    function cwd () { return '/' }
	    function chdir (dir) {
	        throw new Error('process.chdir is not supported');
	    }function umask() { return 0; }

	    // from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
	    var performance = global$1.performance || {};
	    var performanceNow =
	      performance.now        ||
	      performance.mozNow     ||
	      performance.msNow      ||
	      performance.oNow       ||
	      performance.webkitNow  ||
	      function(){ return (new Date()).getTime() };

	    // generate timestamp or delta
	    // see http://nodejs.org/api/process.html#process_process_hrtime
	    function hrtime(previousTimestamp){
	      var clocktime = performanceNow.call(performance)*1e-3;
	      var seconds = Math.floor(clocktime);
	      var nanoseconds = Math.floor((clocktime%1)*1e9);
	      if (previousTimestamp) {
	        seconds = seconds - previousTimestamp[0];
	        nanoseconds = nanoseconds - previousTimestamp[1];
	        if (nanoseconds<0) {
	          seconds--;
	          nanoseconds += 1e9;
	        }
	      }
	      return [seconds,nanoseconds]
	    }

	    var startTime = new Date();
	    function uptime() {
	      var currentTime = new Date();
	      var dif = currentTime - startTime;
	      return dif / 1000;
	    }

	    var process = {
	      nextTick: nextTick,
	      title: title,
	      browser: browser$2,
	      env: env,
	      argv: argv,
	      version: version,
	      versions: versions,
	      on: on,
	      addListener: addListener,
	      once: once,
	      off: off,
	      removeListener: removeListener,
	      removeAllListeners: removeAllListeners,
	      emit: emit,
	      binding: binding,
	      cwd: cwd,
	      chdir: chdir,
	      umask: umask,
	      hrtime: hrtime,
	      platform: platform,
	      release: release,
	      config: config,
	      uptime: uptime
	    };

	    var normalizeHeaderName;
	    var hasRequiredNormalizeHeaderName;

	    function requireNormalizeHeaderName () {
	    	if (hasRequiredNormalizeHeaderName) return normalizeHeaderName;
	    	hasRequiredNormalizeHeaderName = 1;

	    	var utils = requireUtils();

	    	normalizeHeaderName = function normalizeHeaderName(headers, normalizedName) {
	    	  utils.forEach(headers, function processHeader(value, name) {
	    	    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
	    	      headers[normalizedName] = value;
	    	      delete headers[name];
	    	    }
	    	  });
	    	};
	    	return normalizeHeaderName;
	    }

	    var AxiosError_1;
	    var hasRequiredAxiosError;

	    function requireAxiosError () {
	    	if (hasRequiredAxiosError) return AxiosError_1;
	    	hasRequiredAxiosError = 1;

	    	var utils = requireUtils();

	    	/**
	    	 * Create an Error with the specified message, config, error code, request and response.
	    	 *
	    	 * @param {string} message The error message.
	    	 * @param {string} [code] The error code (for example, 'ECONNABORTED').
	    	 * @param {Object} [config] The config.
	    	 * @param {Object} [request] The request.
	    	 * @param {Object} [response] The response.
	    	 * @returns {Error} The created error.
	    	 */
	    	function AxiosError(message, code, config, request, response) {
	    	  Error.call(this);
	    	  this.message = message;
	    	  this.name = 'AxiosError';
	    	  code && (this.code = code);
	    	  config && (this.config = config);
	    	  request && (this.request = request);
	    	  response && (this.response = response);
	    	}

	    	utils.inherits(AxiosError, Error, {
	    	  toJSON: function toJSON() {
	    	    return {
	    	      // Standard
	    	      message: this.message,
	    	      name: this.name,
	    	      // Microsoft
	    	      description: this.description,
	    	      number: this.number,
	    	      // Mozilla
	    	      fileName: this.fileName,
	    	      lineNumber: this.lineNumber,
	    	      columnNumber: this.columnNumber,
	    	      stack: this.stack,
	    	      // Axios
	    	      config: this.config,
	    	      code: this.code,
	    	      status: this.response && this.response.status ? this.response.status : null
	    	    };
	    	  }
	    	});

	    	var prototype = AxiosError.prototype;
	    	var descriptors = {};

	    	[
	    	  'ERR_BAD_OPTION_VALUE',
	    	  'ERR_BAD_OPTION',
	    	  'ECONNABORTED',
	    	  'ETIMEDOUT',
	    	  'ERR_NETWORK',
	    	  'ERR_FR_TOO_MANY_REDIRECTS',
	    	  'ERR_DEPRECATED',
	    	  'ERR_BAD_RESPONSE',
	    	  'ERR_BAD_REQUEST',
	    	  'ERR_CANCELED'
	    	// eslint-disable-next-line func-names
	    	].forEach(function(code) {
	    	  descriptors[code] = {value: code};
	    	});

	    	Object.defineProperties(AxiosError, descriptors);
	    	Object.defineProperty(prototype, 'isAxiosError', {value: true});

	    	// eslint-disable-next-line func-names
	    	AxiosError.from = function(error, code, config, request, response, customProps) {
	    	  var axiosError = Object.create(prototype);

	    	  utils.toFlatObject(error, axiosError, function filter(obj) {
	    	    return obj !== Error.prototype;
	    	  });

	    	  AxiosError.call(axiosError, error.message, code, config, request, response);

	    	  axiosError.name = error.name;

	    	  customProps && Object.assign(axiosError, customProps);

	    	  return axiosError;
	    	};

	    	AxiosError_1 = AxiosError;
	    	return AxiosError_1;
	    }

	    var transitional;
	    var hasRequiredTransitional;

	    function requireTransitional () {
	    	if (hasRequiredTransitional) return transitional;
	    	hasRequiredTransitional = 1;

	    	transitional = {
	    	  silentJSONParsing: true,
	    	  forcedJSONParsing: true,
	    	  clarifyTimeoutError: false
	    	};
	    	return transitional;
	    }

	    var lookup = [];
	    var revLookup = [];
	    var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
	    var inited = false;
	    function init () {
	      inited = true;
	      var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	      for (var i = 0, len = code.length; i < len; ++i) {
	        lookup[i] = code[i];
	        revLookup[code.charCodeAt(i)] = i;
	      }

	      revLookup['-'.charCodeAt(0)] = 62;
	      revLookup['_'.charCodeAt(0)] = 63;
	    }

	    function toByteArray (b64) {
	      if (!inited) {
	        init();
	      }
	      var i, j, l, tmp, placeHolders, arr;
	      var len = b64.length;

	      if (len % 4 > 0) {
	        throw new Error('Invalid string. Length must be a multiple of 4')
	      }

	      // the number of equal signs (place holders)
	      // if there are two placeholders, than the two characters before it
	      // represent one byte
	      // if there is only one, then the three characters before it represent 2 bytes
	      // this is just a cheap hack to not do indexOf twice
	      placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

	      // base64 is 4/3 + up to two characters of the original data
	      arr = new Arr(len * 3 / 4 - placeHolders);

	      // if there are placeholders, only get up to the last complete 4 chars
	      l = placeHolders > 0 ? len - 4 : len;

	      var L = 0;

	      for (i = 0, j = 0; i < l; i += 4, j += 3) {
	        tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];
	        arr[L++] = (tmp >> 16) & 0xFF;
	        arr[L++] = (tmp >> 8) & 0xFF;
	        arr[L++] = tmp & 0xFF;
	      }

	      if (placeHolders === 2) {
	        tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
	        arr[L++] = tmp & 0xFF;
	      } else if (placeHolders === 1) {
	        tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);
	        arr[L++] = (tmp >> 8) & 0xFF;
	        arr[L++] = tmp & 0xFF;
	      }

	      return arr
	    }

	    function tripletToBase64 (num) {
	      return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
	    }

	    function encodeChunk (uint8, start, end) {
	      var tmp;
	      var output = [];
	      for (var i = start; i < end; i += 3) {
	        tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
	        output.push(tripletToBase64(tmp));
	      }
	      return output.join('')
	    }

	    function fromByteArray (uint8) {
	      if (!inited) {
	        init();
	      }
	      var tmp;
	      var len = uint8.length;
	      var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
	      var output = '';
	      var parts = [];
	      var maxChunkLength = 16383; // must be multiple of 3

	      // go through the array every three bytes, we'll deal with trailing stuff later
	      for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
	        parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
	      }

	      // pad the end with zeros, but make sure to not forget the extra bytes
	      if (extraBytes === 1) {
	        tmp = uint8[len - 1];
	        output += lookup[tmp >> 2];
	        output += lookup[(tmp << 4) & 0x3F];
	        output += '==';
	      } else if (extraBytes === 2) {
	        tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
	        output += lookup[tmp >> 10];
	        output += lookup[(tmp >> 4) & 0x3F];
	        output += lookup[(tmp << 2) & 0x3F];
	        output += '=';
	      }

	      parts.push(output);

	      return parts.join('')
	    }

	    function read (buffer, offset, isLE, mLen, nBytes) {
	      var e, m;
	      var eLen = nBytes * 8 - mLen - 1;
	      var eMax = (1 << eLen) - 1;
	      var eBias = eMax >> 1;
	      var nBits = -7;
	      var i = isLE ? (nBytes - 1) : 0;
	      var d = isLE ? -1 : 1;
	      var s = buffer[offset + i];

	      i += d;

	      e = s & ((1 << (-nBits)) - 1);
	      s >>= (-nBits);
	      nBits += eLen;
	      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	      m = e & ((1 << (-nBits)) - 1);
	      e >>= (-nBits);
	      nBits += mLen;
	      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	      if (e === 0) {
	        e = 1 - eBias;
	      } else if (e === eMax) {
	        return m ? NaN : ((s ? -1 : 1) * Infinity)
	      } else {
	        m = m + Math.pow(2, mLen);
	        e = e - eBias;
	      }
	      return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	    }

	    function write (buffer, value, offset, isLE, mLen, nBytes) {
	      var e, m, c;
	      var eLen = nBytes * 8 - mLen - 1;
	      var eMax = (1 << eLen) - 1;
	      var eBias = eMax >> 1;
	      var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
	      var i = isLE ? 0 : (nBytes - 1);
	      var d = isLE ? 1 : -1;
	      var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

	      value = Math.abs(value);

	      if (isNaN(value) || value === Infinity) {
	        m = isNaN(value) ? 1 : 0;
	        e = eMax;
	      } else {
	        e = Math.floor(Math.log(value) / Math.LN2);
	        if (value * (c = Math.pow(2, -e)) < 1) {
	          e--;
	          c *= 2;
	        }
	        if (e + eBias >= 1) {
	          value += rt / c;
	        } else {
	          value += rt * Math.pow(2, 1 - eBias);
	        }
	        if (value * c >= 2) {
	          e++;
	          c /= 2;
	        }

	        if (e + eBias >= eMax) {
	          m = 0;
	          e = eMax;
	        } else if (e + eBias >= 1) {
	          m = (value * c - 1) * Math.pow(2, mLen);
	          e = e + eBias;
	        } else {
	          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
	          e = 0;
	        }
	      }

	      for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

	      e = (e << mLen) | m;
	      eLen += mLen;
	      for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

	      buffer[offset + i - d] |= s * 128;
	    }

	    var toString = {}.toString;

	    var isArray = Array.isArray || function (arr) {
	      return toString.call(arr) == '[object Array]';
	    };

	    var INSPECT_MAX_BYTES = 50;

	    /**
	     * If `Buffer.TYPED_ARRAY_SUPPORT`:
	     *   === true    Use Uint8Array implementation (fastest)
	     *   === false   Use Object implementation (most compatible, even IE6)
	     *
	     * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	     * Opera 11.6+, iOS 4.2+.
	     *
	     * Due to various browser bugs, sometimes the Object implementation will be used even
	     * when the browser supports typed arrays.
	     *
	     * Note:
	     *
	     *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	     *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	     *
	     *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	     *
	     *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	     *     incorrect length in some situations.

	     * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	     * get the Object implementation, which is slower but behaves correctly.
	     */
	    Buffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined
	      ? global$1.TYPED_ARRAY_SUPPORT
	      : true;

	    /*
	     * Export kMaxLength after typed array support is determined.
	     */
	    kMaxLength();

	    function kMaxLength () {
	      return Buffer.TYPED_ARRAY_SUPPORT
	        ? 0x7fffffff
	        : 0x3fffffff
	    }

	    function createBuffer (that, length) {
	      if (kMaxLength() < length) {
	        throw new RangeError('Invalid typed array length')
	      }
	      if (Buffer.TYPED_ARRAY_SUPPORT) {
	        // Return an augmented `Uint8Array` instance, for best performance
	        that = new Uint8Array(length);
	        that.__proto__ = Buffer.prototype;
	      } else {
	        // Fallback: Return an object instance of the Buffer class
	        if (that === null) {
	          that = new Buffer(length);
	        }
	        that.length = length;
	      }

	      return that
	    }

	    /**
	     * The Buffer constructor returns instances of `Uint8Array` that have their
	     * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
	     * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
	     * and the `Uint8Array` methods. Square bracket notation works as expected -- it
	     * returns a single octet.
	     *
	     * The `Uint8Array` prototype remains unmodified.
	     */

	    function Buffer (arg, encodingOrOffset, length) {
	      if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
	        return new Buffer(arg, encodingOrOffset, length)
	      }

	      // Common case.
	      if (typeof arg === 'number') {
	        if (typeof encodingOrOffset === 'string') {
	          throw new Error(
	            'If encoding is specified then the first argument must be a string'
	          )
	        }
	        return allocUnsafe(this, arg)
	      }
	      return from(this, arg, encodingOrOffset, length)
	    }

	    Buffer.poolSize = 8192; // not used by this implementation

	    // TODO: Legacy, not needed anymore. Remove in next major version.
	    Buffer._augment = function (arr) {
	      arr.__proto__ = Buffer.prototype;
	      return arr
	    };

	    function from (that, value, encodingOrOffset, length) {
	      if (typeof value === 'number') {
	        throw new TypeError('"value" argument must not be a number')
	      }

	      if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
	        return fromArrayBuffer(that, value, encodingOrOffset, length)
	      }

	      if (typeof value === 'string') {
	        return fromString(that, value, encodingOrOffset)
	      }

	      return fromObject(that, value)
	    }

	    /**
	     * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
	     * if value is a number.
	     * Buffer.from(str[, encoding])
	     * Buffer.from(array)
	     * Buffer.from(buffer)
	     * Buffer.from(arrayBuffer[, byteOffset[, length]])
	     **/
	    Buffer.from = function (value, encodingOrOffset, length) {
	      return from(null, value, encodingOrOffset, length)
	    };

	    if (Buffer.TYPED_ARRAY_SUPPORT) {
	      Buffer.prototype.__proto__ = Uint8Array.prototype;
	      Buffer.__proto__ = Uint8Array;
	      if (typeof Symbol !== 'undefined' && Symbol.species &&
	          Buffer[Symbol.species] === Buffer) ;
	    }

	    function assertSize (size) {
	      if (typeof size !== 'number') {
	        throw new TypeError('"size" argument must be a number')
	      } else if (size < 0) {
	        throw new RangeError('"size" argument must not be negative')
	      }
	    }

	    function alloc (that, size, fill, encoding) {
	      assertSize(size);
	      if (size <= 0) {
	        return createBuffer(that, size)
	      }
	      if (fill !== undefined) {
	        // Only pay attention to encoding if it's a string. This
	        // prevents accidentally sending in a number that would
	        // be interpretted as a start offset.
	        return typeof encoding === 'string'
	          ? createBuffer(that, size).fill(fill, encoding)
	          : createBuffer(that, size).fill(fill)
	      }
	      return createBuffer(that, size)
	    }

	    /**
	     * Creates a new filled Buffer instance.
	     * alloc(size[, fill[, encoding]])
	     **/
	    Buffer.alloc = function (size, fill, encoding) {
	      return alloc(null, size, fill, encoding)
	    };

	    function allocUnsafe (that, size) {
	      assertSize(size);
	      that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
	      if (!Buffer.TYPED_ARRAY_SUPPORT) {
	        for (var i = 0; i < size; ++i) {
	          that[i] = 0;
	        }
	      }
	      return that
	    }

	    /**
	     * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
	     * */
	    Buffer.allocUnsafe = function (size) {
	      return allocUnsafe(null, size)
	    };
	    /**
	     * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
	     */
	    Buffer.allocUnsafeSlow = function (size) {
	      return allocUnsafe(null, size)
	    };

	    function fromString (that, string, encoding) {
	      if (typeof encoding !== 'string' || encoding === '') {
	        encoding = 'utf8';
	      }

	      if (!Buffer.isEncoding(encoding)) {
	        throw new TypeError('"encoding" must be a valid string encoding')
	      }

	      var length = byteLength(string, encoding) | 0;
	      that = createBuffer(that, length);

	      var actual = that.write(string, encoding);

	      if (actual !== length) {
	        // Writing a hex string, for example, that contains invalid characters will
	        // cause everything after the first invalid character to be ignored. (e.g.
	        // 'abxxcd' will be treated as 'ab')
	        that = that.slice(0, actual);
	      }

	      return that
	    }

	    function fromArrayLike (that, array) {
	      var length = array.length < 0 ? 0 : checked(array.length) | 0;
	      that = createBuffer(that, length);
	      for (var i = 0; i < length; i += 1) {
	        that[i] = array[i] & 255;
	      }
	      return that
	    }

	    function fromArrayBuffer (that, array, byteOffset, length) {
	      array.byteLength; // this throws if `array` is not a valid ArrayBuffer

	      if (byteOffset < 0 || array.byteLength < byteOffset) {
	        throw new RangeError('\'offset\' is out of bounds')
	      }

	      if (array.byteLength < byteOffset + (length || 0)) {
	        throw new RangeError('\'length\' is out of bounds')
	      }

	      if (byteOffset === undefined && length === undefined) {
	        array = new Uint8Array(array);
	      } else if (length === undefined) {
	        array = new Uint8Array(array, byteOffset);
	      } else {
	        array = new Uint8Array(array, byteOffset, length);
	      }

	      if (Buffer.TYPED_ARRAY_SUPPORT) {
	        // Return an augmented `Uint8Array` instance, for best performance
	        that = array;
	        that.__proto__ = Buffer.prototype;
	      } else {
	        // Fallback: Return an object instance of the Buffer class
	        that = fromArrayLike(that, array);
	      }
	      return that
	    }

	    function fromObject (that, obj) {
	      if (internalIsBuffer(obj)) {
	        var len = checked(obj.length) | 0;
	        that = createBuffer(that, len);

	        if (that.length === 0) {
	          return that
	        }

	        obj.copy(that, 0, 0, len);
	        return that
	      }

	      if (obj) {
	        if ((typeof ArrayBuffer !== 'undefined' &&
	            obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
	          if (typeof obj.length !== 'number' || isnan(obj.length)) {
	            return createBuffer(that, 0)
	          }
	          return fromArrayLike(that, obj)
	        }

	        if (obj.type === 'Buffer' && isArray(obj.data)) {
	          return fromArrayLike(that, obj.data)
	        }
	      }

	      throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
	    }

	    function checked (length) {
	      // Note: cannot use `length < kMaxLength()` here because that fails when
	      // length is NaN (which is otherwise coerced to zero.)
	      if (length >= kMaxLength()) {
	        throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                             'size: 0x' + kMaxLength().toString(16) + ' bytes')
	      }
	      return length | 0
	    }
	    Buffer.isBuffer = isBuffer;
	    function internalIsBuffer (b) {
	      return !!(b != null && b._isBuffer)
	    }

	    Buffer.compare = function compare (a, b) {
	      if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
	        throw new TypeError('Arguments must be Buffers')
	      }

	      if (a === b) return 0

	      var x = a.length;
	      var y = b.length;

	      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	        if (a[i] !== b[i]) {
	          x = a[i];
	          y = b[i];
	          break
	        }
	      }

	      if (x < y) return -1
	      if (y < x) return 1
	      return 0
	    };

	    Buffer.isEncoding = function isEncoding (encoding) {
	      switch (String(encoding).toLowerCase()) {
	        case 'hex':
	        case 'utf8':
	        case 'utf-8':
	        case 'ascii':
	        case 'latin1':
	        case 'binary':
	        case 'base64':
	        case 'ucs2':
	        case 'ucs-2':
	        case 'utf16le':
	        case 'utf-16le':
	          return true
	        default:
	          return false
	      }
	    };

	    Buffer.concat = function concat (list, length) {
	      if (!isArray(list)) {
	        throw new TypeError('"list" argument must be an Array of Buffers')
	      }

	      if (list.length === 0) {
	        return Buffer.alloc(0)
	      }

	      var i;
	      if (length === undefined) {
	        length = 0;
	        for (i = 0; i < list.length; ++i) {
	          length += list[i].length;
	        }
	      }

	      var buffer = Buffer.allocUnsafe(length);
	      var pos = 0;
	      for (i = 0; i < list.length; ++i) {
	        var buf = list[i];
	        if (!internalIsBuffer(buf)) {
	          throw new TypeError('"list" argument must be an Array of Buffers')
	        }
	        buf.copy(buffer, pos);
	        pos += buf.length;
	      }
	      return buffer
	    };

	    function byteLength (string, encoding) {
	      if (internalIsBuffer(string)) {
	        return string.length
	      }
	      if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
	          (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
	        return string.byteLength
	      }
	      if (typeof string !== 'string') {
	        string = '' + string;
	      }

	      var len = string.length;
	      if (len === 0) return 0

	      // Use a for loop to avoid recursion
	      var loweredCase = false;
	      for (;;) {
	        switch (encoding) {
	          case 'ascii':
	          case 'latin1':
	          case 'binary':
	            return len
	          case 'utf8':
	          case 'utf-8':
	          case undefined:
	            return utf8ToBytes(string).length
	          case 'ucs2':
	          case 'ucs-2':
	          case 'utf16le':
	          case 'utf-16le':
	            return len * 2
	          case 'hex':
	            return len >>> 1
	          case 'base64':
	            return base64ToBytes(string).length
	          default:
	            if (loweredCase) return utf8ToBytes(string).length // assume utf8
	            encoding = ('' + encoding).toLowerCase();
	            loweredCase = true;
	        }
	      }
	    }
	    Buffer.byteLength = byteLength;

	    function slowToString (encoding, start, end) {
	      var loweredCase = false;

	      // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
	      // property of a typed array.

	      // This behaves neither like String nor Uint8Array in that we set start/end
	      // to their upper/lower bounds if the value passed is out of range.
	      // undefined is handled specially as per ECMA-262 6th Edition,
	      // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
	      if (start === undefined || start < 0) {
	        start = 0;
	      }
	      // Return early if start > this.length. Done here to prevent potential uint32
	      // coercion fail below.
	      if (start > this.length) {
	        return ''
	      }

	      if (end === undefined || end > this.length) {
	        end = this.length;
	      }

	      if (end <= 0) {
	        return ''
	      }

	      // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
	      end >>>= 0;
	      start >>>= 0;

	      if (end <= start) {
	        return ''
	      }

	      if (!encoding) encoding = 'utf8';

	      while (true) {
	        switch (encoding) {
	          case 'hex':
	            return hexSlice(this, start, end)

	          case 'utf8':
	          case 'utf-8':
	            return utf8Slice(this, start, end)

	          case 'ascii':
	            return asciiSlice(this, start, end)

	          case 'latin1':
	          case 'binary':
	            return latin1Slice(this, start, end)

	          case 'base64':
	            return base64Slice(this, start, end)

	          case 'ucs2':
	          case 'ucs-2':
	          case 'utf16le':
	          case 'utf-16le':
	            return utf16leSlice(this, start, end)

	          default:
	            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	            encoding = (encoding + '').toLowerCase();
	            loweredCase = true;
	        }
	      }
	    }

	    // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
	    // Buffer instances.
	    Buffer.prototype._isBuffer = true;

	    function swap (b, n, m) {
	      var i = b[n];
	      b[n] = b[m];
	      b[m] = i;
	    }

	    Buffer.prototype.swap16 = function swap16 () {
	      var len = this.length;
	      if (len % 2 !== 0) {
	        throw new RangeError('Buffer size must be a multiple of 16-bits')
	      }
	      for (var i = 0; i < len; i += 2) {
	        swap(this, i, i + 1);
	      }
	      return this
	    };

	    Buffer.prototype.swap32 = function swap32 () {
	      var len = this.length;
	      if (len % 4 !== 0) {
	        throw new RangeError('Buffer size must be a multiple of 32-bits')
	      }
	      for (var i = 0; i < len; i += 4) {
	        swap(this, i, i + 3);
	        swap(this, i + 1, i + 2);
	      }
	      return this
	    };

	    Buffer.prototype.swap64 = function swap64 () {
	      var len = this.length;
	      if (len % 8 !== 0) {
	        throw new RangeError('Buffer size must be a multiple of 64-bits')
	      }
	      for (var i = 0; i < len; i += 8) {
	        swap(this, i, i + 7);
	        swap(this, i + 1, i + 6);
	        swap(this, i + 2, i + 5);
	        swap(this, i + 3, i + 4);
	      }
	      return this
	    };

	    Buffer.prototype.toString = function toString () {
	      var length = this.length | 0;
	      if (length === 0) return ''
	      if (arguments.length === 0) return utf8Slice(this, 0, length)
	      return slowToString.apply(this, arguments)
	    };

	    Buffer.prototype.equals = function equals (b) {
	      if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')
	      if (this === b) return true
	      return Buffer.compare(this, b) === 0
	    };

	    Buffer.prototype.inspect = function inspect () {
	      var str = '';
	      var max = INSPECT_MAX_BYTES;
	      if (this.length > 0) {
	        str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
	        if (this.length > max) str += ' ... ';
	      }
	      return '<Buffer ' + str + '>'
	    };

	    Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
	      if (!internalIsBuffer(target)) {
	        throw new TypeError('Argument must be a Buffer')
	      }

	      if (start === undefined) {
	        start = 0;
	      }
	      if (end === undefined) {
	        end = target ? target.length : 0;
	      }
	      if (thisStart === undefined) {
	        thisStart = 0;
	      }
	      if (thisEnd === undefined) {
	        thisEnd = this.length;
	      }

	      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
	        throw new RangeError('out of range index')
	      }

	      if (thisStart >= thisEnd && start >= end) {
	        return 0
	      }
	      if (thisStart >= thisEnd) {
	        return -1
	      }
	      if (start >= end) {
	        return 1
	      }

	      start >>>= 0;
	      end >>>= 0;
	      thisStart >>>= 0;
	      thisEnd >>>= 0;

	      if (this === target) return 0

	      var x = thisEnd - thisStart;
	      var y = end - start;
	      var len = Math.min(x, y);

	      var thisCopy = this.slice(thisStart, thisEnd);
	      var targetCopy = target.slice(start, end);

	      for (var i = 0; i < len; ++i) {
	        if (thisCopy[i] !== targetCopy[i]) {
	          x = thisCopy[i];
	          y = targetCopy[i];
	          break
	        }
	      }

	      if (x < y) return -1
	      if (y < x) return 1
	      return 0
	    };

	    // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
	    // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
	    //
	    // Arguments:
	    // - buffer - a Buffer to search
	    // - val - a string, Buffer, or number
	    // - byteOffset - an index into `buffer`; will be clamped to an int32
	    // - encoding - an optional encoding, relevant is val is a string
	    // - dir - true for indexOf, false for lastIndexOf
	    function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
	      // Empty buffer means no match
	      if (buffer.length === 0) return -1

	      // Normalize byteOffset
	      if (typeof byteOffset === 'string') {
	        encoding = byteOffset;
	        byteOffset = 0;
	      } else if (byteOffset > 0x7fffffff) {
	        byteOffset = 0x7fffffff;
	      } else if (byteOffset < -0x80000000) {
	        byteOffset = -0x80000000;
	      }
	      byteOffset = +byteOffset;  // Coerce to Number.
	      if (isNaN(byteOffset)) {
	        // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
	        byteOffset = dir ? 0 : (buffer.length - 1);
	      }

	      // Normalize byteOffset: negative offsets start from the end of the buffer
	      if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
	      if (byteOffset >= buffer.length) {
	        if (dir) return -1
	        else byteOffset = buffer.length - 1;
	      } else if (byteOffset < 0) {
	        if (dir) byteOffset = 0;
	        else return -1
	      }

	      // Normalize val
	      if (typeof val === 'string') {
	        val = Buffer.from(val, encoding);
	      }

	      // Finally, search either indexOf (if dir is true) or lastIndexOf
	      if (internalIsBuffer(val)) {
	        // Special case: looking for empty string/buffer always fails
	        if (val.length === 0) {
	          return -1
	        }
	        return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
	      } else if (typeof val === 'number') {
	        val = val & 0xFF; // Search for a byte value [0-255]
	        if (Buffer.TYPED_ARRAY_SUPPORT &&
	            typeof Uint8Array.prototype.indexOf === 'function') {
	          if (dir) {
	            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
	          } else {
	            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
	          }
	        }
	        return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
	      }

	      throw new TypeError('val must be string, number or Buffer')
	    }

	    function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
	      var indexSize = 1;
	      var arrLength = arr.length;
	      var valLength = val.length;

	      if (encoding !== undefined) {
	        encoding = String(encoding).toLowerCase();
	        if (encoding === 'ucs2' || encoding === 'ucs-2' ||
	            encoding === 'utf16le' || encoding === 'utf-16le') {
	          if (arr.length < 2 || val.length < 2) {
	            return -1
	          }
	          indexSize = 2;
	          arrLength /= 2;
	          valLength /= 2;
	          byteOffset /= 2;
	        }
	      }

	      function read (buf, i) {
	        if (indexSize === 1) {
	          return buf[i]
	        } else {
	          return buf.readUInt16BE(i * indexSize)
	        }
	      }

	      var i;
	      if (dir) {
	        var foundIndex = -1;
	        for (i = byteOffset; i < arrLength; i++) {
	          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
	            if (foundIndex === -1) foundIndex = i;
	            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
	          } else {
	            if (foundIndex !== -1) i -= i - foundIndex;
	            foundIndex = -1;
	          }
	        }
	      } else {
	        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
	        for (i = byteOffset; i >= 0; i--) {
	          var found = true;
	          for (var j = 0; j < valLength; j++) {
	            if (read(arr, i + j) !== read(val, j)) {
	              found = false;
	              break
	            }
	          }
	          if (found) return i
	        }
	      }

	      return -1
	    }

	    Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
	      return this.indexOf(val, byteOffset, encoding) !== -1
	    };

	    Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
	      return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
	    };

	    Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
	      return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
	    };

	    function hexWrite (buf, string, offset, length) {
	      offset = Number(offset) || 0;
	      var remaining = buf.length - offset;
	      if (!length) {
	        length = remaining;
	      } else {
	        length = Number(length);
	        if (length > remaining) {
	          length = remaining;
	        }
	      }

	      // must be an even number of digits
	      var strLen = string.length;
	      if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

	      if (length > strLen / 2) {
	        length = strLen / 2;
	      }
	      for (var i = 0; i < length; ++i) {
	        var parsed = parseInt(string.substr(i * 2, 2), 16);
	        if (isNaN(parsed)) return i
	        buf[offset + i] = parsed;
	      }
	      return i
	    }

	    function utf8Write (buf, string, offset, length) {
	      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	    }

	    function asciiWrite (buf, string, offset, length) {
	      return blitBuffer(asciiToBytes(string), buf, offset, length)
	    }

	    function latin1Write (buf, string, offset, length) {
	      return asciiWrite(buf, string, offset, length)
	    }

	    function base64Write (buf, string, offset, length) {
	      return blitBuffer(base64ToBytes(string), buf, offset, length)
	    }

	    function ucs2Write (buf, string, offset, length) {
	      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	    }

	    Buffer.prototype.write = function write (string, offset, length, encoding) {
	      // Buffer#write(string)
	      if (offset === undefined) {
	        encoding = 'utf8';
	        length = this.length;
	        offset = 0;
	      // Buffer#write(string, encoding)
	      } else if (length === undefined && typeof offset === 'string') {
	        encoding = offset;
	        length = this.length;
	        offset = 0;
	      // Buffer#write(string, offset[, length][, encoding])
	      } else if (isFinite(offset)) {
	        offset = offset | 0;
	        if (isFinite(length)) {
	          length = length | 0;
	          if (encoding === undefined) encoding = 'utf8';
	        } else {
	          encoding = length;
	          length = undefined;
	        }
	      // legacy write(string, encoding, offset, length) - remove in v0.13
	      } else {
	        throw new Error(
	          'Buffer.write(string, encoding, offset[, length]) is no longer supported'
	        )
	      }

	      var remaining = this.length - offset;
	      if (length === undefined || length > remaining) length = remaining;

	      if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	        throw new RangeError('Attempt to write outside buffer bounds')
	      }

	      if (!encoding) encoding = 'utf8';

	      var loweredCase = false;
	      for (;;) {
	        switch (encoding) {
	          case 'hex':
	            return hexWrite(this, string, offset, length)

	          case 'utf8':
	          case 'utf-8':
	            return utf8Write(this, string, offset, length)

	          case 'ascii':
	            return asciiWrite(this, string, offset, length)

	          case 'latin1':
	          case 'binary':
	            return latin1Write(this, string, offset, length)

	          case 'base64':
	            // Warning: maxLength not taken into account in base64Write
	            return base64Write(this, string, offset, length)

	          case 'ucs2':
	          case 'ucs-2':
	          case 'utf16le':
	          case 'utf-16le':
	            return ucs2Write(this, string, offset, length)

	          default:
	            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	            encoding = ('' + encoding).toLowerCase();
	            loweredCase = true;
	        }
	      }
	    };

	    Buffer.prototype.toJSON = function toJSON () {
	      return {
	        type: 'Buffer',
	        data: Array.prototype.slice.call(this._arr || this, 0)
	      }
	    };

	    function base64Slice (buf, start, end) {
	      if (start === 0 && end === buf.length) {
	        return fromByteArray(buf)
	      } else {
	        return fromByteArray(buf.slice(start, end))
	      }
	    }

	    function utf8Slice (buf, start, end) {
	      end = Math.min(buf.length, end);
	      var res = [];

	      var i = start;
	      while (i < end) {
	        var firstByte = buf[i];
	        var codePoint = null;
	        var bytesPerSequence = (firstByte > 0xEF) ? 4
	          : (firstByte > 0xDF) ? 3
	          : (firstByte > 0xBF) ? 2
	          : 1;

	        if (i + bytesPerSequence <= end) {
	          var secondByte, thirdByte, fourthByte, tempCodePoint;

	          switch (bytesPerSequence) {
	            case 1:
	              if (firstByte < 0x80) {
	                codePoint = firstByte;
	              }
	              break
	            case 2:
	              secondByte = buf[i + 1];
	              if ((secondByte & 0xC0) === 0x80) {
	                tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
	                if (tempCodePoint > 0x7F) {
	                  codePoint = tempCodePoint;
	                }
	              }
	              break
	            case 3:
	              secondByte = buf[i + 1];
	              thirdByte = buf[i + 2];
	              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	                tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
	                if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	                  codePoint = tempCodePoint;
	                }
	              }
	              break
	            case 4:
	              secondByte = buf[i + 1];
	              thirdByte = buf[i + 2];
	              fourthByte = buf[i + 3];
	              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	                tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
	                if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	                  codePoint = tempCodePoint;
	                }
	              }
	          }
	        }

	        if (codePoint === null) {
	          // we did not generate a valid codePoint so insert a
	          // replacement char (U+FFFD) and advance only 1 byte
	          codePoint = 0xFFFD;
	          bytesPerSequence = 1;
	        } else if (codePoint > 0xFFFF) {
	          // encode to utf16 (surrogate pair dance)
	          codePoint -= 0x10000;
	          res.push(codePoint >>> 10 & 0x3FF | 0xD800);
	          codePoint = 0xDC00 | codePoint & 0x3FF;
	        }

	        res.push(codePoint);
	        i += bytesPerSequence;
	      }

	      return decodeCodePointsArray(res)
	    }

	    // Based on http://stackoverflow.com/a/22747272/680742, the browser with
	    // the lowest limit is Chrome, with 0x10000 args.
	    // We go 1 magnitude less, for safety
	    var MAX_ARGUMENTS_LENGTH = 0x1000;

	    function decodeCodePointsArray (codePoints) {
	      var len = codePoints.length;
	      if (len <= MAX_ARGUMENTS_LENGTH) {
	        return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	      }

	      // Decode in chunks to avoid "call stack size exceeded".
	      var res = '';
	      var i = 0;
	      while (i < len) {
	        res += String.fromCharCode.apply(
	          String,
	          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	        );
	      }
	      return res
	    }

	    function asciiSlice (buf, start, end) {
	      var ret = '';
	      end = Math.min(buf.length, end);

	      for (var i = start; i < end; ++i) {
	        ret += String.fromCharCode(buf[i] & 0x7F);
	      }
	      return ret
	    }

	    function latin1Slice (buf, start, end) {
	      var ret = '';
	      end = Math.min(buf.length, end);

	      for (var i = start; i < end; ++i) {
	        ret += String.fromCharCode(buf[i]);
	      }
	      return ret
	    }

	    function hexSlice (buf, start, end) {
	      var len = buf.length;

	      if (!start || start < 0) start = 0;
	      if (!end || end < 0 || end > len) end = len;

	      var out = '';
	      for (var i = start; i < end; ++i) {
	        out += toHex(buf[i]);
	      }
	      return out
	    }

	    function utf16leSlice (buf, start, end) {
	      var bytes = buf.slice(start, end);
	      var res = '';
	      for (var i = 0; i < bytes.length; i += 2) {
	        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
	      }
	      return res
	    }

	    Buffer.prototype.slice = function slice (start, end) {
	      var len = this.length;
	      start = ~~start;
	      end = end === undefined ? len : ~~end;

	      if (start < 0) {
	        start += len;
	        if (start < 0) start = 0;
	      } else if (start > len) {
	        start = len;
	      }

	      if (end < 0) {
	        end += len;
	        if (end < 0) end = 0;
	      } else if (end > len) {
	        end = len;
	      }

	      if (end < start) end = start;

	      var newBuf;
	      if (Buffer.TYPED_ARRAY_SUPPORT) {
	        newBuf = this.subarray(start, end);
	        newBuf.__proto__ = Buffer.prototype;
	      } else {
	        var sliceLen = end - start;
	        newBuf = new Buffer(sliceLen, undefined);
	        for (var i = 0; i < sliceLen; ++i) {
	          newBuf[i] = this[i + start];
	        }
	      }

	      return newBuf
	    };

	    /*
	     * Need to make sure that buffer isn't trying to write out of bounds.
	     */
	    function checkOffset (offset, ext, length) {
	      if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	      if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	    }

	    Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	      offset = offset | 0;
	      byteLength = byteLength | 0;
	      if (!noAssert) checkOffset(offset, byteLength, this.length);

	      var val = this[offset];
	      var mul = 1;
	      var i = 0;
	      while (++i < byteLength && (mul *= 0x100)) {
	        val += this[offset + i] * mul;
	      }

	      return val
	    };

	    Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	      offset = offset | 0;
	      byteLength = byteLength | 0;
	      if (!noAssert) {
	        checkOffset(offset, byteLength, this.length);
	      }

	      var val = this[offset + --byteLength];
	      var mul = 1;
	      while (byteLength > 0 && (mul *= 0x100)) {
	        val += this[offset + --byteLength] * mul;
	      }

	      return val
	    };

	    Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	      if (!noAssert) checkOffset(offset, 1, this.length);
	      return this[offset]
	    };

	    Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	      if (!noAssert) checkOffset(offset, 2, this.length);
	      return this[offset] | (this[offset + 1] << 8)
	    };

	    Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	      if (!noAssert) checkOffset(offset, 2, this.length);
	      return (this[offset] << 8) | this[offset + 1]
	    };

	    Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	      if (!noAssert) checkOffset(offset, 4, this.length);

	      return ((this[offset]) |
	          (this[offset + 1] << 8) |
	          (this[offset + 2] << 16)) +
	          (this[offset + 3] * 0x1000000)
	    };

	    Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	      if (!noAssert) checkOffset(offset, 4, this.length);

	      return (this[offset] * 0x1000000) +
	        ((this[offset + 1] << 16) |
	        (this[offset + 2] << 8) |
	        this[offset + 3])
	    };

	    Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	      offset = offset | 0;
	      byteLength = byteLength | 0;
	      if (!noAssert) checkOffset(offset, byteLength, this.length);

	      var val = this[offset];
	      var mul = 1;
	      var i = 0;
	      while (++i < byteLength && (mul *= 0x100)) {
	        val += this[offset + i] * mul;
	      }
	      mul *= 0x80;

	      if (val >= mul) val -= Math.pow(2, 8 * byteLength);

	      return val
	    };

	    Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	      offset = offset | 0;
	      byteLength = byteLength | 0;
	      if (!noAssert) checkOffset(offset, byteLength, this.length);

	      var i = byteLength;
	      var mul = 1;
	      var val = this[offset + --i];
	      while (i > 0 && (mul *= 0x100)) {
	        val += this[offset + --i] * mul;
	      }
	      mul *= 0x80;

	      if (val >= mul) val -= Math.pow(2, 8 * byteLength);

	      return val
	    };

	    Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	      if (!noAssert) checkOffset(offset, 1, this.length);
	      if (!(this[offset] & 0x80)) return (this[offset])
	      return ((0xff - this[offset] + 1) * -1)
	    };

	    Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	      if (!noAssert) checkOffset(offset, 2, this.length);
	      var val = this[offset] | (this[offset + 1] << 8);
	      return (val & 0x8000) ? val | 0xFFFF0000 : val
	    };

	    Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	      if (!noAssert) checkOffset(offset, 2, this.length);
	      var val = this[offset + 1] | (this[offset] << 8);
	      return (val & 0x8000) ? val | 0xFFFF0000 : val
	    };

	    Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	      if (!noAssert) checkOffset(offset, 4, this.length);

	      return (this[offset]) |
	        (this[offset + 1] << 8) |
	        (this[offset + 2] << 16) |
	        (this[offset + 3] << 24)
	    };

	    Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	      if (!noAssert) checkOffset(offset, 4, this.length);

	      return (this[offset] << 24) |
	        (this[offset + 1] << 16) |
	        (this[offset + 2] << 8) |
	        (this[offset + 3])
	    };

	    Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	      if (!noAssert) checkOffset(offset, 4, this.length);
	      return read(this, offset, true, 23, 4)
	    };

	    Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	      if (!noAssert) checkOffset(offset, 4, this.length);
	      return read(this, offset, false, 23, 4)
	    };

	    Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	      if (!noAssert) checkOffset(offset, 8, this.length);
	      return read(this, offset, true, 52, 8)
	    };

	    Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	      if (!noAssert) checkOffset(offset, 8, this.length);
	      return read(this, offset, false, 52, 8)
	    };

	    function checkInt (buf, value, offset, ext, max, min) {
	      if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
	      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
	      if (offset + ext > buf.length) throw new RangeError('Index out of range')
	    }

	    Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	      value = +value;
	      offset = offset | 0;
	      byteLength = byteLength | 0;
	      if (!noAssert) {
	        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
	        checkInt(this, value, offset, byteLength, maxBytes, 0);
	      }

	      var mul = 1;
	      var i = 0;
	      this[offset] = value & 0xFF;
	      while (++i < byteLength && (mul *= 0x100)) {
	        this[offset + i] = (value / mul) & 0xFF;
	      }

	      return offset + byteLength
	    };

	    Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	      value = +value;
	      offset = offset | 0;
	      byteLength = byteLength | 0;
	      if (!noAssert) {
	        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
	        checkInt(this, value, offset, byteLength, maxBytes, 0);
	      }

	      var i = byteLength - 1;
	      var mul = 1;
	      this[offset + i] = value & 0xFF;
	      while (--i >= 0 && (mul *= 0x100)) {
	        this[offset + i] = (value / mul) & 0xFF;
	      }

	      return offset + byteLength
	    };

	    Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	      value = +value;
	      offset = offset | 0;
	      if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
	      if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
	      this[offset] = (value & 0xff);
	      return offset + 1
	    };

	    function objectWriteUInt16 (buf, value, offset, littleEndian) {
	      if (value < 0) value = 0xffff + value + 1;
	      for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
	        buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	          (littleEndian ? i : 1 - i) * 8;
	      }
	    }

	    Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	      value = +value;
	      offset = offset | 0;
	      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
	      if (Buffer.TYPED_ARRAY_SUPPORT) {
	        this[offset] = (value & 0xff);
	        this[offset + 1] = (value >>> 8);
	      } else {
	        objectWriteUInt16(this, value, offset, true);
	      }
	      return offset + 2
	    };

	    Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	      value = +value;
	      offset = offset | 0;
	      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
	      if (Buffer.TYPED_ARRAY_SUPPORT) {
	        this[offset] = (value >>> 8);
	        this[offset + 1] = (value & 0xff);
	      } else {
	        objectWriteUInt16(this, value, offset, false);
	      }
	      return offset + 2
	    };

	    function objectWriteUInt32 (buf, value, offset, littleEndian) {
	      if (value < 0) value = 0xffffffff + value + 1;
	      for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
	        buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
	      }
	    }

	    Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	      value = +value;
	      offset = offset | 0;
	      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
	      if (Buffer.TYPED_ARRAY_SUPPORT) {
	        this[offset + 3] = (value >>> 24);
	        this[offset + 2] = (value >>> 16);
	        this[offset + 1] = (value >>> 8);
	        this[offset] = (value & 0xff);
	      } else {
	        objectWriteUInt32(this, value, offset, true);
	      }
	      return offset + 4
	    };

	    Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	      value = +value;
	      offset = offset | 0;
	      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
	      if (Buffer.TYPED_ARRAY_SUPPORT) {
	        this[offset] = (value >>> 24);
	        this[offset + 1] = (value >>> 16);
	        this[offset + 2] = (value >>> 8);
	        this[offset + 3] = (value & 0xff);
	      } else {
	        objectWriteUInt32(this, value, offset, false);
	      }
	      return offset + 4
	    };

	    Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	      value = +value;
	      offset = offset | 0;
	      if (!noAssert) {
	        var limit = Math.pow(2, 8 * byteLength - 1);

	        checkInt(this, value, offset, byteLength, limit - 1, -limit);
	      }

	      var i = 0;
	      var mul = 1;
	      var sub = 0;
	      this[offset] = value & 0xFF;
	      while (++i < byteLength && (mul *= 0x100)) {
	        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
	          sub = 1;
	        }
	        this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
	      }

	      return offset + byteLength
	    };

	    Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	      value = +value;
	      offset = offset | 0;
	      if (!noAssert) {
	        var limit = Math.pow(2, 8 * byteLength - 1);

	        checkInt(this, value, offset, byteLength, limit - 1, -limit);
	      }

	      var i = byteLength - 1;
	      var mul = 1;
	      var sub = 0;
	      this[offset + i] = value & 0xFF;
	      while (--i >= 0 && (mul *= 0x100)) {
	        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
	          sub = 1;
	        }
	        this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
	      }

	      return offset + byteLength
	    };

	    Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	      value = +value;
	      offset = offset | 0;
	      if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
	      if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
	      if (value < 0) value = 0xff + value + 1;
	      this[offset] = (value & 0xff);
	      return offset + 1
	    };

	    Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	      value = +value;
	      offset = offset | 0;
	      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
	      if (Buffer.TYPED_ARRAY_SUPPORT) {
	        this[offset] = (value & 0xff);
	        this[offset + 1] = (value >>> 8);
	      } else {
	        objectWriteUInt16(this, value, offset, true);
	      }
	      return offset + 2
	    };

	    Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	      value = +value;
	      offset = offset | 0;
	      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
	      if (Buffer.TYPED_ARRAY_SUPPORT) {
	        this[offset] = (value >>> 8);
	        this[offset + 1] = (value & 0xff);
	      } else {
	        objectWriteUInt16(this, value, offset, false);
	      }
	      return offset + 2
	    };

	    Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	      value = +value;
	      offset = offset | 0;
	      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
	      if (Buffer.TYPED_ARRAY_SUPPORT) {
	        this[offset] = (value & 0xff);
	        this[offset + 1] = (value >>> 8);
	        this[offset + 2] = (value >>> 16);
	        this[offset + 3] = (value >>> 24);
	      } else {
	        objectWriteUInt32(this, value, offset, true);
	      }
	      return offset + 4
	    };

	    Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	      value = +value;
	      offset = offset | 0;
	      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
	      if (value < 0) value = 0xffffffff + value + 1;
	      if (Buffer.TYPED_ARRAY_SUPPORT) {
	        this[offset] = (value >>> 24);
	        this[offset + 1] = (value >>> 16);
	        this[offset + 2] = (value >>> 8);
	        this[offset + 3] = (value & 0xff);
	      } else {
	        objectWriteUInt32(this, value, offset, false);
	      }
	      return offset + 4
	    };

	    function checkIEEE754 (buf, value, offset, ext, max, min) {
	      if (offset + ext > buf.length) throw new RangeError('Index out of range')
	      if (offset < 0) throw new RangeError('Index out of range')
	    }

	    function writeFloat (buf, value, offset, littleEndian, noAssert) {
	      if (!noAssert) {
	        checkIEEE754(buf, value, offset, 4);
	      }
	      write(buf, value, offset, littleEndian, 23, 4);
	      return offset + 4
	    }

	    Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	      return writeFloat(this, value, offset, true, noAssert)
	    };

	    Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	      return writeFloat(this, value, offset, false, noAssert)
	    };

	    function writeDouble (buf, value, offset, littleEndian, noAssert) {
	      if (!noAssert) {
	        checkIEEE754(buf, value, offset, 8);
	      }
	      write(buf, value, offset, littleEndian, 52, 8);
	      return offset + 8
	    }

	    Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	      return writeDouble(this, value, offset, true, noAssert)
	    };

	    Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	      return writeDouble(this, value, offset, false, noAssert)
	    };

	    // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	    Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	      if (!start) start = 0;
	      if (!end && end !== 0) end = this.length;
	      if (targetStart >= target.length) targetStart = target.length;
	      if (!targetStart) targetStart = 0;
	      if (end > 0 && end < start) end = start;

	      // Copy 0 bytes; we're done
	      if (end === start) return 0
	      if (target.length === 0 || this.length === 0) return 0

	      // Fatal error conditions
	      if (targetStart < 0) {
	        throw new RangeError('targetStart out of bounds')
	      }
	      if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	      if (end < 0) throw new RangeError('sourceEnd out of bounds')

	      // Are we oob?
	      if (end > this.length) end = this.length;
	      if (target.length - targetStart < end - start) {
	        end = target.length - targetStart + start;
	      }

	      var len = end - start;
	      var i;

	      if (this === target && start < targetStart && targetStart < end) {
	        // descending copy from end
	        for (i = len - 1; i >= 0; --i) {
	          target[i + targetStart] = this[i + start];
	        }
	      } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	        // ascending copy from start
	        for (i = 0; i < len; ++i) {
	          target[i + targetStart] = this[i + start];
	        }
	      } else {
	        Uint8Array.prototype.set.call(
	          target,
	          this.subarray(start, start + len),
	          targetStart
	        );
	      }

	      return len
	    };

	    // Usage:
	    //    buffer.fill(number[, offset[, end]])
	    //    buffer.fill(buffer[, offset[, end]])
	    //    buffer.fill(string[, offset[, end]][, encoding])
	    Buffer.prototype.fill = function fill (val, start, end, encoding) {
	      // Handle string cases:
	      if (typeof val === 'string') {
	        if (typeof start === 'string') {
	          encoding = start;
	          start = 0;
	          end = this.length;
	        } else if (typeof end === 'string') {
	          encoding = end;
	          end = this.length;
	        }
	        if (val.length === 1) {
	          var code = val.charCodeAt(0);
	          if (code < 256) {
	            val = code;
	          }
	        }
	        if (encoding !== undefined && typeof encoding !== 'string') {
	          throw new TypeError('encoding must be a string')
	        }
	        if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
	          throw new TypeError('Unknown encoding: ' + encoding)
	        }
	      } else if (typeof val === 'number') {
	        val = val & 255;
	      }

	      // Invalid ranges are not set to a default, so can range check early.
	      if (start < 0 || this.length < start || this.length < end) {
	        throw new RangeError('Out of range index')
	      }

	      if (end <= start) {
	        return this
	      }

	      start = start >>> 0;
	      end = end === undefined ? this.length : end >>> 0;

	      if (!val) val = 0;

	      var i;
	      if (typeof val === 'number') {
	        for (i = start; i < end; ++i) {
	          this[i] = val;
	        }
	      } else {
	        var bytes = internalIsBuffer(val)
	          ? val
	          : utf8ToBytes(new Buffer(val, encoding).toString());
	        var len = bytes.length;
	        for (i = 0; i < end - start; ++i) {
	          this[i + start] = bytes[i % len];
	        }
	      }

	      return this
	    };

	    // HELPER FUNCTIONS
	    // ================

	    var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

	    function base64clean (str) {
	      // Node strips out invalid characters like \n and \t from the string, base64-js does not
	      str = stringtrim(str).replace(INVALID_BASE64_RE, '');
	      // Node converts strings with length < 2 to ''
	      if (str.length < 2) return ''
	      // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	      while (str.length % 4 !== 0) {
	        str = str + '=';
	      }
	      return str
	    }

	    function stringtrim (str) {
	      if (str.trim) return str.trim()
	      return str.replace(/^\s+|\s+$/g, '')
	    }

	    function toHex (n) {
	      if (n < 16) return '0' + n.toString(16)
	      return n.toString(16)
	    }

	    function utf8ToBytes (string, units) {
	      units = units || Infinity;
	      var codePoint;
	      var length = string.length;
	      var leadSurrogate = null;
	      var bytes = [];

	      for (var i = 0; i < length; ++i) {
	        codePoint = string.charCodeAt(i);

	        // is surrogate component
	        if (codePoint > 0xD7FF && codePoint < 0xE000) {
	          // last char was a lead
	          if (!leadSurrogate) {
	            // no lead yet
	            if (codePoint > 0xDBFF) {
	              // unexpected trail
	              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	              continue
	            } else if (i + 1 === length) {
	              // unpaired lead
	              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	              continue
	            }

	            // valid lead
	            leadSurrogate = codePoint;

	            continue
	          }

	          // 2 leads in a row
	          if (codePoint < 0xDC00) {
	            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	            leadSurrogate = codePoint;
	            continue
	          }

	          // valid surrogate pair
	          codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
	        } else if (leadSurrogate) {
	          // valid bmp char, but last char was a lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	        }

	        leadSurrogate = null;

	        // encode utf8
	        if (codePoint < 0x80) {
	          if ((units -= 1) < 0) break
	          bytes.push(codePoint);
	        } else if (codePoint < 0x800) {
	          if ((units -= 2) < 0) break
	          bytes.push(
	            codePoint >> 0x6 | 0xC0,
	            codePoint & 0x3F | 0x80
	          );
	        } else if (codePoint < 0x10000) {
	          if ((units -= 3) < 0) break
	          bytes.push(
	            codePoint >> 0xC | 0xE0,
	            codePoint >> 0x6 & 0x3F | 0x80,
	            codePoint & 0x3F | 0x80
	          );
	        } else if (codePoint < 0x110000) {
	          if ((units -= 4) < 0) break
	          bytes.push(
	            codePoint >> 0x12 | 0xF0,
	            codePoint >> 0xC & 0x3F | 0x80,
	            codePoint >> 0x6 & 0x3F | 0x80,
	            codePoint & 0x3F | 0x80
	          );
	        } else {
	          throw new Error('Invalid code point')
	        }
	      }

	      return bytes
	    }

	    function asciiToBytes (str) {
	      var byteArray = [];
	      for (var i = 0; i < str.length; ++i) {
	        // Node's code seems to be doing this and not & 0x7F..
	        byteArray.push(str.charCodeAt(i) & 0xFF);
	      }
	      return byteArray
	    }

	    function utf16leToBytes (str, units) {
	      var c, hi, lo;
	      var byteArray = [];
	      for (var i = 0; i < str.length; ++i) {
	        if ((units -= 2) < 0) break

	        c = str.charCodeAt(i);
	        hi = c >> 8;
	        lo = c % 256;
	        byteArray.push(lo);
	        byteArray.push(hi);
	      }

	      return byteArray
	    }


	    function base64ToBytes (str) {
	      return toByteArray(base64clean(str))
	    }

	    function blitBuffer (src, dst, offset, length) {
	      for (var i = 0; i < length; ++i) {
	        if ((i + offset >= dst.length) || (i >= src.length)) break
	        dst[i + offset] = src[i];
	      }
	      return i
	    }

	    function isnan (val) {
	      return val !== val // eslint-disable-line no-self-compare
	    }


	    // the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
	    // The _isBuffer check is for Safari 5-7 support, because it's missing
	    // Object.prototype.constructor. Remove this eventually
	    function isBuffer(obj) {
	      return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))
	    }

	    function isFastBuffer (obj) {
	      return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
	    }

	    // For Node v0.10 support. Remove this eventually.
	    function isSlowBuffer (obj) {
	      return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))
	    }

	    var toFormData_1;
	    var hasRequiredToFormData;

	    function requireToFormData () {
	    	if (hasRequiredToFormData) return toFormData_1;
	    	hasRequiredToFormData = 1;

	    	var utils = requireUtils();

	    	/**
	    	 * Convert a data object to FormData
	    	 * @param {Object} obj
	    	 * @param {?Object} [formData]
	    	 * @returns {Object}
	    	 **/

	    	function toFormData(obj, formData) {
	    	  // eslint-disable-next-line no-param-reassign
	    	  formData = formData || new FormData();

	    	  var stack = [];

	    	  function convertValue(value) {
	    	    if (value === null) return '';

	    	    if (utils.isDate(value)) {
	    	      return value.toISOString();
	    	    }

	    	    if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {
	    	      return typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);
	    	    }

	    	    return value;
	    	  }

	    	  function build(data, parentKey) {
	    	    if (utils.isPlainObject(data) || utils.isArray(data)) {
	    	      if (stack.indexOf(data) !== -1) {
	    	        throw Error('Circular reference detected in ' + parentKey);
	    	      }

	    	      stack.push(data);

	    	      utils.forEach(data, function each(value, key) {
	    	        if (utils.isUndefined(value)) return;
	    	        var fullKey = parentKey ? parentKey + '.' + key : key;
	    	        var arr;

	    	        if (value && !parentKey && typeof value === 'object') {
	    	          if (utils.endsWith(key, '{}')) {
	    	            // eslint-disable-next-line no-param-reassign
	    	            value = JSON.stringify(value);
	    	          } else if (utils.endsWith(key, '[]') && (arr = utils.toArray(value))) {
	    	            // eslint-disable-next-line func-names
	    	            arr.forEach(function(el) {
	    	              !utils.isUndefined(el) && formData.append(fullKey, convertValue(el));
	    	            });
	    	            return;
	    	          }
	    	        }

	    	        build(value, fullKey);
	    	      });

	    	      stack.pop();
	    	    } else {
	    	      formData.append(parentKey, convertValue(data));
	    	    }
	    	  }

	    	  build(obj);

	    	  return formData;
	    	}

	    	toFormData_1 = toFormData;
	    	return toFormData_1;
	    }

	    var settle;
	    var hasRequiredSettle;

	    function requireSettle () {
	    	if (hasRequiredSettle) return settle;
	    	hasRequiredSettle = 1;

	    	var AxiosError = requireAxiosError();

	    	/**
	    	 * Resolve or reject a Promise based on response status.
	    	 *
	    	 * @param {Function} resolve A function that resolves the promise.
	    	 * @param {Function} reject A function that rejects the promise.
	    	 * @param {object} response The response.
	    	 */
	    	settle = function settle(resolve, reject, response) {
	    	  var validateStatus = response.config.validateStatus;
	    	  if (!response.status || !validateStatus || validateStatus(response.status)) {
	    	    resolve(response);
	    	  } else {
	    	    reject(new AxiosError(
	    	      'Request failed with status code ' + response.status,
	    	      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
	    	      response.config,
	    	      response.request,
	    	      response
	    	    ));
	    	  }
	    	};
	    	return settle;
	    }

	    var cookies;
	    var hasRequiredCookies;

	    function requireCookies () {
	    	if (hasRequiredCookies) return cookies;
	    	hasRequiredCookies = 1;

	    	var utils = requireUtils();

	    	cookies = (
	    	  utils.isStandardBrowserEnv() ?

	    	  // Standard browser envs support document.cookie
	    	    (function standardBrowserEnv() {
	    	      return {
	    	        write: function write(name, value, expires, path, domain, secure) {
	    	          var cookie = [];
	    	          cookie.push(name + '=' + encodeURIComponent(value));

	    	          if (utils.isNumber(expires)) {
	    	            cookie.push('expires=' + new Date(expires).toGMTString());
	    	          }

	    	          if (utils.isString(path)) {
	    	            cookie.push('path=' + path);
	    	          }

	    	          if (utils.isString(domain)) {
	    	            cookie.push('domain=' + domain);
	    	          }

	    	          if (secure === true) {
	    	            cookie.push('secure');
	    	          }

	    	          document.cookie = cookie.join('; ');
	    	        },

	    	        read: function read(name) {
	    	          var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
	    	          return (match ? decodeURIComponent(match[3]) : null);
	    	        },

	    	        remove: function remove(name) {
	    	          this.write(name, '', Date.now() - 86400000);
	    	        }
	    	      };
	    	    })() :

	    	  // Non standard browser env (web workers, react-native) lack needed support.
	    	    (function nonStandardBrowserEnv() {
	    	      return {
	    	        write: function write() {},
	    	        read: function read() { return null; },
	    	        remove: function remove() {}
	    	      };
	    	    })()
	    	);
	    	return cookies;
	    }

	    var isAbsoluteURL;
	    var hasRequiredIsAbsoluteURL;

	    function requireIsAbsoluteURL () {
	    	if (hasRequiredIsAbsoluteURL) return isAbsoluteURL;
	    	hasRequiredIsAbsoluteURL = 1;

	    	/**
	    	 * Determines whether the specified URL is absolute
	    	 *
	    	 * @param {string} url The URL to test
	    	 * @returns {boolean} True if the specified URL is absolute, otherwise false
	    	 */
	    	isAbsoluteURL = function isAbsoluteURL(url) {
	    	  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
	    	  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
	    	  // by any combination of letters, digits, plus, period, or hyphen.
	    	  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
	    	};
	    	return isAbsoluteURL;
	    }

	    var combineURLs;
	    var hasRequiredCombineURLs;

	    function requireCombineURLs () {
	    	if (hasRequiredCombineURLs) return combineURLs;
	    	hasRequiredCombineURLs = 1;

	    	/**
	    	 * Creates a new URL by combining the specified URLs
	    	 *
	    	 * @param {string} baseURL The base URL
	    	 * @param {string} relativeURL The relative URL
	    	 * @returns {string} The combined URL
	    	 */
	    	combineURLs = function combineURLs(baseURL, relativeURL) {
	    	  return relativeURL
	    	    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
	    	    : baseURL;
	    	};
	    	return combineURLs;
	    }

	    var buildFullPath;
	    var hasRequiredBuildFullPath;

	    function requireBuildFullPath () {
	    	if (hasRequiredBuildFullPath) return buildFullPath;
	    	hasRequiredBuildFullPath = 1;

	    	var isAbsoluteURL = requireIsAbsoluteURL();
	    	var combineURLs = requireCombineURLs();

	    	/**
	    	 * Creates a new URL by combining the baseURL with the requestedURL,
	    	 * only when the requestedURL is not already an absolute URL.
	    	 * If the requestURL is absolute, this function returns the requestedURL untouched.
	    	 *
	    	 * @param {string} baseURL The base URL
	    	 * @param {string} requestedURL Absolute or relative URL to combine
	    	 * @returns {string} The combined full path
	    	 */
	    	buildFullPath = function buildFullPath(baseURL, requestedURL) {
	    	  if (baseURL && !isAbsoluteURL(requestedURL)) {
	    	    return combineURLs(baseURL, requestedURL);
	    	  }
	    	  return requestedURL;
	    	};
	    	return buildFullPath;
	    }

	    var parseHeaders;
	    var hasRequiredParseHeaders;

	    function requireParseHeaders () {
	    	if (hasRequiredParseHeaders) return parseHeaders;
	    	hasRequiredParseHeaders = 1;

	    	var utils = requireUtils();

	    	// Headers whose duplicates are ignored by node
	    	// c.f. https://nodejs.org/api/http.html#http_message_headers
	    	var ignoreDuplicateOf = [
	    	  'age', 'authorization', 'content-length', 'content-type', 'etag',
	    	  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
	    	  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
	    	  'referer', 'retry-after', 'user-agent'
	    	];

	    	/**
	    	 * Parse headers into an object
	    	 *
	    	 * ```
	    	 * Date: Wed, 27 Aug 2014 08:58:49 GMT
	    	 * Content-Type: application/json
	    	 * Connection: keep-alive
	    	 * Transfer-Encoding: chunked
	    	 * ```
	    	 *
	    	 * @param {String} headers Headers needing to be parsed
	    	 * @returns {Object} Headers parsed into an object
	    	 */
	    	parseHeaders = function parseHeaders(headers) {
	    	  var parsed = {};
	    	  var key;
	    	  var val;
	    	  var i;

	    	  if (!headers) { return parsed; }

	    	  utils.forEach(headers.split('\n'), function parser(line) {
	    	    i = line.indexOf(':');
	    	    key = utils.trim(line.substr(0, i)).toLowerCase();
	    	    val = utils.trim(line.substr(i + 1));

	    	    if (key) {
	    	      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
	    	        return;
	    	      }
	    	      if (key === 'set-cookie') {
	    	        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
	    	      } else {
	    	        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
	    	      }
	    	    }
	    	  });

	    	  return parsed;
	    	};
	    	return parseHeaders;
	    }

	    var isURLSameOrigin;
	    var hasRequiredIsURLSameOrigin;

	    function requireIsURLSameOrigin () {
	    	if (hasRequiredIsURLSameOrigin) return isURLSameOrigin;
	    	hasRequiredIsURLSameOrigin = 1;

	    	var utils = requireUtils();

	    	isURLSameOrigin = (
	    	  utils.isStandardBrowserEnv() ?

	    	  // Standard browser envs have full support of the APIs needed to test
	    	  // whether the request URL is of the same origin as current location.
	    	    (function standardBrowserEnv() {
	    	      var msie = /(msie|trident)/i.test(navigator.userAgent);
	    	      var urlParsingNode = document.createElement('a');
	    	      var originURL;

	    	      /**
	    	    * Parse a URL to discover it's components
	    	    *
	    	    * @param {String} url The URL to be parsed
	    	    * @returns {Object}
	    	    */
	    	      function resolveURL(url) {
	    	        var href = url;

	    	        if (msie) {
	    	        // IE needs attribute set twice to normalize properties
	    	          urlParsingNode.setAttribute('href', href);
	    	          href = urlParsingNode.href;
	    	        }

	    	        urlParsingNode.setAttribute('href', href);

	    	        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
	    	        return {
	    	          href: urlParsingNode.href,
	    	          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
	    	          host: urlParsingNode.host,
	    	          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
	    	          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
	    	          hostname: urlParsingNode.hostname,
	    	          port: urlParsingNode.port,
	    	          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
	    	            urlParsingNode.pathname :
	    	            '/' + urlParsingNode.pathname
	    	        };
	    	      }

	    	      originURL = resolveURL(window.location.href);

	    	      /**
	    	    * Determine if a URL shares the same origin as the current location
	    	    *
	    	    * @param {String} requestURL The URL to test
	    	    * @returns {boolean} True if URL shares the same origin, otherwise false
	    	    */
	    	      return function isURLSameOrigin(requestURL) {
	    	        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
	    	        return (parsed.protocol === originURL.protocol &&
	    	            parsed.host === originURL.host);
	    	      };
	    	    })() :

	    	  // Non standard browser envs (web workers, react-native) lack needed support.
	    	    (function nonStandardBrowserEnv() {
	    	      return function isURLSameOrigin() {
	    	        return true;
	    	      };
	    	    })()
	    	);
	    	return isURLSameOrigin;
	    }

	    var CanceledError_1;
	    var hasRequiredCanceledError;

	    function requireCanceledError () {
	    	if (hasRequiredCanceledError) return CanceledError_1;
	    	hasRequiredCanceledError = 1;

	    	var AxiosError = requireAxiosError();
	    	var utils = requireUtils();

	    	/**
	    	 * A `CanceledError` is an object that is thrown when an operation is canceled.
	    	 *
	    	 * @class
	    	 * @param {string=} message The message.
	    	 */
	    	function CanceledError(message) {
	    	  // eslint-disable-next-line no-eq-null,eqeqeq
	    	  AxiosError.call(this, message == null ? 'canceled' : message, AxiosError.ERR_CANCELED);
	    	  this.name = 'CanceledError';
	    	}

	    	utils.inherits(CanceledError, AxiosError, {
	    	  __CANCEL__: true
	    	});

	    	CanceledError_1 = CanceledError;
	    	return CanceledError_1;
	    }

	    var parseProtocol;
	    var hasRequiredParseProtocol;

	    function requireParseProtocol () {
	    	if (hasRequiredParseProtocol) return parseProtocol;
	    	hasRequiredParseProtocol = 1;

	    	parseProtocol = function parseProtocol(url) {
	    	  var match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
	    	  return match && match[1] || '';
	    	};
	    	return parseProtocol;
	    }

	    var xhr;
	    var hasRequiredXhr;

	    function requireXhr () {
	    	if (hasRequiredXhr) return xhr;
	    	hasRequiredXhr = 1;

	    	var utils = requireUtils();
	    	var settle = requireSettle();
	    	var cookies = requireCookies();
	    	var buildURL = requireBuildURL();
	    	var buildFullPath = requireBuildFullPath();
	    	var parseHeaders = requireParseHeaders();
	    	var isURLSameOrigin = requireIsURLSameOrigin();
	    	var transitionalDefaults = requireTransitional();
	    	var AxiosError = requireAxiosError();
	    	var CanceledError = requireCanceledError();
	    	var parseProtocol = requireParseProtocol();

	    	xhr = function xhrAdapter(config) {
	    	  return new Promise(function dispatchXhrRequest(resolve, reject) {
	    	    var requestData = config.data;
	    	    var requestHeaders = config.headers;
	    	    var responseType = config.responseType;
	    	    var onCanceled;
	    	    function done() {
	    	      if (config.cancelToken) {
	    	        config.cancelToken.unsubscribe(onCanceled);
	    	      }

	    	      if (config.signal) {
	    	        config.signal.removeEventListener('abort', onCanceled);
	    	      }
	    	    }

	    	    if (utils.isFormData(requestData) && utils.isStandardBrowserEnv()) {
	    	      delete requestHeaders['Content-Type']; // Let the browser set it
	    	    }

	    	    var request = new XMLHttpRequest();

	    	    // HTTP basic authentication
	    	    if (config.auth) {
	    	      var username = config.auth.username || '';
	    	      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
	    	      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
	    	    }

	    	    var fullPath = buildFullPath(config.baseURL, config.url);

	    	    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

	    	    // Set the request timeout in MS
	    	    request.timeout = config.timeout;

	    	    function onloadend() {
	    	      if (!request) {
	    	        return;
	    	      }
	    	      // Prepare the response
	    	      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
	    	      var responseData = !responseType || responseType === 'text' ||  responseType === 'json' ?
	    	        request.responseText : request.response;
	    	      var response = {
	    	        data: responseData,
	    	        status: request.status,
	    	        statusText: request.statusText,
	    	        headers: responseHeaders,
	    	        config: config,
	    	        request: request
	    	      };

	    	      settle(function _resolve(value) {
	    	        resolve(value);
	    	        done();
	    	      }, function _reject(err) {
	    	        reject(err);
	    	        done();
	    	      }, response);

	    	      // Clean up request
	    	      request = null;
	    	    }

	    	    if ('onloadend' in request) {
	    	      // Use onloadend if available
	    	      request.onloadend = onloadend;
	    	    } else {
	    	      // Listen for ready state to emulate onloadend
	    	      request.onreadystatechange = function handleLoad() {
	    	        if (!request || request.readyState !== 4) {
	    	          return;
	    	        }

	    	        // The request errored out and we didn't get a response, this will be
	    	        // handled by onerror instead
	    	        // With one exception: request that using file: protocol, most browsers
	    	        // will return status as 0 even though it's a successful request
	    	        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
	    	          return;
	    	        }
	    	        // readystate handler is calling before onerror or ontimeout handlers,
	    	        // so we should call onloadend on the next 'tick'
	    	        setTimeout(onloadend);
	    	      };
	    	    }

	    	    // Handle browser request cancellation (as opposed to a manual cancellation)
	    	    request.onabort = function handleAbort() {
	    	      if (!request) {
	    	        return;
	    	      }

	    	      reject(new AxiosError('Request aborted', AxiosError.ECONNABORTED, config, request));

	    	      // Clean up request
	    	      request = null;
	    	    };

	    	    // Handle low level network errors
	    	    request.onerror = function handleError() {
	    	      // Real errors are hidden from us by the browser
	    	      // onerror should only fire if it's a network error
	    	      reject(new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request, request));

	    	      // Clean up request
	    	      request = null;
	    	    };

	    	    // Handle timeout
	    	    request.ontimeout = function handleTimeout() {
	    	      var timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';
	    	      var transitional = config.transitional || transitionalDefaults;
	    	      if (config.timeoutErrorMessage) {
	    	        timeoutErrorMessage = config.timeoutErrorMessage;
	    	      }
	    	      reject(new AxiosError(
	    	        timeoutErrorMessage,
	    	        transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
	    	        config,
	    	        request));

	    	      // Clean up request
	    	      request = null;
	    	    };

	    	    // Add xsrf header
	    	    // This is only done if running in a standard browser environment.
	    	    // Specifically not if we're in a web worker, or react-native.
	    	    if (utils.isStandardBrowserEnv()) {
	    	      // Add xsrf header
	    	      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
	    	        cookies.read(config.xsrfCookieName) :
	    	        undefined;

	    	      if (xsrfValue) {
	    	        requestHeaders[config.xsrfHeaderName] = xsrfValue;
	    	      }
	    	    }

	    	    // Add headers to the request
	    	    if ('setRequestHeader' in request) {
	    	      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
	    	        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
	    	          // Remove Content-Type if data is undefined
	    	          delete requestHeaders[key];
	    	        } else {
	    	          // Otherwise add header to the request
	    	          request.setRequestHeader(key, val);
	    	        }
	    	      });
	    	    }

	    	    // Add withCredentials to request if needed
	    	    if (!utils.isUndefined(config.withCredentials)) {
	    	      request.withCredentials = !!config.withCredentials;
	    	    }

	    	    // Add responseType to request if needed
	    	    if (responseType && responseType !== 'json') {
	    	      request.responseType = config.responseType;
	    	    }

	    	    // Handle progress if needed
	    	    if (typeof config.onDownloadProgress === 'function') {
	    	      request.addEventListener('progress', config.onDownloadProgress);
	    	    }

	    	    // Not all browsers support upload events
	    	    if (typeof config.onUploadProgress === 'function' && request.upload) {
	    	      request.upload.addEventListener('progress', config.onUploadProgress);
	    	    }

	    	    if (config.cancelToken || config.signal) {
	    	      // Handle cancellation
	    	      // eslint-disable-next-line func-names
	    	      onCanceled = function(cancel) {
	    	        if (!request) {
	    	          return;
	    	        }
	    	        reject(!cancel || (cancel && cancel.type) ? new CanceledError() : cancel);
	    	        request.abort();
	    	        request = null;
	    	      };

	    	      config.cancelToken && config.cancelToken.subscribe(onCanceled);
	    	      if (config.signal) {
	    	        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);
	    	      }
	    	    }

	    	    if (!requestData) {
	    	      requestData = null;
	    	    }

	    	    var protocol = parseProtocol(fullPath);

	    	    if (protocol && [ 'http', 'https', 'file' ].indexOf(protocol) === -1) {
	    	      reject(new AxiosError('Unsupported protocol ' + protocol + ':', AxiosError.ERR_BAD_REQUEST, config));
	    	      return;
	    	    }


	    	    // Send the request
	    	    request.send(requestData);
	    	  });
	    	};
	    	return xhr;
	    }

	    var followRedirects = {exports: {}};

	    var browser$1 = true;

	    var src = {exports: {}};

	    var browser = {exports: {}};

	    /**
	     * Helpers.
	     */

	    var ms;
	    var hasRequiredMs;

	    function requireMs () {
	    	if (hasRequiredMs) return ms;
	    	hasRequiredMs = 1;
	    	var s = 1000;
	    	var m = s * 60;
	    	var h = m * 60;
	    	var d = h * 24;
	    	var w = d * 7;
	    	var y = d * 365.25;

	    	/**
	    	 * Parse or format the given `val`.
	    	 *
	    	 * Options:
	    	 *
	    	 *  - `long` verbose formatting [false]
	    	 *
	    	 * @param {String|Number} val
	    	 * @param {Object} [options]
	    	 * @throws {Error} throw an error if val is not a non-empty string or a number
	    	 * @return {String|Number}
	    	 * @api public
	    	 */

	    	ms = function(val, options) {
	    	  options = options || {};
	    	  var type = typeof val;
	    	  if (type === 'string' && val.length > 0) {
	    	    return parse(val);
	    	  } else if (type === 'number' && isFinite(val)) {
	    	    return options.long ? fmtLong(val) : fmtShort(val);
	    	  }
	    	  throw new Error(
	    	    'val is not a non-empty string or a valid number. val=' +
	    	      JSON.stringify(val)
	    	  );
	    	};

	    	/**
	    	 * Parse the given `str` and return milliseconds.
	    	 *
	    	 * @param {String} str
	    	 * @return {Number}
	    	 * @api private
	    	 */

	    	function parse(str) {
	    	  str = String(str);
	    	  if (str.length > 100) {
	    	    return;
	    	  }
	    	  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
	    	    str
	    	  );
	    	  if (!match) {
	    	    return;
	    	  }
	    	  var n = parseFloat(match[1]);
	    	  var type = (match[2] || 'ms').toLowerCase();
	    	  switch (type) {
	    	    case 'years':
	    	    case 'year':
	    	    case 'yrs':
	    	    case 'yr':
	    	    case 'y':
	    	      return n * y;
	    	    case 'weeks':
	    	    case 'week':
	    	    case 'w':
	    	      return n * w;
	    	    case 'days':
	    	    case 'day':
	    	    case 'd':
	    	      return n * d;
	    	    case 'hours':
	    	    case 'hour':
	    	    case 'hrs':
	    	    case 'hr':
	    	    case 'h':
	    	      return n * h;
	    	    case 'minutes':
	    	    case 'minute':
	    	    case 'mins':
	    	    case 'min':
	    	    case 'm':
	    	      return n * m;
	    	    case 'seconds':
	    	    case 'second':
	    	    case 'secs':
	    	    case 'sec':
	    	    case 's':
	    	      return n * s;
	    	    case 'milliseconds':
	    	    case 'millisecond':
	    	    case 'msecs':
	    	    case 'msec':
	    	    case 'ms':
	    	      return n;
	    	    default:
	    	      return undefined;
	    	  }
	    	}

	    	/**
	    	 * Short format for `ms`.
	    	 *
	    	 * @param {Number} ms
	    	 * @return {String}
	    	 * @api private
	    	 */

	    	function fmtShort(ms) {
	    	  var msAbs = Math.abs(ms);
	    	  if (msAbs >= d) {
	    	    return Math.round(ms / d) + 'd';
	    	  }
	    	  if (msAbs >= h) {
	    	    return Math.round(ms / h) + 'h';
	    	  }
	    	  if (msAbs >= m) {
	    	    return Math.round(ms / m) + 'm';
	    	  }
	    	  if (msAbs >= s) {
	    	    return Math.round(ms / s) + 's';
	    	  }
	    	  return ms + 'ms';
	    	}

	    	/**
	    	 * Long format for `ms`.
	    	 *
	    	 * @param {Number} ms
	    	 * @return {String}
	    	 * @api private
	    	 */

	    	function fmtLong(ms) {
	    	  var msAbs = Math.abs(ms);
	    	  if (msAbs >= d) {
	    	    return plural(ms, msAbs, d, 'day');
	    	  }
	    	  if (msAbs >= h) {
	    	    return plural(ms, msAbs, h, 'hour');
	    	  }
	    	  if (msAbs >= m) {
	    	    return plural(ms, msAbs, m, 'minute');
	    	  }
	    	  if (msAbs >= s) {
	    	    return plural(ms, msAbs, s, 'second');
	    	  }
	    	  return ms + ' ms';
	    	}

	    	/**
	    	 * Pluralization helper.
	    	 */

	    	function plural(ms, msAbs, n, name) {
	    	  var isPlural = msAbs >= n * 1.5;
	    	  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
	    	}
	    	return ms;
	    }

	    var common;
	    var hasRequiredCommon;

	    function requireCommon () {
	    	if (hasRequiredCommon) return common;
	    	hasRequiredCommon = 1;
	    	/**
	    	 * This is the common logic for both the Node.js and web browser
	    	 * implementations of `debug()`.
	    	 */

	    	function setup(env) {
	    		createDebug.debug = createDebug;
	    		createDebug.default = createDebug;
	    		createDebug.coerce = coerce;
	    		createDebug.disable = disable;
	    		createDebug.enable = enable;
	    		createDebug.enabled = enabled;
	    		createDebug.humanize = requireMs();
	    		createDebug.destroy = destroy;

	    		Object.keys(env).forEach(key => {
	    			createDebug[key] = env[key];
	    		});

	    		/**
	    		* The currently active debug mode names, and names to skip.
	    		*/

	    		createDebug.names = [];
	    		createDebug.skips = [];

	    		/**
	    		* Map of special "%n" handling functions, for the debug "format" argument.
	    		*
	    		* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	    		*/
	    		createDebug.formatters = {};

	    		/**
	    		* Selects a color for a debug namespace
	    		* @param {String} namespace The namespace string for the debug instance to be colored
	    		* @return {Number|String} An ANSI color code for the given namespace
	    		* @api private
	    		*/
	    		function selectColor(namespace) {
	    			let hash = 0;

	    			for (let i = 0; i < namespace.length; i++) {
	    				hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
	    				hash |= 0; // Convert to 32bit integer
	    			}

	    			return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	    		}
	    		createDebug.selectColor = selectColor;

	    		/**
	    		* Create a debugger with the given `namespace`.
	    		*
	    		* @param {String} namespace
	    		* @return {Function}
	    		* @api public
	    		*/
	    		function createDebug(namespace) {
	    			let prevTime;
	    			let enableOverride = null;
	    			let namespacesCache;
	    			let enabledCache;

	    			function debug(...args) {
	    				// Disabled?
	    				if (!debug.enabled) {
	    					return;
	    				}

	    				const self = debug;

	    				// Set `diff` timestamp
	    				const curr = Number(new Date());
	    				const ms = curr - (prevTime || curr);
	    				self.diff = ms;
	    				self.prev = prevTime;
	    				self.curr = curr;
	    				prevTime = curr;

	    				args[0] = createDebug.coerce(args[0]);

	    				if (typeof args[0] !== 'string') {
	    					// Anything else let's inspect with %O
	    					args.unshift('%O');
	    				}

	    				// Apply any `formatters` transformations
	    				let index = 0;
	    				args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
	    					// If we encounter an escaped % then don't increase the array index
	    					if (match === '%%') {
	    						return '%';
	    					}
	    					index++;
	    					const formatter = createDebug.formatters[format];
	    					if (typeof formatter === 'function') {
	    						const val = args[index];
	    						match = formatter.call(self, val);

	    						// Now we need to remove `args[index]` since it's inlined in the `format`
	    						args.splice(index, 1);
	    						index--;
	    					}
	    					return match;
	    				});

	    				// Apply env-specific formatting (colors, etc.)
	    				createDebug.formatArgs.call(self, args);

	    				const logFn = self.log || createDebug.log;
	    				logFn.apply(self, args);
	    			}

	    			debug.namespace = namespace;
	    			debug.useColors = createDebug.useColors();
	    			debug.color = createDebug.selectColor(namespace);
	    			debug.extend = extend;
	    			debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

	    			Object.defineProperty(debug, 'enabled', {
	    				enumerable: true,
	    				configurable: false,
	    				get: () => {
	    					if (enableOverride !== null) {
	    						return enableOverride;
	    					}
	    					if (namespacesCache !== createDebug.namespaces) {
	    						namespacesCache = createDebug.namespaces;
	    						enabledCache = createDebug.enabled(namespace);
	    					}

	    					return enabledCache;
	    				},
	    				set: v => {
	    					enableOverride = v;
	    				}
	    			});

	    			// Env-specific initialization logic for debug instances
	    			if (typeof createDebug.init === 'function') {
	    				createDebug.init(debug);
	    			}

	    			return debug;
	    		}

	    		function extend(namespace, delimiter) {
	    			const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
	    			newDebug.log = this.log;
	    			return newDebug;
	    		}

	    		/**
	    		* Enables a debug mode by namespaces. This can include modes
	    		* separated by a colon and wildcards.
	    		*
	    		* @param {String} namespaces
	    		* @api public
	    		*/
	    		function enable(namespaces) {
	    			createDebug.save(namespaces);
	    			createDebug.namespaces = namespaces;

	    			createDebug.names = [];
	    			createDebug.skips = [];

	    			let i;
	    			const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
	    			const len = split.length;

	    			for (i = 0; i < len; i++) {
	    				if (!split[i]) {
	    					// ignore empty strings
	    					continue;
	    				}

	    				namespaces = split[i].replace(/\*/g, '.*?');

	    				if (namespaces[0] === '-') {
	    					createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
	    				} else {
	    					createDebug.names.push(new RegExp('^' + namespaces + '$'));
	    				}
	    			}
	    		}

	    		/**
	    		* Disable debug output.
	    		*
	    		* @return {String} namespaces
	    		* @api public
	    		*/
	    		function disable() {
	    			const namespaces = [
	    				...createDebug.names.map(toNamespace),
	    				...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
	    			].join(',');
	    			createDebug.enable('');
	    			return namespaces;
	    		}

	    		/**
	    		* Returns true if the given mode name is enabled, false otherwise.
	    		*
	    		* @param {String} name
	    		* @return {Boolean}
	    		* @api public
	    		*/
	    		function enabled(name) {
	    			if (name[name.length - 1] === '*') {
	    				return true;
	    			}

	    			let i;
	    			let len;

	    			for (i = 0, len = createDebug.skips.length; i < len; i++) {
	    				if (createDebug.skips[i].test(name)) {
	    					return false;
	    				}
	    			}

	    			for (i = 0, len = createDebug.names.length; i < len; i++) {
	    				if (createDebug.names[i].test(name)) {
	    					return true;
	    				}
	    			}

	    			return false;
	    		}

	    		/**
	    		* Convert regexp to namespace
	    		*
	    		* @param {RegExp} regxep
	    		* @return {String} namespace
	    		* @api private
	    		*/
	    		function toNamespace(regexp) {
	    			return regexp.toString()
	    				.substring(2, regexp.toString().length - 2)
	    				.replace(/\.\*\?$/, '*');
	    		}

	    		/**
	    		* Coerce `val`.
	    		*
	    		* @param {Mixed} val
	    		* @return {Mixed}
	    		* @api private
	    		*/
	    		function coerce(val) {
	    			if (val instanceof Error) {
	    				return val.stack || val.message;
	    			}
	    			return val;
	    		}

	    		/**
	    		* XXX DO NOT USE. This is a temporary stub function.
	    		* XXX It WILL be removed in the next major release.
	    		*/
	    		function destroy() {
	    			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	    		}

	    		createDebug.enable(createDebug.load());

	    		return createDebug;
	    	}

	    	common = setup;
	    	return common;
	    }

	    var hasRequiredBrowser;

	    function requireBrowser () {
	    	if (hasRequiredBrowser) return browser.exports;
	    	hasRequiredBrowser = 1;
	    	(function (module, exports) {
	    		/**
	    		 * This is the web browser implementation of `debug()`.
	    		 */

	    		exports.formatArgs = formatArgs;
	    		exports.save = save;
	    		exports.load = load;
	    		exports.useColors = useColors;
	    		exports.storage = localstorage();
	    		exports.destroy = (() => {
	    			let warned = false;

	    			return () => {
	    				if (!warned) {
	    					warned = true;
	    					console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	    				}
	    			};
	    		})();

	    		/**
	    		 * Colors.
	    		 */

	    		exports.colors = [
	    			'#0000CC',
	    			'#0000FF',
	    			'#0033CC',
	    			'#0033FF',
	    			'#0066CC',
	    			'#0066FF',
	    			'#0099CC',
	    			'#0099FF',
	    			'#00CC00',
	    			'#00CC33',
	    			'#00CC66',
	    			'#00CC99',
	    			'#00CCCC',
	    			'#00CCFF',
	    			'#3300CC',
	    			'#3300FF',
	    			'#3333CC',
	    			'#3333FF',
	    			'#3366CC',
	    			'#3366FF',
	    			'#3399CC',
	    			'#3399FF',
	    			'#33CC00',
	    			'#33CC33',
	    			'#33CC66',
	    			'#33CC99',
	    			'#33CCCC',
	    			'#33CCFF',
	    			'#6600CC',
	    			'#6600FF',
	    			'#6633CC',
	    			'#6633FF',
	    			'#66CC00',
	    			'#66CC33',
	    			'#9900CC',
	    			'#9900FF',
	    			'#9933CC',
	    			'#9933FF',
	    			'#99CC00',
	    			'#99CC33',
	    			'#CC0000',
	    			'#CC0033',
	    			'#CC0066',
	    			'#CC0099',
	    			'#CC00CC',
	    			'#CC00FF',
	    			'#CC3300',
	    			'#CC3333',
	    			'#CC3366',
	    			'#CC3399',
	    			'#CC33CC',
	    			'#CC33FF',
	    			'#CC6600',
	    			'#CC6633',
	    			'#CC9900',
	    			'#CC9933',
	    			'#CCCC00',
	    			'#CCCC33',
	    			'#FF0000',
	    			'#FF0033',
	    			'#FF0066',
	    			'#FF0099',
	    			'#FF00CC',
	    			'#FF00FF',
	    			'#FF3300',
	    			'#FF3333',
	    			'#FF3366',
	    			'#FF3399',
	    			'#FF33CC',
	    			'#FF33FF',
	    			'#FF6600',
	    			'#FF6633',
	    			'#FF9900',
	    			'#FF9933',
	    			'#FFCC00',
	    			'#FFCC33'
	    		];

	    		/**
	    		 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
	    		 * and the Firebug extension (any Firefox version) are known
	    		 * to support "%c" CSS customizations.
	    		 *
	    		 * TODO: add a `localStorage` variable to explicitly enable/disable colors
	    		 */

	    		// eslint-disable-next-line complexity
	    		function useColors() {
	    			// NB: In an Electron preload script, document will be defined but not fully
	    			// initialized. Since we know we're in Chrome, we'll just detect this case
	    			// explicitly
	    			if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
	    				return true;
	    			}

	    			// Internet Explorer and Edge do not support colors.
	    			if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
	    				return false;
	    			}

	    			// Is webkit? http://stackoverflow.com/a/16459606/376773
	    			// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	    			return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
	    				// Is firebug? http://stackoverflow.com/a/398120/376773
	    				(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
	    				// Is firefox >= v31?
	    				// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
	    				(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
	    				// Double check webkit in userAgent just in case we are in a worker
	    				(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
	    		}

	    		/**
	    		 * Colorize log arguments if enabled.
	    		 *
	    		 * @api public
	    		 */

	    		function formatArgs(args) {
	    			args[0] = (this.useColors ? '%c' : '') +
	    				this.namespace +
	    				(this.useColors ? ' %c' : ' ') +
	    				args[0] +
	    				(this.useColors ? '%c ' : ' ') +
	    				'+' + module.exports.humanize(this.diff);

	    			if (!this.useColors) {
	    				return;
	    			}

	    			const c = 'color: ' + this.color;
	    			args.splice(1, 0, c, 'color: inherit');

	    			// The final "%c" is somewhat tricky, because there could be other
	    			// arguments passed either before or after the %c, so we need to
	    			// figure out the correct index to insert the CSS into
	    			let index = 0;
	    			let lastC = 0;
	    			args[0].replace(/%[a-zA-Z%]/g, match => {
	    				if (match === '%%') {
	    					return;
	    				}
	    				index++;
	    				if (match === '%c') {
	    					// We only are interested in the *last* %c
	    					// (the user may have provided their own)
	    					lastC = index;
	    				}
	    			});

	    			args.splice(lastC, 0, c);
	    		}

	    		/**
	    		 * Invokes `console.debug()` when available.
	    		 * No-op when `console.debug` is not a "function".
	    		 * If `console.debug` is not available, falls back
	    		 * to `console.log`.
	    		 *
	    		 * @api public
	    		 */
	    		exports.log = console.debug || console.log || (() => {});

	    		/**
	    		 * Save `namespaces`.
	    		 *
	    		 * @param {String} namespaces
	    		 * @api private
	    		 */
	    		function save(namespaces) {
	    			try {
	    				if (namespaces) {
	    					exports.storage.setItem('debug', namespaces);
	    				} else {
	    					exports.storage.removeItem('debug');
	    				}
	    			} catch (error) {
	    				// Swallow
	    				// XXX (@Qix-) should we be logging these?
	    			}
	    		}

	    		/**
	    		 * Load `namespaces`.
	    		 *
	    		 * @return {String} returns the previously persisted debug modes
	    		 * @api private
	    		 */
	    		function load() {
	    			let r;
	    			try {
	    				r = exports.storage.getItem('debug');
	    			} catch (error) {
	    				// Swallow
	    				// XXX (@Qix-) should we be logging these?
	    			}

	    			// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	    			if (!r && typeof process !== 'undefined' && 'env' in process) {
	    				r = process.env.DEBUG;
	    			}

	    			return r;
	    		}

	    		/**
	    		 * Localstorage attempts to return the localstorage.
	    		 *
	    		 * This is necessary because safari throws
	    		 * when a user disables cookies/localstorage
	    		 * and you attempt to access it.
	    		 *
	    		 * @return {LocalStorage}
	    		 * @api private
	    		 */

	    		function localstorage() {
	    			try {
	    				// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
	    				// The Browser also has localStorage in the global context.
	    				return localStorage;
	    			} catch (error) {
	    				// Swallow
	    				// XXX (@Qix-) should we be logging these?
	    			}
	    		}

	    		module.exports = requireCommon()(exports);

	    		const {formatters} = module.exports;

	    		/**
	    		 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	    		 */

	    		formatters.j = function (v) {
	    			try {
	    				return JSON.stringify(v);
	    			} catch (error) {
	    				return '[UnexpectedJSONParseError]: ' + error.message;
	    			}
	    		}; 
	    	} (browser, browser.exports));
	    	return browser.exports;
	    }

	    var node = {exports: {}};

	    var hasFlag;
	    var hasRequiredHasFlag;

	    function requireHasFlag () {
	    	if (hasRequiredHasFlag) return hasFlag;
	    	hasRequiredHasFlag = 1;
	    	hasFlag = (flag, argv) => {
	    		argv = argv || process.argv;
	    		const prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
	    		const pos = argv.indexOf(prefix + flag);
	    		const terminatorPos = argv.indexOf('--');
	    		return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
	    	};
	    	return hasFlag;
	    }

	    var supportsColor_1;
	    var hasRequiredSupportsColor;

	    function requireSupportsColor () {
	    	if (hasRequiredSupportsColor) return supportsColor_1;
	    	hasRequiredSupportsColor = 1;
	    	const os = require$$0__default["default"];
	    	const hasFlag = requireHasFlag();

	    	const env = process.env;

	    	let forceColor;
	    	if (hasFlag('no-color') ||
	    		hasFlag('no-colors') ||
	    		hasFlag('color=false')) {
	    		forceColor = false;
	    	} else if (hasFlag('color') ||
	    		hasFlag('colors') ||
	    		hasFlag('color=true') ||
	    		hasFlag('color=always')) {
	    		forceColor = true;
	    	}
	    	if ('FORCE_COLOR' in env) {
	    		forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
	    	}

	    	function translateLevel(level) {
	    		if (level === 0) {
	    			return false;
	    		}

	    		return {
	    			level,
	    			hasBasic: true,
	    			has256: level >= 2,
	    			has16m: level >= 3
	    		};
	    	}

	    	function supportsColor(stream) {
	    		if (forceColor === false) {
	    			return 0;
	    		}

	    		if (hasFlag('color=16m') ||
	    			hasFlag('color=full') ||
	    			hasFlag('color=truecolor')) {
	    			return 3;
	    		}

	    		if (hasFlag('color=256')) {
	    			return 2;
	    		}

	    		if (stream && !stream.isTTY && forceColor !== true) {
	    			return 0;
	    		}

	    		const min = forceColor ? 1 : 0;

	    		if (process.platform === 'win32') {
	    			// Node.js 7.5.0 is the first version of Node.js to include a patch to
	    			// libuv that enables 256 color output on Windows. Anything earlier and it
	    			// won't work. However, here we target Node.js 8 at minimum as it is an LTS
	    			// release, and Node.js 7 is not. Windows 10 build 10586 is the first Windows
	    			// release that supports 256 colors. Windows 10 build 14931 is the first release
	    			// that supports 16m/TrueColor.
	    			const osRelease = os.release().split('.');
	    			if (
	    				Number(process.versions.node.split('.')[0]) >= 8 &&
	    				Number(osRelease[0]) >= 10 &&
	    				Number(osRelease[2]) >= 10586
	    			) {
	    				return Number(osRelease[2]) >= 14931 ? 3 : 2;
	    			}

	    			return 1;
	    		}

	    		if ('CI' in env) {
	    			if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
	    				return 1;
	    			}

	    			return min;
	    		}

	    		if ('TEAMCITY_VERSION' in env) {
	    			return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
	    		}

	    		if (env.COLORTERM === 'truecolor') {
	    			return 3;
	    		}

	    		if ('TERM_PROGRAM' in env) {
	    			const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

	    			switch (env.TERM_PROGRAM) {
	    				case 'iTerm.app':
	    					return version >= 3 ? 3 : 2;
	    				case 'Apple_Terminal':
	    					return 2;
	    				// No default
	    			}
	    		}

	    		if (/-256(color)?$/i.test(env.TERM)) {
	    			return 2;
	    		}

	    		if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
	    			return 1;
	    		}

	    		if ('COLORTERM' in env) {
	    			return 1;
	    		}

	    		if (env.TERM === 'dumb') {
	    			return min;
	    		}

	    		return min;
	    	}

	    	function getSupportLevel(stream) {
	    		const level = supportsColor(stream);
	    		return translateLevel(level);
	    	}

	    	supportsColor_1 = {
	    		supportsColor: getSupportLevel,
	    		stdout: getSupportLevel(process.stdout),
	    		stderr: getSupportLevel(process.stderr)
	    	};
	    	return supportsColor_1;
	    }

	    var hasRequiredNode;

	    function requireNode () {
	    	if (hasRequiredNode) return node.exports;
	    	hasRequiredNode = 1;
	    	(function (module, exports) {
	    		const tty = require$$0__default$1["default"];
	    		const util = require$$1__default["default"];

	    		/**
	    		 * This is the Node.js implementation of `debug()`.
	    		 */

	    		exports.init = init;
	    		exports.log = log;
	    		exports.formatArgs = formatArgs;
	    		exports.save = save;
	    		exports.load = load;
	    		exports.useColors = useColors;
	    		exports.destroy = util.deprecate(
	    			() => {},
	    			'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
	    		);

	    		/**
	    		 * Colors.
	    		 */

	    		exports.colors = [6, 2, 3, 4, 5, 1];

	    		try {
	    			// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
	    			// eslint-disable-next-line import/no-extraneous-dependencies
	    			const supportsColor = requireSupportsColor();

	    			if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
	    				exports.colors = [
	    					20,
	    					21,
	    					26,
	    					27,
	    					32,
	    					33,
	    					38,
	    					39,
	    					40,
	    					41,
	    					42,
	    					43,
	    					44,
	    					45,
	    					56,
	    					57,
	    					62,
	    					63,
	    					68,
	    					69,
	    					74,
	    					75,
	    					76,
	    					77,
	    					78,
	    					79,
	    					80,
	    					81,
	    					92,
	    					93,
	    					98,
	    					99,
	    					112,
	    					113,
	    					128,
	    					129,
	    					134,
	    					135,
	    					148,
	    					149,
	    					160,
	    					161,
	    					162,
	    					163,
	    					164,
	    					165,
	    					166,
	    					167,
	    					168,
	    					169,
	    					170,
	    					171,
	    					172,
	    					173,
	    					178,
	    					179,
	    					184,
	    					185,
	    					196,
	    					197,
	    					198,
	    					199,
	    					200,
	    					201,
	    					202,
	    					203,
	    					204,
	    					205,
	    					206,
	    					207,
	    					208,
	    					209,
	    					214,
	    					215,
	    					220,
	    					221
	    				];
	    			}
	    		} catch (error) {
	    			// Swallow - we only care if `supports-color` is available; it doesn't have to be.
	    		}

	    		/**
	    		 * Build up the default `inspectOpts` object from the environment variables.
	    		 *
	    		 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
	    		 */

	    		exports.inspectOpts = Object.keys(process.env).filter(key => {
	    			return /^debug_/i.test(key);
	    		}).reduce((obj, key) => {
	    			// Camel-case
	    			const prop = key
	    				.substring(6)
	    				.toLowerCase()
	    				.replace(/_([a-z])/g, (_, k) => {
	    					return k.toUpperCase();
	    				});

	    			// Coerce string value into JS value
	    			let val = process.env[key];
	    			if (/^(yes|on|true|enabled)$/i.test(val)) {
	    				val = true;
	    			} else if (/^(no|off|false|disabled)$/i.test(val)) {
	    				val = false;
	    			} else if (val === 'null') {
	    				val = null;
	    			} else {
	    				val = Number(val);
	    			}

	    			obj[prop] = val;
	    			return obj;
	    		}, {});

	    		/**
	    		 * Is stdout a TTY? Colored output is enabled when `true`.
	    		 */

	    		function useColors() {
	    			return 'colors' in exports.inspectOpts ?
	    				Boolean(exports.inspectOpts.colors) :
	    				tty.isatty(process.stderr.fd);
	    		}

	    		/**
	    		 * Adds ANSI color escape codes if enabled.
	    		 *
	    		 * @api public
	    		 */

	    		function formatArgs(args) {
	    			const {namespace: name, useColors} = this;

	    			if (useColors) {
	    				const c = this.color;
	    				const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
	    				const prefix = `  ${colorCode};1m${name} \u001B[0m`;

	    				args[0] = prefix + args[0].split('\n').join('\n' + prefix);
	    				args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
	    			} else {
	    				args[0] = getDate() + name + ' ' + args[0];
	    			}
	    		}

	    		function getDate() {
	    			if (exports.inspectOpts.hideDate) {
	    				return '';
	    			}
	    			return new Date().toISOString() + ' ';
	    		}

	    		/**
	    		 * Invokes `util.format()` with the specified arguments and writes to stderr.
	    		 */

	    		function log(...args) {
	    			return process.stderr.write(util.format(...args) + '\n');
	    		}

	    		/**
	    		 * Save `namespaces`.
	    		 *
	    		 * @param {String} namespaces
	    		 * @api private
	    		 */
	    		function save(namespaces) {
	    			if (namespaces) {
	    				process.env.DEBUG = namespaces;
	    			} else {
	    				// If you set a process.env field to null or undefined, it gets cast to the
	    				// string 'null' or 'undefined'. Just delete instead.
	    				delete process.env.DEBUG;
	    			}
	    		}

	    		/**
	    		 * Load `namespaces`.
	    		 *
	    		 * @return {String} returns the previously persisted debug modes
	    		 * @api private
	    		 */

	    		function load() {
	    			return process.env.DEBUG;
	    		}

	    		/**
	    		 * Init logic for `debug` instances.
	    		 *
	    		 * Create a new `inspectOpts` object in case `useColors` is set
	    		 * differently for a particular `debug` instance.
	    		 */

	    		function init(debug) {
	    			debug.inspectOpts = {};

	    			const keys = Object.keys(exports.inspectOpts);
	    			for (let i = 0; i < keys.length; i++) {
	    				debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
	    			}
	    		}

	    		module.exports = requireCommon()(exports);

	    		const {formatters} = module.exports;

	    		/**
	    		 * Map %o to `util.inspect()`, all on a single line.
	    		 */

	    		formatters.o = function (v) {
	    			this.inspectOpts.colors = this.useColors;
	    			return util.inspect(v, this.inspectOpts)
	    				.split('\n')
	    				.map(str => str.trim())
	    				.join(' ');
	    		};

	    		/**
	    		 * Map %O to `util.inspect()`, allowing multiple lines if needed.
	    		 */

	    		formatters.O = function (v) {
	    			this.inspectOpts.colors = this.useColors;
	    			return util.inspect(v, this.inspectOpts);
	    		}; 
	    	} (node, node.exports));
	    	return node.exports;
	    }

	    var hasRequiredSrc;

	    function requireSrc () {
	    	if (hasRequiredSrc) return src.exports;
	    	hasRequiredSrc = 1;
	    	if (typeof process === 'undefined' || process.type === 'renderer' || browser$1 === true || process.__nwjs) {
	    		src.exports = requireBrowser();
	    	} else {
	    		src.exports = requireNode();
	    	}
	    	return src.exports;
	    }

	    var debug_1;
	    var hasRequiredDebug;

	    function requireDebug () {
	    	if (hasRequiredDebug) return debug_1;
	    	hasRequiredDebug = 1;
	    	var debug;

	    	debug_1 = function () {
	    	  if (!debug) {
	    	    try {
	    	      /* eslint global-require: off */
	    	      debug = requireSrc()("follow-redirects");
	    	    }
	    	    catch (error) { /* */ }
	    	    if (typeof debug !== "function") {
	    	      debug = function () { /* */ };
	    	    }
	    	  }
	    	  debug.apply(null, arguments);
	    	};
	    	return debug_1;
	    }

	    var hasRequiredFollowRedirects;

	    function requireFollowRedirects () {
	    	if (hasRequiredFollowRedirects) return followRedirects.exports;
	    	hasRequiredFollowRedirects = 1;
	    	var url = require$$0__default$2["default"];
	    	var URL = url.URL;
	    	var http = require$$1__default$1["default"];
	    	var https = require$$2__default["default"];
	    	var Writable = require$$3__default["default"].Writable;
	    	var assert = require$$4__default["default"];
	    	var debug = requireDebug();

	    	// Create handlers that pass events from native requests
	    	var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
	    	var eventHandlers = Object.create(null);
	    	events.forEach(function (event) {
	    	  eventHandlers[event] = function (arg1, arg2, arg3) {
	    	    this._redirectable.emit(event, arg1, arg2, arg3);
	    	  };
	    	});

	    	var InvalidUrlError = createErrorType(
	    	  "ERR_INVALID_URL",
	    	  "Invalid URL",
	    	  TypeError
	    	);
	    	// Error types with codes
	    	var RedirectionError = createErrorType(
	    	  "ERR_FR_REDIRECTION_FAILURE",
	    	  "Redirected request failed"
	    	);
	    	var TooManyRedirectsError = createErrorType(
	    	  "ERR_FR_TOO_MANY_REDIRECTS",
	    	  "Maximum number of redirects exceeded"
	    	);
	    	var MaxBodyLengthExceededError = createErrorType(
	    	  "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
	    	  "Request body larger than maxBodyLength limit"
	    	);
	    	var WriteAfterEndError = createErrorType(
	    	  "ERR_STREAM_WRITE_AFTER_END",
	    	  "write after end"
	    	);

	    	// An HTTP(S) request that can be redirected
	    	function RedirectableRequest(options, responseCallback) {
	    	  // Initialize the request
	    	  Writable.call(this);
	    	  this._sanitizeOptions(options);
	    	  this._options = options;
	    	  this._ended = false;
	    	  this._ending = false;
	    	  this._redirectCount = 0;
	    	  this._redirects = [];
	    	  this._requestBodyLength = 0;
	    	  this._requestBodyBuffers = [];

	    	  // Attach a callback if passed
	    	  if (responseCallback) {
	    	    this.on("response", responseCallback);
	    	  }

	    	  // React to responses of native requests
	    	  var self = this;
	    	  this._onNativeResponse = function (response) {
	    	    self._processResponse(response);
	    	  };

	    	  // Perform the first request
	    	  this._performRequest();
	    	}
	    	RedirectableRequest.prototype = Object.create(Writable.prototype);

	    	RedirectableRequest.prototype.abort = function () {
	    	  abortRequest(this._currentRequest);
	    	  this.emit("abort");
	    	};

	    	// Writes buffered data to the current native request
	    	RedirectableRequest.prototype.write = function (data, encoding, callback) {
	    	  // Writing is not allowed if end has been called
	    	  if (this._ending) {
	    	    throw new WriteAfterEndError();
	    	  }

	    	  // Validate input and shift parameters if necessary
	    	  if (!isString(data) && !isBuffer(data)) {
	    	    throw new TypeError("data should be a string, Buffer or Uint8Array");
	    	  }
	    	  if (isFunction(encoding)) {
	    	    callback = encoding;
	    	    encoding = null;
	    	  }

	    	  // Ignore empty buffers, since writing them doesn't invoke the callback
	    	  // https://github.com/nodejs/node/issues/22066
	    	  if (data.length === 0) {
	    	    if (callback) {
	    	      callback();
	    	    }
	    	    return;
	    	  }
	    	  // Only write when we don't exceed the maximum body length
	    	  if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
	    	    this._requestBodyLength += data.length;
	    	    this._requestBodyBuffers.push({ data: data, encoding: encoding });
	    	    this._currentRequest.write(data, encoding, callback);
	    	  }
	    	  // Error when we exceed the maximum body length
	    	  else {
	    	    this.emit("error", new MaxBodyLengthExceededError());
	    	    this.abort();
	    	  }
	    	};

	    	// Ends the current native request
	    	RedirectableRequest.prototype.end = function (data, encoding, callback) {
	    	  // Shift parameters if necessary
	    	  if (isFunction(data)) {
	    	    callback = data;
	    	    data = encoding = null;
	    	  }
	    	  else if (isFunction(encoding)) {
	    	    callback = encoding;
	    	    encoding = null;
	    	  }

	    	  // Write data if needed and end
	    	  if (!data) {
	    	    this._ended = this._ending = true;
	    	    this._currentRequest.end(null, null, callback);
	    	  }
	    	  else {
	    	    var self = this;
	    	    var currentRequest = this._currentRequest;
	    	    this.write(data, encoding, function () {
	    	      self._ended = true;
	    	      currentRequest.end(null, null, callback);
	    	    });
	    	    this._ending = true;
	    	  }
	    	};

	    	// Sets a header value on the current native request
	    	RedirectableRequest.prototype.setHeader = function (name, value) {
	    	  this._options.headers[name] = value;
	    	  this._currentRequest.setHeader(name, value);
	    	};

	    	// Clears a header value on the current native request
	    	RedirectableRequest.prototype.removeHeader = function (name) {
	    	  delete this._options.headers[name];
	    	  this._currentRequest.removeHeader(name);
	    	};

	    	// Global timeout for all underlying requests
	    	RedirectableRequest.prototype.setTimeout = function (msecs, callback) {
	    	  var self = this;

	    	  // Destroys the socket on timeout
	    	  function destroyOnTimeout(socket) {
	    	    socket.setTimeout(msecs);
	    	    socket.removeListener("timeout", socket.destroy);
	    	    socket.addListener("timeout", socket.destroy);
	    	  }

	    	  // Sets up a timer to trigger a timeout event
	    	  function startTimer(socket) {
	    	    if (self._timeout) {
	    	      clearTimeout(self._timeout);
	    	    }
	    	    self._timeout = setTimeout(function () {
	    	      self.emit("timeout");
	    	      clearTimer();
	    	    }, msecs);
	    	    destroyOnTimeout(socket);
	    	  }

	    	  // Stops a timeout from triggering
	    	  function clearTimer() {
	    	    // Clear the timeout
	    	    if (self._timeout) {
	    	      clearTimeout(self._timeout);
	    	      self._timeout = null;
	    	    }

	    	    // Clean up all attached listeners
	    	    self.removeListener("abort", clearTimer);
	    	    self.removeListener("error", clearTimer);
	    	    self.removeListener("response", clearTimer);
	    	    if (callback) {
	    	      self.removeListener("timeout", callback);
	    	    }
	    	    if (!self.socket) {
	    	      self._currentRequest.removeListener("socket", startTimer);
	    	    }
	    	  }

	    	  // Attach callback if passed
	    	  if (callback) {
	    	    this.on("timeout", callback);
	    	  }

	    	  // Start the timer if or when the socket is opened
	    	  if (this.socket) {
	    	    startTimer(this.socket);
	    	  }
	    	  else {
	    	    this._currentRequest.once("socket", startTimer);
	    	  }

	    	  // Clean up on events
	    	  this.on("socket", destroyOnTimeout);
	    	  this.on("abort", clearTimer);
	    	  this.on("error", clearTimer);
	    	  this.on("response", clearTimer);

	    	  return this;
	    	};

	    	// Proxy all other public ClientRequest methods
	    	[
	    	  "flushHeaders", "getHeader",
	    	  "setNoDelay", "setSocketKeepAlive",
	    	].forEach(function (method) {
	    	  RedirectableRequest.prototype[method] = function (a, b) {
	    	    return this._currentRequest[method](a, b);
	    	  };
	    	});

	    	// Proxy all public ClientRequest properties
	    	["aborted", "connection", "socket"].forEach(function (property) {
	    	  Object.defineProperty(RedirectableRequest.prototype, property, {
	    	    get: function () { return this._currentRequest[property]; },
	    	  });
	    	});

	    	RedirectableRequest.prototype._sanitizeOptions = function (options) {
	    	  // Ensure headers are always present
	    	  if (!options.headers) {
	    	    options.headers = {};
	    	  }

	    	  // Since http.request treats host as an alias of hostname,
	    	  // but the url module interprets host as hostname plus port,
	    	  // eliminate the host property to avoid confusion.
	    	  if (options.host) {
	    	    // Use hostname if set, because it has precedence
	    	    if (!options.hostname) {
	    	      options.hostname = options.host;
	    	    }
	    	    delete options.host;
	    	  }

	    	  // Complete the URL object when necessary
	    	  if (!options.pathname && options.path) {
	    	    var searchPos = options.path.indexOf("?");
	    	    if (searchPos < 0) {
	    	      options.pathname = options.path;
	    	    }
	    	    else {
	    	      options.pathname = options.path.substring(0, searchPos);
	    	      options.search = options.path.substring(searchPos);
	    	    }
	    	  }
	    	};


	    	// Executes the next native request (initial or redirect)
	    	RedirectableRequest.prototype._performRequest = function () {
	    	  // Load the native protocol
	    	  var protocol = this._options.protocol;
	    	  var nativeProtocol = this._options.nativeProtocols[protocol];
	    	  if (!nativeProtocol) {
	    	    this.emit("error", new TypeError("Unsupported protocol " + protocol));
	    	    return;
	    	  }

	    	  // If specified, use the agent corresponding to the protocol
	    	  // (HTTP and HTTPS use different types of agents)
	    	  if (this._options.agents) {
	    	    var scheme = protocol.slice(0, -1);
	    	    this._options.agent = this._options.agents[scheme];
	    	  }

	    	  // Create the native request and set up its event handlers
	    	  var request = this._currentRequest =
	    	        nativeProtocol.request(this._options, this._onNativeResponse);
	    	  request._redirectable = this;
	    	  for (var event of events) {
	    	    request.on(event, eventHandlers[event]);
	    	  }

	    	  // RFC72305.3.1: When making a request directly to an origin server, []
	    	  // a client MUST send only the absolute path [] as the request-target.
	    	  this._currentUrl = /^\//.test(this._options.path) ?
	    	    url.format(this._options) :
	    	    // When making a request to a proxy, []
	    	    // a client MUST send the target URI in absolute-form [].
	    	    this._options.path;

	    	  // End a redirected request
	    	  // (The first request must be ended explicitly with RedirectableRequest#end)
	    	  if (this._isRedirect) {
	    	    // Write the request entity and end
	    	    var i = 0;
	    	    var self = this;
	    	    var buffers = this._requestBodyBuffers;
	    	    (function writeNext(error) {
	    	      // Only write if this request has not been redirected yet
	    	      /* istanbul ignore else */
	    	      if (request === self._currentRequest) {
	    	        // Report any write errors
	    	        /* istanbul ignore if */
	    	        if (error) {
	    	          self.emit("error", error);
	    	        }
	    	        // Write the next buffer if there are still left
	    	        else if (i < buffers.length) {
	    	          var buffer = buffers[i++];
	    	          /* istanbul ignore else */
	    	          if (!request.finished) {
	    	            request.write(buffer.data, buffer.encoding, writeNext);
	    	          }
	    	        }
	    	        // End the request if `end` has been called on us
	    	        else if (self._ended) {
	    	          request.end();
	    	        }
	    	      }
	    	    }());
	    	  }
	    	};

	    	// Processes a response from the current native request
	    	RedirectableRequest.prototype._processResponse = function (response) {
	    	  // Store the redirected response
	    	  var statusCode = response.statusCode;
	    	  if (this._options.trackRedirects) {
	    	    this._redirects.push({
	    	      url: this._currentUrl,
	    	      headers: response.headers,
	    	      statusCode: statusCode,
	    	    });
	    	  }

	    	  // RFC72316.4: The 3xx (Redirection) class of status code indicates
	    	  // that further action needs to be taken by the user agent in order to
	    	  // fulfill the request. If a Location header field is provided,
	    	  // the user agent MAY automatically redirect its request to the URI
	    	  // referenced by the Location field value,
	    	  // even if the specific status code is not understood.

	    	  // If the response is not a redirect; return it as-is
	    	  var location = response.headers.location;
	    	  if (!location || this._options.followRedirects === false ||
	    	      statusCode < 300 || statusCode >= 400) {
	    	    response.responseUrl = this._currentUrl;
	    	    response.redirects = this._redirects;
	    	    this.emit("response", response);

	    	    // Clean up
	    	    this._requestBodyBuffers = [];
	    	    return;
	    	  }

	    	  // The response is a redirect, so abort the current request
	    	  abortRequest(this._currentRequest);
	    	  // Discard the remainder of the response to avoid waiting for data
	    	  response.destroy();

	    	  // RFC72316.4: A client SHOULD detect and intervene
	    	  // in cyclical redirections (i.e., "infinite" redirection loops).
	    	  if (++this._redirectCount > this._options.maxRedirects) {
	    	    this.emit("error", new TooManyRedirectsError());
	    	    return;
	    	  }

	    	  // Store the request headers if applicable
	    	  var requestHeaders;
	    	  var beforeRedirect = this._options.beforeRedirect;
	    	  if (beforeRedirect) {
	    	    requestHeaders = Object.assign({
	    	      // The Host header was set by nativeProtocol.request
	    	      Host: response.req.getHeader("host"),
	    	    }, this._options.headers);
	    	  }

	    	  // RFC72316.4: Automatic redirection needs to done with
	    	  // care for methods not known to be safe, []
	    	  // RFC72316.4.23: For historical reasons, a user agent MAY change
	    	  // the request method from POST to GET for the subsequent request.
	    	  var method = this._options.method;
	    	  if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" ||
	    	      // RFC72316.4.4: The 303 (See Other) status code indicates that
	    	      // the server is redirecting the user agent to a different resource []
	    	      // A user agent can perform a retrieval request targeting that URI
	    	      // (a GET or HEAD request if using HTTP) []
	    	      (statusCode === 303) && !/^(?:GET|HEAD)$/.test(this._options.method)) {
	    	    this._options.method = "GET";
	    	    // Drop a possible entity and headers related to it
	    	    this._requestBodyBuffers = [];
	    	    removeMatchingHeaders(/^content-/i, this._options.headers);
	    	  }

	    	  // Drop the Host header, as the redirect might lead to a different host
	    	  var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);

	    	  // If the redirect is relative, carry over the host of the last request
	    	  var currentUrlParts = url.parse(this._currentUrl);
	    	  var currentHost = currentHostHeader || currentUrlParts.host;
	    	  var currentUrl = /^\w+:/.test(location) ? this._currentUrl :
	    	    url.format(Object.assign(currentUrlParts, { host: currentHost }));

	    	  // Determine the URL of the redirection
	    	  var redirectUrl;
	    	  try {
	    	    redirectUrl = url.resolve(currentUrl, location);
	    	  }
	    	  catch (cause) {
	    	    this.emit("error", new RedirectionError({ cause: cause }));
	    	    return;
	    	  }

	    	  // Create the redirected request
	    	  debug("redirecting to", redirectUrl);
	    	  this._isRedirect = true;
	    	  var redirectUrlParts = url.parse(redirectUrl);
	    	  Object.assign(this._options, redirectUrlParts);

	    	  // Drop confidential headers when redirecting to a less secure protocol
	    	  // or to a different domain that is not a superdomain
	    	  if (redirectUrlParts.protocol !== currentUrlParts.protocol &&
	    	     redirectUrlParts.protocol !== "https:" ||
	    	     redirectUrlParts.host !== currentHost &&
	    	     !isSubdomain(redirectUrlParts.host, currentHost)) {
	    	    removeMatchingHeaders(/^(?:authorization|cookie)$/i, this._options.headers);
	    	  }

	    	  // Evaluate the beforeRedirect callback
	    	  if (isFunction(beforeRedirect)) {
	    	    var responseDetails = {
	    	      headers: response.headers,
	    	      statusCode: statusCode,
	    	    };
	    	    var requestDetails = {
	    	      url: currentUrl,
	    	      method: method,
	    	      headers: requestHeaders,
	    	    };
	    	    try {
	    	      beforeRedirect(this._options, responseDetails, requestDetails);
	    	    }
	    	    catch (err) {
	    	      this.emit("error", err);
	    	      return;
	    	    }
	    	    this._sanitizeOptions(this._options);
	    	  }

	    	  // Perform the redirected request
	    	  try {
	    	    this._performRequest();
	    	  }
	    	  catch (cause) {
	    	    this.emit("error", new RedirectionError({ cause: cause }));
	    	  }
	    	};

	    	// Wraps the key/value object of protocols with redirect functionality
	    	function wrap(protocols) {
	    	  // Default settings
	    	  var exports = {
	    	    maxRedirects: 21,
	    	    maxBodyLength: 10 * 1024 * 1024,
	    	  };

	    	  // Wrap each protocol
	    	  var nativeProtocols = {};
	    	  Object.keys(protocols).forEach(function (scheme) {
	    	    var protocol = scheme + ":";
	    	    var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
	    	    var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);

	    	    // Executes a request, following redirects
	    	    function request(input, options, callback) {
	    	      // Parse parameters
	    	      if (isString(input)) {
	    	        var parsed;
	    	        try {
	    	          parsed = urlToOptions(new URL(input));
	    	        }
	    	        catch (err) {
	    	          /* istanbul ignore next */
	    	          parsed = url.parse(input);
	    	        }
	    	        if (!isString(parsed.protocol)) {
	    	          throw new InvalidUrlError({ input });
	    	        }
	    	        input = parsed;
	    	      }
	    	      else if (URL && (input instanceof URL)) {
	    	        input = urlToOptions(input);
	    	      }
	    	      else {
	    	        callback = options;
	    	        options = input;
	    	        input = { protocol: protocol };
	    	      }
	    	      if (isFunction(options)) {
	    	        callback = options;
	    	        options = null;
	    	      }

	    	      // Set defaults
	    	      options = Object.assign({
	    	        maxRedirects: exports.maxRedirects,
	    	        maxBodyLength: exports.maxBodyLength,
	    	      }, input, options);
	    	      options.nativeProtocols = nativeProtocols;
	    	      if (!isString(options.host) && !isString(options.hostname)) {
	    	        options.hostname = "::1";
	    	      }

	    	      assert.equal(options.protocol, protocol, "protocol mismatch");
	    	      debug("options", options);
	    	      return new RedirectableRequest(options, callback);
	    	    }

	    	    // Executes a GET request, following redirects
	    	    function get(input, options, callback) {
	    	      var wrappedRequest = wrappedProtocol.request(input, options, callback);
	    	      wrappedRequest.end();
	    	      return wrappedRequest;
	    	    }

	    	    // Expose the properties on the wrapped protocol
	    	    Object.defineProperties(wrappedProtocol, {
	    	      request: { value: request, configurable: true, enumerable: true, writable: true },
	    	      get: { value: get, configurable: true, enumerable: true, writable: true },
	    	    });
	    	  });
	    	  return exports;
	    	}

	    	/* istanbul ignore next */
	    	function noop() { /* empty */ }

	    	// from https://github.com/nodejs/node/blob/master/lib/internal/url.js
	    	function urlToOptions(urlObject) {
	    	  var options = {
	    	    protocol: urlObject.protocol,
	    	    hostname: urlObject.hostname.startsWith("[") ?
	    	      /* istanbul ignore next */
	    	      urlObject.hostname.slice(1, -1) :
	    	      urlObject.hostname,
	    	    hash: urlObject.hash,
	    	    search: urlObject.search,
	    	    pathname: urlObject.pathname,
	    	    path: urlObject.pathname + urlObject.search,
	    	    href: urlObject.href,
	    	  };
	    	  if (urlObject.port !== "") {
	    	    options.port = Number(urlObject.port);
	    	  }
	    	  return options;
	    	}

	    	function removeMatchingHeaders(regex, headers) {
	    	  var lastValue;
	    	  for (var header in headers) {
	    	    if (regex.test(header)) {
	    	      lastValue = headers[header];
	    	      delete headers[header];
	    	    }
	    	  }
	    	  return (lastValue === null || typeof lastValue === "undefined") ?
	    	    undefined : String(lastValue).trim();
	    	}

	    	function createErrorType(code, message, baseClass) {
	    	  // Create constructor
	    	  function CustomError(properties) {
	    	    Error.captureStackTrace(this, this.constructor);
	    	    Object.assign(this, properties || {});
	    	    this.code = code;
	    	    this.message = this.cause ? message + ": " + this.cause.message : message;
	    	  }

	    	  // Attach constructor and set default properties
	    	  CustomError.prototype = new (baseClass || Error)();
	    	  CustomError.prototype.constructor = CustomError;
	    	  CustomError.prototype.name = "Error [" + code + "]";
	    	  return CustomError;
	    	}

	    	function abortRequest(request) {
	    	  for (var event of events) {
	    	    request.removeListener(event, eventHandlers[event]);
	    	  }
	    	  request.on("error", noop);
	    	  request.abort();
	    	}

	    	function isSubdomain(subdomain, domain) {
	    	  assert(isString(subdomain) && isString(domain));
	    	  var dot = subdomain.length - domain.length - 1;
	    	  return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
	    	}

	    	function isString(value) {
	    	  return typeof value === "string" || value instanceof String;
	    	}

	    	function isFunction(value) {
	    	  return typeof value === "function";
	    	}

	    	function isBuffer(value) {
	    	  return typeof value === "object" && ("length" in value);
	    	}

	    	// Exports
	    	followRedirects.exports = wrap({ http: http, https: https });
	    	followRedirects.exports.wrap = wrap;
	    	return followRedirects.exports;
	    }

	    var data;
	    var hasRequiredData;

	    function requireData () {
	    	if (hasRequiredData) return data;
	    	hasRequiredData = 1;
	    	data = {
	    	  "version": "0.27.2"
	    	};
	    	return data;
	    }

	    var http_1;
	    var hasRequiredHttp;

	    function requireHttp () {
	    	if (hasRequiredHttp) return http_1;
	    	hasRequiredHttp = 1;

	    	var utils = requireUtils();
	    	var settle = requireSettle();
	    	var buildFullPath = requireBuildFullPath();
	    	var buildURL = requireBuildURL();
	    	var http = require$$1__default$1["default"];
	    	var https = require$$2__default["default"];
	    	var httpFollow = requireFollowRedirects().http;
	    	var httpsFollow = requireFollowRedirects().https;
	    	var url = require$$0__default$2["default"];
	    	var zlib = require$$8__default["default"];
	    	var VERSION = requireData().version;
	    	var transitionalDefaults = requireTransitional();
	    	var AxiosError = requireAxiosError();
	    	var CanceledError = requireCanceledError();

	    	var isHttps = /https:?/;

	    	var supportedProtocols = [ 'http:', 'https:', 'file:' ];

	    	/**
	    	 *
	    	 * @param {http.ClientRequestArgs} options
	    	 * @param {AxiosProxyConfig} proxy
	    	 * @param {string} location
	    	 */
	    	function setProxy(options, proxy, location) {
	    	  options.hostname = proxy.host;
	    	  options.host = proxy.host;
	    	  options.port = proxy.port;
	    	  options.path = location;

	    	  // Basic proxy authorization
	    	  if (proxy.auth) {
	    	    var base64 = Buffer.from(proxy.auth.username + ':' + proxy.auth.password, 'utf8').toString('base64');
	    	    options.headers['Proxy-Authorization'] = 'Basic ' + base64;
	    	  }

	    	  // If a proxy is used, any redirects must also pass through the proxy
	    	  options.beforeRedirect = function beforeRedirect(redirection) {
	    	    redirection.headers.host = redirection.host;
	    	    setProxy(redirection, proxy, redirection.href);
	    	  };
	    	}

	    	/*eslint consistent-return:0*/
	    	http_1 = function httpAdapter(config) {
	    	  return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) {
	    	    var onCanceled;
	    	    function done() {
	    	      if (config.cancelToken) {
	    	        config.cancelToken.unsubscribe(onCanceled);
	    	      }

	    	      if (config.signal) {
	    	        config.signal.removeEventListener('abort', onCanceled);
	    	      }
	    	    }
	    	    var resolve = function resolve(value) {
	    	      done();
	    	      resolvePromise(value);
	    	    };
	    	    var rejected = false;
	    	    var reject = function reject(value) {
	    	      done();
	    	      rejected = true;
	    	      rejectPromise(value);
	    	    };
	    	    var data = config.data;
	    	    var headers = config.headers;
	    	    var headerNames = {};

	    	    Object.keys(headers).forEach(function storeLowerName(name) {
	    	      headerNames[name.toLowerCase()] = name;
	    	    });

	    	    // Set User-Agent (required by some servers)
	    	    // See https://github.com/axios/axios/issues/69
	    	    if ('user-agent' in headerNames) {
	    	      // User-Agent is specified; handle case where no UA header is desired
	    	      if (!headers[headerNames['user-agent']]) {
	    	        delete headers[headerNames['user-agent']];
	    	      }
	    	      // Otherwise, use specified value
	    	    } else {
	    	      // Only set header if it hasn't been set in config
	    	      headers['User-Agent'] = 'axios/' + VERSION;
	    	    }

	    	    // support for https://www.npmjs.com/package/form-data api
	    	    if (utils.isFormData(data) && utils.isFunction(data.getHeaders)) {
	    	      Object.assign(headers, data.getHeaders());
	    	    } else if (data && !utils.isStream(data)) {
	    	      if (isBuffer(data)) ; else if (utils.isArrayBuffer(data)) {
	    	        data = Buffer.from(new Uint8Array(data));
	    	      } else if (utils.isString(data)) {
	    	        data = Buffer.from(data, 'utf-8');
	    	      } else {
	    	        return reject(new AxiosError(
	    	          'Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream',
	    	          AxiosError.ERR_BAD_REQUEST,
	    	          config
	    	        ));
	    	      }

	    	      if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {
	    	        return reject(new AxiosError(
	    	          'Request body larger than maxBodyLength limit',
	    	          AxiosError.ERR_BAD_REQUEST,
	    	          config
	    	        ));
	    	      }

	    	      // Add Content-Length header if data exists
	    	      if (!headerNames['content-length']) {
	    	        headers['Content-Length'] = data.length;
	    	      }
	    	    }

	    	    // HTTP basic authentication
	    	    var auth = undefined;
	    	    if (config.auth) {
	    	      var username = config.auth.username || '';
	    	      var password = config.auth.password || '';
	    	      auth = username + ':' + password;
	    	    }

	    	    // Parse url
	    	    var fullPath = buildFullPath(config.baseURL, config.url);
	    	    var parsed = url.parse(fullPath);
	    	    var protocol = parsed.protocol || supportedProtocols[0];

	    	    if (supportedProtocols.indexOf(protocol) === -1) {
	    	      return reject(new AxiosError(
	    	        'Unsupported protocol ' + protocol,
	    	        AxiosError.ERR_BAD_REQUEST,
	    	        config
	    	      ));
	    	    }

	    	    if (!auth && parsed.auth) {
	    	      var urlAuth = parsed.auth.split(':');
	    	      var urlUsername = urlAuth[0] || '';
	    	      var urlPassword = urlAuth[1] || '';
	    	      auth = urlUsername + ':' + urlPassword;
	    	    }

	    	    if (auth && headerNames.authorization) {
	    	      delete headers[headerNames.authorization];
	    	    }

	    	    var isHttpsRequest = isHttps.test(protocol);
	    	    var agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;

	    	    try {
	    	      buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\?/, '');
	    	    } catch (err) {
	    	      var customErr = new Error(err.message);
	    	      customErr.config = config;
	    	      customErr.url = config.url;
	    	      customErr.exists = true;
	    	      reject(customErr);
	    	    }

	    	    var options = {
	    	      path: buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\?/, ''),
	    	      method: config.method.toUpperCase(),
	    	      headers: headers,
	    	      agent: agent,
	    	      agents: { http: config.httpAgent, https: config.httpsAgent },
	    	      auth: auth
	    	    };

	    	    if (config.socketPath) {
	    	      options.socketPath = config.socketPath;
	    	    } else {
	    	      options.hostname = parsed.hostname;
	    	      options.port = parsed.port;
	    	    }

	    	    var proxy = config.proxy;
	    	    if (!proxy && proxy !== false) {
	    	      var proxyEnv = protocol.slice(0, -1) + '_proxy';
	    	      var proxyUrl = process.env[proxyEnv] || process.env[proxyEnv.toUpperCase()];
	    	      if (proxyUrl) {
	    	        var parsedProxyUrl = url.parse(proxyUrl);
	    	        var noProxyEnv = process.env.no_proxy || process.env.NO_PROXY;
	    	        var shouldProxy = true;

	    	        if (noProxyEnv) {
	    	          var noProxy = noProxyEnv.split(',').map(function trim(s) {
	    	            return s.trim();
	    	          });

	    	          shouldProxy = !noProxy.some(function proxyMatch(proxyElement) {
	    	            if (!proxyElement) {
	    	              return false;
	    	            }
	    	            if (proxyElement === '*') {
	    	              return true;
	    	            }
	    	            if (proxyElement[0] === '.' &&
	    	                parsed.hostname.substr(parsed.hostname.length - proxyElement.length) === proxyElement) {
	    	              return true;
	    	            }

	    	            return parsed.hostname === proxyElement;
	    	          });
	    	        }

	    	        if (shouldProxy) {
	    	          proxy = {
	    	            host: parsedProxyUrl.hostname,
	    	            port: parsedProxyUrl.port,
	    	            protocol: parsedProxyUrl.protocol
	    	          };

	    	          if (parsedProxyUrl.auth) {
	    	            var proxyUrlAuth = parsedProxyUrl.auth.split(':');
	    	            proxy.auth = {
	    	              username: proxyUrlAuth[0],
	    	              password: proxyUrlAuth[1]
	    	            };
	    	          }
	    	        }
	    	      }
	    	    }

	    	    if (proxy) {
	    	      options.headers.host = parsed.hostname + (parsed.port ? ':' + parsed.port : '');
	    	      setProxy(options, proxy, protocol + '//' + parsed.hostname + (parsed.port ? ':' + parsed.port : '') + options.path);
	    	    }

	    	    var transport;
	    	    var isHttpsProxy = isHttpsRequest && (proxy ? isHttps.test(proxy.protocol) : true);
	    	    if (config.transport) {
	    	      transport = config.transport;
	    	    } else if (config.maxRedirects === 0) {
	    	      transport = isHttpsProxy ? https : http;
	    	    } else {
	    	      if (config.maxRedirects) {
	    	        options.maxRedirects = config.maxRedirects;
	    	      }
	    	      if (config.beforeRedirect) {
	    	        options.beforeRedirect = config.beforeRedirect;
	    	      }
	    	      transport = isHttpsProxy ? httpsFollow : httpFollow;
	    	    }

	    	    if (config.maxBodyLength > -1) {
	    	      options.maxBodyLength = config.maxBodyLength;
	    	    }

	    	    if (config.insecureHTTPParser) {
	    	      options.insecureHTTPParser = config.insecureHTTPParser;
	    	    }

	    	    // Create the request
	    	    var req = transport.request(options, function handleResponse(res) {
	    	      if (req.aborted) return;

	    	      // uncompress the response body transparently if required
	    	      var stream = res;

	    	      // return the last request in case of redirects
	    	      var lastRequest = res.req || req;


	    	      // if no content, is HEAD request or decompress disabled we should not decompress
	    	      if (res.statusCode !== 204 && lastRequest.method !== 'HEAD' && config.decompress !== false) {
	    	        switch (res.headers['content-encoding']) {
	    	        /*eslint default-case:0*/
	    	        case 'gzip':
	    	        case 'compress':
	    	        case 'deflate':
	    	        // add the unzipper to the body stream processing pipeline
	    	          stream = stream.pipe(zlib.createUnzip());

	    	          // remove the content-encoding in order to not confuse downstream operations
	    	          delete res.headers['content-encoding'];
	    	          break;
	    	        }
	    	      }

	    	      var response = {
	    	        status: res.statusCode,
	    	        statusText: res.statusMessage,
	    	        headers: res.headers,
	    	        config: config,
	    	        request: lastRequest
	    	      };

	    	      if (config.responseType === 'stream') {
	    	        response.data = stream;
	    	        settle(resolve, reject, response);
	    	      } else {
	    	        var responseBuffer = [];
	    	        var totalResponseBytes = 0;
	    	        stream.on('data', function handleStreamData(chunk) {
	    	          responseBuffer.push(chunk);
	    	          totalResponseBytes += chunk.length;

	    	          // make sure the content length is not over the maxContentLength if specified
	    	          if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
	    	            // stream.destoy() emit aborted event before calling reject() on Node.js v16
	    	            rejected = true;
	    	            stream.destroy();
	    	            reject(new AxiosError('maxContentLength size of ' + config.maxContentLength + ' exceeded',
	    	              AxiosError.ERR_BAD_RESPONSE, config, lastRequest));
	    	          }
	    	        });

	    	        stream.on('aborted', function handlerStreamAborted() {
	    	          if (rejected) {
	    	            return;
	    	          }
	    	          stream.destroy();
	    	          reject(new AxiosError(
	    	            'maxContentLength size of ' + config.maxContentLength + ' exceeded',
	    	            AxiosError.ERR_BAD_RESPONSE,
	    	            config,
	    	            lastRequest
	    	          ));
	    	        });

	    	        stream.on('error', function handleStreamError(err) {
	    	          if (req.aborted) return;
	    	          reject(AxiosError.from(err, null, config, lastRequest));
	    	        });

	    	        stream.on('end', function handleStreamEnd() {
	    	          try {
	    	            var responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
	    	            if (config.responseType !== 'arraybuffer') {
	    	              responseData = responseData.toString(config.responseEncoding);
	    	              if (!config.responseEncoding || config.responseEncoding === 'utf8') {
	    	                responseData = utils.stripBOM(responseData);
	    	              }
	    	            }
	    	            response.data = responseData;
	    	          } catch (err) {
	    	            reject(AxiosError.from(err, null, config, response.request, response));
	    	          }
	    	          settle(resolve, reject, response);
	    	        });
	    	      }
	    	    });

	    	    // Handle errors
	    	    req.on('error', function handleRequestError(err) {
	    	      // @todo remove
	    	      // if (req.aborted && err.code !== AxiosError.ERR_FR_TOO_MANY_REDIRECTS) return;
	    	      reject(AxiosError.from(err, null, config, req));
	    	    });

	    	    // set tcp keep alive to prevent drop connection by peer
	    	    req.on('socket', function handleRequestSocket(socket) {
	    	      // default interval of sending ack packet is 1 minute
	    	      socket.setKeepAlive(true, 1000 * 60);
	    	    });

	    	    // Handle request timeout
	    	    if (config.timeout) {
	    	      // This is forcing a int timeout to avoid problems if the `req` interface doesn't handle other types.
	    	      var timeout = parseInt(config.timeout, 10);

	    	      if (isNaN(timeout)) {
	    	        reject(new AxiosError(
	    	          'error trying to parse `config.timeout` to int',
	    	          AxiosError.ERR_BAD_OPTION_VALUE,
	    	          config,
	    	          req
	    	        ));

	    	        return;
	    	      }

	    	      // Sometime, the response will be very slow, and does not respond, the connect event will be block by event loop system.
	    	      // And timer callback will be fired, and abort() will be invoked before connection, then get "socket hang up" and code ECONNRESET.
	    	      // At this time, if we have a large number of request, nodejs will hang up some socket on background. and the number will up and up.
	    	      // And then these socket which be hang up will devoring CPU little by little.
	    	      // ClientRequest.setTimeout will be fired on the specify milliseconds, and can make sure that abort() will be fired after connect.
	    	      req.setTimeout(timeout, function handleRequestTimeout() {
	    	        req.abort();
	    	        var transitional = config.transitional || transitionalDefaults;
	    	        reject(new AxiosError(
	    	          'timeout of ' + timeout + 'ms exceeded',
	    	          transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
	    	          config,
	    	          req
	    	        ));
	    	      });
	    	    }

	    	    if (config.cancelToken || config.signal) {
	    	      // Handle cancellation
	    	      // eslint-disable-next-line func-names
	    	      onCanceled = function(cancel) {
	    	        if (req.aborted) return;

	    	        req.abort();
	    	        reject(!cancel || (cancel && cancel.type) ? new CanceledError() : cancel);
	    	      };

	    	      config.cancelToken && config.cancelToken.subscribe(onCanceled);
	    	      if (config.signal) {
	    	        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);
	    	      }
	    	    }


	    	    // Send the request
	    	    if (utils.isStream(data)) {
	    	      data.on('error', function handleStreamError(err) {
	    	        reject(AxiosError.from(err, config, null, req));
	    	      }).pipe(req);
	    	    } else {
	    	      req.end(data);
	    	    }
	    	  });
	    	};
	    	return http_1;
	    }

	    var delayed_stream;
	    var hasRequiredDelayed_stream;

	    function requireDelayed_stream () {
	    	if (hasRequiredDelayed_stream) return delayed_stream;
	    	hasRequiredDelayed_stream = 1;
	    	var Stream = require$$3__default["default"].Stream;
	    	var util = require$$1__default["default"];

	    	delayed_stream = DelayedStream;
	    	function DelayedStream() {
	    	  this.source = null;
	    	  this.dataSize = 0;
	    	  this.maxDataSize = 1024 * 1024;
	    	  this.pauseStream = true;

	    	  this._maxDataSizeExceeded = false;
	    	  this._released = false;
	    	  this._bufferedEvents = [];
	    	}
	    	util.inherits(DelayedStream, Stream);

	    	DelayedStream.create = function(source, options) {
	    	  var delayedStream = new this();

	    	  options = options || {};
	    	  for (var option in options) {
	    	    delayedStream[option] = options[option];
	    	  }

	    	  delayedStream.source = source;

	    	  var realEmit = source.emit;
	    	  source.emit = function() {
	    	    delayedStream._handleEmit(arguments);
	    	    return realEmit.apply(source, arguments);
	    	  };

	    	  source.on('error', function() {});
	    	  if (delayedStream.pauseStream) {
	    	    source.pause();
	    	  }

	    	  return delayedStream;
	    	};

	    	Object.defineProperty(DelayedStream.prototype, 'readable', {
	    	  configurable: true,
	    	  enumerable: true,
	    	  get: function() {
	    	    return this.source.readable;
	    	  }
	    	});

	    	DelayedStream.prototype.setEncoding = function() {
	    	  return this.source.setEncoding.apply(this.source, arguments);
	    	};

	    	DelayedStream.prototype.resume = function() {
	    	  if (!this._released) {
	    	    this.release();
	    	  }

	    	  this.source.resume();
	    	};

	    	DelayedStream.prototype.pause = function() {
	    	  this.source.pause();
	    	};

	    	DelayedStream.prototype.release = function() {
	    	  this._released = true;

	    	  this._bufferedEvents.forEach(function(args) {
	    	    this.emit.apply(this, args);
	    	  }.bind(this));
	    	  this._bufferedEvents = [];
	    	};

	    	DelayedStream.prototype.pipe = function() {
	    	  var r = Stream.prototype.pipe.apply(this, arguments);
	    	  this.resume();
	    	  return r;
	    	};

	    	DelayedStream.prototype._handleEmit = function(args) {
	    	  if (this._released) {
	    	    this.emit.apply(this, args);
	    	    return;
	    	  }

	    	  if (args[0] === 'data') {
	    	    this.dataSize += args[1].length;
	    	    this._checkIfMaxDataSizeExceeded();
	    	  }

	    	  this._bufferedEvents.push(args);
	    	};

	    	DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
	    	  if (this._maxDataSizeExceeded) {
	    	    return;
	    	  }

	    	  if (this.dataSize <= this.maxDataSize) {
	    	    return;
	    	  }

	    	  this._maxDataSizeExceeded = true;
	    	  var message =
	    	    'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.';
	    	  this.emit('error', new Error(message));
	    	};
	    	return delayed_stream;
	    }

	    var combined_stream;
	    var hasRequiredCombined_stream;

	    function requireCombined_stream () {
	    	if (hasRequiredCombined_stream) return combined_stream;
	    	hasRequiredCombined_stream = 1;
	    	var util = require$$1__default["default"];
	    	var Stream = require$$3__default["default"].Stream;
	    	var DelayedStream = requireDelayed_stream();

	    	combined_stream = CombinedStream;
	    	function CombinedStream() {
	    	  this.writable = false;
	    	  this.readable = true;
	    	  this.dataSize = 0;
	    	  this.maxDataSize = 2 * 1024 * 1024;
	    	  this.pauseStreams = true;

	    	  this._released = false;
	    	  this._streams = [];
	    	  this._currentStream = null;
	    	  this._insideLoop = false;
	    	  this._pendingNext = false;
	    	}
	    	util.inherits(CombinedStream, Stream);

	    	CombinedStream.create = function(options) {
	    	  var combinedStream = new this();

	    	  options = options || {};
	    	  for (var option in options) {
	    	    combinedStream[option] = options[option];
	    	  }

	    	  return combinedStream;
	    	};

	    	CombinedStream.isStreamLike = function(stream) {
	    	  return (typeof stream !== 'function')
	    	    && (typeof stream !== 'string')
	    	    && (typeof stream !== 'boolean')
	    	    && (typeof stream !== 'number')
	    	    && (!isBuffer(stream));
	    	};

	    	CombinedStream.prototype.append = function(stream) {
	    	  var isStreamLike = CombinedStream.isStreamLike(stream);

	    	  if (isStreamLike) {
	    	    if (!(stream instanceof DelayedStream)) {
	    	      var newStream = DelayedStream.create(stream, {
	    	        maxDataSize: Infinity,
	    	        pauseStream: this.pauseStreams,
	    	      });
	    	      stream.on('data', this._checkDataSize.bind(this));
	    	      stream = newStream;
	    	    }

	    	    this._handleErrors(stream);

	    	    if (this.pauseStreams) {
	    	      stream.pause();
	    	    }
	    	  }

	    	  this._streams.push(stream);
	    	  return this;
	    	};

	    	CombinedStream.prototype.pipe = function(dest, options) {
	    	  Stream.prototype.pipe.call(this, dest, options);
	    	  this.resume();
	    	  return dest;
	    	};

	    	CombinedStream.prototype._getNext = function() {
	    	  this._currentStream = null;

	    	  if (this._insideLoop) {
	    	    this._pendingNext = true;
	    	    return; // defer call
	    	  }

	    	  this._insideLoop = true;
	    	  try {
	    	    do {
	    	      this._pendingNext = false;
	    	      this._realGetNext();
	    	    } while (this._pendingNext);
	    	  } finally {
	    	    this._insideLoop = false;
	    	  }
	    	};

	    	CombinedStream.prototype._realGetNext = function() {
	    	  var stream = this._streams.shift();


	    	  if (typeof stream == 'undefined') {
	    	    this.end();
	    	    return;
	    	  }

	    	  if (typeof stream !== 'function') {
	    	    this._pipeNext(stream);
	    	    return;
	    	  }

	    	  var getStream = stream;
	    	  getStream(function(stream) {
	    	    var isStreamLike = CombinedStream.isStreamLike(stream);
	    	    if (isStreamLike) {
	    	      stream.on('data', this._checkDataSize.bind(this));
	    	      this._handleErrors(stream);
	    	    }

	    	    this._pipeNext(stream);
	    	  }.bind(this));
	    	};

	    	CombinedStream.prototype._pipeNext = function(stream) {
	    	  this._currentStream = stream;

	    	  var isStreamLike = CombinedStream.isStreamLike(stream);
	    	  if (isStreamLike) {
	    	    stream.on('end', this._getNext.bind(this));
	    	    stream.pipe(this, {end: false});
	    	    return;
	    	  }

	    	  var value = stream;
	    	  this.write(value);
	    	  this._getNext();
	    	};

	    	CombinedStream.prototype._handleErrors = function(stream) {
	    	  var self = this;
	    	  stream.on('error', function(err) {
	    	    self._emitError(err);
	    	  });
	    	};

	    	CombinedStream.prototype.write = function(data) {
	    	  this.emit('data', data);
	    	};

	    	CombinedStream.prototype.pause = function() {
	    	  if (!this.pauseStreams) {
	    	    return;
	    	  }

	    	  if(this.pauseStreams && this._currentStream && typeof(this._currentStream.pause) == 'function') this._currentStream.pause();
	    	  this.emit('pause');
	    	};

	    	CombinedStream.prototype.resume = function() {
	    	  if (!this._released) {
	    	    this._released = true;
	    	    this.writable = true;
	    	    this._getNext();
	    	  }

	    	  if(this.pauseStreams && this._currentStream && typeof(this._currentStream.resume) == 'function') this._currentStream.resume();
	    	  this.emit('resume');
	    	};

	    	CombinedStream.prototype.end = function() {
	    	  this._reset();
	    	  this.emit('end');
	    	};

	    	CombinedStream.prototype.destroy = function() {
	    	  this._reset();
	    	  this.emit('close');
	    	};

	    	CombinedStream.prototype._reset = function() {
	    	  this.writable = false;
	    	  this._streams = [];
	    	  this._currentStream = null;
	    	};

	    	CombinedStream.prototype._checkDataSize = function() {
	    	  this._updateDataSize();
	    	  if (this.dataSize <= this.maxDataSize) {
	    	    return;
	    	  }

	    	  var message =
	    	    'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.';
	    	  this._emitError(new Error(message));
	    	};

	    	CombinedStream.prototype._updateDataSize = function() {
	    	  this.dataSize = 0;

	    	  var self = this;
	    	  this._streams.forEach(function(stream) {
	    	    if (!stream.dataSize) {
	    	      return;
	    	    }

	    	    self.dataSize += stream.dataSize;
	    	  });

	    	  if (this._currentStream && this._currentStream.dataSize) {
	    	    this.dataSize += this._currentStream.dataSize;
	    	  }
	    	};

	    	CombinedStream.prototype._emitError = function(err) {
	    	  this._reset();
	    	  this.emit('error', err);
	    	};
	    	return combined_stream;
	    }

	    var mimeTypes = {};

	    var require$$0 = {
	    	"application/1d-interleaved-parityfec": {
	    	source: "iana"
	    },
	    	"application/3gpdash-qoe-report+xml": {
	    	source: "iana",
	    	charset: "UTF-8",
	    	compressible: true
	    },
	    	"application/3gpp-ims+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/3gpphal+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/3gpphalforms+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/a2l": {
	    	source: "iana"
	    },
	    	"application/ace+cbor": {
	    	source: "iana"
	    },
	    	"application/activemessage": {
	    	source: "iana"
	    },
	    	"application/activity+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/alto-costmap+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/alto-costmapfilter+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/alto-directory+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/alto-endpointcost+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/alto-endpointcostparams+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/alto-endpointprop+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/alto-endpointpropparams+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/alto-error+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/alto-networkmap+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/alto-networkmapfilter+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/alto-updatestreamcontrol+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/alto-updatestreamparams+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/aml": {
	    	source: "iana"
	    },
	    	"application/andrew-inset": {
	    	source: "iana",
	    	extensions: [
	    		"ez"
	    	]
	    },
	    	"application/applefile": {
	    	source: "iana"
	    },
	    	"application/applixware": {
	    	source: "apache",
	    	extensions: [
	    		"aw"
	    	]
	    },
	    	"application/at+jwt": {
	    	source: "iana"
	    },
	    	"application/atf": {
	    	source: "iana"
	    },
	    	"application/atfx": {
	    	source: "iana"
	    },
	    	"application/atom+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"atom"
	    	]
	    },
	    	"application/atomcat+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"atomcat"
	    	]
	    },
	    	"application/atomdeleted+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"atomdeleted"
	    	]
	    },
	    	"application/atomicmail": {
	    	source: "iana"
	    },
	    	"application/atomsvc+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"atomsvc"
	    	]
	    },
	    	"application/atsc-dwd+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"dwd"
	    	]
	    },
	    	"application/atsc-dynamic-event-message": {
	    	source: "iana"
	    },
	    	"application/atsc-held+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"held"
	    	]
	    },
	    	"application/atsc-rdt+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/atsc-rsat+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"rsat"
	    	]
	    },
	    	"application/atxml": {
	    	source: "iana"
	    },
	    	"application/auth-policy+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/bacnet-xdd+zip": {
	    	source: "iana",
	    	compressible: false
	    },
	    	"application/batch-smtp": {
	    	source: "iana"
	    },
	    	"application/bdoc": {
	    	compressible: false,
	    	extensions: [
	    		"bdoc"
	    	]
	    },
	    	"application/beep+xml": {
	    	source: "iana",
	    	charset: "UTF-8",
	    	compressible: true
	    },
	    	"application/calendar+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/calendar+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"xcs"
	    	]
	    },
	    	"application/call-completion": {
	    	source: "iana"
	    },
	    	"application/cals-1840": {
	    	source: "iana"
	    },
	    	"application/captive+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/cbor": {
	    	source: "iana"
	    },
	    	"application/cbor-seq": {
	    	source: "iana"
	    },
	    	"application/cccex": {
	    	source: "iana"
	    },
	    	"application/ccmp+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/ccxml+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"ccxml"
	    	]
	    },
	    	"application/cdfx+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"cdfx"
	    	]
	    },
	    	"application/cdmi-capability": {
	    	source: "iana",
	    	extensions: [
	    		"cdmia"
	    	]
	    },
	    	"application/cdmi-container": {
	    	source: "iana",
	    	extensions: [
	    		"cdmic"
	    	]
	    },
	    	"application/cdmi-domain": {
	    	source: "iana",
	    	extensions: [
	    		"cdmid"
	    	]
	    },
	    	"application/cdmi-object": {
	    	source: "iana",
	    	extensions: [
	    		"cdmio"
	    	]
	    },
	    	"application/cdmi-queue": {
	    	source: "iana",
	    	extensions: [
	    		"cdmiq"
	    	]
	    },
	    	"application/cdni": {
	    	source: "iana"
	    },
	    	"application/cea": {
	    	source: "iana"
	    },
	    	"application/cea-2018+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/cellml+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/cfw": {
	    	source: "iana"
	    },
	    	"application/city+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/clr": {
	    	source: "iana"
	    },
	    	"application/clue+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/clue_info+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/cms": {
	    	source: "iana"
	    },
	    	"application/cnrp+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/coap-group+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/coap-payload": {
	    	source: "iana"
	    },
	    	"application/commonground": {
	    	source: "iana"
	    },
	    	"application/conference-info+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/cose": {
	    	source: "iana"
	    },
	    	"application/cose-key": {
	    	source: "iana"
	    },
	    	"application/cose-key-set": {
	    	source: "iana"
	    },
	    	"application/cpl+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"cpl"
	    	]
	    },
	    	"application/csrattrs": {
	    	source: "iana"
	    },
	    	"application/csta+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/cstadata+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/csvm+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/cu-seeme": {
	    	source: "apache",
	    	extensions: [
	    		"cu"
	    	]
	    },
	    	"application/cwt": {
	    	source: "iana"
	    },
	    	"application/cybercash": {
	    	source: "iana"
	    },
	    	"application/dart": {
	    	compressible: true
	    },
	    	"application/dash+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"mpd"
	    	]
	    },
	    	"application/dash-patch+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"mpp"
	    	]
	    },
	    	"application/dashdelta": {
	    	source: "iana"
	    },
	    	"application/davmount+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"davmount"
	    	]
	    },
	    	"application/dca-rft": {
	    	source: "iana"
	    },
	    	"application/dcd": {
	    	source: "iana"
	    },
	    	"application/dec-dx": {
	    	source: "iana"
	    },
	    	"application/dialog-info+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/dicom": {
	    	source: "iana"
	    },
	    	"application/dicom+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/dicom+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/dii": {
	    	source: "iana"
	    },
	    	"application/dit": {
	    	source: "iana"
	    },
	    	"application/dns": {
	    	source: "iana"
	    },
	    	"application/dns+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/dns-message": {
	    	source: "iana"
	    },
	    	"application/docbook+xml": {
	    	source: "apache",
	    	compressible: true,
	    	extensions: [
	    		"dbk"
	    	]
	    },
	    	"application/dots+cbor": {
	    	source: "iana"
	    },
	    	"application/dskpp+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/dssc+der": {
	    	source: "iana",
	    	extensions: [
	    		"dssc"
	    	]
	    },
	    	"application/dssc+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"xdssc"
	    	]
	    },
	    	"application/dvcs": {
	    	source: "iana"
	    },
	    	"application/ecmascript": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"es",
	    		"ecma"
	    	]
	    },
	    	"application/edi-consent": {
	    	source: "iana"
	    },
	    	"application/edi-x12": {
	    	source: "iana",
	    	compressible: false
	    },
	    	"application/edifact": {
	    	source: "iana",
	    	compressible: false
	    },
	    	"application/efi": {
	    	source: "iana"
	    },
	    	"application/elm+json": {
	    	source: "iana",
	    	charset: "UTF-8",
	    	compressible: true
	    },
	    	"application/elm+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/emergencycalldata.cap+xml": {
	    	source: "iana",
	    	charset: "UTF-8",
	    	compressible: true
	    },
	    	"application/emergencycalldata.comment+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/emergencycalldata.control+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/emergencycalldata.deviceinfo+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/emergencycalldata.ecall.msd": {
	    	source: "iana"
	    },
	    	"application/emergencycalldata.providerinfo+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/emergencycalldata.serviceinfo+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/emergencycalldata.subscriberinfo+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/emergencycalldata.veds+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/emma+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"emma"
	    	]
	    },
	    	"application/emotionml+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"emotionml"
	    	]
	    },
	    	"application/encaprtp": {
	    	source: "iana"
	    },
	    	"application/epp+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/epub+zip": {
	    	source: "iana",
	    	compressible: false,
	    	extensions: [
	    		"epub"
	    	]
	    },
	    	"application/eshop": {
	    	source: "iana"
	    },
	    	"application/exi": {
	    	source: "iana",
	    	extensions: [
	    		"exi"
	    	]
	    },
	    	"application/expect-ct-report+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/express": {
	    	source: "iana",
	    	extensions: [
	    		"exp"
	    	]
	    },
	    	"application/fastinfoset": {
	    	source: "iana"
	    },
	    	"application/fastsoap": {
	    	source: "iana"
	    },
	    	"application/fdt+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"fdt"
	    	]
	    },
	    	"application/fhir+json": {
	    	source: "iana",
	    	charset: "UTF-8",
	    	compressible: true
	    },
	    	"application/fhir+xml": {
	    	source: "iana",
	    	charset: "UTF-8",
	    	compressible: true
	    },
	    	"application/fido.trusted-apps+json": {
	    	compressible: true
	    },
	    	"application/fits": {
	    	source: "iana"
	    },
	    	"application/flexfec": {
	    	source: "iana"
	    },
	    	"application/font-sfnt": {
	    	source: "iana"
	    },
	    	"application/font-tdpfr": {
	    	source: "iana",
	    	extensions: [
	    		"pfr"
	    	]
	    },
	    	"application/font-woff": {
	    	source: "iana",
	    	compressible: false
	    },
	    	"application/framework-attributes+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/geo+json": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"geojson"
	    	]
	    },
	    	"application/geo+json-seq": {
	    	source: "iana"
	    },
	    	"application/geopackage+sqlite3": {
	    	source: "iana"
	    },
	    	"application/geoxacml+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/gltf-buffer": {
	    	source: "iana"
	    },
	    	"application/gml+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"gml"
	    	]
	    },
	    	"application/gpx+xml": {
	    	source: "apache",
	    	compressible: true,
	    	extensions: [
	    		"gpx"
	    	]
	    },
	    	"application/gxf": {
	    	source: "apache",
	    	extensions: [
	    		"gxf"
	    	]
	    },
	    	"application/gzip": {
	    	source: "iana",
	    	compressible: false,
	    	extensions: [
	    		"gz"
	    	]
	    },
	    	"application/h224": {
	    	source: "iana"
	    },
	    	"application/held+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/hjson": {
	    	extensions: [
	    		"hjson"
	    	]
	    },
	    	"application/http": {
	    	source: "iana"
	    },
	    	"application/hyperstudio": {
	    	source: "iana",
	    	extensions: [
	    		"stk"
	    	]
	    },
	    	"application/ibe-key-request+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/ibe-pkg-reply+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/ibe-pp-data": {
	    	source: "iana"
	    },
	    	"application/iges": {
	    	source: "iana"
	    },
	    	"application/im-iscomposing+xml": {
	    	source: "iana",
	    	charset: "UTF-8",
	    	compressible: true
	    },
	    	"application/index": {
	    	source: "iana"
	    },
	    	"application/index.cmd": {
	    	source: "iana"
	    },
	    	"application/index.obj": {
	    	source: "iana"
	    },
	    	"application/index.response": {
	    	source: "iana"
	    },
	    	"application/index.vnd": {
	    	source: "iana"
	    },
	    	"application/inkml+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"ink",
	    		"inkml"
	    	]
	    },
	    	"application/iotp": {
	    	source: "iana"
	    },
	    	"application/ipfix": {
	    	source: "iana",
	    	extensions: [
	    		"ipfix"
	    	]
	    },
	    	"application/ipp": {
	    	source: "iana"
	    },
	    	"application/isup": {
	    	source: "iana"
	    },
	    	"application/its+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"its"
	    	]
	    },
	    	"application/java-archive": {
	    	source: "apache",
	    	compressible: false,
	    	extensions: [
	    		"jar",
	    		"war",
	    		"ear"
	    	]
	    },
	    	"application/java-serialized-object": {
	    	source: "apache",
	    	compressible: false,
	    	extensions: [
	    		"ser"
	    	]
	    },
	    	"application/java-vm": {
	    	source: "apache",
	    	compressible: false,
	    	extensions: [
	    		"class"
	    	]
	    },
	    	"application/javascript": {
	    	source: "iana",
	    	charset: "UTF-8",
	    	compressible: true,
	    	extensions: [
	    		"js",
	    		"mjs"
	    	]
	    },
	    	"application/jf2feed+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/jose": {
	    	source: "iana"
	    },
	    	"application/jose+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/jrd+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/jscalendar+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/json": {
	    	source: "iana",
	    	charset: "UTF-8",
	    	compressible: true,
	    	extensions: [
	    		"json",
	    		"map"
	    	]
	    },
	    	"application/json-patch+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/json-seq": {
	    	source: "iana"
	    },
	    	"application/json5": {
	    	extensions: [
	    		"json5"
	    	]
	    },
	    	"application/jsonml+json": {
	    	source: "apache",
	    	compressible: true,
	    	extensions: [
	    		"jsonml"
	    	]
	    },
	    	"application/jwk+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/jwk-set+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/jwt": {
	    	source: "iana"
	    },
	    	"application/kpml-request+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/kpml-response+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/ld+json": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"jsonld"
	    	]
	    },
	    	"application/lgr+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"lgr"
	    	]
	    },
	    	"application/link-format": {
	    	source: "iana"
	    },
	    	"application/load-control+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/lost+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"lostxml"
	    	]
	    },
	    	"application/lostsync+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/lpf+zip": {
	    	source: "iana",
	    	compressible: false
	    },
	    	"application/lxf": {
	    	source: "iana"
	    },
	    	"application/mac-binhex40": {
	    	source: "iana",
	    	extensions: [
	    		"hqx"
	    	]
	    },
	    	"application/mac-compactpro": {
	    	source: "apache",
	    	extensions: [
	    		"cpt"
	    	]
	    },
	    	"application/macwriteii": {
	    	source: "iana"
	    },
	    	"application/mads+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"mads"
	    	]
	    },
	    	"application/manifest+json": {
	    	source: "iana",
	    	charset: "UTF-8",
	    	compressible: true,
	    	extensions: [
	    		"webmanifest"
	    	]
	    },
	    	"application/marc": {
	    	source: "iana",
	    	extensions: [
	    		"mrc"
	    	]
	    },
	    	"application/marcxml+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"mrcx"
	    	]
	    },
	    	"application/mathematica": {
	    	source: "iana",
	    	extensions: [
	    		"ma",
	    		"nb",
	    		"mb"
	    	]
	    },
	    	"application/mathml+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"mathml"
	    	]
	    },
	    	"application/mathml-content+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/mathml-presentation+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/mbms-associated-procedure-description+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/mbms-deregister+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/mbms-envelope+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/mbms-msk+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/mbms-msk-response+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/mbms-protection-description+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/mbms-reception-report+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/mbms-register+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/mbms-register-response+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/mbms-schedule+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/mbms-user-service-description+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/mbox": {
	    	source: "iana",
	    	extensions: [
	    		"mbox"
	    	]
	    },
	    	"application/media-policy-dataset+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"mpf"
	    	]
	    },
	    	"application/media_control+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/mediaservercontrol+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"mscml"
	    	]
	    },
	    	"application/merge-patch+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/metalink+xml": {
	    	source: "apache",
	    	compressible: true,
	    	extensions: [
	    		"metalink"
	    	]
	    },
	    	"application/metalink4+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"meta4"
	    	]
	    },
	    	"application/mets+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"mets"
	    	]
	    },
	    	"application/mf4": {
	    	source: "iana"
	    },
	    	"application/mikey": {
	    	source: "iana"
	    },
	    	"application/mipc": {
	    	source: "iana"
	    },
	    	"application/missing-blocks+cbor-seq": {
	    	source: "iana"
	    },
	    	"application/mmt-aei+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"maei"
	    	]
	    },
	    	"application/mmt-usd+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"musd"
	    	]
	    },
	    	"application/mods+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"mods"
	    	]
	    },
	    	"application/moss-keys": {
	    	source: "iana"
	    },
	    	"application/moss-signature": {
	    	source: "iana"
	    },
	    	"application/mosskey-data": {
	    	source: "iana"
	    },
	    	"application/mosskey-request": {
	    	source: "iana"
	    },
	    	"application/mp21": {
	    	source: "iana",
	    	extensions: [
	    		"m21",
	    		"mp21"
	    	]
	    },
	    	"application/mp4": {
	    	source: "iana",
	    	extensions: [
	    		"mp4s",
	    		"m4p"
	    	]
	    },
	    	"application/mpeg4-generic": {
	    	source: "iana"
	    },
	    	"application/mpeg4-iod": {
	    	source: "iana"
	    },
	    	"application/mpeg4-iod-xmt": {
	    	source: "iana"
	    },
	    	"application/mrb-consumer+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/mrb-publish+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/msc-ivr+xml": {
	    	source: "iana",
	    	charset: "UTF-8",
	    	compressible: true
	    },
	    	"application/msc-mixer+xml": {
	    	source: "iana",
	    	charset: "UTF-8",
	    	compressible: true
	    },
	    	"application/msword": {
	    	source: "iana",
	    	compressible: false,
	    	extensions: [
	    		"doc",
	    		"dot"
	    	]
	    },
	    	"application/mud+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/multipart-core": {
	    	source: "iana"
	    },
	    	"application/mxf": {
	    	source: "iana",
	    	extensions: [
	    		"mxf"
	    	]
	    },
	    	"application/n-quads": {
	    	source: "iana",
	    	extensions: [
	    		"nq"
	    	]
	    },
	    	"application/n-triples": {
	    	source: "iana",
	    	extensions: [
	    		"nt"
	    	]
	    },
	    	"application/nasdata": {
	    	source: "iana"
	    },
	    	"application/news-checkgroups": {
	    	source: "iana",
	    	charset: "US-ASCII"
	    },
	    	"application/news-groupinfo": {
	    	source: "iana",
	    	charset: "US-ASCII"
	    },
	    	"application/news-transmission": {
	    	source: "iana"
	    },
	    	"application/nlsml+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/node": {
	    	source: "iana",
	    	extensions: [
	    		"cjs"
	    	]
	    },
	    	"application/nss": {
	    	source: "iana"
	    },
	    	"application/oauth-authz-req+jwt": {
	    	source: "iana"
	    },
	    	"application/oblivious-dns-message": {
	    	source: "iana"
	    },
	    	"application/ocsp-request": {
	    	source: "iana"
	    },
	    	"application/ocsp-response": {
	    	source: "iana"
	    },
	    	"application/octet-stream": {
	    	source: "iana",
	    	compressible: false,
	    	extensions: [
	    		"bin",
	    		"dms",
	    		"lrf",
	    		"mar",
	    		"so",
	    		"dist",
	    		"distz",
	    		"pkg",
	    		"bpk",
	    		"dump",
	    		"elc",
	    		"deploy",
	    		"exe",
	    		"dll",
	    		"deb",
	    		"dmg",
	    		"iso",
	    		"img",
	    		"msi",
	    		"msp",
	    		"msm",
	    		"buffer"
	    	]
	    },
	    	"application/oda": {
	    	source: "iana",
	    	extensions: [
	    		"oda"
	    	]
	    },
	    	"application/odm+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/odx": {
	    	source: "iana"
	    },
	    	"application/oebps-package+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"opf"
	    	]
	    },
	    	"application/ogg": {
	    	source: "iana",
	    	compressible: false,
	    	extensions: [
	    		"ogx"
	    	]
	    },
	    	"application/omdoc+xml": {
	    	source: "apache",
	    	compressible: true,
	    	extensions: [
	    		"omdoc"
	    	]
	    },
	    	"application/onenote": {
	    	source: "apache",
	    	extensions: [
	    		"onetoc",
	    		"onetoc2",
	    		"onetmp",
	    		"onepkg"
	    	]
	    },
	    	"application/opc-nodeset+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/oscore": {
	    	source: "iana"
	    },
	    	"application/oxps": {
	    	source: "iana",
	    	extensions: [
	    		"oxps"
	    	]
	    },
	    	"application/p21": {
	    	source: "iana"
	    },
	    	"application/p21+zip": {
	    	source: "iana",
	    	compressible: false
	    },
	    	"application/p2p-overlay+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"relo"
	    	]
	    },
	    	"application/parityfec": {
	    	source: "iana"
	    },
	    	"application/passport": {
	    	source: "iana"
	    },
	    	"application/patch-ops-error+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"xer"
	    	]
	    },
	    	"application/pdf": {
	    	source: "iana",
	    	compressible: false,
	    	extensions: [
	    		"pdf"
	    	]
	    },
	    	"application/pdx": {
	    	source: "iana"
	    },
	    	"application/pem-certificate-chain": {
	    	source: "iana"
	    },
	    	"application/pgp-encrypted": {
	    	source: "iana",
	    	compressible: false,
	    	extensions: [
	    		"pgp"
	    	]
	    },
	    	"application/pgp-keys": {
	    	source: "iana",
	    	extensions: [
	    		"asc"
	    	]
	    },
	    	"application/pgp-signature": {
	    	source: "iana",
	    	extensions: [
	    		"asc",
	    		"sig"
	    	]
	    },
	    	"application/pics-rules": {
	    	source: "apache",
	    	extensions: [
	    		"prf"
	    	]
	    },
	    	"application/pidf+xml": {
	    	source: "iana",
	    	charset: "UTF-8",
	    	compressible: true
	    },
	    	"application/pidf-diff+xml": {
	    	source: "iana",
	    	charset: "UTF-8",
	    	compressible: true
	    },
	    	"application/pkcs10": {
	    	source: "iana",
	    	extensions: [
	    		"p10"
	    	]
	    },
	    	"application/pkcs12": {
	    	source: "iana"
	    },
	    	"application/pkcs7-mime": {
	    	source: "iana",
	    	extensions: [
	    		"p7m",
	    		"p7c"
	    	]
	    },
	    	"application/pkcs7-signature": {
	    	source: "iana",
	    	extensions: [
	    		"p7s"
	    	]
	    },
	    	"application/pkcs8": {
	    	source: "iana",
	    	extensions: [
	    		"p8"
	    	]
	    },
	    	"application/pkcs8-encrypted": {
	    	source: "iana"
	    },
	    	"application/pkix-attr-cert": {
	    	source: "iana",
	    	extensions: [
	    		"ac"
	    	]
	    },
	    	"application/pkix-cert": {
	    	source: "iana",
	    	extensions: [
	    		"cer"
	    	]
	    },
	    	"application/pkix-crl": {
	    	source: "iana",
	    	extensions: [
	    		"crl"
	    	]
	    },
	    	"application/pkix-pkipath": {
	    	source: "iana",
	    	extensions: [
	    		"pkipath"
	    	]
	    },
	    	"application/pkixcmp": {
	    	source: "iana",
	    	extensions: [
	    		"pki"
	    	]
	    },
	    	"application/pls+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"pls"
	    	]
	    },
	    	"application/poc-settings+xml": {
	    	source: "iana",
	    	charset: "UTF-8",
	    	compressible: true
	    },
	    	"application/postscript": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"ai",
	    		"eps",
	    		"ps"
	    	]
	    },
	    	"application/ppsp-tracker+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/problem+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/problem+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/provenance+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"provx"
	    	]
	    },
	    	"application/prs.alvestrand.titrax-sheet": {
	    	source: "iana"
	    },
	    	"application/prs.cww": {
	    	source: "iana",
	    	extensions: [
	    		"cww"
	    	]
	    },
	    	"application/prs.cyn": {
	    	source: "iana",
	    	charset: "7-BIT"
	    },
	    	"application/prs.hpub+zip": {
	    	source: "iana",
	    	compressible: false
	    },
	    	"application/prs.nprend": {
	    	source: "iana"
	    },
	    	"application/prs.plucker": {
	    	source: "iana"
	    },
	    	"application/prs.rdf-xml-crypt": {
	    	source: "iana"
	    },
	    	"application/prs.xsf+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/pskc+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"pskcxml"
	    	]
	    },
	    	"application/pvd+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/qsig": {
	    	source: "iana"
	    },
	    	"application/raml+yaml": {
	    	compressible: true,
	    	extensions: [
	    		"raml"
	    	]
	    },
	    	"application/raptorfec": {
	    	source: "iana"
	    },
	    	"application/rdap+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/rdf+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"rdf",
	    		"owl"
	    	]
	    },
	    	"application/reginfo+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"rif"
	    	]
	    },
	    	"application/relax-ng-compact-syntax": {
	    	source: "iana",
	    	extensions: [
	    		"rnc"
	    	]
	    },
	    	"application/remote-printing": {
	    	source: "iana"
	    },
	    	"application/reputon+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/resource-lists+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"rl"
	    	]
	    },
	    	"application/resource-lists-diff+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"rld"
	    	]
	    },
	    	"application/rfc+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/riscos": {
	    	source: "iana"
	    },
	    	"application/rlmi+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/rls-services+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"rs"
	    	]
	    },
	    	"application/route-apd+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"rapd"
	    	]
	    },
	    	"application/route-s-tsid+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"sls"
	    	]
	    },
	    	"application/route-usd+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"rusd"
	    	]
	    },
	    	"application/rpki-ghostbusters": {
	    	source: "iana",
	    	extensions: [
	    		"gbr"
	    	]
	    },
	    	"application/rpki-manifest": {
	    	source: "iana",
	    	extensions: [
	    		"mft"
	    	]
	    },
	    	"application/rpki-publication": {
	    	source: "iana"
	    },
	    	"application/rpki-roa": {
	    	source: "iana",
	    	extensions: [
	    		"roa"
	    	]
	    },
	    	"application/rpki-updown": {
	    	source: "iana"
	    },
	    	"application/rsd+xml": {
	    	source: "apache",
	    	compressible: true,
	    	extensions: [
	    		"rsd"
	    	]
	    },
	    	"application/rss+xml": {
	    	source: "apache",
	    	compressible: true,
	    	extensions: [
	    		"rss"
	    	]
	    },
	    	"application/rtf": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"rtf"
	    	]
	    },
	    	"application/rtploopback": {
	    	source: "iana"
	    },
	    	"application/rtx": {
	    	source: "iana"
	    },
	    	"application/samlassertion+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/samlmetadata+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/sarif+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/sarif-external-properties+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/sbe": {
	    	source: "iana"
	    },
	    	"application/sbml+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"sbml"
	    	]
	    },
	    	"application/scaip+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/scim+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/scvp-cv-request": {
	    	source: "iana",
	    	extensions: [
	    		"scq"
	    	]
	    },
	    	"application/scvp-cv-response": {
	    	source: "iana",
	    	extensions: [
	    		"scs"
	    	]
	    },
	    	"application/scvp-vp-request": {
	    	source: "iana",
	    	extensions: [
	    		"spq"
	    	]
	    },
	    	"application/scvp-vp-response": {
	    	source: "iana",
	    	extensions: [
	    		"spp"
	    	]
	    },
	    	"application/sdp": {
	    	source: "iana",
	    	extensions: [
	    		"sdp"
	    	]
	    },
	    	"application/secevent+jwt": {
	    	source: "iana"
	    },
	    	"application/senml+cbor": {
	    	source: "iana"
	    },
	    	"application/senml+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/senml+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"senmlx"
	    	]
	    },
	    	"application/senml-etch+cbor": {
	    	source: "iana"
	    },
	    	"application/senml-etch+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/senml-exi": {
	    	source: "iana"
	    },
	    	"application/sensml+cbor": {
	    	source: "iana"
	    },
	    	"application/sensml+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/sensml+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"sensmlx"
	    	]
	    },
	    	"application/sensml-exi": {
	    	source: "iana"
	    },
	    	"application/sep+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/sep-exi": {
	    	source: "iana"
	    },
	    	"application/session-info": {
	    	source: "iana"
	    },
	    	"application/set-payment": {
	    	source: "iana"
	    },
	    	"application/set-payment-initiation": {
	    	source: "iana",
	    	extensions: [
	    		"setpay"
	    	]
	    },
	    	"application/set-registration": {
	    	source: "iana"
	    },
	    	"application/set-registration-initiation": {
	    	source: "iana",
	    	extensions: [
	    		"setreg"
	    	]
	    },
	    	"application/sgml": {
	    	source: "iana"
	    },
	    	"application/sgml-open-catalog": {
	    	source: "iana"
	    },
	    	"application/shf+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"shf"
	    	]
	    },
	    	"application/sieve": {
	    	source: "iana",
	    	extensions: [
	    		"siv",
	    		"sieve"
	    	]
	    },
	    	"application/simple-filter+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/simple-message-summary": {
	    	source: "iana"
	    },
	    	"application/simplesymbolcontainer": {
	    	source: "iana"
	    },
	    	"application/sipc": {
	    	source: "iana"
	    },
	    	"application/slate": {
	    	source: "iana"
	    },
	    	"application/smil": {
	    	source: "iana"
	    },
	    	"application/smil+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"smi",
	    		"smil"
	    	]
	    },
	    	"application/smpte336m": {
	    	source: "iana"
	    },
	    	"application/soap+fastinfoset": {
	    	source: "iana"
	    },
	    	"application/soap+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/sparql-query": {
	    	source: "iana",
	    	extensions: [
	    		"rq"
	    	]
	    },
	    	"application/sparql-results+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"srx"
	    	]
	    },
	    	"application/spdx+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/spirits-event+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/sql": {
	    	source: "iana"
	    },
	    	"application/srgs": {
	    	source: "iana",
	    	extensions: [
	    		"gram"
	    	]
	    },
	    	"application/srgs+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"grxml"
	    	]
	    },
	    	"application/sru+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"sru"
	    	]
	    },
	    	"application/ssdl+xml": {
	    	source: "apache",
	    	compressible: true,
	    	extensions: [
	    		"ssdl"
	    	]
	    },
	    	"application/ssml+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"ssml"
	    	]
	    },
	    	"application/stix+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/swid+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"swidtag"
	    	]
	    },
	    	"application/tamp-apex-update": {
	    	source: "iana"
	    },
	    	"application/tamp-apex-update-confirm": {
	    	source: "iana"
	    },
	    	"application/tamp-community-update": {
	    	source: "iana"
	    },
	    	"application/tamp-community-update-confirm": {
	    	source: "iana"
	    },
	    	"application/tamp-error": {
	    	source: "iana"
	    },
	    	"application/tamp-sequence-adjust": {
	    	source: "iana"
	    },
	    	"application/tamp-sequence-adjust-confirm": {
	    	source: "iana"
	    },
	    	"application/tamp-status-query": {
	    	source: "iana"
	    },
	    	"application/tamp-status-response": {
	    	source: "iana"
	    },
	    	"application/tamp-update": {
	    	source: "iana"
	    },
	    	"application/tamp-update-confirm": {
	    	source: "iana"
	    },
	    	"application/tar": {
	    	compressible: true
	    },
	    	"application/taxii+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/td+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/tei+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"tei",
	    		"teicorpus"
	    	]
	    },
	    	"application/tetra_isi": {
	    	source: "iana"
	    },
	    	"application/thraud+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"tfi"
	    	]
	    },
	    	"application/timestamp-query": {
	    	source: "iana"
	    },
	    	"application/timestamp-reply": {
	    	source: "iana"
	    },
	    	"application/timestamped-data": {
	    	source: "iana",
	    	extensions: [
	    		"tsd"
	    	]
	    },
	    	"application/tlsrpt+gzip": {
	    	source: "iana"
	    },
	    	"application/tlsrpt+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/tnauthlist": {
	    	source: "iana"
	    },
	    	"application/token-introspection+jwt": {
	    	source: "iana"
	    },
	    	"application/toml": {
	    	compressible: true,
	    	extensions: [
	    		"toml"
	    	]
	    },
	    	"application/trickle-ice-sdpfrag": {
	    	source: "iana"
	    },
	    	"application/trig": {
	    	source: "iana",
	    	extensions: [
	    		"trig"
	    	]
	    },
	    	"application/ttml+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"ttml"
	    	]
	    },
	    	"application/tve-trigger": {
	    	source: "iana"
	    },
	    	"application/tzif": {
	    	source: "iana"
	    },
	    	"application/tzif-leap": {
	    	source: "iana"
	    },
	    	"application/ubjson": {
	    	compressible: false,
	    	extensions: [
	    		"ubj"
	    	]
	    },
	    	"application/ulpfec": {
	    	source: "iana"
	    },
	    	"application/urc-grpsheet+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/urc-ressheet+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"rsheet"
	    	]
	    },
	    	"application/urc-targetdesc+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"td"
	    	]
	    },
	    	"application/urc-uisocketdesc+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vcard+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vcard+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vemmi": {
	    	source: "iana"
	    },
	    	"application/vividence.scriptfile": {
	    	source: "apache"
	    },
	    	"application/vnd.1000minds.decision-model+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"1km"
	    	]
	    },
	    	"application/vnd.3gpp-prose+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.3gpp-prose-pc3ch+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.3gpp-v2x-local-service-information": {
	    	source: "iana"
	    },
	    	"application/vnd.3gpp.5gnas": {
	    	source: "iana"
	    },
	    	"application/vnd.3gpp.access-transfer-events+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.3gpp.bsf+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.3gpp.gmop+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.3gpp.gtpc": {
	    	source: "iana"
	    },
	    	"application/vnd.3gpp.interworking-data": {
	    	source: "iana"
	    },
	    	"application/vnd.3gpp.lpp": {
	    	source: "iana"
	    },
	    	"application/vnd.3gpp.mc-signalling-ear": {
	    	source: "iana"
	    },
	    	"application/vnd.3gpp.mcdata-affiliation-command+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.3gpp.mcdata-info+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.3gpp.mcdata-payload": {
	    	source: "iana"
	    },
	    	"application/vnd.3gpp.mcdata-service-config+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.3gpp.mcdata-signalling": {
	    	source: "iana"
	    },
	    	"application/vnd.3gpp.mcdata-ue-config+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.3gpp.mcdata-user-profile+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.3gpp.mcptt-affiliation-command+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.3gpp.mcptt-floor-request+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.3gpp.mcptt-info+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.3gpp.mcptt-location-info+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.3gpp.mcptt-service-config+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.3gpp.mcptt-signed+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.3gpp.mcptt-ue-config+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.3gpp.mcptt-ue-init-config+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.3gpp.mcptt-user-profile+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.3gpp.mcvideo-affiliation-command+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.3gpp.mcvideo-affiliation-info+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.3gpp.mcvideo-info+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.3gpp.mcvideo-location-info+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.3gpp.mcvideo-service-config+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.3gpp.mcvideo-transmission-request+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.3gpp.mcvideo-ue-config+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.3gpp.mcvideo-user-profile+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.3gpp.mid-call+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.3gpp.ngap": {
	    	source: "iana"
	    },
	    	"application/vnd.3gpp.pfcp": {
	    	source: "iana"
	    },
	    	"application/vnd.3gpp.pic-bw-large": {
	    	source: "iana",
	    	extensions: [
	    		"plb"
	    	]
	    },
	    	"application/vnd.3gpp.pic-bw-small": {
	    	source: "iana",
	    	extensions: [
	    		"psb"
	    	]
	    },
	    	"application/vnd.3gpp.pic-bw-var": {
	    	source: "iana",
	    	extensions: [
	    		"pvb"
	    	]
	    },
	    	"application/vnd.3gpp.s1ap": {
	    	source: "iana"
	    },
	    	"application/vnd.3gpp.sms": {
	    	source: "iana"
	    },
	    	"application/vnd.3gpp.sms+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.3gpp.srvcc-ext+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.3gpp.srvcc-info+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.3gpp.state-and-event-info+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.3gpp.ussd+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.3gpp2.bcmcsinfo+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.3gpp2.sms": {
	    	source: "iana"
	    },
	    	"application/vnd.3gpp2.tcap": {
	    	source: "iana",
	    	extensions: [
	    		"tcap"
	    	]
	    },
	    	"application/vnd.3lightssoftware.imagescal": {
	    	source: "iana"
	    },
	    	"application/vnd.3m.post-it-notes": {
	    	source: "iana",
	    	extensions: [
	    		"pwn"
	    	]
	    },
	    	"application/vnd.accpac.simply.aso": {
	    	source: "iana",
	    	extensions: [
	    		"aso"
	    	]
	    },
	    	"application/vnd.accpac.simply.imp": {
	    	source: "iana",
	    	extensions: [
	    		"imp"
	    	]
	    },
	    	"application/vnd.acucobol": {
	    	source: "iana",
	    	extensions: [
	    		"acu"
	    	]
	    },
	    	"application/vnd.acucorp": {
	    	source: "iana",
	    	extensions: [
	    		"atc",
	    		"acutc"
	    	]
	    },
	    	"application/vnd.adobe.air-application-installer-package+zip": {
	    	source: "apache",
	    	compressible: false,
	    	extensions: [
	    		"air"
	    	]
	    },
	    	"application/vnd.adobe.flash.movie": {
	    	source: "iana"
	    },
	    	"application/vnd.adobe.formscentral.fcdt": {
	    	source: "iana",
	    	extensions: [
	    		"fcdt"
	    	]
	    },
	    	"application/vnd.adobe.fxp": {
	    	source: "iana",
	    	extensions: [
	    		"fxp",
	    		"fxpl"
	    	]
	    },
	    	"application/vnd.adobe.partial-upload": {
	    	source: "iana"
	    },
	    	"application/vnd.adobe.xdp+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"xdp"
	    	]
	    },
	    	"application/vnd.adobe.xfdf": {
	    	source: "iana",
	    	extensions: [
	    		"xfdf"
	    	]
	    },
	    	"application/vnd.aether.imp": {
	    	source: "iana"
	    },
	    	"application/vnd.afpc.afplinedata": {
	    	source: "iana"
	    },
	    	"application/vnd.afpc.afplinedata-pagedef": {
	    	source: "iana"
	    },
	    	"application/vnd.afpc.cmoca-cmresource": {
	    	source: "iana"
	    },
	    	"application/vnd.afpc.foca-charset": {
	    	source: "iana"
	    },
	    	"application/vnd.afpc.foca-codedfont": {
	    	source: "iana"
	    },
	    	"application/vnd.afpc.foca-codepage": {
	    	source: "iana"
	    },
	    	"application/vnd.afpc.modca": {
	    	source: "iana"
	    },
	    	"application/vnd.afpc.modca-cmtable": {
	    	source: "iana"
	    },
	    	"application/vnd.afpc.modca-formdef": {
	    	source: "iana"
	    },
	    	"application/vnd.afpc.modca-mediummap": {
	    	source: "iana"
	    },
	    	"application/vnd.afpc.modca-objectcontainer": {
	    	source: "iana"
	    },
	    	"application/vnd.afpc.modca-overlay": {
	    	source: "iana"
	    },
	    	"application/vnd.afpc.modca-pagesegment": {
	    	source: "iana"
	    },
	    	"application/vnd.age": {
	    	source: "iana",
	    	extensions: [
	    		"age"
	    	]
	    },
	    	"application/vnd.ah-barcode": {
	    	source: "iana"
	    },
	    	"application/vnd.ahead.space": {
	    	source: "iana",
	    	extensions: [
	    		"ahead"
	    	]
	    },
	    	"application/vnd.airzip.filesecure.azf": {
	    	source: "iana",
	    	extensions: [
	    		"azf"
	    	]
	    },
	    	"application/vnd.airzip.filesecure.azs": {
	    	source: "iana",
	    	extensions: [
	    		"azs"
	    	]
	    },
	    	"application/vnd.amadeus+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.amazon.ebook": {
	    	source: "apache",
	    	extensions: [
	    		"azw"
	    	]
	    },
	    	"application/vnd.amazon.mobi8-ebook": {
	    	source: "iana"
	    },
	    	"application/vnd.americandynamics.acc": {
	    	source: "iana",
	    	extensions: [
	    		"acc"
	    	]
	    },
	    	"application/vnd.amiga.ami": {
	    	source: "iana",
	    	extensions: [
	    		"ami"
	    	]
	    },
	    	"application/vnd.amundsen.maze+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.android.ota": {
	    	source: "iana"
	    },
	    	"application/vnd.android.package-archive": {
	    	source: "apache",
	    	compressible: false,
	    	extensions: [
	    		"apk"
	    	]
	    },
	    	"application/vnd.anki": {
	    	source: "iana"
	    },
	    	"application/vnd.anser-web-certificate-issue-initiation": {
	    	source: "iana",
	    	extensions: [
	    		"cii"
	    	]
	    },
	    	"application/vnd.anser-web-funds-transfer-initiation": {
	    	source: "apache",
	    	extensions: [
	    		"fti"
	    	]
	    },
	    	"application/vnd.antix.game-component": {
	    	source: "iana",
	    	extensions: [
	    		"atx"
	    	]
	    },
	    	"application/vnd.apache.arrow.file": {
	    	source: "iana"
	    },
	    	"application/vnd.apache.arrow.stream": {
	    	source: "iana"
	    },
	    	"application/vnd.apache.thrift.binary": {
	    	source: "iana"
	    },
	    	"application/vnd.apache.thrift.compact": {
	    	source: "iana"
	    },
	    	"application/vnd.apache.thrift.json": {
	    	source: "iana"
	    },
	    	"application/vnd.api+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.aplextor.warrp+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.apothekende.reservation+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.apple.installer+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"mpkg"
	    	]
	    },
	    	"application/vnd.apple.keynote": {
	    	source: "iana",
	    	extensions: [
	    		"key"
	    	]
	    },
	    	"application/vnd.apple.mpegurl": {
	    	source: "iana",
	    	extensions: [
	    		"m3u8"
	    	]
	    },
	    	"application/vnd.apple.numbers": {
	    	source: "iana",
	    	extensions: [
	    		"numbers"
	    	]
	    },
	    	"application/vnd.apple.pages": {
	    	source: "iana",
	    	extensions: [
	    		"pages"
	    	]
	    },
	    	"application/vnd.apple.pkpass": {
	    	compressible: false,
	    	extensions: [
	    		"pkpass"
	    	]
	    },
	    	"application/vnd.arastra.swi": {
	    	source: "iana"
	    },
	    	"application/vnd.aristanetworks.swi": {
	    	source: "iana",
	    	extensions: [
	    		"swi"
	    	]
	    },
	    	"application/vnd.artisan+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.artsquare": {
	    	source: "iana"
	    },
	    	"application/vnd.astraea-software.iota": {
	    	source: "iana",
	    	extensions: [
	    		"iota"
	    	]
	    },
	    	"application/vnd.audiograph": {
	    	source: "iana",
	    	extensions: [
	    		"aep"
	    	]
	    },
	    	"application/vnd.autopackage": {
	    	source: "iana"
	    },
	    	"application/vnd.avalon+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.avistar+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.balsamiq.bmml+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"bmml"
	    	]
	    },
	    	"application/vnd.balsamiq.bmpr": {
	    	source: "iana"
	    },
	    	"application/vnd.banana-accounting": {
	    	source: "iana"
	    },
	    	"application/vnd.bbf.usp.error": {
	    	source: "iana"
	    },
	    	"application/vnd.bbf.usp.msg": {
	    	source: "iana"
	    },
	    	"application/vnd.bbf.usp.msg+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.bekitzur-stech+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.bint.med-content": {
	    	source: "iana"
	    },
	    	"application/vnd.biopax.rdf+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.blink-idb-value-wrapper": {
	    	source: "iana"
	    },
	    	"application/vnd.blueice.multipass": {
	    	source: "iana",
	    	extensions: [
	    		"mpm"
	    	]
	    },
	    	"application/vnd.bluetooth.ep.oob": {
	    	source: "iana"
	    },
	    	"application/vnd.bluetooth.le.oob": {
	    	source: "iana"
	    },
	    	"application/vnd.bmi": {
	    	source: "iana",
	    	extensions: [
	    		"bmi"
	    	]
	    },
	    	"application/vnd.bpf": {
	    	source: "iana"
	    },
	    	"application/vnd.bpf3": {
	    	source: "iana"
	    },
	    	"application/vnd.businessobjects": {
	    	source: "iana",
	    	extensions: [
	    		"rep"
	    	]
	    },
	    	"application/vnd.byu.uapi+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.cab-jscript": {
	    	source: "iana"
	    },
	    	"application/vnd.canon-cpdl": {
	    	source: "iana"
	    },
	    	"application/vnd.canon-lips": {
	    	source: "iana"
	    },
	    	"application/vnd.capasystems-pg+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.cendio.thinlinc.clientconf": {
	    	source: "iana"
	    },
	    	"application/vnd.century-systems.tcp_stream": {
	    	source: "iana"
	    },
	    	"application/vnd.chemdraw+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"cdxml"
	    	]
	    },
	    	"application/vnd.chess-pgn": {
	    	source: "iana"
	    },
	    	"application/vnd.chipnuts.karaoke-mmd": {
	    	source: "iana",
	    	extensions: [
	    		"mmd"
	    	]
	    },
	    	"application/vnd.ciedi": {
	    	source: "iana"
	    },
	    	"application/vnd.cinderella": {
	    	source: "iana",
	    	extensions: [
	    		"cdy"
	    	]
	    },
	    	"application/vnd.cirpack.isdn-ext": {
	    	source: "iana"
	    },
	    	"application/vnd.citationstyles.style+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"csl"
	    	]
	    },
	    	"application/vnd.claymore": {
	    	source: "iana",
	    	extensions: [
	    		"cla"
	    	]
	    },
	    	"application/vnd.cloanto.rp9": {
	    	source: "iana",
	    	extensions: [
	    		"rp9"
	    	]
	    },
	    	"application/vnd.clonk.c4group": {
	    	source: "iana",
	    	extensions: [
	    		"c4g",
	    		"c4d",
	    		"c4f",
	    		"c4p",
	    		"c4u"
	    	]
	    },
	    	"application/vnd.cluetrust.cartomobile-config": {
	    	source: "iana",
	    	extensions: [
	    		"c11amc"
	    	]
	    },
	    	"application/vnd.cluetrust.cartomobile-config-pkg": {
	    	source: "iana",
	    	extensions: [
	    		"c11amz"
	    	]
	    },
	    	"application/vnd.coffeescript": {
	    	source: "iana"
	    },
	    	"application/vnd.collabio.xodocuments.document": {
	    	source: "iana"
	    },
	    	"application/vnd.collabio.xodocuments.document-template": {
	    	source: "iana"
	    },
	    	"application/vnd.collabio.xodocuments.presentation": {
	    	source: "iana"
	    },
	    	"application/vnd.collabio.xodocuments.presentation-template": {
	    	source: "iana"
	    },
	    	"application/vnd.collabio.xodocuments.spreadsheet": {
	    	source: "iana"
	    },
	    	"application/vnd.collabio.xodocuments.spreadsheet-template": {
	    	source: "iana"
	    },
	    	"application/vnd.collection+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.collection.doc+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.collection.next+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.comicbook+zip": {
	    	source: "iana",
	    	compressible: false
	    },
	    	"application/vnd.comicbook-rar": {
	    	source: "iana"
	    },
	    	"application/vnd.commerce-battelle": {
	    	source: "iana"
	    },
	    	"application/vnd.commonspace": {
	    	source: "iana",
	    	extensions: [
	    		"csp"
	    	]
	    },
	    	"application/vnd.contact.cmsg": {
	    	source: "iana",
	    	extensions: [
	    		"cdbcmsg"
	    	]
	    },
	    	"application/vnd.coreos.ignition+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.cosmocaller": {
	    	source: "iana",
	    	extensions: [
	    		"cmc"
	    	]
	    },
	    	"application/vnd.crick.clicker": {
	    	source: "iana",
	    	extensions: [
	    		"clkx"
	    	]
	    },
	    	"application/vnd.crick.clicker.keyboard": {
	    	source: "iana",
	    	extensions: [
	    		"clkk"
	    	]
	    },
	    	"application/vnd.crick.clicker.palette": {
	    	source: "iana",
	    	extensions: [
	    		"clkp"
	    	]
	    },
	    	"application/vnd.crick.clicker.template": {
	    	source: "iana",
	    	extensions: [
	    		"clkt"
	    	]
	    },
	    	"application/vnd.crick.clicker.wordbank": {
	    	source: "iana",
	    	extensions: [
	    		"clkw"
	    	]
	    },
	    	"application/vnd.criticaltools.wbs+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"wbs"
	    	]
	    },
	    	"application/vnd.cryptii.pipe+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.crypto-shade-file": {
	    	source: "iana"
	    },
	    	"application/vnd.cryptomator.encrypted": {
	    	source: "iana"
	    },
	    	"application/vnd.cryptomator.vault": {
	    	source: "iana"
	    },
	    	"application/vnd.ctc-posml": {
	    	source: "iana",
	    	extensions: [
	    		"pml"
	    	]
	    },
	    	"application/vnd.ctct.ws+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.cups-pdf": {
	    	source: "iana"
	    },
	    	"application/vnd.cups-postscript": {
	    	source: "iana"
	    },
	    	"application/vnd.cups-ppd": {
	    	source: "iana",
	    	extensions: [
	    		"ppd"
	    	]
	    },
	    	"application/vnd.cups-raster": {
	    	source: "iana"
	    },
	    	"application/vnd.cups-raw": {
	    	source: "iana"
	    },
	    	"application/vnd.curl": {
	    	source: "iana"
	    },
	    	"application/vnd.curl.car": {
	    	source: "apache",
	    	extensions: [
	    		"car"
	    	]
	    },
	    	"application/vnd.curl.pcurl": {
	    	source: "apache",
	    	extensions: [
	    		"pcurl"
	    	]
	    },
	    	"application/vnd.cyan.dean.root+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.cybank": {
	    	source: "iana"
	    },
	    	"application/vnd.cyclonedx+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.cyclonedx+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.d2l.coursepackage1p0+zip": {
	    	source: "iana",
	    	compressible: false
	    },
	    	"application/vnd.d3m-dataset": {
	    	source: "iana"
	    },
	    	"application/vnd.d3m-problem": {
	    	source: "iana"
	    },
	    	"application/vnd.dart": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"dart"
	    	]
	    },
	    	"application/vnd.data-vision.rdz": {
	    	source: "iana",
	    	extensions: [
	    		"rdz"
	    	]
	    },
	    	"application/vnd.datapackage+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.dataresource+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.dbf": {
	    	source: "iana",
	    	extensions: [
	    		"dbf"
	    	]
	    },
	    	"application/vnd.debian.binary-package": {
	    	source: "iana"
	    },
	    	"application/vnd.dece.data": {
	    	source: "iana",
	    	extensions: [
	    		"uvf",
	    		"uvvf",
	    		"uvd",
	    		"uvvd"
	    	]
	    },
	    	"application/vnd.dece.ttml+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"uvt",
	    		"uvvt"
	    	]
	    },
	    	"application/vnd.dece.unspecified": {
	    	source: "iana",
	    	extensions: [
	    		"uvx",
	    		"uvvx"
	    	]
	    },
	    	"application/vnd.dece.zip": {
	    	source: "iana",
	    	extensions: [
	    		"uvz",
	    		"uvvz"
	    	]
	    },
	    	"application/vnd.denovo.fcselayout-link": {
	    	source: "iana",
	    	extensions: [
	    		"fe_launch"
	    	]
	    },
	    	"application/vnd.desmume.movie": {
	    	source: "iana"
	    },
	    	"application/vnd.dir-bi.plate-dl-nosuffix": {
	    	source: "iana"
	    },
	    	"application/vnd.dm.delegation+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.dna": {
	    	source: "iana",
	    	extensions: [
	    		"dna"
	    	]
	    },
	    	"application/vnd.document+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.dolby.mlp": {
	    	source: "apache",
	    	extensions: [
	    		"mlp"
	    	]
	    },
	    	"application/vnd.dolby.mobile.1": {
	    	source: "iana"
	    },
	    	"application/vnd.dolby.mobile.2": {
	    	source: "iana"
	    },
	    	"application/vnd.doremir.scorecloud-binary-document": {
	    	source: "iana"
	    },
	    	"application/vnd.dpgraph": {
	    	source: "iana",
	    	extensions: [
	    		"dpg"
	    	]
	    },
	    	"application/vnd.dreamfactory": {
	    	source: "iana",
	    	extensions: [
	    		"dfac"
	    	]
	    },
	    	"application/vnd.drive+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.ds-keypoint": {
	    	source: "apache",
	    	extensions: [
	    		"kpxx"
	    	]
	    },
	    	"application/vnd.dtg.local": {
	    	source: "iana"
	    },
	    	"application/vnd.dtg.local.flash": {
	    	source: "iana"
	    },
	    	"application/vnd.dtg.local.html": {
	    	source: "iana"
	    },
	    	"application/vnd.dvb.ait": {
	    	source: "iana",
	    	extensions: [
	    		"ait"
	    	]
	    },
	    	"application/vnd.dvb.dvbisl+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.dvb.dvbj": {
	    	source: "iana"
	    },
	    	"application/vnd.dvb.esgcontainer": {
	    	source: "iana"
	    },
	    	"application/vnd.dvb.ipdcdftnotifaccess": {
	    	source: "iana"
	    },
	    	"application/vnd.dvb.ipdcesgaccess": {
	    	source: "iana"
	    },
	    	"application/vnd.dvb.ipdcesgaccess2": {
	    	source: "iana"
	    },
	    	"application/vnd.dvb.ipdcesgpdd": {
	    	source: "iana"
	    },
	    	"application/vnd.dvb.ipdcroaming": {
	    	source: "iana"
	    },
	    	"application/vnd.dvb.iptv.alfec-base": {
	    	source: "iana"
	    },
	    	"application/vnd.dvb.iptv.alfec-enhancement": {
	    	source: "iana"
	    },
	    	"application/vnd.dvb.notif-aggregate-root+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.dvb.notif-container+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.dvb.notif-generic+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.dvb.notif-ia-msglist+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.dvb.notif-ia-registration-request+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.dvb.notif-ia-registration-response+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.dvb.notif-init+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.dvb.pfr": {
	    	source: "iana"
	    },
	    	"application/vnd.dvb.service": {
	    	source: "iana",
	    	extensions: [
	    		"svc"
	    	]
	    },
	    	"application/vnd.dxr": {
	    	source: "iana"
	    },
	    	"application/vnd.dynageo": {
	    	source: "iana",
	    	extensions: [
	    		"geo"
	    	]
	    },
	    	"application/vnd.dzr": {
	    	source: "iana"
	    },
	    	"application/vnd.easykaraoke.cdgdownload": {
	    	source: "iana"
	    },
	    	"application/vnd.ecdis-update": {
	    	source: "iana"
	    },
	    	"application/vnd.ecip.rlp": {
	    	source: "iana"
	    },
	    	"application/vnd.eclipse.ditto+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.ecowin.chart": {
	    	source: "iana",
	    	extensions: [
	    		"mag"
	    	]
	    },
	    	"application/vnd.ecowin.filerequest": {
	    	source: "iana"
	    },
	    	"application/vnd.ecowin.fileupdate": {
	    	source: "iana"
	    },
	    	"application/vnd.ecowin.series": {
	    	source: "iana"
	    },
	    	"application/vnd.ecowin.seriesrequest": {
	    	source: "iana"
	    },
	    	"application/vnd.ecowin.seriesupdate": {
	    	source: "iana"
	    },
	    	"application/vnd.efi.img": {
	    	source: "iana"
	    },
	    	"application/vnd.efi.iso": {
	    	source: "iana"
	    },
	    	"application/vnd.emclient.accessrequest+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.enliven": {
	    	source: "iana",
	    	extensions: [
	    		"nml"
	    	]
	    },
	    	"application/vnd.enphase.envoy": {
	    	source: "iana"
	    },
	    	"application/vnd.eprints.data+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.epson.esf": {
	    	source: "iana",
	    	extensions: [
	    		"esf"
	    	]
	    },
	    	"application/vnd.epson.msf": {
	    	source: "iana",
	    	extensions: [
	    		"msf"
	    	]
	    },
	    	"application/vnd.epson.quickanime": {
	    	source: "iana",
	    	extensions: [
	    		"qam"
	    	]
	    },
	    	"application/vnd.epson.salt": {
	    	source: "iana",
	    	extensions: [
	    		"slt"
	    	]
	    },
	    	"application/vnd.epson.ssf": {
	    	source: "iana",
	    	extensions: [
	    		"ssf"
	    	]
	    },
	    	"application/vnd.ericsson.quickcall": {
	    	source: "iana"
	    },
	    	"application/vnd.espass-espass+zip": {
	    	source: "iana",
	    	compressible: false
	    },
	    	"application/vnd.eszigno3+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"es3",
	    		"et3"
	    	]
	    },
	    	"application/vnd.etsi.aoc+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.etsi.asic-e+zip": {
	    	source: "iana",
	    	compressible: false
	    },
	    	"application/vnd.etsi.asic-s+zip": {
	    	source: "iana",
	    	compressible: false
	    },
	    	"application/vnd.etsi.cug+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.etsi.iptvcommand+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.etsi.iptvdiscovery+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.etsi.iptvprofile+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.etsi.iptvsad-bc+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.etsi.iptvsad-cod+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.etsi.iptvsad-npvr+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.etsi.iptvservice+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.etsi.iptvsync+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.etsi.iptvueprofile+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.etsi.mcid+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.etsi.mheg5": {
	    	source: "iana"
	    },
	    	"application/vnd.etsi.overload-control-policy-dataset+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.etsi.pstn+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.etsi.sci+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.etsi.simservs+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.etsi.timestamp-token": {
	    	source: "iana"
	    },
	    	"application/vnd.etsi.tsl+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.etsi.tsl.der": {
	    	source: "iana"
	    },
	    	"application/vnd.eu.kasparian.car+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.eudora.data": {
	    	source: "iana"
	    },
	    	"application/vnd.evolv.ecig.profile": {
	    	source: "iana"
	    },
	    	"application/vnd.evolv.ecig.settings": {
	    	source: "iana"
	    },
	    	"application/vnd.evolv.ecig.theme": {
	    	source: "iana"
	    },
	    	"application/vnd.exstream-empower+zip": {
	    	source: "iana",
	    	compressible: false
	    },
	    	"application/vnd.exstream-package": {
	    	source: "iana"
	    },
	    	"application/vnd.ezpix-album": {
	    	source: "iana",
	    	extensions: [
	    		"ez2"
	    	]
	    },
	    	"application/vnd.ezpix-package": {
	    	source: "iana",
	    	extensions: [
	    		"ez3"
	    	]
	    },
	    	"application/vnd.f-secure.mobile": {
	    	source: "iana"
	    },
	    	"application/vnd.familysearch.gedcom+zip": {
	    	source: "iana",
	    	compressible: false
	    },
	    	"application/vnd.fastcopy-disk-image": {
	    	source: "iana"
	    },
	    	"application/vnd.fdf": {
	    	source: "iana",
	    	extensions: [
	    		"fdf"
	    	]
	    },
	    	"application/vnd.fdsn.mseed": {
	    	source: "iana",
	    	extensions: [
	    		"mseed"
	    	]
	    },
	    	"application/vnd.fdsn.seed": {
	    	source: "iana",
	    	extensions: [
	    		"seed",
	    		"dataless"
	    	]
	    },
	    	"application/vnd.ffsns": {
	    	source: "iana"
	    },
	    	"application/vnd.ficlab.flb+zip": {
	    	source: "iana",
	    	compressible: false
	    },
	    	"application/vnd.filmit.zfc": {
	    	source: "iana"
	    },
	    	"application/vnd.fints": {
	    	source: "iana"
	    },
	    	"application/vnd.firemonkeys.cloudcell": {
	    	source: "iana"
	    },
	    	"application/vnd.flographit": {
	    	source: "iana",
	    	extensions: [
	    		"gph"
	    	]
	    },
	    	"application/vnd.fluxtime.clip": {
	    	source: "iana",
	    	extensions: [
	    		"ftc"
	    	]
	    },
	    	"application/vnd.font-fontforge-sfd": {
	    	source: "iana"
	    },
	    	"application/vnd.framemaker": {
	    	source: "iana",
	    	extensions: [
	    		"fm",
	    		"frame",
	    		"maker",
	    		"book"
	    	]
	    },
	    	"application/vnd.frogans.fnc": {
	    	source: "iana",
	    	extensions: [
	    		"fnc"
	    	]
	    },
	    	"application/vnd.frogans.ltf": {
	    	source: "iana",
	    	extensions: [
	    		"ltf"
	    	]
	    },
	    	"application/vnd.fsc.weblaunch": {
	    	source: "iana",
	    	extensions: [
	    		"fsc"
	    	]
	    },
	    	"application/vnd.fujifilm.fb.docuworks": {
	    	source: "iana"
	    },
	    	"application/vnd.fujifilm.fb.docuworks.binder": {
	    	source: "iana"
	    },
	    	"application/vnd.fujifilm.fb.docuworks.container": {
	    	source: "iana"
	    },
	    	"application/vnd.fujifilm.fb.jfi+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.fujitsu.oasys": {
	    	source: "iana",
	    	extensions: [
	    		"oas"
	    	]
	    },
	    	"application/vnd.fujitsu.oasys2": {
	    	source: "iana",
	    	extensions: [
	    		"oa2"
	    	]
	    },
	    	"application/vnd.fujitsu.oasys3": {
	    	source: "iana",
	    	extensions: [
	    		"oa3"
	    	]
	    },
	    	"application/vnd.fujitsu.oasysgp": {
	    	source: "iana",
	    	extensions: [
	    		"fg5"
	    	]
	    },
	    	"application/vnd.fujitsu.oasysprs": {
	    	source: "iana",
	    	extensions: [
	    		"bh2"
	    	]
	    },
	    	"application/vnd.fujixerox.art-ex": {
	    	source: "iana"
	    },
	    	"application/vnd.fujixerox.art4": {
	    	source: "iana"
	    },
	    	"application/vnd.fujixerox.ddd": {
	    	source: "iana",
	    	extensions: [
	    		"ddd"
	    	]
	    },
	    	"application/vnd.fujixerox.docuworks": {
	    	source: "iana",
	    	extensions: [
	    		"xdw"
	    	]
	    },
	    	"application/vnd.fujixerox.docuworks.binder": {
	    	source: "iana",
	    	extensions: [
	    		"xbd"
	    	]
	    },
	    	"application/vnd.fujixerox.docuworks.container": {
	    	source: "iana"
	    },
	    	"application/vnd.fujixerox.hbpl": {
	    	source: "iana"
	    },
	    	"application/vnd.fut-misnet": {
	    	source: "iana"
	    },
	    	"application/vnd.futoin+cbor": {
	    	source: "iana"
	    },
	    	"application/vnd.futoin+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.fuzzysheet": {
	    	source: "iana",
	    	extensions: [
	    		"fzs"
	    	]
	    },
	    	"application/vnd.genomatix.tuxedo": {
	    	source: "iana",
	    	extensions: [
	    		"txd"
	    	]
	    },
	    	"application/vnd.gentics.grd+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.geo+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.geocube+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.geogebra.file": {
	    	source: "iana",
	    	extensions: [
	    		"ggb"
	    	]
	    },
	    	"application/vnd.geogebra.slides": {
	    	source: "iana"
	    },
	    	"application/vnd.geogebra.tool": {
	    	source: "iana",
	    	extensions: [
	    		"ggt"
	    	]
	    },
	    	"application/vnd.geometry-explorer": {
	    	source: "iana",
	    	extensions: [
	    		"gex",
	    		"gre"
	    	]
	    },
	    	"application/vnd.geonext": {
	    	source: "iana",
	    	extensions: [
	    		"gxt"
	    	]
	    },
	    	"application/vnd.geoplan": {
	    	source: "iana",
	    	extensions: [
	    		"g2w"
	    	]
	    },
	    	"application/vnd.geospace": {
	    	source: "iana",
	    	extensions: [
	    		"g3w"
	    	]
	    },
	    	"application/vnd.gerber": {
	    	source: "iana"
	    },
	    	"application/vnd.globalplatform.card-content-mgt": {
	    	source: "iana"
	    },
	    	"application/vnd.globalplatform.card-content-mgt-response": {
	    	source: "iana"
	    },
	    	"application/vnd.gmx": {
	    	source: "iana",
	    	extensions: [
	    		"gmx"
	    	]
	    },
	    	"application/vnd.google-apps.document": {
	    	compressible: false,
	    	extensions: [
	    		"gdoc"
	    	]
	    },
	    	"application/vnd.google-apps.presentation": {
	    	compressible: false,
	    	extensions: [
	    		"gslides"
	    	]
	    },
	    	"application/vnd.google-apps.spreadsheet": {
	    	compressible: false,
	    	extensions: [
	    		"gsheet"
	    	]
	    },
	    	"application/vnd.google-earth.kml+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"kml"
	    	]
	    },
	    	"application/vnd.google-earth.kmz": {
	    	source: "iana",
	    	compressible: false,
	    	extensions: [
	    		"kmz"
	    	]
	    },
	    	"application/vnd.gov.sk.e-form+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.gov.sk.e-form+zip": {
	    	source: "iana",
	    	compressible: false
	    },
	    	"application/vnd.gov.sk.xmldatacontainer+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.grafeq": {
	    	source: "iana",
	    	extensions: [
	    		"gqf",
	    		"gqs"
	    	]
	    },
	    	"application/vnd.gridmp": {
	    	source: "iana"
	    },
	    	"application/vnd.groove-account": {
	    	source: "iana",
	    	extensions: [
	    		"gac"
	    	]
	    },
	    	"application/vnd.groove-help": {
	    	source: "iana",
	    	extensions: [
	    		"ghf"
	    	]
	    },
	    	"application/vnd.groove-identity-message": {
	    	source: "iana",
	    	extensions: [
	    		"gim"
	    	]
	    },
	    	"application/vnd.groove-injector": {
	    	source: "iana",
	    	extensions: [
	    		"grv"
	    	]
	    },
	    	"application/vnd.groove-tool-message": {
	    	source: "iana",
	    	extensions: [
	    		"gtm"
	    	]
	    },
	    	"application/vnd.groove-tool-template": {
	    	source: "iana",
	    	extensions: [
	    		"tpl"
	    	]
	    },
	    	"application/vnd.groove-vcard": {
	    	source: "iana",
	    	extensions: [
	    		"vcg"
	    	]
	    },
	    	"application/vnd.hal+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.hal+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"hal"
	    	]
	    },
	    	"application/vnd.handheld-entertainment+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"zmm"
	    	]
	    },
	    	"application/vnd.hbci": {
	    	source: "iana",
	    	extensions: [
	    		"hbci"
	    	]
	    },
	    	"application/vnd.hc+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.hcl-bireports": {
	    	source: "iana"
	    },
	    	"application/vnd.hdt": {
	    	source: "iana"
	    },
	    	"application/vnd.heroku+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.hhe.lesson-player": {
	    	source: "iana",
	    	extensions: [
	    		"les"
	    	]
	    },
	    	"application/vnd.hl7cda+xml": {
	    	source: "iana",
	    	charset: "UTF-8",
	    	compressible: true
	    },
	    	"application/vnd.hl7v2+xml": {
	    	source: "iana",
	    	charset: "UTF-8",
	    	compressible: true
	    },
	    	"application/vnd.hp-hpgl": {
	    	source: "iana",
	    	extensions: [
	    		"hpgl"
	    	]
	    },
	    	"application/vnd.hp-hpid": {
	    	source: "iana",
	    	extensions: [
	    		"hpid"
	    	]
	    },
	    	"application/vnd.hp-hps": {
	    	source: "iana",
	    	extensions: [
	    		"hps"
	    	]
	    },
	    	"application/vnd.hp-jlyt": {
	    	source: "iana",
	    	extensions: [
	    		"jlt"
	    	]
	    },
	    	"application/vnd.hp-pcl": {
	    	source: "iana",
	    	extensions: [
	    		"pcl"
	    	]
	    },
	    	"application/vnd.hp-pclxl": {
	    	source: "iana",
	    	extensions: [
	    		"pclxl"
	    	]
	    },
	    	"application/vnd.httphone": {
	    	source: "iana"
	    },
	    	"application/vnd.hydrostatix.sof-data": {
	    	source: "iana",
	    	extensions: [
	    		"sfd-hdstx"
	    	]
	    },
	    	"application/vnd.hyper+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.hyper-item+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.hyperdrive+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.hzn-3d-crossword": {
	    	source: "iana"
	    },
	    	"application/vnd.ibm.afplinedata": {
	    	source: "iana"
	    },
	    	"application/vnd.ibm.electronic-media": {
	    	source: "iana"
	    },
	    	"application/vnd.ibm.minipay": {
	    	source: "iana",
	    	extensions: [
	    		"mpy"
	    	]
	    },
	    	"application/vnd.ibm.modcap": {
	    	source: "iana",
	    	extensions: [
	    		"afp",
	    		"listafp",
	    		"list3820"
	    	]
	    },
	    	"application/vnd.ibm.rights-management": {
	    	source: "iana",
	    	extensions: [
	    		"irm"
	    	]
	    },
	    	"application/vnd.ibm.secure-container": {
	    	source: "iana",
	    	extensions: [
	    		"sc"
	    	]
	    },
	    	"application/vnd.iccprofile": {
	    	source: "iana",
	    	extensions: [
	    		"icc",
	    		"icm"
	    	]
	    },
	    	"application/vnd.ieee.1905": {
	    	source: "iana"
	    },
	    	"application/vnd.igloader": {
	    	source: "iana",
	    	extensions: [
	    		"igl"
	    	]
	    },
	    	"application/vnd.imagemeter.folder+zip": {
	    	source: "iana",
	    	compressible: false
	    },
	    	"application/vnd.imagemeter.image+zip": {
	    	source: "iana",
	    	compressible: false
	    },
	    	"application/vnd.immervision-ivp": {
	    	source: "iana",
	    	extensions: [
	    		"ivp"
	    	]
	    },
	    	"application/vnd.immervision-ivu": {
	    	source: "iana",
	    	extensions: [
	    		"ivu"
	    	]
	    },
	    	"application/vnd.ims.imsccv1p1": {
	    	source: "iana"
	    },
	    	"application/vnd.ims.imsccv1p2": {
	    	source: "iana"
	    },
	    	"application/vnd.ims.imsccv1p3": {
	    	source: "iana"
	    },
	    	"application/vnd.ims.lis.v2.result+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.ims.lti.v2.toolconsumerprofile+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.ims.lti.v2.toolproxy+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.ims.lti.v2.toolproxy.id+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.ims.lti.v2.toolsettings+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.ims.lti.v2.toolsettings.simple+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.informedcontrol.rms+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.informix-visionary": {
	    	source: "iana"
	    },
	    	"application/vnd.infotech.project": {
	    	source: "iana"
	    },
	    	"application/vnd.infotech.project+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.innopath.wamp.notification": {
	    	source: "iana"
	    },
	    	"application/vnd.insors.igm": {
	    	source: "iana",
	    	extensions: [
	    		"igm"
	    	]
	    },
	    	"application/vnd.intercon.formnet": {
	    	source: "iana",
	    	extensions: [
	    		"xpw",
	    		"xpx"
	    	]
	    },
	    	"application/vnd.intergeo": {
	    	source: "iana",
	    	extensions: [
	    		"i2g"
	    	]
	    },
	    	"application/vnd.intertrust.digibox": {
	    	source: "iana"
	    },
	    	"application/vnd.intertrust.nncp": {
	    	source: "iana"
	    },
	    	"application/vnd.intu.qbo": {
	    	source: "iana",
	    	extensions: [
	    		"qbo"
	    	]
	    },
	    	"application/vnd.intu.qfx": {
	    	source: "iana",
	    	extensions: [
	    		"qfx"
	    	]
	    },
	    	"application/vnd.iptc.g2.catalogitem+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.iptc.g2.conceptitem+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.iptc.g2.knowledgeitem+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.iptc.g2.newsitem+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.iptc.g2.newsmessage+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.iptc.g2.packageitem+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.iptc.g2.planningitem+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.ipunplugged.rcprofile": {
	    	source: "iana",
	    	extensions: [
	    		"rcprofile"
	    	]
	    },
	    	"application/vnd.irepository.package+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"irp"
	    	]
	    },
	    	"application/vnd.is-xpr": {
	    	source: "iana",
	    	extensions: [
	    		"xpr"
	    	]
	    },
	    	"application/vnd.isac.fcs": {
	    	source: "iana",
	    	extensions: [
	    		"fcs"
	    	]
	    },
	    	"application/vnd.iso11783-10+zip": {
	    	source: "iana",
	    	compressible: false
	    },
	    	"application/vnd.jam": {
	    	source: "iana",
	    	extensions: [
	    		"jam"
	    	]
	    },
	    	"application/vnd.japannet-directory-service": {
	    	source: "iana"
	    },
	    	"application/vnd.japannet-jpnstore-wakeup": {
	    	source: "iana"
	    },
	    	"application/vnd.japannet-payment-wakeup": {
	    	source: "iana"
	    },
	    	"application/vnd.japannet-registration": {
	    	source: "iana"
	    },
	    	"application/vnd.japannet-registration-wakeup": {
	    	source: "iana"
	    },
	    	"application/vnd.japannet-setstore-wakeup": {
	    	source: "iana"
	    },
	    	"application/vnd.japannet-verification": {
	    	source: "iana"
	    },
	    	"application/vnd.japannet-verification-wakeup": {
	    	source: "iana"
	    },
	    	"application/vnd.jcp.javame.midlet-rms": {
	    	source: "iana",
	    	extensions: [
	    		"rms"
	    	]
	    },
	    	"application/vnd.jisp": {
	    	source: "iana",
	    	extensions: [
	    		"jisp"
	    	]
	    },
	    	"application/vnd.joost.joda-archive": {
	    	source: "iana",
	    	extensions: [
	    		"joda"
	    	]
	    },
	    	"application/vnd.jsk.isdn-ngn": {
	    	source: "iana"
	    },
	    	"application/vnd.kahootz": {
	    	source: "iana",
	    	extensions: [
	    		"ktz",
	    		"ktr"
	    	]
	    },
	    	"application/vnd.kde.karbon": {
	    	source: "iana",
	    	extensions: [
	    		"karbon"
	    	]
	    },
	    	"application/vnd.kde.kchart": {
	    	source: "iana",
	    	extensions: [
	    		"chrt"
	    	]
	    },
	    	"application/vnd.kde.kformula": {
	    	source: "iana",
	    	extensions: [
	    		"kfo"
	    	]
	    },
	    	"application/vnd.kde.kivio": {
	    	source: "iana",
	    	extensions: [
	    		"flw"
	    	]
	    },
	    	"application/vnd.kde.kontour": {
	    	source: "iana",
	    	extensions: [
	    		"kon"
	    	]
	    },
	    	"application/vnd.kde.kpresenter": {
	    	source: "iana",
	    	extensions: [
	    		"kpr",
	    		"kpt"
	    	]
	    },
	    	"application/vnd.kde.kspread": {
	    	source: "iana",
	    	extensions: [
	    		"ksp"
	    	]
	    },
	    	"application/vnd.kde.kword": {
	    	source: "iana",
	    	extensions: [
	    		"kwd",
	    		"kwt"
	    	]
	    },
	    	"application/vnd.kenameaapp": {
	    	source: "iana",
	    	extensions: [
	    		"htke"
	    	]
	    },
	    	"application/vnd.kidspiration": {
	    	source: "iana",
	    	extensions: [
	    		"kia"
	    	]
	    },
	    	"application/vnd.kinar": {
	    	source: "iana",
	    	extensions: [
	    		"kne",
	    		"knp"
	    	]
	    },
	    	"application/vnd.koan": {
	    	source: "iana",
	    	extensions: [
	    		"skp",
	    		"skd",
	    		"skt",
	    		"skm"
	    	]
	    },
	    	"application/vnd.kodak-descriptor": {
	    	source: "iana",
	    	extensions: [
	    		"sse"
	    	]
	    },
	    	"application/vnd.las": {
	    	source: "iana"
	    },
	    	"application/vnd.las.las+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.las.las+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"lasxml"
	    	]
	    },
	    	"application/vnd.laszip": {
	    	source: "iana"
	    },
	    	"application/vnd.leap+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.liberty-request+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.llamagraphics.life-balance.desktop": {
	    	source: "iana",
	    	extensions: [
	    		"lbd"
	    	]
	    },
	    	"application/vnd.llamagraphics.life-balance.exchange+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"lbe"
	    	]
	    },
	    	"application/vnd.logipipe.circuit+zip": {
	    	source: "iana",
	    	compressible: false
	    },
	    	"application/vnd.loom": {
	    	source: "iana"
	    },
	    	"application/vnd.lotus-1-2-3": {
	    	source: "iana",
	    	extensions: [
	    		"123"
	    	]
	    },
	    	"application/vnd.lotus-approach": {
	    	source: "iana",
	    	extensions: [
	    		"apr"
	    	]
	    },
	    	"application/vnd.lotus-freelance": {
	    	source: "iana",
	    	extensions: [
	    		"pre"
	    	]
	    },
	    	"application/vnd.lotus-notes": {
	    	source: "iana",
	    	extensions: [
	    		"nsf"
	    	]
	    },
	    	"application/vnd.lotus-organizer": {
	    	source: "iana",
	    	extensions: [
	    		"org"
	    	]
	    },
	    	"application/vnd.lotus-screencam": {
	    	source: "iana",
	    	extensions: [
	    		"scm"
	    	]
	    },
	    	"application/vnd.lotus-wordpro": {
	    	source: "iana",
	    	extensions: [
	    		"lwp"
	    	]
	    },
	    	"application/vnd.macports.portpkg": {
	    	source: "iana",
	    	extensions: [
	    		"portpkg"
	    	]
	    },
	    	"application/vnd.mapbox-vector-tile": {
	    	source: "iana",
	    	extensions: [
	    		"mvt"
	    	]
	    },
	    	"application/vnd.marlin.drm.actiontoken+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.marlin.drm.conftoken+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.marlin.drm.license+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.marlin.drm.mdcf": {
	    	source: "iana"
	    },
	    	"application/vnd.mason+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.maxar.archive.3tz+zip": {
	    	source: "iana",
	    	compressible: false
	    },
	    	"application/vnd.maxmind.maxmind-db": {
	    	source: "iana"
	    },
	    	"application/vnd.mcd": {
	    	source: "iana",
	    	extensions: [
	    		"mcd"
	    	]
	    },
	    	"application/vnd.medcalcdata": {
	    	source: "iana",
	    	extensions: [
	    		"mc1"
	    	]
	    },
	    	"application/vnd.mediastation.cdkey": {
	    	source: "iana",
	    	extensions: [
	    		"cdkey"
	    	]
	    },
	    	"application/vnd.meridian-slingshot": {
	    	source: "iana"
	    },
	    	"application/vnd.mfer": {
	    	source: "iana",
	    	extensions: [
	    		"mwf"
	    	]
	    },
	    	"application/vnd.mfmp": {
	    	source: "iana",
	    	extensions: [
	    		"mfm"
	    	]
	    },
	    	"application/vnd.micro+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.micrografx.flo": {
	    	source: "iana",
	    	extensions: [
	    		"flo"
	    	]
	    },
	    	"application/vnd.micrografx.igx": {
	    	source: "iana",
	    	extensions: [
	    		"igx"
	    	]
	    },
	    	"application/vnd.microsoft.portable-executable": {
	    	source: "iana"
	    },
	    	"application/vnd.microsoft.windows.thumbnail-cache": {
	    	source: "iana"
	    },
	    	"application/vnd.miele+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.mif": {
	    	source: "iana",
	    	extensions: [
	    		"mif"
	    	]
	    },
	    	"application/vnd.minisoft-hp3000-save": {
	    	source: "iana"
	    },
	    	"application/vnd.mitsubishi.misty-guard.trustweb": {
	    	source: "iana"
	    },
	    	"application/vnd.mobius.daf": {
	    	source: "iana",
	    	extensions: [
	    		"daf"
	    	]
	    },
	    	"application/vnd.mobius.dis": {
	    	source: "iana",
	    	extensions: [
	    		"dis"
	    	]
	    },
	    	"application/vnd.mobius.mbk": {
	    	source: "iana",
	    	extensions: [
	    		"mbk"
	    	]
	    },
	    	"application/vnd.mobius.mqy": {
	    	source: "iana",
	    	extensions: [
	    		"mqy"
	    	]
	    },
	    	"application/vnd.mobius.msl": {
	    	source: "iana",
	    	extensions: [
	    		"msl"
	    	]
	    },
	    	"application/vnd.mobius.plc": {
	    	source: "iana",
	    	extensions: [
	    		"plc"
	    	]
	    },
	    	"application/vnd.mobius.txf": {
	    	source: "iana",
	    	extensions: [
	    		"txf"
	    	]
	    },
	    	"application/vnd.mophun.application": {
	    	source: "iana",
	    	extensions: [
	    		"mpn"
	    	]
	    },
	    	"application/vnd.mophun.certificate": {
	    	source: "iana",
	    	extensions: [
	    		"mpc"
	    	]
	    },
	    	"application/vnd.motorola.flexsuite": {
	    	source: "iana"
	    },
	    	"application/vnd.motorola.flexsuite.adsi": {
	    	source: "iana"
	    },
	    	"application/vnd.motorola.flexsuite.fis": {
	    	source: "iana"
	    },
	    	"application/vnd.motorola.flexsuite.gotap": {
	    	source: "iana"
	    },
	    	"application/vnd.motorola.flexsuite.kmr": {
	    	source: "iana"
	    },
	    	"application/vnd.motorola.flexsuite.ttc": {
	    	source: "iana"
	    },
	    	"application/vnd.motorola.flexsuite.wem": {
	    	source: "iana"
	    },
	    	"application/vnd.motorola.iprm": {
	    	source: "iana"
	    },
	    	"application/vnd.mozilla.xul+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"xul"
	    	]
	    },
	    	"application/vnd.ms-3mfdocument": {
	    	source: "iana"
	    },
	    	"application/vnd.ms-artgalry": {
	    	source: "iana",
	    	extensions: [
	    		"cil"
	    	]
	    },
	    	"application/vnd.ms-asf": {
	    	source: "iana"
	    },
	    	"application/vnd.ms-cab-compressed": {
	    	source: "iana",
	    	extensions: [
	    		"cab"
	    	]
	    },
	    	"application/vnd.ms-color.iccprofile": {
	    	source: "apache"
	    },
	    	"application/vnd.ms-excel": {
	    	source: "iana",
	    	compressible: false,
	    	extensions: [
	    		"xls",
	    		"xlm",
	    		"xla",
	    		"xlc",
	    		"xlt",
	    		"xlw"
	    	]
	    },
	    	"application/vnd.ms-excel.addin.macroenabled.12": {
	    	source: "iana",
	    	extensions: [
	    		"xlam"
	    	]
	    },
	    	"application/vnd.ms-excel.sheet.binary.macroenabled.12": {
	    	source: "iana",
	    	extensions: [
	    		"xlsb"
	    	]
	    },
	    	"application/vnd.ms-excel.sheet.macroenabled.12": {
	    	source: "iana",
	    	extensions: [
	    		"xlsm"
	    	]
	    },
	    	"application/vnd.ms-excel.template.macroenabled.12": {
	    	source: "iana",
	    	extensions: [
	    		"xltm"
	    	]
	    },
	    	"application/vnd.ms-fontobject": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"eot"
	    	]
	    },
	    	"application/vnd.ms-htmlhelp": {
	    	source: "iana",
	    	extensions: [
	    		"chm"
	    	]
	    },
	    	"application/vnd.ms-ims": {
	    	source: "iana",
	    	extensions: [
	    		"ims"
	    	]
	    },
	    	"application/vnd.ms-lrm": {
	    	source: "iana",
	    	extensions: [
	    		"lrm"
	    	]
	    },
	    	"application/vnd.ms-office.activex+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.ms-officetheme": {
	    	source: "iana",
	    	extensions: [
	    		"thmx"
	    	]
	    },
	    	"application/vnd.ms-opentype": {
	    	source: "apache",
	    	compressible: true
	    },
	    	"application/vnd.ms-outlook": {
	    	compressible: false,
	    	extensions: [
	    		"msg"
	    	]
	    },
	    	"application/vnd.ms-package.obfuscated-opentype": {
	    	source: "apache"
	    },
	    	"application/vnd.ms-pki.seccat": {
	    	source: "apache",
	    	extensions: [
	    		"cat"
	    	]
	    },
	    	"application/vnd.ms-pki.stl": {
	    	source: "apache",
	    	extensions: [
	    		"stl"
	    	]
	    },
	    	"application/vnd.ms-playready.initiator+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.ms-powerpoint": {
	    	source: "iana",
	    	compressible: false,
	    	extensions: [
	    		"ppt",
	    		"pps",
	    		"pot"
	    	]
	    },
	    	"application/vnd.ms-powerpoint.addin.macroenabled.12": {
	    	source: "iana",
	    	extensions: [
	    		"ppam"
	    	]
	    },
	    	"application/vnd.ms-powerpoint.presentation.macroenabled.12": {
	    	source: "iana",
	    	extensions: [
	    		"pptm"
	    	]
	    },
	    	"application/vnd.ms-powerpoint.slide.macroenabled.12": {
	    	source: "iana",
	    	extensions: [
	    		"sldm"
	    	]
	    },
	    	"application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
	    	source: "iana",
	    	extensions: [
	    		"ppsm"
	    	]
	    },
	    	"application/vnd.ms-powerpoint.template.macroenabled.12": {
	    	source: "iana",
	    	extensions: [
	    		"potm"
	    	]
	    },
	    	"application/vnd.ms-printdevicecapabilities+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.ms-printing.printticket+xml": {
	    	source: "apache",
	    	compressible: true
	    },
	    	"application/vnd.ms-printschematicket+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.ms-project": {
	    	source: "iana",
	    	extensions: [
	    		"mpp",
	    		"mpt"
	    	]
	    },
	    	"application/vnd.ms-tnef": {
	    	source: "iana"
	    },
	    	"application/vnd.ms-windows.devicepairing": {
	    	source: "iana"
	    },
	    	"application/vnd.ms-windows.nwprinting.oob": {
	    	source: "iana"
	    },
	    	"application/vnd.ms-windows.printerpairing": {
	    	source: "iana"
	    },
	    	"application/vnd.ms-windows.wsd.oob": {
	    	source: "iana"
	    },
	    	"application/vnd.ms-wmdrm.lic-chlg-req": {
	    	source: "iana"
	    },
	    	"application/vnd.ms-wmdrm.lic-resp": {
	    	source: "iana"
	    },
	    	"application/vnd.ms-wmdrm.meter-chlg-req": {
	    	source: "iana"
	    },
	    	"application/vnd.ms-wmdrm.meter-resp": {
	    	source: "iana"
	    },
	    	"application/vnd.ms-word.document.macroenabled.12": {
	    	source: "iana",
	    	extensions: [
	    		"docm"
	    	]
	    },
	    	"application/vnd.ms-word.template.macroenabled.12": {
	    	source: "iana",
	    	extensions: [
	    		"dotm"
	    	]
	    },
	    	"application/vnd.ms-works": {
	    	source: "iana",
	    	extensions: [
	    		"wps",
	    		"wks",
	    		"wcm",
	    		"wdb"
	    	]
	    },
	    	"application/vnd.ms-wpl": {
	    	source: "iana",
	    	extensions: [
	    		"wpl"
	    	]
	    },
	    	"application/vnd.ms-xpsdocument": {
	    	source: "iana",
	    	compressible: false,
	    	extensions: [
	    		"xps"
	    	]
	    },
	    	"application/vnd.msa-disk-image": {
	    	source: "iana"
	    },
	    	"application/vnd.mseq": {
	    	source: "iana",
	    	extensions: [
	    		"mseq"
	    	]
	    },
	    	"application/vnd.msign": {
	    	source: "iana"
	    },
	    	"application/vnd.multiad.creator": {
	    	source: "iana"
	    },
	    	"application/vnd.multiad.creator.cif": {
	    	source: "iana"
	    },
	    	"application/vnd.music-niff": {
	    	source: "iana"
	    },
	    	"application/vnd.musician": {
	    	source: "iana",
	    	extensions: [
	    		"mus"
	    	]
	    },
	    	"application/vnd.muvee.style": {
	    	source: "iana",
	    	extensions: [
	    		"msty"
	    	]
	    },
	    	"application/vnd.mynfc": {
	    	source: "iana",
	    	extensions: [
	    		"taglet"
	    	]
	    },
	    	"application/vnd.nacamar.ybrid+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.ncd.control": {
	    	source: "iana"
	    },
	    	"application/vnd.ncd.reference": {
	    	source: "iana"
	    },
	    	"application/vnd.nearst.inv+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.nebumind.line": {
	    	source: "iana"
	    },
	    	"application/vnd.nervana": {
	    	source: "iana"
	    },
	    	"application/vnd.netfpx": {
	    	source: "iana"
	    },
	    	"application/vnd.neurolanguage.nlu": {
	    	source: "iana",
	    	extensions: [
	    		"nlu"
	    	]
	    },
	    	"application/vnd.nimn": {
	    	source: "iana"
	    },
	    	"application/vnd.nintendo.nitro.rom": {
	    	source: "iana"
	    },
	    	"application/vnd.nintendo.snes.rom": {
	    	source: "iana"
	    },
	    	"application/vnd.nitf": {
	    	source: "iana",
	    	extensions: [
	    		"ntf",
	    		"nitf"
	    	]
	    },
	    	"application/vnd.noblenet-directory": {
	    	source: "iana",
	    	extensions: [
	    		"nnd"
	    	]
	    },
	    	"application/vnd.noblenet-sealer": {
	    	source: "iana",
	    	extensions: [
	    		"nns"
	    	]
	    },
	    	"application/vnd.noblenet-web": {
	    	source: "iana",
	    	extensions: [
	    		"nnw"
	    	]
	    },
	    	"application/vnd.nokia.catalogs": {
	    	source: "iana"
	    },
	    	"application/vnd.nokia.conml+wbxml": {
	    	source: "iana"
	    },
	    	"application/vnd.nokia.conml+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.nokia.iptv.config+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.nokia.isds-radio-presets": {
	    	source: "iana"
	    },
	    	"application/vnd.nokia.landmark+wbxml": {
	    	source: "iana"
	    },
	    	"application/vnd.nokia.landmark+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.nokia.landmarkcollection+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.nokia.n-gage.ac+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"ac"
	    	]
	    },
	    	"application/vnd.nokia.n-gage.data": {
	    	source: "iana",
	    	extensions: [
	    		"ngdat"
	    	]
	    },
	    	"application/vnd.nokia.n-gage.symbian.install": {
	    	source: "iana",
	    	extensions: [
	    		"n-gage"
	    	]
	    },
	    	"application/vnd.nokia.ncd": {
	    	source: "iana"
	    },
	    	"application/vnd.nokia.pcd+wbxml": {
	    	source: "iana"
	    },
	    	"application/vnd.nokia.pcd+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.nokia.radio-preset": {
	    	source: "iana",
	    	extensions: [
	    		"rpst"
	    	]
	    },
	    	"application/vnd.nokia.radio-presets": {
	    	source: "iana",
	    	extensions: [
	    		"rpss"
	    	]
	    },
	    	"application/vnd.novadigm.edm": {
	    	source: "iana",
	    	extensions: [
	    		"edm"
	    	]
	    },
	    	"application/vnd.novadigm.edx": {
	    	source: "iana",
	    	extensions: [
	    		"edx"
	    	]
	    },
	    	"application/vnd.novadigm.ext": {
	    	source: "iana",
	    	extensions: [
	    		"ext"
	    	]
	    },
	    	"application/vnd.ntt-local.content-share": {
	    	source: "iana"
	    },
	    	"application/vnd.ntt-local.file-transfer": {
	    	source: "iana"
	    },
	    	"application/vnd.ntt-local.ogw_remote-access": {
	    	source: "iana"
	    },
	    	"application/vnd.ntt-local.sip-ta_remote": {
	    	source: "iana"
	    },
	    	"application/vnd.ntt-local.sip-ta_tcp_stream": {
	    	source: "iana"
	    },
	    	"application/vnd.oasis.opendocument.chart": {
	    	source: "iana",
	    	extensions: [
	    		"odc"
	    	]
	    },
	    	"application/vnd.oasis.opendocument.chart-template": {
	    	source: "iana",
	    	extensions: [
	    		"otc"
	    	]
	    },
	    	"application/vnd.oasis.opendocument.database": {
	    	source: "iana",
	    	extensions: [
	    		"odb"
	    	]
	    },
	    	"application/vnd.oasis.opendocument.formula": {
	    	source: "iana",
	    	extensions: [
	    		"odf"
	    	]
	    },
	    	"application/vnd.oasis.opendocument.formula-template": {
	    	source: "iana",
	    	extensions: [
	    		"odft"
	    	]
	    },
	    	"application/vnd.oasis.opendocument.graphics": {
	    	source: "iana",
	    	compressible: false,
	    	extensions: [
	    		"odg"
	    	]
	    },
	    	"application/vnd.oasis.opendocument.graphics-template": {
	    	source: "iana",
	    	extensions: [
	    		"otg"
	    	]
	    },
	    	"application/vnd.oasis.opendocument.image": {
	    	source: "iana",
	    	extensions: [
	    		"odi"
	    	]
	    },
	    	"application/vnd.oasis.opendocument.image-template": {
	    	source: "iana",
	    	extensions: [
	    		"oti"
	    	]
	    },
	    	"application/vnd.oasis.opendocument.presentation": {
	    	source: "iana",
	    	compressible: false,
	    	extensions: [
	    		"odp"
	    	]
	    },
	    	"application/vnd.oasis.opendocument.presentation-template": {
	    	source: "iana",
	    	extensions: [
	    		"otp"
	    	]
	    },
	    	"application/vnd.oasis.opendocument.spreadsheet": {
	    	source: "iana",
	    	compressible: false,
	    	extensions: [
	    		"ods"
	    	]
	    },
	    	"application/vnd.oasis.opendocument.spreadsheet-template": {
	    	source: "iana",
	    	extensions: [
	    		"ots"
	    	]
	    },
	    	"application/vnd.oasis.opendocument.text": {
	    	source: "iana",
	    	compressible: false,
	    	extensions: [
	    		"odt"
	    	]
	    },
	    	"application/vnd.oasis.opendocument.text-master": {
	    	source: "iana",
	    	extensions: [
	    		"odm"
	    	]
	    },
	    	"application/vnd.oasis.opendocument.text-template": {
	    	source: "iana",
	    	extensions: [
	    		"ott"
	    	]
	    },
	    	"application/vnd.oasis.opendocument.text-web": {
	    	source: "iana",
	    	extensions: [
	    		"oth"
	    	]
	    },
	    	"application/vnd.obn": {
	    	source: "iana"
	    },
	    	"application/vnd.ocf+cbor": {
	    	source: "iana"
	    },
	    	"application/vnd.oci.image.manifest.v1+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.oftn.l10n+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.oipf.contentaccessdownload+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.oipf.contentaccessstreaming+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.oipf.cspg-hexbinary": {
	    	source: "iana"
	    },
	    	"application/vnd.oipf.dae.svg+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.oipf.dae.xhtml+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.oipf.mippvcontrolmessage+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.oipf.pae.gem": {
	    	source: "iana"
	    },
	    	"application/vnd.oipf.spdiscovery+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.oipf.spdlist+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.oipf.ueprofile+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.oipf.userprofile+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.olpc-sugar": {
	    	source: "iana",
	    	extensions: [
	    		"xo"
	    	]
	    },
	    	"application/vnd.oma-scws-config": {
	    	source: "iana"
	    },
	    	"application/vnd.oma-scws-http-request": {
	    	source: "iana"
	    },
	    	"application/vnd.oma-scws-http-response": {
	    	source: "iana"
	    },
	    	"application/vnd.oma.bcast.associated-procedure-parameter+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.oma.bcast.drm-trigger+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.oma.bcast.imd+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.oma.bcast.ltkm": {
	    	source: "iana"
	    },
	    	"application/vnd.oma.bcast.notification+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.oma.bcast.provisioningtrigger": {
	    	source: "iana"
	    },
	    	"application/vnd.oma.bcast.sgboot": {
	    	source: "iana"
	    },
	    	"application/vnd.oma.bcast.sgdd+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.oma.bcast.sgdu": {
	    	source: "iana"
	    },
	    	"application/vnd.oma.bcast.simple-symbol-container": {
	    	source: "iana"
	    },
	    	"application/vnd.oma.bcast.smartcard-trigger+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.oma.bcast.sprov+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.oma.bcast.stkm": {
	    	source: "iana"
	    },
	    	"application/vnd.oma.cab-address-book+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.oma.cab-feature-handler+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.oma.cab-pcc+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.oma.cab-subs-invite+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.oma.cab-user-prefs+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.oma.dcd": {
	    	source: "iana"
	    },
	    	"application/vnd.oma.dcdc": {
	    	source: "iana"
	    },
	    	"application/vnd.oma.dd2+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"dd2"
	    	]
	    },
	    	"application/vnd.oma.drm.risd+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.oma.group-usage-list+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.oma.lwm2m+cbor": {
	    	source: "iana"
	    },
	    	"application/vnd.oma.lwm2m+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.oma.lwm2m+tlv": {
	    	source: "iana"
	    },
	    	"application/vnd.oma.pal+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.oma.poc.detailed-progress-report+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.oma.poc.final-report+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.oma.poc.groups+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.oma.poc.invocation-descriptor+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.oma.poc.optimized-progress-report+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.oma.push": {
	    	source: "iana"
	    },
	    	"application/vnd.oma.scidm.messages+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.oma.xcap-directory+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.omads-email+xml": {
	    	source: "iana",
	    	charset: "UTF-8",
	    	compressible: true
	    },
	    	"application/vnd.omads-file+xml": {
	    	source: "iana",
	    	charset: "UTF-8",
	    	compressible: true
	    },
	    	"application/vnd.omads-folder+xml": {
	    	source: "iana",
	    	charset: "UTF-8",
	    	compressible: true
	    },
	    	"application/vnd.omaloc-supl-init": {
	    	source: "iana"
	    },
	    	"application/vnd.onepager": {
	    	source: "iana"
	    },
	    	"application/vnd.onepagertamp": {
	    	source: "iana"
	    },
	    	"application/vnd.onepagertamx": {
	    	source: "iana"
	    },
	    	"application/vnd.onepagertat": {
	    	source: "iana"
	    },
	    	"application/vnd.onepagertatp": {
	    	source: "iana"
	    },
	    	"application/vnd.onepagertatx": {
	    	source: "iana"
	    },
	    	"application/vnd.openblox.game+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"obgx"
	    	]
	    },
	    	"application/vnd.openblox.game-binary": {
	    	source: "iana"
	    },
	    	"application/vnd.openeye.oeb": {
	    	source: "iana"
	    },
	    	"application/vnd.openofficeorg.extension": {
	    	source: "apache",
	    	extensions: [
	    		"oxt"
	    	]
	    },
	    	"application/vnd.openstreetmap.data+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"osm"
	    	]
	    },
	    	"application/vnd.opentimestamps.ots": {
	    	source: "iana"
	    },
	    	"application/vnd.openxmlformats-officedocument.custom-properties+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.drawing+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.extended-properties+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.presentationml.presentation": {
	    	source: "iana",
	    	compressible: false,
	    	extensions: [
	    		"pptx"
	    	]
	    },
	    	"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.presentationml.slide": {
	    	source: "iana",
	    	extensions: [
	    		"sldx"
	    	]
	    },
	    	"application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
	    	source: "iana",
	    	extensions: [
	    		"ppsx"
	    	]
	    },
	    	"application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.presentationml.template": {
	    	source: "iana",
	    	extensions: [
	    		"potx"
	    	]
	    },
	    	"application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
	    	source: "iana",
	    	compressible: false,
	    	extensions: [
	    		"xlsx"
	    	]
	    },
	    	"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
	    	source: "iana",
	    	extensions: [
	    		"xltx"
	    	]
	    },
	    	"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.theme+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.themeoverride+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.vmldrawing": {
	    	source: "iana"
	    },
	    	"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
	    	source: "iana",
	    	compressible: false,
	    	extensions: [
	    		"docx"
	    	]
	    },
	    	"application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
	    	source: "iana",
	    	extensions: [
	    		"dotx"
	    	]
	    },
	    	"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-package.core-properties+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.openxmlformats-package.relationships+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.oracle.resource+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.orange.indata": {
	    	source: "iana"
	    },
	    	"application/vnd.osa.netdeploy": {
	    	source: "iana"
	    },
	    	"application/vnd.osgeo.mapguide.package": {
	    	source: "iana",
	    	extensions: [
	    		"mgp"
	    	]
	    },
	    	"application/vnd.osgi.bundle": {
	    	source: "iana"
	    },
	    	"application/vnd.osgi.dp": {
	    	source: "iana",
	    	extensions: [
	    		"dp"
	    	]
	    },
	    	"application/vnd.osgi.subsystem": {
	    	source: "iana",
	    	extensions: [
	    		"esa"
	    	]
	    },
	    	"application/vnd.otps.ct-kip+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.oxli.countgraph": {
	    	source: "iana"
	    },
	    	"application/vnd.pagerduty+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.palm": {
	    	source: "iana",
	    	extensions: [
	    		"pdb",
	    		"pqa",
	    		"oprc"
	    	]
	    },
	    	"application/vnd.panoply": {
	    	source: "iana"
	    },
	    	"application/vnd.paos.xml": {
	    	source: "iana"
	    },
	    	"application/vnd.patentdive": {
	    	source: "iana"
	    },
	    	"application/vnd.patientecommsdoc": {
	    	source: "iana"
	    },
	    	"application/vnd.pawaafile": {
	    	source: "iana",
	    	extensions: [
	    		"paw"
	    	]
	    },
	    	"application/vnd.pcos": {
	    	source: "iana"
	    },
	    	"application/vnd.pg.format": {
	    	source: "iana",
	    	extensions: [
	    		"str"
	    	]
	    },
	    	"application/vnd.pg.osasli": {
	    	source: "iana",
	    	extensions: [
	    		"ei6"
	    	]
	    },
	    	"application/vnd.piaccess.application-licence": {
	    	source: "iana"
	    },
	    	"application/vnd.picsel": {
	    	source: "iana",
	    	extensions: [
	    		"efif"
	    	]
	    },
	    	"application/vnd.pmi.widget": {
	    	source: "iana",
	    	extensions: [
	    		"wg"
	    	]
	    },
	    	"application/vnd.poc.group-advertisement+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.pocketlearn": {
	    	source: "iana",
	    	extensions: [
	    		"plf"
	    	]
	    },
	    	"application/vnd.powerbuilder6": {
	    	source: "iana",
	    	extensions: [
	    		"pbd"
	    	]
	    },
	    	"application/vnd.powerbuilder6-s": {
	    	source: "iana"
	    },
	    	"application/vnd.powerbuilder7": {
	    	source: "iana"
	    },
	    	"application/vnd.powerbuilder7-s": {
	    	source: "iana"
	    },
	    	"application/vnd.powerbuilder75": {
	    	source: "iana"
	    },
	    	"application/vnd.powerbuilder75-s": {
	    	source: "iana"
	    },
	    	"application/vnd.preminet": {
	    	source: "iana"
	    },
	    	"application/vnd.previewsystems.box": {
	    	source: "iana",
	    	extensions: [
	    		"box"
	    	]
	    },
	    	"application/vnd.proteus.magazine": {
	    	source: "iana",
	    	extensions: [
	    		"mgz"
	    	]
	    },
	    	"application/vnd.psfs": {
	    	source: "iana"
	    },
	    	"application/vnd.publishare-delta-tree": {
	    	source: "iana",
	    	extensions: [
	    		"qps"
	    	]
	    },
	    	"application/vnd.pvi.ptid1": {
	    	source: "iana",
	    	extensions: [
	    		"ptid"
	    	]
	    },
	    	"application/vnd.pwg-multiplexed": {
	    	source: "iana"
	    },
	    	"application/vnd.pwg-xhtml-print+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.qualcomm.brew-app-res": {
	    	source: "iana"
	    },
	    	"application/vnd.quarantainenet": {
	    	source: "iana"
	    },
	    	"application/vnd.quark.quarkxpress": {
	    	source: "iana",
	    	extensions: [
	    		"qxd",
	    		"qxt",
	    		"qwd",
	    		"qwt",
	    		"qxl",
	    		"qxb"
	    	]
	    },
	    	"application/vnd.quobject-quoxdocument": {
	    	source: "iana"
	    },
	    	"application/vnd.radisys.moml+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.radisys.msml+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.radisys.msml-audit+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.radisys.msml-audit-conf+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.radisys.msml-audit-conn+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.radisys.msml-audit-dialog+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.radisys.msml-audit-stream+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.radisys.msml-conf+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.radisys.msml-dialog+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.radisys.msml-dialog-base+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.radisys.msml-dialog-fax-detect+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.radisys.msml-dialog-group+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.radisys.msml-dialog-speech+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.radisys.msml-dialog-transform+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.rainstor.data": {
	    	source: "iana"
	    },
	    	"application/vnd.rapid": {
	    	source: "iana"
	    },
	    	"application/vnd.rar": {
	    	source: "iana",
	    	extensions: [
	    		"rar"
	    	]
	    },
	    	"application/vnd.realvnc.bed": {
	    	source: "iana",
	    	extensions: [
	    		"bed"
	    	]
	    },
	    	"application/vnd.recordare.musicxml": {
	    	source: "iana",
	    	extensions: [
	    		"mxl"
	    	]
	    },
	    	"application/vnd.recordare.musicxml+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"musicxml"
	    	]
	    },
	    	"application/vnd.renlearn.rlprint": {
	    	source: "iana"
	    },
	    	"application/vnd.resilient.logic": {
	    	source: "iana"
	    },
	    	"application/vnd.restful+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.rig.cryptonote": {
	    	source: "iana",
	    	extensions: [
	    		"cryptonote"
	    	]
	    },
	    	"application/vnd.rim.cod": {
	    	source: "apache",
	    	extensions: [
	    		"cod"
	    	]
	    },
	    	"application/vnd.rn-realmedia": {
	    	source: "apache",
	    	extensions: [
	    		"rm"
	    	]
	    },
	    	"application/vnd.rn-realmedia-vbr": {
	    	source: "apache",
	    	extensions: [
	    		"rmvb"
	    	]
	    },
	    	"application/vnd.route66.link66+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"link66"
	    	]
	    },
	    	"application/vnd.rs-274x": {
	    	source: "iana"
	    },
	    	"application/vnd.ruckus.download": {
	    	source: "iana"
	    },
	    	"application/vnd.s3sms": {
	    	source: "iana"
	    },
	    	"application/vnd.sailingtracker.track": {
	    	source: "iana",
	    	extensions: [
	    		"st"
	    	]
	    },
	    	"application/vnd.sar": {
	    	source: "iana"
	    },
	    	"application/vnd.sbm.cid": {
	    	source: "iana"
	    },
	    	"application/vnd.sbm.mid2": {
	    	source: "iana"
	    },
	    	"application/vnd.scribus": {
	    	source: "iana"
	    },
	    	"application/vnd.sealed.3df": {
	    	source: "iana"
	    },
	    	"application/vnd.sealed.csf": {
	    	source: "iana"
	    },
	    	"application/vnd.sealed.doc": {
	    	source: "iana"
	    },
	    	"application/vnd.sealed.eml": {
	    	source: "iana"
	    },
	    	"application/vnd.sealed.mht": {
	    	source: "iana"
	    },
	    	"application/vnd.sealed.net": {
	    	source: "iana"
	    },
	    	"application/vnd.sealed.ppt": {
	    	source: "iana"
	    },
	    	"application/vnd.sealed.tiff": {
	    	source: "iana"
	    },
	    	"application/vnd.sealed.xls": {
	    	source: "iana"
	    },
	    	"application/vnd.sealedmedia.softseal.html": {
	    	source: "iana"
	    },
	    	"application/vnd.sealedmedia.softseal.pdf": {
	    	source: "iana"
	    },
	    	"application/vnd.seemail": {
	    	source: "iana",
	    	extensions: [
	    		"see"
	    	]
	    },
	    	"application/vnd.seis+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.sema": {
	    	source: "iana",
	    	extensions: [
	    		"sema"
	    	]
	    },
	    	"application/vnd.semd": {
	    	source: "iana",
	    	extensions: [
	    		"semd"
	    	]
	    },
	    	"application/vnd.semf": {
	    	source: "iana",
	    	extensions: [
	    		"semf"
	    	]
	    },
	    	"application/vnd.shade-save-file": {
	    	source: "iana"
	    },
	    	"application/vnd.shana.informed.formdata": {
	    	source: "iana",
	    	extensions: [
	    		"ifm"
	    	]
	    },
	    	"application/vnd.shana.informed.formtemplate": {
	    	source: "iana",
	    	extensions: [
	    		"itp"
	    	]
	    },
	    	"application/vnd.shana.informed.interchange": {
	    	source: "iana",
	    	extensions: [
	    		"iif"
	    	]
	    },
	    	"application/vnd.shana.informed.package": {
	    	source: "iana",
	    	extensions: [
	    		"ipk"
	    	]
	    },
	    	"application/vnd.shootproof+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.shopkick+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.shp": {
	    	source: "iana"
	    },
	    	"application/vnd.shx": {
	    	source: "iana"
	    },
	    	"application/vnd.sigrok.session": {
	    	source: "iana"
	    },
	    	"application/vnd.simtech-mindmapper": {
	    	source: "iana",
	    	extensions: [
	    		"twd",
	    		"twds"
	    	]
	    },
	    	"application/vnd.siren+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.smaf": {
	    	source: "iana",
	    	extensions: [
	    		"mmf"
	    	]
	    },
	    	"application/vnd.smart.notebook": {
	    	source: "iana"
	    },
	    	"application/vnd.smart.teacher": {
	    	source: "iana",
	    	extensions: [
	    		"teacher"
	    	]
	    },
	    	"application/vnd.snesdev-page-table": {
	    	source: "iana"
	    },
	    	"application/vnd.software602.filler.form+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"fo"
	    	]
	    },
	    	"application/vnd.software602.filler.form-xml-zip": {
	    	source: "iana"
	    },
	    	"application/vnd.solent.sdkm+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"sdkm",
	    		"sdkd"
	    	]
	    },
	    	"application/vnd.spotfire.dxp": {
	    	source: "iana",
	    	extensions: [
	    		"dxp"
	    	]
	    },
	    	"application/vnd.spotfire.sfs": {
	    	source: "iana",
	    	extensions: [
	    		"sfs"
	    	]
	    },
	    	"application/vnd.sqlite3": {
	    	source: "iana"
	    },
	    	"application/vnd.sss-cod": {
	    	source: "iana"
	    },
	    	"application/vnd.sss-dtf": {
	    	source: "iana"
	    },
	    	"application/vnd.sss-ntf": {
	    	source: "iana"
	    },
	    	"application/vnd.stardivision.calc": {
	    	source: "apache",
	    	extensions: [
	    		"sdc"
	    	]
	    },
	    	"application/vnd.stardivision.draw": {
	    	source: "apache",
	    	extensions: [
	    		"sda"
	    	]
	    },
	    	"application/vnd.stardivision.impress": {
	    	source: "apache",
	    	extensions: [
	    		"sdd"
	    	]
	    },
	    	"application/vnd.stardivision.math": {
	    	source: "apache",
	    	extensions: [
	    		"smf"
	    	]
	    },
	    	"application/vnd.stardivision.writer": {
	    	source: "apache",
	    	extensions: [
	    		"sdw",
	    		"vor"
	    	]
	    },
	    	"application/vnd.stardivision.writer-global": {
	    	source: "apache",
	    	extensions: [
	    		"sgl"
	    	]
	    },
	    	"application/vnd.stepmania.package": {
	    	source: "iana",
	    	extensions: [
	    		"smzip"
	    	]
	    },
	    	"application/vnd.stepmania.stepchart": {
	    	source: "iana",
	    	extensions: [
	    		"sm"
	    	]
	    },
	    	"application/vnd.street-stream": {
	    	source: "iana"
	    },
	    	"application/vnd.sun.wadl+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"wadl"
	    	]
	    },
	    	"application/vnd.sun.xml.calc": {
	    	source: "apache",
	    	extensions: [
	    		"sxc"
	    	]
	    },
	    	"application/vnd.sun.xml.calc.template": {
	    	source: "apache",
	    	extensions: [
	    		"stc"
	    	]
	    },
	    	"application/vnd.sun.xml.draw": {
	    	source: "apache",
	    	extensions: [
	    		"sxd"
	    	]
	    },
	    	"application/vnd.sun.xml.draw.template": {
	    	source: "apache",
	    	extensions: [
	    		"std"
	    	]
	    },
	    	"application/vnd.sun.xml.impress": {
	    	source: "apache",
	    	extensions: [
	    		"sxi"
	    	]
	    },
	    	"application/vnd.sun.xml.impress.template": {
	    	source: "apache",
	    	extensions: [
	    		"sti"
	    	]
	    },
	    	"application/vnd.sun.xml.math": {
	    	source: "apache",
	    	extensions: [
	    		"sxm"
	    	]
	    },
	    	"application/vnd.sun.xml.writer": {
	    	source: "apache",
	    	extensions: [
	    		"sxw"
	    	]
	    },
	    	"application/vnd.sun.xml.writer.global": {
	    	source: "apache",
	    	extensions: [
	    		"sxg"
	    	]
	    },
	    	"application/vnd.sun.xml.writer.template": {
	    	source: "apache",
	    	extensions: [
	    		"stw"
	    	]
	    },
	    	"application/vnd.sus-calendar": {
	    	source: "iana",
	    	extensions: [
	    		"sus",
	    		"susp"
	    	]
	    },
	    	"application/vnd.svd": {
	    	source: "iana",
	    	extensions: [
	    		"svd"
	    	]
	    },
	    	"application/vnd.swiftview-ics": {
	    	source: "iana"
	    },
	    	"application/vnd.sycle+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.syft+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.symbian.install": {
	    	source: "apache",
	    	extensions: [
	    		"sis",
	    		"sisx"
	    	]
	    },
	    	"application/vnd.syncml+xml": {
	    	source: "iana",
	    	charset: "UTF-8",
	    	compressible: true,
	    	extensions: [
	    		"xsm"
	    	]
	    },
	    	"application/vnd.syncml.dm+wbxml": {
	    	source: "iana",
	    	charset: "UTF-8",
	    	extensions: [
	    		"bdm"
	    	]
	    },
	    	"application/vnd.syncml.dm+xml": {
	    	source: "iana",
	    	charset: "UTF-8",
	    	compressible: true,
	    	extensions: [
	    		"xdm"
	    	]
	    },
	    	"application/vnd.syncml.dm.notification": {
	    	source: "iana"
	    },
	    	"application/vnd.syncml.dmddf+wbxml": {
	    	source: "iana"
	    },
	    	"application/vnd.syncml.dmddf+xml": {
	    	source: "iana",
	    	charset: "UTF-8",
	    	compressible: true,
	    	extensions: [
	    		"ddf"
	    	]
	    },
	    	"application/vnd.syncml.dmtnds+wbxml": {
	    	source: "iana"
	    },
	    	"application/vnd.syncml.dmtnds+xml": {
	    	source: "iana",
	    	charset: "UTF-8",
	    	compressible: true
	    },
	    	"application/vnd.syncml.ds.notification": {
	    	source: "iana"
	    },
	    	"application/vnd.tableschema+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.tao.intent-module-archive": {
	    	source: "iana",
	    	extensions: [
	    		"tao"
	    	]
	    },
	    	"application/vnd.tcpdump.pcap": {
	    	source: "iana",
	    	extensions: [
	    		"pcap",
	    		"cap",
	    		"dmp"
	    	]
	    },
	    	"application/vnd.think-cell.ppttc+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.tmd.mediaflex.api+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.tml": {
	    	source: "iana"
	    },
	    	"application/vnd.tmobile-livetv": {
	    	source: "iana",
	    	extensions: [
	    		"tmo"
	    	]
	    },
	    	"application/vnd.tri.onesource": {
	    	source: "iana"
	    },
	    	"application/vnd.trid.tpt": {
	    	source: "iana",
	    	extensions: [
	    		"tpt"
	    	]
	    },
	    	"application/vnd.triscape.mxs": {
	    	source: "iana",
	    	extensions: [
	    		"mxs"
	    	]
	    },
	    	"application/vnd.trueapp": {
	    	source: "iana",
	    	extensions: [
	    		"tra"
	    	]
	    },
	    	"application/vnd.truedoc": {
	    	source: "iana"
	    },
	    	"application/vnd.ubisoft.webplayer": {
	    	source: "iana"
	    },
	    	"application/vnd.ufdl": {
	    	source: "iana",
	    	extensions: [
	    		"ufd",
	    		"ufdl"
	    	]
	    },
	    	"application/vnd.uiq.theme": {
	    	source: "iana",
	    	extensions: [
	    		"utz"
	    	]
	    },
	    	"application/vnd.umajin": {
	    	source: "iana",
	    	extensions: [
	    		"umj"
	    	]
	    },
	    	"application/vnd.unity": {
	    	source: "iana",
	    	extensions: [
	    		"unityweb"
	    	]
	    },
	    	"application/vnd.uoml+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"uoml"
	    	]
	    },
	    	"application/vnd.uplanet.alert": {
	    	source: "iana"
	    },
	    	"application/vnd.uplanet.alert-wbxml": {
	    	source: "iana"
	    },
	    	"application/vnd.uplanet.bearer-choice": {
	    	source: "iana"
	    },
	    	"application/vnd.uplanet.bearer-choice-wbxml": {
	    	source: "iana"
	    },
	    	"application/vnd.uplanet.cacheop": {
	    	source: "iana"
	    },
	    	"application/vnd.uplanet.cacheop-wbxml": {
	    	source: "iana"
	    },
	    	"application/vnd.uplanet.channel": {
	    	source: "iana"
	    },
	    	"application/vnd.uplanet.channel-wbxml": {
	    	source: "iana"
	    },
	    	"application/vnd.uplanet.list": {
	    	source: "iana"
	    },
	    	"application/vnd.uplanet.list-wbxml": {
	    	source: "iana"
	    },
	    	"application/vnd.uplanet.listcmd": {
	    	source: "iana"
	    },
	    	"application/vnd.uplanet.listcmd-wbxml": {
	    	source: "iana"
	    },
	    	"application/vnd.uplanet.signal": {
	    	source: "iana"
	    },
	    	"application/vnd.uri-map": {
	    	source: "iana"
	    },
	    	"application/vnd.valve.source.material": {
	    	source: "iana"
	    },
	    	"application/vnd.vcx": {
	    	source: "iana",
	    	extensions: [
	    		"vcx"
	    	]
	    },
	    	"application/vnd.vd-study": {
	    	source: "iana"
	    },
	    	"application/vnd.vectorworks": {
	    	source: "iana"
	    },
	    	"application/vnd.vel+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.verimatrix.vcas": {
	    	source: "iana"
	    },
	    	"application/vnd.veritone.aion+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.veryant.thin": {
	    	source: "iana"
	    },
	    	"application/vnd.ves.encrypted": {
	    	source: "iana"
	    },
	    	"application/vnd.vidsoft.vidconference": {
	    	source: "iana"
	    },
	    	"application/vnd.visio": {
	    	source: "iana",
	    	extensions: [
	    		"vsd",
	    		"vst",
	    		"vss",
	    		"vsw"
	    	]
	    },
	    	"application/vnd.visionary": {
	    	source: "iana",
	    	extensions: [
	    		"vis"
	    	]
	    },
	    	"application/vnd.vividence.scriptfile": {
	    	source: "iana"
	    },
	    	"application/vnd.vsf": {
	    	source: "iana",
	    	extensions: [
	    		"vsf"
	    	]
	    },
	    	"application/vnd.wap.sic": {
	    	source: "iana"
	    },
	    	"application/vnd.wap.slc": {
	    	source: "iana"
	    },
	    	"application/vnd.wap.wbxml": {
	    	source: "iana",
	    	charset: "UTF-8",
	    	extensions: [
	    		"wbxml"
	    	]
	    },
	    	"application/vnd.wap.wmlc": {
	    	source: "iana",
	    	extensions: [
	    		"wmlc"
	    	]
	    },
	    	"application/vnd.wap.wmlscriptc": {
	    	source: "iana",
	    	extensions: [
	    		"wmlsc"
	    	]
	    },
	    	"application/vnd.webturbo": {
	    	source: "iana",
	    	extensions: [
	    		"wtb"
	    	]
	    },
	    	"application/vnd.wfa.dpp": {
	    	source: "iana"
	    },
	    	"application/vnd.wfa.p2p": {
	    	source: "iana"
	    },
	    	"application/vnd.wfa.wsc": {
	    	source: "iana"
	    },
	    	"application/vnd.windows.devicepairing": {
	    	source: "iana"
	    },
	    	"application/vnd.wmc": {
	    	source: "iana"
	    },
	    	"application/vnd.wmf.bootstrap": {
	    	source: "iana"
	    },
	    	"application/vnd.wolfram.mathematica": {
	    	source: "iana"
	    },
	    	"application/vnd.wolfram.mathematica.package": {
	    	source: "iana"
	    },
	    	"application/vnd.wolfram.player": {
	    	source: "iana",
	    	extensions: [
	    		"nbp"
	    	]
	    },
	    	"application/vnd.wordperfect": {
	    	source: "iana",
	    	extensions: [
	    		"wpd"
	    	]
	    },
	    	"application/vnd.wqd": {
	    	source: "iana",
	    	extensions: [
	    		"wqd"
	    	]
	    },
	    	"application/vnd.wrq-hp3000-labelled": {
	    	source: "iana"
	    },
	    	"application/vnd.wt.stf": {
	    	source: "iana",
	    	extensions: [
	    		"stf"
	    	]
	    },
	    	"application/vnd.wv.csp+wbxml": {
	    	source: "iana"
	    },
	    	"application/vnd.wv.csp+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.wv.ssp+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.xacml+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.xara": {
	    	source: "iana",
	    	extensions: [
	    		"xar"
	    	]
	    },
	    	"application/vnd.xfdl": {
	    	source: "iana",
	    	extensions: [
	    		"xfdl"
	    	]
	    },
	    	"application/vnd.xfdl.webform": {
	    	source: "iana"
	    },
	    	"application/vnd.xmi+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vnd.xmpie.cpkg": {
	    	source: "iana"
	    },
	    	"application/vnd.xmpie.dpkg": {
	    	source: "iana"
	    },
	    	"application/vnd.xmpie.plan": {
	    	source: "iana"
	    },
	    	"application/vnd.xmpie.ppkg": {
	    	source: "iana"
	    },
	    	"application/vnd.xmpie.xlim": {
	    	source: "iana"
	    },
	    	"application/vnd.yamaha.hv-dic": {
	    	source: "iana",
	    	extensions: [
	    		"hvd"
	    	]
	    },
	    	"application/vnd.yamaha.hv-script": {
	    	source: "iana",
	    	extensions: [
	    		"hvs"
	    	]
	    },
	    	"application/vnd.yamaha.hv-voice": {
	    	source: "iana",
	    	extensions: [
	    		"hvp"
	    	]
	    },
	    	"application/vnd.yamaha.openscoreformat": {
	    	source: "iana",
	    	extensions: [
	    		"osf"
	    	]
	    },
	    	"application/vnd.yamaha.openscoreformat.osfpvg+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"osfpvg"
	    	]
	    },
	    	"application/vnd.yamaha.remote-setup": {
	    	source: "iana"
	    },
	    	"application/vnd.yamaha.smaf-audio": {
	    	source: "iana",
	    	extensions: [
	    		"saf"
	    	]
	    },
	    	"application/vnd.yamaha.smaf-phrase": {
	    	source: "iana",
	    	extensions: [
	    		"spf"
	    	]
	    },
	    	"application/vnd.yamaha.through-ngn": {
	    	source: "iana"
	    },
	    	"application/vnd.yamaha.tunnel-udpencap": {
	    	source: "iana"
	    },
	    	"application/vnd.yaoweme": {
	    	source: "iana"
	    },
	    	"application/vnd.yellowriver-custom-menu": {
	    	source: "iana",
	    	extensions: [
	    		"cmp"
	    	]
	    },
	    	"application/vnd.youtube.yt": {
	    	source: "iana"
	    },
	    	"application/vnd.zul": {
	    	source: "iana",
	    	extensions: [
	    		"zir",
	    		"zirz"
	    	]
	    },
	    	"application/vnd.zzazz.deck+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"zaz"
	    	]
	    },
	    	"application/voicexml+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"vxml"
	    	]
	    },
	    	"application/voucher-cms+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/vq-rtcpxr": {
	    	source: "iana"
	    },
	    	"application/wasm": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"wasm"
	    	]
	    },
	    	"application/watcherinfo+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"wif"
	    	]
	    },
	    	"application/webpush-options+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/whoispp-query": {
	    	source: "iana"
	    },
	    	"application/whoispp-response": {
	    	source: "iana"
	    },
	    	"application/widget": {
	    	source: "iana",
	    	extensions: [
	    		"wgt"
	    	]
	    },
	    	"application/winhlp": {
	    	source: "apache",
	    	extensions: [
	    		"hlp"
	    	]
	    },
	    	"application/wita": {
	    	source: "iana"
	    },
	    	"application/wordperfect5.1": {
	    	source: "iana"
	    },
	    	"application/wsdl+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"wsdl"
	    	]
	    },
	    	"application/wspolicy+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"wspolicy"
	    	]
	    },
	    	"application/x-7z-compressed": {
	    	source: "apache",
	    	compressible: false,
	    	extensions: [
	    		"7z"
	    	]
	    },
	    	"application/x-abiword": {
	    	source: "apache",
	    	extensions: [
	    		"abw"
	    	]
	    },
	    	"application/x-ace-compressed": {
	    	source: "apache",
	    	extensions: [
	    		"ace"
	    	]
	    },
	    	"application/x-amf": {
	    	source: "apache"
	    },
	    	"application/x-apple-diskimage": {
	    	source: "apache",
	    	extensions: [
	    		"dmg"
	    	]
	    },
	    	"application/x-arj": {
	    	compressible: false,
	    	extensions: [
	    		"arj"
	    	]
	    },
	    	"application/x-authorware-bin": {
	    	source: "apache",
	    	extensions: [
	    		"aab",
	    		"x32",
	    		"u32",
	    		"vox"
	    	]
	    },
	    	"application/x-authorware-map": {
	    	source: "apache",
	    	extensions: [
	    		"aam"
	    	]
	    },
	    	"application/x-authorware-seg": {
	    	source: "apache",
	    	extensions: [
	    		"aas"
	    	]
	    },
	    	"application/x-bcpio": {
	    	source: "apache",
	    	extensions: [
	    		"bcpio"
	    	]
	    },
	    	"application/x-bdoc": {
	    	compressible: false,
	    	extensions: [
	    		"bdoc"
	    	]
	    },
	    	"application/x-bittorrent": {
	    	source: "apache",
	    	extensions: [
	    		"torrent"
	    	]
	    },
	    	"application/x-blorb": {
	    	source: "apache",
	    	extensions: [
	    		"blb",
	    		"blorb"
	    	]
	    },
	    	"application/x-bzip": {
	    	source: "apache",
	    	compressible: false,
	    	extensions: [
	    		"bz"
	    	]
	    },
	    	"application/x-bzip2": {
	    	source: "apache",
	    	compressible: false,
	    	extensions: [
	    		"bz2",
	    		"boz"
	    	]
	    },
	    	"application/x-cbr": {
	    	source: "apache",
	    	extensions: [
	    		"cbr",
	    		"cba",
	    		"cbt",
	    		"cbz",
	    		"cb7"
	    	]
	    },
	    	"application/x-cdlink": {
	    	source: "apache",
	    	extensions: [
	    		"vcd"
	    	]
	    },
	    	"application/x-cfs-compressed": {
	    	source: "apache",
	    	extensions: [
	    		"cfs"
	    	]
	    },
	    	"application/x-chat": {
	    	source: "apache",
	    	extensions: [
	    		"chat"
	    	]
	    },
	    	"application/x-chess-pgn": {
	    	source: "apache",
	    	extensions: [
	    		"pgn"
	    	]
	    },
	    	"application/x-chrome-extension": {
	    	extensions: [
	    		"crx"
	    	]
	    },
	    	"application/x-cocoa": {
	    	source: "nginx",
	    	extensions: [
	    		"cco"
	    	]
	    },
	    	"application/x-compress": {
	    	source: "apache"
	    },
	    	"application/x-conference": {
	    	source: "apache",
	    	extensions: [
	    		"nsc"
	    	]
	    },
	    	"application/x-cpio": {
	    	source: "apache",
	    	extensions: [
	    		"cpio"
	    	]
	    },
	    	"application/x-csh": {
	    	source: "apache",
	    	extensions: [
	    		"csh"
	    	]
	    },
	    	"application/x-deb": {
	    	compressible: false
	    },
	    	"application/x-debian-package": {
	    	source: "apache",
	    	extensions: [
	    		"deb",
	    		"udeb"
	    	]
	    },
	    	"application/x-dgc-compressed": {
	    	source: "apache",
	    	extensions: [
	    		"dgc"
	    	]
	    },
	    	"application/x-director": {
	    	source: "apache",
	    	extensions: [
	    		"dir",
	    		"dcr",
	    		"dxr",
	    		"cst",
	    		"cct",
	    		"cxt",
	    		"w3d",
	    		"fgd",
	    		"swa"
	    	]
	    },
	    	"application/x-doom": {
	    	source: "apache",
	    	extensions: [
	    		"wad"
	    	]
	    },
	    	"application/x-dtbncx+xml": {
	    	source: "apache",
	    	compressible: true,
	    	extensions: [
	    		"ncx"
	    	]
	    },
	    	"application/x-dtbook+xml": {
	    	source: "apache",
	    	compressible: true,
	    	extensions: [
	    		"dtb"
	    	]
	    },
	    	"application/x-dtbresource+xml": {
	    	source: "apache",
	    	compressible: true,
	    	extensions: [
	    		"res"
	    	]
	    },
	    	"application/x-dvi": {
	    	source: "apache",
	    	compressible: false,
	    	extensions: [
	    		"dvi"
	    	]
	    },
	    	"application/x-envoy": {
	    	source: "apache",
	    	extensions: [
	    		"evy"
	    	]
	    },
	    	"application/x-eva": {
	    	source: "apache",
	    	extensions: [
	    		"eva"
	    	]
	    },
	    	"application/x-font-bdf": {
	    	source: "apache",
	    	extensions: [
	    		"bdf"
	    	]
	    },
	    	"application/x-font-dos": {
	    	source: "apache"
	    },
	    	"application/x-font-framemaker": {
	    	source: "apache"
	    },
	    	"application/x-font-ghostscript": {
	    	source: "apache",
	    	extensions: [
	    		"gsf"
	    	]
	    },
	    	"application/x-font-libgrx": {
	    	source: "apache"
	    },
	    	"application/x-font-linux-psf": {
	    	source: "apache",
	    	extensions: [
	    		"psf"
	    	]
	    },
	    	"application/x-font-pcf": {
	    	source: "apache",
	    	extensions: [
	    		"pcf"
	    	]
	    },
	    	"application/x-font-snf": {
	    	source: "apache",
	    	extensions: [
	    		"snf"
	    	]
	    },
	    	"application/x-font-speedo": {
	    	source: "apache"
	    },
	    	"application/x-font-sunos-news": {
	    	source: "apache"
	    },
	    	"application/x-font-type1": {
	    	source: "apache",
	    	extensions: [
	    		"pfa",
	    		"pfb",
	    		"pfm",
	    		"afm"
	    	]
	    },
	    	"application/x-font-vfont": {
	    	source: "apache"
	    },
	    	"application/x-freearc": {
	    	source: "apache",
	    	extensions: [
	    		"arc"
	    	]
	    },
	    	"application/x-futuresplash": {
	    	source: "apache",
	    	extensions: [
	    		"spl"
	    	]
	    },
	    	"application/x-gca-compressed": {
	    	source: "apache",
	    	extensions: [
	    		"gca"
	    	]
	    },
	    	"application/x-glulx": {
	    	source: "apache",
	    	extensions: [
	    		"ulx"
	    	]
	    },
	    	"application/x-gnumeric": {
	    	source: "apache",
	    	extensions: [
	    		"gnumeric"
	    	]
	    },
	    	"application/x-gramps-xml": {
	    	source: "apache",
	    	extensions: [
	    		"gramps"
	    	]
	    },
	    	"application/x-gtar": {
	    	source: "apache",
	    	extensions: [
	    		"gtar"
	    	]
	    },
	    	"application/x-gzip": {
	    	source: "apache"
	    },
	    	"application/x-hdf": {
	    	source: "apache",
	    	extensions: [
	    		"hdf"
	    	]
	    },
	    	"application/x-httpd-php": {
	    	compressible: true,
	    	extensions: [
	    		"php"
	    	]
	    },
	    	"application/x-install-instructions": {
	    	source: "apache",
	    	extensions: [
	    		"install"
	    	]
	    },
	    	"application/x-iso9660-image": {
	    	source: "apache",
	    	extensions: [
	    		"iso"
	    	]
	    },
	    	"application/x-iwork-keynote-sffkey": {
	    	extensions: [
	    		"key"
	    	]
	    },
	    	"application/x-iwork-numbers-sffnumbers": {
	    	extensions: [
	    		"numbers"
	    	]
	    },
	    	"application/x-iwork-pages-sffpages": {
	    	extensions: [
	    		"pages"
	    	]
	    },
	    	"application/x-java-archive-diff": {
	    	source: "nginx",
	    	extensions: [
	    		"jardiff"
	    	]
	    },
	    	"application/x-java-jnlp-file": {
	    	source: "apache",
	    	compressible: false,
	    	extensions: [
	    		"jnlp"
	    	]
	    },
	    	"application/x-javascript": {
	    	compressible: true
	    },
	    	"application/x-keepass2": {
	    	extensions: [
	    		"kdbx"
	    	]
	    },
	    	"application/x-latex": {
	    	source: "apache",
	    	compressible: false,
	    	extensions: [
	    		"latex"
	    	]
	    },
	    	"application/x-lua-bytecode": {
	    	extensions: [
	    		"luac"
	    	]
	    },
	    	"application/x-lzh-compressed": {
	    	source: "apache",
	    	extensions: [
	    		"lzh",
	    		"lha"
	    	]
	    },
	    	"application/x-makeself": {
	    	source: "nginx",
	    	extensions: [
	    		"run"
	    	]
	    },
	    	"application/x-mie": {
	    	source: "apache",
	    	extensions: [
	    		"mie"
	    	]
	    },
	    	"application/x-mobipocket-ebook": {
	    	source: "apache",
	    	extensions: [
	    		"prc",
	    		"mobi"
	    	]
	    },
	    	"application/x-mpegurl": {
	    	compressible: false
	    },
	    	"application/x-ms-application": {
	    	source: "apache",
	    	extensions: [
	    		"application"
	    	]
	    },
	    	"application/x-ms-shortcut": {
	    	source: "apache",
	    	extensions: [
	    		"lnk"
	    	]
	    },
	    	"application/x-ms-wmd": {
	    	source: "apache",
	    	extensions: [
	    		"wmd"
	    	]
	    },
	    	"application/x-ms-wmz": {
	    	source: "apache",
	    	extensions: [
	    		"wmz"
	    	]
	    },
	    	"application/x-ms-xbap": {
	    	source: "apache",
	    	extensions: [
	    		"xbap"
	    	]
	    },
	    	"application/x-msaccess": {
	    	source: "apache",
	    	extensions: [
	    		"mdb"
	    	]
	    },
	    	"application/x-msbinder": {
	    	source: "apache",
	    	extensions: [
	    		"obd"
	    	]
	    },
	    	"application/x-mscardfile": {
	    	source: "apache",
	    	extensions: [
	    		"crd"
	    	]
	    },
	    	"application/x-msclip": {
	    	source: "apache",
	    	extensions: [
	    		"clp"
	    	]
	    },
	    	"application/x-msdos-program": {
	    	extensions: [
	    		"exe"
	    	]
	    },
	    	"application/x-msdownload": {
	    	source: "apache",
	    	extensions: [
	    		"exe",
	    		"dll",
	    		"com",
	    		"bat",
	    		"msi"
	    	]
	    },
	    	"application/x-msmediaview": {
	    	source: "apache",
	    	extensions: [
	    		"mvb",
	    		"m13",
	    		"m14"
	    	]
	    },
	    	"application/x-msmetafile": {
	    	source: "apache",
	    	extensions: [
	    		"wmf",
	    		"wmz",
	    		"emf",
	    		"emz"
	    	]
	    },
	    	"application/x-msmoney": {
	    	source: "apache",
	    	extensions: [
	    		"mny"
	    	]
	    },
	    	"application/x-mspublisher": {
	    	source: "apache",
	    	extensions: [
	    		"pub"
	    	]
	    },
	    	"application/x-msschedule": {
	    	source: "apache",
	    	extensions: [
	    		"scd"
	    	]
	    },
	    	"application/x-msterminal": {
	    	source: "apache",
	    	extensions: [
	    		"trm"
	    	]
	    },
	    	"application/x-mswrite": {
	    	source: "apache",
	    	extensions: [
	    		"wri"
	    	]
	    },
	    	"application/x-netcdf": {
	    	source: "apache",
	    	extensions: [
	    		"nc",
	    		"cdf"
	    	]
	    },
	    	"application/x-ns-proxy-autoconfig": {
	    	compressible: true,
	    	extensions: [
	    		"pac"
	    	]
	    },
	    	"application/x-nzb": {
	    	source: "apache",
	    	extensions: [
	    		"nzb"
	    	]
	    },
	    	"application/x-perl": {
	    	source: "nginx",
	    	extensions: [
	    		"pl",
	    		"pm"
	    	]
	    },
	    	"application/x-pilot": {
	    	source: "nginx",
	    	extensions: [
	    		"prc",
	    		"pdb"
	    	]
	    },
	    	"application/x-pkcs12": {
	    	source: "apache",
	    	compressible: false,
	    	extensions: [
	    		"p12",
	    		"pfx"
	    	]
	    },
	    	"application/x-pkcs7-certificates": {
	    	source: "apache",
	    	extensions: [
	    		"p7b",
	    		"spc"
	    	]
	    },
	    	"application/x-pkcs7-certreqresp": {
	    	source: "apache",
	    	extensions: [
	    		"p7r"
	    	]
	    },
	    	"application/x-pki-message": {
	    	source: "iana"
	    },
	    	"application/x-rar-compressed": {
	    	source: "apache",
	    	compressible: false,
	    	extensions: [
	    		"rar"
	    	]
	    },
	    	"application/x-redhat-package-manager": {
	    	source: "nginx",
	    	extensions: [
	    		"rpm"
	    	]
	    },
	    	"application/x-research-info-systems": {
	    	source: "apache",
	    	extensions: [
	    		"ris"
	    	]
	    },
	    	"application/x-sea": {
	    	source: "nginx",
	    	extensions: [
	    		"sea"
	    	]
	    },
	    	"application/x-sh": {
	    	source: "apache",
	    	compressible: true,
	    	extensions: [
	    		"sh"
	    	]
	    },
	    	"application/x-shar": {
	    	source: "apache",
	    	extensions: [
	    		"shar"
	    	]
	    },
	    	"application/x-shockwave-flash": {
	    	source: "apache",
	    	compressible: false,
	    	extensions: [
	    		"swf"
	    	]
	    },
	    	"application/x-silverlight-app": {
	    	source: "apache",
	    	extensions: [
	    		"xap"
	    	]
	    },
	    	"application/x-sql": {
	    	source: "apache",
	    	extensions: [
	    		"sql"
	    	]
	    },
	    	"application/x-stuffit": {
	    	source: "apache",
	    	compressible: false,
	    	extensions: [
	    		"sit"
	    	]
	    },
	    	"application/x-stuffitx": {
	    	source: "apache",
	    	extensions: [
	    		"sitx"
	    	]
	    },
	    	"application/x-subrip": {
	    	source: "apache",
	    	extensions: [
	    		"srt"
	    	]
	    },
	    	"application/x-sv4cpio": {
	    	source: "apache",
	    	extensions: [
	    		"sv4cpio"
	    	]
	    },
	    	"application/x-sv4crc": {
	    	source: "apache",
	    	extensions: [
	    		"sv4crc"
	    	]
	    },
	    	"application/x-t3vm-image": {
	    	source: "apache",
	    	extensions: [
	    		"t3"
	    	]
	    },
	    	"application/x-tads": {
	    	source: "apache",
	    	extensions: [
	    		"gam"
	    	]
	    },
	    	"application/x-tar": {
	    	source: "apache",
	    	compressible: true,
	    	extensions: [
	    		"tar"
	    	]
	    },
	    	"application/x-tcl": {
	    	source: "apache",
	    	extensions: [
	    		"tcl",
	    		"tk"
	    	]
	    },
	    	"application/x-tex": {
	    	source: "apache",
	    	extensions: [
	    		"tex"
	    	]
	    },
	    	"application/x-tex-tfm": {
	    	source: "apache",
	    	extensions: [
	    		"tfm"
	    	]
	    },
	    	"application/x-texinfo": {
	    	source: "apache",
	    	extensions: [
	    		"texinfo",
	    		"texi"
	    	]
	    },
	    	"application/x-tgif": {
	    	source: "apache",
	    	extensions: [
	    		"obj"
	    	]
	    },
	    	"application/x-ustar": {
	    	source: "apache",
	    	extensions: [
	    		"ustar"
	    	]
	    },
	    	"application/x-virtualbox-hdd": {
	    	compressible: true,
	    	extensions: [
	    		"hdd"
	    	]
	    },
	    	"application/x-virtualbox-ova": {
	    	compressible: true,
	    	extensions: [
	    		"ova"
	    	]
	    },
	    	"application/x-virtualbox-ovf": {
	    	compressible: true,
	    	extensions: [
	    		"ovf"
	    	]
	    },
	    	"application/x-virtualbox-vbox": {
	    	compressible: true,
	    	extensions: [
	    		"vbox"
	    	]
	    },
	    	"application/x-virtualbox-vbox-extpack": {
	    	compressible: false,
	    	extensions: [
	    		"vbox-extpack"
	    	]
	    },
	    	"application/x-virtualbox-vdi": {
	    	compressible: true,
	    	extensions: [
	    		"vdi"
	    	]
	    },
	    	"application/x-virtualbox-vhd": {
	    	compressible: true,
	    	extensions: [
	    		"vhd"
	    	]
	    },
	    	"application/x-virtualbox-vmdk": {
	    	compressible: true,
	    	extensions: [
	    		"vmdk"
	    	]
	    },
	    	"application/x-wais-source": {
	    	source: "apache",
	    	extensions: [
	    		"src"
	    	]
	    },
	    	"application/x-web-app-manifest+json": {
	    	compressible: true,
	    	extensions: [
	    		"webapp"
	    	]
	    },
	    	"application/x-www-form-urlencoded": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/x-x509-ca-cert": {
	    	source: "iana",
	    	extensions: [
	    		"der",
	    		"crt",
	    		"pem"
	    	]
	    },
	    	"application/x-x509-ca-ra-cert": {
	    	source: "iana"
	    },
	    	"application/x-x509-next-ca-cert": {
	    	source: "iana"
	    },
	    	"application/x-xfig": {
	    	source: "apache",
	    	extensions: [
	    		"fig"
	    	]
	    },
	    	"application/x-xliff+xml": {
	    	source: "apache",
	    	compressible: true,
	    	extensions: [
	    		"xlf"
	    	]
	    },
	    	"application/x-xpinstall": {
	    	source: "apache",
	    	compressible: false,
	    	extensions: [
	    		"xpi"
	    	]
	    },
	    	"application/x-xz": {
	    	source: "apache",
	    	extensions: [
	    		"xz"
	    	]
	    },
	    	"application/x-zmachine": {
	    	source: "apache",
	    	extensions: [
	    		"z1",
	    		"z2",
	    		"z3",
	    		"z4",
	    		"z5",
	    		"z6",
	    		"z7",
	    		"z8"
	    	]
	    },
	    	"application/x400-bp": {
	    	source: "iana"
	    },
	    	"application/xacml+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/xaml+xml": {
	    	source: "apache",
	    	compressible: true,
	    	extensions: [
	    		"xaml"
	    	]
	    },
	    	"application/xcap-att+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"xav"
	    	]
	    },
	    	"application/xcap-caps+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"xca"
	    	]
	    },
	    	"application/xcap-diff+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"xdf"
	    	]
	    },
	    	"application/xcap-el+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"xel"
	    	]
	    },
	    	"application/xcap-error+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/xcap-ns+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"xns"
	    	]
	    },
	    	"application/xcon-conference-info+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/xcon-conference-info-diff+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/xenc+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"xenc"
	    	]
	    },
	    	"application/xhtml+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"xhtml",
	    		"xht"
	    	]
	    },
	    	"application/xhtml-voice+xml": {
	    	source: "apache",
	    	compressible: true
	    },
	    	"application/xliff+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"xlf"
	    	]
	    },
	    	"application/xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"xml",
	    		"xsl",
	    		"xsd",
	    		"rng"
	    	]
	    },
	    	"application/xml-dtd": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"dtd"
	    	]
	    },
	    	"application/xml-external-parsed-entity": {
	    	source: "iana"
	    },
	    	"application/xml-patch+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/xmpp+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/xop+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"xop"
	    	]
	    },
	    	"application/xproc+xml": {
	    	source: "apache",
	    	compressible: true,
	    	extensions: [
	    		"xpl"
	    	]
	    },
	    	"application/xslt+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"xsl",
	    		"xslt"
	    	]
	    },
	    	"application/xspf+xml": {
	    	source: "apache",
	    	compressible: true,
	    	extensions: [
	    		"xspf"
	    	]
	    },
	    	"application/xv+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"mxml",
	    		"xhvml",
	    		"xvml",
	    		"xvm"
	    	]
	    },
	    	"application/yang": {
	    	source: "iana",
	    	extensions: [
	    		"yang"
	    	]
	    },
	    	"application/yang-data+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/yang-data+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/yang-patch+json": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/yang-patch+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"application/yin+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"yin"
	    	]
	    },
	    	"application/zip": {
	    	source: "iana",
	    	compressible: false,
	    	extensions: [
	    		"zip"
	    	]
	    },
	    	"application/zlib": {
	    	source: "iana"
	    },
	    	"application/zstd": {
	    	source: "iana"
	    },
	    	"audio/1d-interleaved-parityfec": {
	    	source: "iana"
	    },
	    	"audio/32kadpcm": {
	    	source: "iana"
	    },
	    	"audio/3gpp": {
	    	source: "iana",
	    	compressible: false,
	    	extensions: [
	    		"3gpp"
	    	]
	    },
	    	"audio/3gpp2": {
	    	source: "iana"
	    },
	    	"audio/aac": {
	    	source: "iana"
	    },
	    	"audio/ac3": {
	    	source: "iana"
	    },
	    	"audio/adpcm": {
	    	source: "apache",
	    	extensions: [
	    		"adp"
	    	]
	    },
	    	"audio/amr": {
	    	source: "iana",
	    	extensions: [
	    		"amr"
	    	]
	    },
	    	"audio/amr-wb": {
	    	source: "iana"
	    },
	    	"audio/amr-wb+": {
	    	source: "iana"
	    },
	    	"audio/aptx": {
	    	source: "iana"
	    },
	    	"audio/asc": {
	    	source: "iana"
	    },
	    	"audio/atrac-advanced-lossless": {
	    	source: "iana"
	    },
	    	"audio/atrac-x": {
	    	source: "iana"
	    },
	    	"audio/atrac3": {
	    	source: "iana"
	    },
	    	"audio/basic": {
	    	source: "iana",
	    	compressible: false,
	    	extensions: [
	    		"au",
	    		"snd"
	    	]
	    },
	    	"audio/bv16": {
	    	source: "iana"
	    },
	    	"audio/bv32": {
	    	source: "iana"
	    },
	    	"audio/clearmode": {
	    	source: "iana"
	    },
	    	"audio/cn": {
	    	source: "iana"
	    },
	    	"audio/dat12": {
	    	source: "iana"
	    },
	    	"audio/dls": {
	    	source: "iana"
	    },
	    	"audio/dsr-es201108": {
	    	source: "iana"
	    },
	    	"audio/dsr-es202050": {
	    	source: "iana"
	    },
	    	"audio/dsr-es202211": {
	    	source: "iana"
	    },
	    	"audio/dsr-es202212": {
	    	source: "iana"
	    },
	    	"audio/dv": {
	    	source: "iana"
	    },
	    	"audio/dvi4": {
	    	source: "iana"
	    },
	    	"audio/eac3": {
	    	source: "iana"
	    },
	    	"audio/encaprtp": {
	    	source: "iana"
	    },
	    	"audio/evrc": {
	    	source: "iana"
	    },
	    	"audio/evrc-qcp": {
	    	source: "iana"
	    },
	    	"audio/evrc0": {
	    	source: "iana"
	    },
	    	"audio/evrc1": {
	    	source: "iana"
	    },
	    	"audio/evrcb": {
	    	source: "iana"
	    },
	    	"audio/evrcb0": {
	    	source: "iana"
	    },
	    	"audio/evrcb1": {
	    	source: "iana"
	    },
	    	"audio/evrcnw": {
	    	source: "iana"
	    },
	    	"audio/evrcnw0": {
	    	source: "iana"
	    },
	    	"audio/evrcnw1": {
	    	source: "iana"
	    },
	    	"audio/evrcwb": {
	    	source: "iana"
	    },
	    	"audio/evrcwb0": {
	    	source: "iana"
	    },
	    	"audio/evrcwb1": {
	    	source: "iana"
	    },
	    	"audio/evs": {
	    	source: "iana"
	    },
	    	"audio/flexfec": {
	    	source: "iana"
	    },
	    	"audio/fwdred": {
	    	source: "iana"
	    },
	    	"audio/g711-0": {
	    	source: "iana"
	    },
	    	"audio/g719": {
	    	source: "iana"
	    },
	    	"audio/g722": {
	    	source: "iana"
	    },
	    	"audio/g7221": {
	    	source: "iana"
	    },
	    	"audio/g723": {
	    	source: "iana"
	    },
	    	"audio/g726-16": {
	    	source: "iana"
	    },
	    	"audio/g726-24": {
	    	source: "iana"
	    },
	    	"audio/g726-32": {
	    	source: "iana"
	    },
	    	"audio/g726-40": {
	    	source: "iana"
	    },
	    	"audio/g728": {
	    	source: "iana"
	    },
	    	"audio/g729": {
	    	source: "iana"
	    },
	    	"audio/g7291": {
	    	source: "iana"
	    },
	    	"audio/g729d": {
	    	source: "iana"
	    },
	    	"audio/g729e": {
	    	source: "iana"
	    },
	    	"audio/gsm": {
	    	source: "iana"
	    },
	    	"audio/gsm-efr": {
	    	source: "iana"
	    },
	    	"audio/gsm-hr-08": {
	    	source: "iana"
	    },
	    	"audio/ilbc": {
	    	source: "iana"
	    },
	    	"audio/ip-mr_v2.5": {
	    	source: "iana"
	    },
	    	"audio/isac": {
	    	source: "apache"
	    },
	    	"audio/l16": {
	    	source: "iana"
	    },
	    	"audio/l20": {
	    	source: "iana"
	    },
	    	"audio/l24": {
	    	source: "iana",
	    	compressible: false
	    },
	    	"audio/l8": {
	    	source: "iana"
	    },
	    	"audio/lpc": {
	    	source: "iana"
	    },
	    	"audio/melp": {
	    	source: "iana"
	    },
	    	"audio/melp1200": {
	    	source: "iana"
	    },
	    	"audio/melp2400": {
	    	source: "iana"
	    },
	    	"audio/melp600": {
	    	source: "iana"
	    },
	    	"audio/mhas": {
	    	source: "iana"
	    },
	    	"audio/midi": {
	    	source: "apache",
	    	extensions: [
	    		"mid",
	    		"midi",
	    		"kar",
	    		"rmi"
	    	]
	    },
	    	"audio/mobile-xmf": {
	    	source: "iana",
	    	extensions: [
	    		"mxmf"
	    	]
	    },
	    	"audio/mp3": {
	    	compressible: false,
	    	extensions: [
	    		"mp3"
	    	]
	    },
	    	"audio/mp4": {
	    	source: "iana",
	    	compressible: false,
	    	extensions: [
	    		"m4a",
	    		"mp4a"
	    	]
	    },
	    	"audio/mp4a-latm": {
	    	source: "iana"
	    },
	    	"audio/mpa": {
	    	source: "iana"
	    },
	    	"audio/mpa-robust": {
	    	source: "iana"
	    },
	    	"audio/mpeg": {
	    	source: "iana",
	    	compressible: false,
	    	extensions: [
	    		"mpga",
	    		"mp2",
	    		"mp2a",
	    		"mp3",
	    		"m2a",
	    		"m3a"
	    	]
	    },
	    	"audio/mpeg4-generic": {
	    	source: "iana"
	    },
	    	"audio/musepack": {
	    	source: "apache"
	    },
	    	"audio/ogg": {
	    	source: "iana",
	    	compressible: false,
	    	extensions: [
	    		"oga",
	    		"ogg",
	    		"spx",
	    		"opus"
	    	]
	    },
	    	"audio/opus": {
	    	source: "iana"
	    },
	    	"audio/parityfec": {
	    	source: "iana"
	    },
	    	"audio/pcma": {
	    	source: "iana"
	    },
	    	"audio/pcma-wb": {
	    	source: "iana"
	    },
	    	"audio/pcmu": {
	    	source: "iana"
	    },
	    	"audio/pcmu-wb": {
	    	source: "iana"
	    },
	    	"audio/prs.sid": {
	    	source: "iana"
	    },
	    	"audio/qcelp": {
	    	source: "iana"
	    },
	    	"audio/raptorfec": {
	    	source: "iana"
	    },
	    	"audio/red": {
	    	source: "iana"
	    },
	    	"audio/rtp-enc-aescm128": {
	    	source: "iana"
	    },
	    	"audio/rtp-midi": {
	    	source: "iana"
	    },
	    	"audio/rtploopback": {
	    	source: "iana"
	    },
	    	"audio/rtx": {
	    	source: "iana"
	    },
	    	"audio/s3m": {
	    	source: "apache",
	    	extensions: [
	    		"s3m"
	    	]
	    },
	    	"audio/scip": {
	    	source: "iana"
	    },
	    	"audio/silk": {
	    	source: "apache",
	    	extensions: [
	    		"sil"
	    	]
	    },
	    	"audio/smv": {
	    	source: "iana"
	    },
	    	"audio/smv-qcp": {
	    	source: "iana"
	    },
	    	"audio/smv0": {
	    	source: "iana"
	    },
	    	"audio/sofa": {
	    	source: "iana"
	    },
	    	"audio/sp-midi": {
	    	source: "iana"
	    },
	    	"audio/speex": {
	    	source: "iana"
	    },
	    	"audio/t140c": {
	    	source: "iana"
	    },
	    	"audio/t38": {
	    	source: "iana"
	    },
	    	"audio/telephone-event": {
	    	source: "iana"
	    },
	    	"audio/tetra_acelp": {
	    	source: "iana"
	    },
	    	"audio/tetra_acelp_bb": {
	    	source: "iana"
	    },
	    	"audio/tone": {
	    	source: "iana"
	    },
	    	"audio/tsvcis": {
	    	source: "iana"
	    },
	    	"audio/uemclip": {
	    	source: "iana"
	    },
	    	"audio/ulpfec": {
	    	source: "iana"
	    },
	    	"audio/usac": {
	    	source: "iana"
	    },
	    	"audio/vdvi": {
	    	source: "iana"
	    },
	    	"audio/vmr-wb": {
	    	source: "iana"
	    },
	    	"audio/vnd.3gpp.iufp": {
	    	source: "iana"
	    },
	    	"audio/vnd.4sb": {
	    	source: "iana"
	    },
	    	"audio/vnd.audiokoz": {
	    	source: "iana"
	    },
	    	"audio/vnd.celp": {
	    	source: "iana"
	    },
	    	"audio/vnd.cisco.nse": {
	    	source: "iana"
	    },
	    	"audio/vnd.cmles.radio-events": {
	    	source: "iana"
	    },
	    	"audio/vnd.cns.anp1": {
	    	source: "iana"
	    },
	    	"audio/vnd.cns.inf1": {
	    	source: "iana"
	    },
	    	"audio/vnd.dece.audio": {
	    	source: "iana",
	    	extensions: [
	    		"uva",
	    		"uvva"
	    	]
	    },
	    	"audio/vnd.digital-winds": {
	    	source: "iana",
	    	extensions: [
	    		"eol"
	    	]
	    },
	    	"audio/vnd.dlna.adts": {
	    	source: "iana"
	    },
	    	"audio/vnd.dolby.heaac.1": {
	    	source: "iana"
	    },
	    	"audio/vnd.dolby.heaac.2": {
	    	source: "iana"
	    },
	    	"audio/vnd.dolby.mlp": {
	    	source: "iana"
	    },
	    	"audio/vnd.dolby.mps": {
	    	source: "iana"
	    },
	    	"audio/vnd.dolby.pl2": {
	    	source: "iana"
	    },
	    	"audio/vnd.dolby.pl2x": {
	    	source: "iana"
	    },
	    	"audio/vnd.dolby.pl2z": {
	    	source: "iana"
	    },
	    	"audio/vnd.dolby.pulse.1": {
	    	source: "iana"
	    },
	    	"audio/vnd.dra": {
	    	source: "iana",
	    	extensions: [
	    		"dra"
	    	]
	    },
	    	"audio/vnd.dts": {
	    	source: "iana",
	    	extensions: [
	    		"dts"
	    	]
	    },
	    	"audio/vnd.dts.hd": {
	    	source: "iana",
	    	extensions: [
	    		"dtshd"
	    	]
	    },
	    	"audio/vnd.dts.uhd": {
	    	source: "iana"
	    },
	    	"audio/vnd.dvb.file": {
	    	source: "iana"
	    },
	    	"audio/vnd.everad.plj": {
	    	source: "iana"
	    },
	    	"audio/vnd.hns.audio": {
	    	source: "iana"
	    },
	    	"audio/vnd.lucent.voice": {
	    	source: "iana",
	    	extensions: [
	    		"lvp"
	    	]
	    },
	    	"audio/vnd.ms-playready.media.pya": {
	    	source: "iana",
	    	extensions: [
	    		"pya"
	    	]
	    },
	    	"audio/vnd.nokia.mobile-xmf": {
	    	source: "iana"
	    },
	    	"audio/vnd.nortel.vbk": {
	    	source: "iana"
	    },
	    	"audio/vnd.nuera.ecelp4800": {
	    	source: "iana",
	    	extensions: [
	    		"ecelp4800"
	    	]
	    },
	    	"audio/vnd.nuera.ecelp7470": {
	    	source: "iana",
	    	extensions: [
	    		"ecelp7470"
	    	]
	    },
	    	"audio/vnd.nuera.ecelp9600": {
	    	source: "iana",
	    	extensions: [
	    		"ecelp9600"
	    	]
	    },
	    	"audio/vnd.octel.sbc": {
	    	source: "iana"
	    },
	    	"audio/vnd.presonus.multitrack": {
	    	source: "iana"
	    },
	    	"audio/vnd.qcelp": {
	    	source: "iana"
	    },
	    	"audio/vnd.rhetorex.32kadpcm": {
	    	source: "iana"
	    },
	    	"audio/vnd.rip": {
	    	source: "iana",
	    	extensions: [
	    		"rip"
	    	]
	    },
	    	"audio/vnd.rn-realaudio": {
	    	compressible: false
	    },
	    	"audio/vnd.sealedmedia.softseal.mpeg": {
	    	source: "iana"
	    },
	    	"audio/vnd.vmx.cvsd": {
	    	source: "iana"
	    },
	    	"audio/vnd.wave": {
	    	compressible: false
	    },
	    	"audio/vorbis": {
	    	source: "iana",
	    	compressible: false
	    },
	    	"audio/vorbis-config": {
	    	source: "iana"
	    },
	    	"audio/wav": {
	    	compressible: false,
	    	extensions: [
	    		"wav"
	    	]
	    },
	    	"audio/wave": {
	    	compressible: false,
	    	extensions: [
	    		"wav"
	    	]
	    },
	    	"audio/webm": {
	    	source: "apache",
	    	compressible: false,
	    	extensions: [
	    		"weba"
	    	]
	    },
	    	"audio/x-aac": {
	    	source: "apache",
	    	compressible: false,
	    	extensions: [
	    		"aac"
	    	]
	    },
	    	"audio/x-aiff": {
	    	source: "apache",
	    	extensions: [
	    		"aif",
	    		"aiff",
	    		"aifc"
	    	]
	    },
	    	"audio/x-caf": {
	    	source: "apache",
	    	compressible: false,
	    	extensions: [
	    		"caf"
	    	]
	    },
	    	"audio/x-flac": {
	    	source: "apache",
	    	extensions: [
	    		"flac"
	    	]
	    },
	    	"audio/x-m4a": {
	    	source: "nginx",
	    	extensions: [
	    		"m4a"
	    	]
	    },
	    	"audio/x-matroska": {
	    	source: "apache",
	    	extensions: [
	    		"mka"
	    	]
	    },
	    	"audio/x-mpegurl": {
	    	source: "apache",
	    	extensions: [
	    		"m3u"
	    	]
	    },
	    	"audio/x-ms-wax": {
	    	source: "apache",
	    	extensions: [
	    		"wax"
	    	]
	    },
	    	"audio/x-ms-wma": {
	    	source: "apache",
	    	extensions: [
	    		"wma"
	    	]
	    },
	    	"audio/x-pn-realaudio": {
	    	source: "apache",
	    	extensions: [
	    		"ram",
	    		"ra"
	    	]
	    },
	    	"audio/x-pn-realaudio-plugin": {
	    	source: "apache",
	    	extensions: [
	    		"rmp"
	    	]
	    },
	    	"audio/x-realaudio": {
	    	source: "nginx",
	    	extensions: [
	    		"ra"
	    	]
	    },
	    	"audio/x-tta": {
	    	source: "apache"
	    },
	    	"audio/x-wav": {
	    	source: "apache",
	    	extensions: [
	    		"wav"
	    	]
	    },
	    	"audio/xm": {
	    	source: "apache",
	    	extensions: [
	    		"xm"
	    	]
	    },
	    	"chemical/x-cdx": {
	    	source: "apache",
	    	extensions: [
	    		"cdx"
	    	]
	    },
	    	"chemical/x-cif": {
	    	source: "apache",
	    	extensions: [
	    		"cif"
	    	]
	    },
	    	"chemical/x-cmdf": {
	    	source: "apache",
	    	extensions: [
	    		"cmdf"
	    	]
	    },
	    	"chemical/x-cml": {
	    	source: "apache",
	    	extensions: [
	    		"cml"
	    	]
	    },
	    	"chemical/x-csml": {
	    	source: "apache",
	    	extensions: [
	    		"csml"
	    	]
	    },
	    	"chemical/x-pdb": {
	    	source: "apache"
	    },
	    	"chemical/x-xyz": {
	    	source: "apache",
	    	extensions: [
	    		"xyz"
	    	]
	    },
	    	"font/collection": {
	    	source: "iana",
	    	extensions: [
	    		"ttc"
	    	]
	    },
	    	"font/otf": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"otf"
	    	]
	    },
	    	"font/sfnt": {
	    	source: "iana"
	    },
	    	"font/ttf": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"ttf"
	    	]
	    },
	    	"font/woff": {
	    	source: "iana",
	    	extensions: [
	    		"woff"
	    	]
	    },
	    	"font/woff2": {
	    	source: "iana",
	    	extensions: [
	    		"woff2"
	    	]
	    },
	    	"image/aces": {
	    	source: "iana",
	    	extensions: [
	    		"exr"
	    	]
	    },
	    	"image/apng": {
	    	compressible: false,
	    	extensions: [
	    		"apng"
	    	]
	    },
	    	"image/avci": {
	    	source: "iana",
	    	extensions: [
	    		"avci"
	    	]
	    },
	    	"image/avcs": {
	    	source: "iana",
	    	extensions: [
	    		"avcs"
	    	]
	    },
	    	"image/avif": {
	    	source: "iana",
	    	compressible: false,
	    	extensions: [
	    		"avif"
	    	]
	    },
	    	"image/bmp": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"bmp"
	    	]
	    },
	    	"image/cgm": {
	    	source: "iana",
	    	extensions: [
	    		"cgm"
	    	]
	    },
	    	"image/dicom-rle": {
	    	source: "iana",
	    	extensions: [
	    		"drle"
	    	]
	    },
	    	"image/emf": {
	    	source: "iana",
	    	extensions: [
	    		"emf"
	    	]
	    },
	    	"image/fits": {
	    	source: "iana",
	    	extensions: [
	    		"fits"
	    	]
	    },
	    	"image/g3fax": {
	    	source: "iana",
	    	extensions: [
	    		"g3"
	    	]
	    },
	    	"image/gif": {
	    	source: "iana",
	    	compressible: false,
	    	extensions: [
	    		"gif"
	    	]
	    },
	    	"image/heic": {
	    	source: "iana",
	    	extensions: [
	    		"heic"
	    	]
	    },
	    	"image/heic-sequence": {
	    	source: "iana",
	    	extensions: [
	    		"heics"
	    	]
	    },
	    	"image/heif": {
	    	source: "iana",
	    	extensions: [
	    		"heif"
	    	]
	    },
	    	"image/heif-sequence": {
	    	source: "iana",
	    	extensions: [
	    		"heifs"
	    	]
	    },
	    	"image/hej2k": {
	    	source: "iana",
	    	extensions: [
	    		"hej2"
	    	]
	    },
	    	"image/hsj2": {
	    	source: "iana",
	    	extensions: [
	    		"hsj2"
	    	]
	    },
	    	"image/ief": {
	    	source: "iana",
	    	extensions: [
	    		"ief"
	    	]
	    },
	    	"image/jls": {
	    	source: "iana",
	    	extensions: [
	    		"jls"
	    	]
	    },
	    	"image/jp2": {
	    	source: "iana",
	    	compressible: false,
	    	extensions: [
	    		"jp2",
	    		"jpg2"
	    	]
	    },
	    	"image/jpeg": {
	    	source: "iana",
	    	compressible: false,
	    	extensions: [
	    		"jpeg",
	    		"jpg",
	    		"jpe"
	    	]
	    },
	    	"image/jph": {
	    	source: "iana",
	    	extensions: [
	    		"jph"
	    	]
	    },
	    	"image/jphc": {
	    	source: "iana",
	    	extensions: [
	    		"jhc"
	    	]
	    },
	    	"image/jpm": {
	    	source: "iana",
	    	compressible: false,
	    	extensions: [
	    		"jpm"
	    	]
	    },
	    	"image/jpx": {
	    	source: "iana",
	    	compressible: false,
	    	extensions: [
	    		"jpx",
	    		"jpf"
	    	]
	    },
	    	"image/jxr": {
	    	source: "iana",
	    	extensions: [
	    		"jxr"
	    	]
	    },
	    	"image/jxra": {
	    	source: "iana",
	    	extensions: [
	    		"jxra"
	    	]
	    },
	    	"image/jxrs": {
	    	source: "iana",
	    	extensions: [
	    		"jxrs"
	    	]
	    },
	    	"image/jxs": {
	    	source: "iana",
	    	extensions: [
	    		"jxs"
	    	]
	    },
	    	"image/jxsc": {
	    	source: "iana",
	    	extensions: [
	    		"jxsc"
	    	]
	    },
	    	"image/jxsi": {
	    	source: "iana",
	    	extensions: [
	    		"jxsi"
	    	]
	    },
	    	"image/jxss": {
	    	source: "iana",
	    	extensions: [
	    		"jxss"
	    	]
	    },
	    	"image/ktx": {
	    	source: "iana",
	    	extensions: [
	    		"ktx"
	    	]
	    },
	    	"image/ktx2": {
	    	source: "iana",
	    	extensions: [
	    		"ktx2"
	    	]
	    },
	    	"image/naplps": {
	    	source: "iana"
	    },
	    	"image/pjpeg": {
	    	compressible: false
	    },
	    	"image/png": {
	    	source: "iana",
	    	compressible: false,
	    	extensions: [
	    		"png"
	    	]
	    },
	    	"image/prs.btif": {
	    	source: "iana",
	    	extensions: [
	    		"btif"
	    	]
	    },
	    	"image/prs.pti": {
	    	source: "iana",
	    	extensions: [
	    		"pti"
	    	]
	    },
	    	"image/pwg-raster": {
	    	source: "iana"
	    },
	    	"image/sgi": {
	    	source: "apache",
	    	extensions: [
	    		"sgi"
	    	]
	    },
	    	"image/svg+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"svg",
	    		"svgz"
	    	]
	    },
	    	"image/t38": {
	    	source: "iana",
	    	extensions: [
	    		"t38"
	    	]
	    },
	    	"image/tiff": {
	    	source: "iana",
	    	compressible: false,
	    	extensions: [
	    		"tif",
	    		"tiff"
	    	]
	    },
	    	"image/tiff-fx": {
	    	source: "iana",
	    	extensions: [
	    		"tfx"
	    	]
	    },
	    	"image/vnd.adobe.photoshop": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"psd"
	    	]
	    },
	    	"image/vnd.airzip.accelerator.azv": {
	    	source: "iana",
	    	extensions: [
	    		"azv"
	    	]
	    },
	    	"image/vnd.cns.inf2": {
	    	source: "iana"
	    },
	    	"image/vnd.dece.graphic": {
	    	source: "iana",
	    	extensions: [
	    		"uvi",
	    		"uvvi",
	    		"uvg",
	    		"uvvg"
	    	]
	    },
	    	"image/vnd.djvu": {
	    	source: "iana",
	    	extensions: [
	    		"djvu",
	    		"djv"
	    	]
	    },
	    	"image/vnd.dvb.subtitle": {
	    	source: "iana",
	    	extensions: [
	    		"sub"
	    	]
	    },
	    	"image/vnd.dwg": {
	    	source: "iana",
	    	extensions: [
	    		"dwg"
	    	]
	    },
	    	"image/vnd.dxf": {
	    	source: "iana",
	    	extensions: [
	    		"dxf"
	    	]
	    },
	    	"image/vnd.fastbidsheet": {
	    	source: "iana",
	    	extensions: [
	    		"fbs"
	    	]
	    },
	    	"image/vnd.fpx": {
	    	source: "iana",
	    	extensions: [
	    		"fpx"
	    	]
	    },
	    	"image/vnd.fst": {
	    	source: "iana",
	    	extensions: [
	    		"fst"
	    	]
	    },
	    	"image/vnd.fujixerox.edmics-mmr": {
	    	source: "iana",
	    	extensions: [
	    		"mmr"
	    	]
	    },
	    	"image/vnd.fujixerox.edmics-rlc": {
	    	source: "iana",
	    	extensions: [
	    		"rlc"
	    	]
	    },
	    	"image/vnd.globalgraphics.pgb": {
	    	source: "iana"
	    },
	    	"image/vnd.microsoft.icon": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"ico"
	    	]
	    },
	    	"image/vnd.mix": {
	    	source: "iana"
	    },
	    	"image/vnd.mozilla.apng": {
	    	source: "iana"
	    },
	    	"image/vnd.ms-dds": {
	    	compressible: true,
	    	extensions: [
	    		"dds"
	    	]
	    },
	    	"image/vnd.ms-modi": {
	    	source: "iana",
	    	extensions: [
	    		"mdi"
	    	]
	    },
	    	"image/vnd.ms-photo": {
	    	source: "apache",
	    	extensions: [
	    		"wdp"
	    	]
	    },
	    	"image/vnd.net-fpx": {
	    	source: "iana",
	    	extensions: [
	    		"npx"
	    	]
	    },
	    	"image/vnd.pco.b16": {
	    	source: "iana",
	    	extensions: [
	    		"b16"
	    	]
	    },
	    	"image/vnd.radiance": {
	    	source: "iana"
	    },
	    	"image/vnd.sealed.png": {
	    	source: "iana"
	    },
	    	"image/vnd.sealedmedia.softseal.gif": {
	    	source: "iana"
	    },
	    	"image/vnd.sealedmedia.softseal.jpg": {
	    	source: "iana"
	    },
	    	"image/vnd.svf": {
	    	source: "iana"
	    },
	    	"image/vnd.tencent.tap": {
	    	source: "iana",
	    	extensions: [
	    		"tap"
	    	]
	    },
	    	"image/vnd.valve.source.texture": {
	    	source: "iana",
	    	extensions: [
	    		"vtf"
	    	]
	    },
	    	"image/vnd.wap.wbmp": {
	    	source: "iana",
	    	extensions: [
	    		"wbmp"
	    	]
	    },
	    	"image/vnd.xiff": {
	    	source: "iana",
	    	extensions: [
	    		"xif"
	    	]
	    },
	    	"image/vnd.zbrush.pcx": {
	    	source: "iana",
	    	extensions: [
	    		"pcx"
	    	]
	    },
	    	"image/webp": {
	    	source: "apache",
	    	extensions: [
	    		"webp"
	    	]
	    },
	    	"image/wmf": {
	    	source: "iana",
	    	extensions: [
	    		"wmf"
	    	]
	    },
	    	"image/x-3ds": {
	    	source: "apache",
	    	extensions: [
	    		"3ds"
	    	]
	    },
	    	"image/x-cmu-raster": {
	    	source: "apache",
	    	extensions: [
	    		"ras"
	    	]
	    },
	    	"image/x-cmx": {
	    	source: "apache",
	    	extensions: [
	    		"cmx"
	    	]
	    },
	    	"image/x-freehand": {
	    	source: "apache",
	    	extensions: [
	    		"fh",
	    		"fhc",
	    		"fh4",
	    		"fh5",
	    		"fh7"
	    	]
	    },
	    	"image/x-icon": {
	    	source: "apache",
	    	compressible: true,
	    	extensions: [
	    		"ico"
	    	]
	    },
	    	"image/x-jng": {
	    	source: "nginx",
	    	extensions: [
	    		"jng"
	    	]
	    },
	    	"image/x-mrsid-image": {
	    	source: "apache",
	    	extensions: [
	    		"sid"
	    	]
	    },
	    	"image/x-ms-bmp": {
	    	source: "nginx",
	    	compressible: true,
	    	extensions: [
	    		"bmp"
	    	]
	    },
	    	"image/x-pcx": {
	    	source: "apache",
	    	extensions: [
	    		"pcx"
	    	]
	    },
	    	"image/x-pict": {
	    	source: "apache",
	    	extensions: [
	    		"pic",
	    		"pct"
	    	]
	    },
	    	"image/x-portable-anymap": {
	    	source: "apache",
	    	extensions: [
	    		"pnm"
	    	]
	    },
	    	"image/x-portable-bitmap": {
	    	source: "apache",
	    	extensions: [
	    		"pbm"
	    	]
	    },
	    	"image/x-portable-graymap": {
	    	source: "apache",
	    	extensions: [
	    		"pgm"
	    	]
	    },
	    	"image/x-portable-pixmap": {
	    	source: "apache",
	    	extensions: [
	    		"ppm"
	    	]
	    },
	    	"image/x-rgb": {
	    	source: "apache",
	    	extensions: [
	    		"rgb"
	    	]
	    },
	    	"image/x-tga": {
	    	source: "apache",
	    	extensions: [
	    		"tga"
	    	]
	    },
	    	"image/x-xbitmap": {
	    	source: "apache",
	    	extensions: [
	    		"xbm"
	    	]
	    },
	    	"image/x-xcf": {
	    	compressible: false
	    },
	    	"image/x-xpixmap": {
	    	source: "apache",
	    	extensions: [
	    		"xpm"
	    	]
	    },
	    	"image/x-xwindowdump": {
	    	source: "apache",
	    	extensions: [
	    		"xwd"
	    	]
	    },
	    	"message/cpim": {
	    	source: "iana"
	    },
	    	"message/delivery-status": {
	    	source: "iana"
	    },
	    	"message/disposition-notification": {
	    	source: "iana",
	    	extensions: [
	    		"disposition-notification"
	    	]
	    },
	    	"message/external-body": {
	    	source: "iana"
	    },
	    	"message/feedback-report": {
	    	source: "iana"
	    },
	    	"message/global": {
	    	source: "iana",
	    	extensions: [
	    		"u8msg"
	    	]
	    },
	    	"message/global-delivery-status": {
	    	source: "iana",
	    	extensions: [
	    		"u8dsn"
	    	]
	    },
	    	"message/global-disposition-notification": {
	    	source: "iana",
	    	extensions: [
	    		"u8mdn"
	    	]
	    },
	    	"message/global-headers": {
	    	source: "iana",
	    	extensions: [
	    		"u8hdr"
	    	]
	    },
	    	"message/http": {
	    	source: "iana",
	    	compressible: false
	    },
	    	"message/imdn+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"message/news": {
	    	source: "iana"
	    },
	    	"message/partial": {
	    	source: "iana",
	    	compressible: false
	    },
	    	"message/rfc822": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"eml",
	    		"mime"
	    	]
	    },
	    	"message/s-http": {
	    	source: "iana"
	    },
	    	"message/sip": {
	    	source: "iana"
	    },
	    	"message/sipfrag": {
	    	source: "iana"
	    },
	    	"message/tracking-status": {
	    	source: "iana"
	    },
	    	"message/vnd.si.simp": {
	    	source: "iana"
	    },
	    	"message/vnd.wfa.wsc": {
	    	source: "iana",
	    	extensions: [
	    		"wsc"
	    	]
	    },
	    	"model/3mf": {
	    	source: "iana",
	    	extensions: [
	    		"3mf"
	    	]
	    },
	    	"model/e57": {
	    	source: "iana"
	    },
	    	"model/gltf+json": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"gltf"
	    	]
	    },
	    	"model/gltf-binary": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"glb"
	    	]
	    },
	    	"model/iges": {
	    	source: "iana",
	    	compressible: false,
	    	extensions: [
	    		"igs",
	    		"iges"
	    	]
	    },
	    	"model/mesh": {
	    	source: "iana",
	    	compressible: false,
	    	extensions: [
	    		"msh",
	    		"mesh",
	    		"silo"
	    	]
	    },
	    	"model/mtl": {
	    	source: "iana",
	    	extensions: [
	    		"mtl"
	    	]
	    },
	    	"model/obj": {
	    	source: "iana",
	    	extensions: [
	    		"obj"
	    	]
	    },
	    	"model/step": {
	    	source: "iana"
	    },
	    	"model/step+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"stpx"
	    	]
	    },
	    	"model/step+zip": {
	    	source: "iana",
	    	compressible: false,
	    	extensions: [
	    		"stpz"
	    	]
	    },
	    	"model/step-xml+zip": {
	    	source: "iana",
	    	compressible: false,
	    	extensions: [
	    		"stpxz"
	    	]
	    },
	    	"model/stl": {
	    	source: "iana",
	    	extensions: [
	    		"stl"
	    	]
	    },
	    	"model/vnd.collada+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"dae"
	    	]
	    },
	    	"model/vnd.dwf": {
	    	source: "iana",
	    	extensions: [
	    		"dwf"
	    	]
	    },
	    	"model/vnd.flatland.3dml": {
	    	source: "iana"
	    },
	    	"model/vnd.gdl": {
	    	source: "iana",
	    	extensions: [
	    		"gdl"
	    	]
	    },
	    	"model/vnd.gs-gdl": {
	    	source: "apache"
	    },
	    	"model/vnd.gs.gdl": {
	    	source: "iana"
	    },
	    	"model/vnd.gtw": {
	    	source: "iana",
	    	extensions: [
	    		"gtw"
	    	]
	    },
	    	"model/vnd.moml+xml": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"model/vnd.mts": {
	    	source: "iana",
	    	extensions: [
	    		"mts"
	    	]
	    },
	    	"model/vnd.opengex": {
	    	source: "iana",
	    	extensions: [
	    		"ogex"
	    	]
	    },
	    	"model/vnd.parasolid.transmit.binary": {
	    	source: "iana",
	    	extensions: [
	    		"x_b"
	    	]
	    },
	    	"model/vnd.parasolid.transmit.text": {
	    	source: "iana",
	    	extensions: [
	    		"x_t"
	    	]
	    },
	    	"model/vnd.pytha.pyox": {
	    	source: "iana"
	    },
	    	"model/vnd.rosette.annotated-data-model": {
	    	source: "iana"
	    },
	    	"model/vnd.sap.vds": {
	    	source: "iana",
	    	extensions: [
	    		"vds"
	    	]
	    },
	    	"model/vnd.usdz+zip": {
	    	source: "iana",
	    	compressible: false,
	    	extensions: [
	    		"usdz"
	    	]
	    },
	    	"model/vnd.valve.source.compiled-map": {
	    	source: "iana",
	    	extensions: [
	    		"bsp"
	    	]
	    },
	    	"model/vnd.vtu": {
	    	source: "iana",
	    	extensions: [
	    		"vtu"
	    	]
	    },
	    	"model/vrml": {
	    	source: "iana",
	    	compressible: false,
	    	extensions: [
	    		"wrl",
	    		"vrml"
	    	]
	    },
	    	"model/x3d+binary": {
	    	source: "apache",
	    	compressible: false,
	    	extensions: [
	    		"x3db",
	    		"x3dbz"
	    	]
	    },
	    	"model/x3d+fastinfoset": {
	    	source: "iana",
	    	extensions: [
	    		"x3db"
	    	]
	    },
	    	"model/x3d+vrml": {
	    	source: "apache",
	    	compressible: false,
	    	extensions: [
	    		"x3dv",
	    		"x3dvz"
	    	]
	    },
	    	"model/x3d+xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"x3d",
	    		"x3dz"
	    	]
	    },
	    	"model/x3d-vrml": {
	    	source: "iana",
	    	extensions: [
	    		"x3dv"
	    	]
	    },
	    	"multipart/alternative": {
	    	source: "iana",
	    	compressible: false
	    },
	    	"multipart/appledouble": {
	    	source: "iana"
	    },
	    	"multipart/byteranges": {
	    	source: "iana"
	    },
	    	"multipart/digest": {
	    	source: "iana"
	    },
	    	"multipart/encrypted": {
	    	source: "iana",
	    	compressible: false
	    },
	    	"multipart/form-data": {
	    	source: "iana",
	    	compressible: false
	    },
	    	"multipart/header-set": {
	    	source: "iana"
	    },
	    	"multipart/mixed": {
	    	source: "iana"
	    },
	    	"multipart/multilingual": {
	    	source: "iana"
	    },
	    	"multipart/parallel": {
	    	source: "iana"
	    },
	    	"multipart/related": {
	    	source: "iana",
	    	compressible: false
	    },
	    	"multipart/report": {
	    	source: "iana"
	    },
	    	"multipart/signed": {
	    	source: "iana",
	    	compressible: false
	    },
	    	"multipart/vnd.bint.med-plus": {
	    	source: "iana"
	    },
	    	"multipart/voice-message": {
	    	source: "iana"
	    },
	    	"multipart/x-mixed-replace": {
	    	source: "iana"
	    },
	    	"text/1d-interleaved-parityfec": {
	    	source: "iana"
	    },
	    	"text/cache-manifest": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"appcache",
	    		"manifest"
	    	]
	    },
	    	"text/calendar": {
	    	source: "iana",
	    	extensions: [
	    		"ics",
	    		"ifb"
	    	]
	    },
	    	"text/calender": {
	    	compressible: true
	    },
	    	"text/cmd": {
	    	compressible: true
	    },
	    	"text/coffeescript": {
	    	extensions: [
	    		"coffee",
	    		"litcoffee"
	    	]
	    },
	    	"text/cql": {
	    	source: "iana"
	    },
	    	"text/cql-expression": {
	    	source: "iana"
	    },
	    	"text/cql-identifier": {
	    	source: "iana"
	    },
	    	"text/css": {
	    	source: "iana",
	    	charset: "UTF-8",
	    	compressible: true,
	    	extensions: [
	    		"css"
	    	]
	    },
	    	"text/csv": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"csv"
	    	]
	    },
	    	"text/csv-schema": {
	    	source: "iana"
	    },
	    	"text/directory": {
	    	source: "iana"
	    },
	    	"text/dns": {
	    	source: "iana"
	    },
	    	"text/ecmascript": {
	    	source: "iana"
	    },
	    	"text/encaprtp": {
	    	source: "iana"
	    },
	    	"text/enriched": {
	    	source: "iana"
	    },
	    	"text/fhirpath": {
	    	source: "iana"
	    },
	    	"text/flexfec": {
	    	source: "iana"
	    },
	    	"text/fwdred": {
	    	source: "iana"
	    },
	    	"text/gff3": {
	    	source: "iana"
	    },
	    	"text/grammar-ref-list": {
	    	source: "iana"
	    },
	    	"text/html": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"html",
	    		"htm",
	    		"shtml"
	    	]
	    },
	    	"text/jade": {
	    	extensions: [
	    		"jade"
	    	]
	    },
	    	"text/javascript": {
	    	source: "iana",
	    	compressible: true
	    },
	    	"text/jcr-cnd": {
	    	source: "iana"
	    },
	    	"text/jsx": {
	    	compressible: true,
	    	extensions: [
	    		"jsx"
	    	]
	    },
	    	"text/less": {
	    	compressible: true,
	    	extensions: [
	    		"less"
	    	]
	    },
	    	"text/markdown": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"markdown",
	    		"md"
	    	]
	    },
	    	"text/mathml": {
	    	source: "nginx",
	    	extensions: [
	    		"mml"
	    	]
	    },
	    	"text/mdx": {
	    	compressible: true,
	    	extensions: [
	    		"mdx"
	    	]
	    },
	    	"text/mizar": {
	    	source: "iana"
	    },
	    	"text/n3": {
	    	source: "iana",
	    	charset: "UTF-8",
	    	compressible: true,
	    	extensions: [
	    		"n3"
	    	]
	    },
	    	"text/parameters": {
	    	source: "iana",
	    	charset: "UTF-8"
	    },
	    	"text/parityfec": {
	    	source: "iana"
	    },
	    	"text/plain": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"txt",
	    		"text",
	    		"conf",
	    		"def",
	    		"list",
	    		"log",
	    		"in",
	    		"ini"
	    	]
	    },
	    	"text/provenance-notation": {
	    	source: "iana",
	    	charset: "UTF-8"
	    },
	    	"text/prs.fallenstein.rst": {
	    	source: "iana"
	    },
	    	"text/prs.lines.tag": {
	    	source: "iana",
	    	extensions: [
	    		"dsc"
	    	]
	    },
	    	"text/prs.prop.logic": {
	    	source: "iana"
	    },
	    	"text/raptorfec": {
	    	source: "iana"
	    },
	    	"text/red": {
	    	source: "iana"
	    },
	    	"text/rfc822-headers": {
	    	source: "iana"
	    },
	    	"text/richtext": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"rtx"
	    	]
	    },
	    	"text/rtf": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"rtf"
	    	]
	    },
	    	"text/rtp-enc-aescm128": {
	    	source: "iana"
	    },
	    	"text/rtploopback": {
	    	source: "iana"
	    },
	    	"text/rtx": {
	    	source: "iana"
	    },
	    	"text/sgml": {
	    	source: "iana",
	    	extensions: [
	    		"sgml",
	    		"sgm"
	    	]
	    },
	    	"text/shaclc": {
	    	source: "iana"
	    },
	    	"text/shex": {
	    	source: "iana",
	    	extensions: [
	    		"shex"
	    	]
	    },
	    	"text/slim": {
	    	extensions: [
	    		"slim",
	    		"slm"
	    	]
	    },
	    	"text/spdx": {
	    	source: "iana",
	    	extensions: [
	    		"spdx"
	    	]
	    },
	    	"text/strings": {
	    	source: "iana"
	    },
	    	"text/stylus": {
	    	extensions: [
	    		"stylus",
	    		"styl"
	    	]
	    },
	    	"text/t140": {
	    	source: "iana"
	    },
	    	"text/tab-separated-values": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"tsv"
	    	]
	    },
	    	"text/troff": {
	    	source: "iana",
	    	extensions: [
	    		"t",
	    		"tr",
	    		"roff",
	    		"man",
	    		"me",
	    		"ms"
	    	]
	    },
	    	"text/turtle": {
	    	source: "iana",
	    	charset: "UTF-8",
	    	extensions: [
	    		"ttl"
	    	]
	    },
	    	"text/ulpfec": {
	    	source: "iana"
	    },
	    	"text/uri-list": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"uri",
	    		"uris",
	    		"urls"
	    	]
	    },
	    	"text/vcard": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"vcard"
	    	]
	    },
	    	"text/vnd.a": {
	    	source: "iana"
	    },
	    	"text/vnd.abc": {
	    	source: "iana"
	    },
	    	"text/vnd.ascii-art": {
	    	source: "iana"
	    },
	    	"text/vnd.curl": {
	    	source: "iana",
	    	extensions: [
	    		"curl"
	    	]
	    },
	    	"text/vnd.curl.dcurl": {
	    	source: "apache",
	    	extensions: [
	    		"dcurl"
	    	]
	    },
	    	"text/vnd.curl.mcurl": {
	    	source: "apache",
	    	extensions: [
	    		"mcurl"
	    	]
	    },
	    	"text/vnd.curl.scurl": {
	    	source: "apache",
	    	extensions: [
	    		"scurl"
	    	]
	    },
	    	"text/vnd.debian.copyright": {
	    	source: "iana",
	    	charset: "UTF-8"
	    },
	    	"text/vnd.dmclientscript": {
	    	source: "iana"
	    },
	    	"text/vnd.dvb.subtitle": {
	    	source: "iana",
	    	extensions: [
	    		"sub"
	    	]
	    },
	    	"text/vnd.esmertec.theme-descriptor": {
	    	source: "iana",
	    	charset: "UTF-8"
	    },
	    	"text/vnd.familysearch.gedcom": {
	    	source: "iana",
	    	extensions: [
	    		"ged"
	    	]
	    },
	    	"text/vnd.ficlab.flt": {
	    	source: "iana"
	    },
	    	"text/vnd.fly": {
	    	source: "iana",
	    	extensions: [
	    		"fly"
	    	]
	    },
	    	"text/vnd.fmi.flexstor": {
	    	source: "iana",
	    	extensions: [
	    		"flx"
	    	]
	    },
	    	"text/vnd.gml": {
	    	source: "iana"
	    },
	    	"text/vnd.graphviz": {
	    	source: "iana",
	    	extensions: [
	    		"gv"
	    	]
	    },
	    	"text/vnd.hans": {
	    	source: "iana"
	    },
	    	"text/vnd.hgl": {
	    	source: "iana"
	    },
	    	"text/vnd.in3d.3dml": {
	    	source: "iana",
	    	extensions: [
	    		"3dml"
	    	]
	    },
	    	"text/vnd.in3d.spot": {
	    	source: "iana",
	    	extensions: [
	    		"spot"
	    	]
	    },
	    	"text/vnd.iptc.newsml": {
	    	source: "iana"
	    },
	    	"text/vnd.iptc.nitf": {
	    	source: "iana"
	    },
	    	"text/vnd.latex-z": {
	    	source: "iana"
	    },
	    	"text/vnd.motorola.reflex": {
	    	source: "iana"
	    },
	    	"text/vnd.ms-mediapackage": {
	    	source: "iana"
	    },
	    	"text/vnd.net2phone.commcenter.command": {
	    	source: "iana"
	    },
	    	"text/vnd.radisys.msml-basic-layout": {
	    	source: "iana"
	    },
	    	"text/vnd.senx.warpscript": {
	    	source: "iana"
	    },
	    	"text/vnd.si.uricatalogue": {
	    	source: "iana"
	    },
	    	"text/vnd.sosi": {
	    	source: "iana"
	    },
	    	"text/vnd.sun.j2me.app-descriptor": {
	    	source: "iana",
	    	charset: "UTF-8",
	    	extensions: [
	    		"jad"
	    	]
	    },
	    	"text/vnd.trolltech.linguist": {
	    	source: "iana",
	    	charset: "UTF-8"
	    },
	    	"text/vnd.wap.si": {
	    	source: "iana"
	    },
	    	"text/vnd.wap.sl": {
	    	source: "iana"
	    },
	    	"text/vnd.wap.wml": {
	    	source: "iana",
	    	extensions: [
	    		"wml"
	    	]
	    },
	    	"text/vnd.wap.wmlscript": {
	    	source: "iana",
	    	extensions: [
	    		"wmls"
	    	]
	    },
	    	"text/vtt": {
	    	source: "iana",
	    	charset: "UTF-8",
	    	compressible: true,
	    	extensions: [
	    		"vtt"
	    	]
	    },
	    	"text/x-asm": {
	    	source: "apache",
	    	extensions: [
	    		"s",
	    		"asm"
	    	]
	    },
	    	"text/x-c": {
	    	source: "apache",
	    	extensions: [
	    		"c",
	    		"cc",
	    		"cxx",
	    		"cpp",
	    		"h",
	    		"hh",
	    		"dic"
	    	]
	    },
	    	"text/x-component": {
	    	source: "nginx",
	    	extensions: [
	    		"htc"
	    	]
	    },
	    	"text/x-fortran": {
	    	source: "apache",
	    	extensions: [
	    		"f",
	    		"for",
	    		"f77",
	    		"f90"
	    	]
	    },
	    	"text/x-gwt-rpc": {
	    	compressible: true
	    },
	    	"text/x-handlebars-template": {
	    	extensions: [
	    		"hbs"
	    	]
	    },
	    	"text/x-java-source": {
	    	source: "apache",
	    	extensions: [
	    		"java"
	    	]
	    },
	    	"text/x-jquery-tmpl": {
	    	compressible: true
	    },
	    	"text/x-lua": {
	    	extensions: [
	    		"lua"
	    	]
	    },
	    	"text/x-markdown": {
	    	compressible: true,
	    	extensions: [
	    		"mkd"
	    	]
	    },
	    	"text/x-nfo": {
	    	source: "apache",
	    	extensions: [
	    		"nfo"
	    	]
	    },
	    	"text/x-opml": {
	    	source: "apache",
	    	extensions: [
	    		"opml"
	    	]
	    },
	    	"text/x-org": {
	    	compressible: true,
	    	extensions: [
	    		"org"
	    	]
	    },
	    	"text/x-pascal": {
	    	source: "apache",
	    	extensions: [
	    		"p",
	    		"pas"
	    	]
	    },
	    	"text/x-processing": {
	    	compressible: true,
	    	extensions: [
	    		"pde"
	    	]
	    },
	    	"text/x-sass": {
	    	extensions: [
	    		"sass"
	    	]
	    },
	    	"text/x-scss": {
	    	extensions: [
	    		"scss"
	    	]
	    },
	    	"text/x-setext": {
	    	source: "apache",
	    	extensions: [
	    		"etx"
	    	]
	    },
	    	"text/x-sfv": {
	    	source: "apache",
	    	extensions: [
	    		"sfv"
	    	]
	    },
	    	"text/x-suse-ymp": {
	    	compressible: true,
	    	extensions: [
	    		"ymp"
	    	]
	    },
	    	"text/x-uuencode": {
	    	source: "apache",
	    	extensions: [
	    		"uu"
	    	]
	    },
	    	"text/x-vcalendar": {
	    	source: "apache",
	    	extensions: [
	    		"vcs"
	    	]
	    },
	    	"text/x-vcard": {
	    	source: "apache",
	    	extensions: [
	    		"vcf"
	    	]
	    },
	    	"text/xml": {
	    	source: "iana",
	    	compressible: true,
	    	extensions: [
	    		"xml"
	    	]
	    },
	    	"text/xml-external-parsed-entity": {
	    	source: "iana"
	    },
	    	"text/yaml": {
	    	compressible: true,
	    	extensions: [
	    		"yaml",
	    		"yml"
	    	]
	    },
	    	"video/1d-interleaved-parityfec": {
	    	source: "iana"
	    },
	    	"video/3gpp": {
	    	source: "iana",
	    	extensions: [
	    		"3gp",
	    		"3gpp"
	    	]
	    },
	    	"video/3gpp-tt": {
	    	source: "iana"
	    },
	    	"video/3gpp2": {
	    	source: "iana",
	    	extensions: [
	    		"3g2"
	    	]
	    },
	    	"video/av1": {
	    	source: "iana"
	    },
	    	"video/bmpeg": {
	    	source: "iana"
	    },
	    	"video/bt656": {
	    	source: "iana"
	    },
	    	"video/celb": {
	    	source: "iana"
	    },
	    	"video/dv": {
	    	source: "iana"
	    },
	    	"video/encaprtp": {
	    	source: "iana"
	    },
	    	"video/ffv1": {
	    	source: "iana"
	    },
	    	"video/flexfec": {
	    	source: "iana"
	    },
	    	"video/h261": {
	    	source: "iana",
	    	extensions: [
	    		"h261"
	    	]
	    },
	    	"video/h263": {
	    	source: "iana",
	    	extensions: [
	    		"h263"
	    	]
	    },
	    	"video/h263-1998": {
	    	source: "iana"
	    },
	    	"video/h263-2000": {
	    	source: "iana"
	    },
	    	"video/h264": {
	    	source: "iana",
	    	extensions: [
	    		"h264"
	    	]
	    },
	    	"video/h264-rcdo": {
	    	source: "iana"
	    },
	    	"video/h264-svc": {
	    	source: "iana"
	    },
	    	"video/h265": {
	    	source: "iana"
	    },
	    	"video/iso.segment": {
	    	source: "iana",
	    	extensions: [
	    		"m4s"
	    	]
	    },
	    	"video/jpeg": {
	    	source: "iana",
	    	extensions: [
	    		"jpgv"
	    	]
	    },
	    	"video/jpeg2000": {
	    	source: "iana"
	    },
	    	"video/jpm": {
	    	source: "apache",
	    	extensions: [
	    		"jpm",
	    		"jpgm"
	    	]
	    },
	    	"video/jxsv": {
	    	source: "iana"
	    },
	    	"video/mj2": {
	    	source: "iana",
	    	extensions: [
	    		"mj2",
	    		"mjp2"
	    	]
	    },
	    	"video/mp1s": {
	    	source: "iana"
	    },
	    	"video/mp2p": {
	    	source: "iana"
	    },
	    	"video/mp2t": {
	    	source: "iana",
	    	extensions: [
	    		"ts"
	    	]
	    },
	    	"video/mp4": {
	    	source: "iana",
	    	compressible: false,
	    	extensions: [
	    		"mp4",
	    		"mp4v",
	    		"mpg4"
	    	]
	    },
	    	"video/mp4v-es": {
	    	source: "iana"
	    },
	    	"video/mpeg": {
	    	source: "iana",
	    	compressible: false,
	    	extensions: [
	    		"mpeg",
	    		"mpg",
	    		"mpe",
	    		"m1v",
	    		"m2v"
	    	]
	    },
	    	"video/mpeg4-generic": {
	    	source: "iana"
	    },
	    	"video/mpv": {
	    	source: "iana"
	    },
	    	"video/nv": {
	    	source: "iana"
	    },
	    	"video/ogg": {
	    	source: "iana",
	    	compressible: false,
	    	extensions: [
	    		"ogv"
	    	]
	    },
	    	"video/parityfec": {
	    	source: "iana"
	    },
	    	"video/pointer": {
	    	source: "iana"
	    },
	    	"video/quicktime": {
	    	source: "iana",
	    	compressible: false,
	    	extensions: [
	    		"qt",
	    		"mov"
	    	]
	    },
	    	"video/raptorfec": {
	    	source: "iana"
	    },
	    	"video/raw": {
	    	source: "iana"
	    },
	    	"video/rtp-enc-aescm128": {
	    	source: "iana"
	    },
	    	"video/rtploopback": {
	    	source: "iana"
	    },
	    	"video/rtx": {
	    	source: "iana"
	    },
	    	"video/scip": {
	    	source: "iana"
	    },
	    	"video/smpte291": {
	    	source: "iana"
	    },
	    	"video/smpte292m": {
	    	source: "iana"
	    },
	    	"video/ulpfec": {
	    	source: "iana"
	    },
	    	"video/vc1": {
	    	source: "iana"
	    },
	    	"video/vc2": {
	    	source: "iana"
	    },
	    	"video/vnd.cctv": {
	    	source: "iana"
	    },
	    	"video/vnd.dece.hd": {
	    	source: "iana",
	    	extensions: [
	    		"uvh",
	    		"uvvh"
	    	]
	    },
	    	"video/vnd.dece.mobile": {
	    	source: "iana",
	    	extensions: [
	    		"uvm",
	    		"uvvm"
	    	]
	    },
	    	"video/vnd.dece.mp4": {
	    	source: "iana"
	    },
	    	"video/vnd.dece.pd": {
	    	source: "iana",
	    	extensions: [
	    		"uvp",
	    		"uvvp"
	    	]
	    },
	    	"video/vnd.dece.sd": {
	    	source: "iana",
	    	extensions: [
	    		"uvs",
	    		"uvvs"
	    	]
	    },
	    	"video/vnd.dece.video": {
	    	source: "iana",
	    	extensions: [
	    		"uvv",
	    		"uvvv"
	    	]
	    },
	    	"video/vnd.directv.mpeg": {
	    	source: "iana"
	    },
	    	"video/vnd.directv.mpeg-tts": {
	    	source: "iana"
	    },
	    	"video/vnd.dlna.mpeg-tts": {
	    	source: "iana"
	    },
	    	"video/vnd.dvb.file": {
	    	source: "iana",
	    	extensions: [
	    		"dvb"
	    	]
	    },
	    	"video/vnd.fvt": {
	    	source: "iana",
	    	extensions: [
	    		"fvt"
	    	]
	    },
	    	"video/vnd.hns.video": {
	    	source: "iana"
	    },
	    	"video/vnd.iptvforum.1dparityfec-1010": {
	    	source: "iana"
	    },
	    	"video/vnd.iptvforum.1dparityfec-2005": {
	    	source: "iana"
	    },
	    	"video/vnd.iptvforum.2dparityfec-1010": {
	    	source: "iana"
	    },
	    	"video/vnd.iptvforum.2dparityfec-2005": {
	    	source: "iana"
	    },
	    	"video/vnd.iptvforum.ttsavc": {
	    	source: "iana"
	    },
	    	"video/vnd.iptvforum.ttsmpeg2": {
	    	source: "iana"
	    },
	    	"video/vnd.motorola.video": {
	    	source: "iana"
	    },
	    	"video/vnd.motorola.videop": {
	    	source: "iana"
	    },
	    	"video/vnd.mpegurl": {
	    	source: "iana",
	    	extensions: [
	    		"mxu",
	    		"m4u"
	    	]
	    },
	    	"video/vnd.ms-playready.media.pyv": {
	    	source: "iana",
	    	extensions: [
	    		"pyv"
	    	]
	    },
	    	"video/vnd.nokia.interleaved-multimedia": {
	    	source: "iana"
	    },
	    	"video/vnd.nokia.mp4vr": {
	    	source: "iana"
	    },
	    	"video/vnd.nokia.videovoip": {
	    	source: "iana"
	    },
	    	"video/vnd.objectvideo": {
	    	source: "iana"
	    },
	    	"video/vnd.radgamettools.bink": {
	    	source: "iana"
	    },
	    	"video/vnd.radgamettools.smacker": {
	    	source: "iana"
	    },
	    	"video/vnd.sealed.mpeg1": {
	    	source: "iana"
	    },
	    	"video/vnd.sealed.mpeg4": {
	    	source: "iana"
	    },
	    	"video/vnd.sealed.swf": {
	    	source: "iana"
	    },
	    	"video/vnd.sealedmedia.softseal.mov": {
	    	source: "iana"
	    },
	    	"video/vnd.uvvu.mp4": {
	    	source: "iana",
	    	extensions: [
	    		"uvu",
	    		"uvvu"
	    	]
	    },
	    	"video/vnd.vivo": {
	    	source: "iana",
	    	extensions: [
	    		"viv"
	    	]
	    },
	    	"video/vnd.youtube.yt": {
	    	source: "iana"
	    },
	    	"video/vp8": {
	    	source: "iana"
	    },
	    	"video/vp9": {
	    	source: "iana"
	    },
	    	"video/webm": {
	    	source: "apache",
	    	compressible: false,
	    	extensions: [
	    		"webm"
	    	]
	    },
	    	"video/x-f4v": {
	    	source: "apache",
	    	extensions: [
	    		"f4v"
	    	]
	    },
	    	"video/x-fli": {
	    	source: "apache",
	    	extensions: [
	    		"fli"
	    	]
	    },
	    	"video/x-flv": {
	    	source: "apache",
	    	compressible: false,
	    	extensions: [
	    		"flv"
	    	]
	    },
	    	"video/x-m4v": {
	    	source: "apache",
	    	extensions: [
	    		"m4v"
	    	]
	    },
	    	"video/x-matroska": {
	    	source: "apache",
	    	compressible: false,
	    	extensions: [
	    		"mkv",
	    		"mk3d",
	    		"mks"
	    	]
	    },
	    	"video/x-mng": {
	    	source: "apache",
	    	extensions: [
	    		"mng"
	    	]
	    },
	    	"video/x-ms-asf": {
	    	source: "apache",
	    	extensions: [
	    		"asf",
	    		"asx"
	    	]
	    },
	    	"video/x-ms-vob": {
	    	source: "apache",
	    	extensions: [
	    		"vob"
	    	]
	    },
	    	"video/x-ms-wm": {
	    	source: "apache",
	    	extensions: [
	    		"wm"
	    	]
	    },
	    	"video/x-ms-wmv": {
	    	source: "apache",
	    	compressible: false,
	    	extensions: [
	    		"wmv"
	    	]
	    },
	    	"video/x-ms-wmx": {
	    	source: "apache",
	    	extensions: [
	    		"wmx"
	    	]
	    },
	    	"video/x-ms-wvx": {
	    	source: "apache",
	    	extensions: [
	    		"wvx"
	    	]
	    },
	    	"video/x-msvideo": {
	    	source: "apache",
	    	extensions: [
	    		"avi"
	    	]
	    },
	    	"video/x-sgi-movie": {
	    	source: "apache",
	    	extensions: [
	    		"movie"
	    	]
	    },
	    	"video/x-smv": {
	    	source: "apache",
	    	extensions: [
	    		"smv"
	    	]
	    },
	    	"x-conference/x-cooltalk": {
	    	source: "apache",
	    	extensions: [
	    		"ice"
	    	]
	    },
	    	"x-shader/x-fragment": {
	    	compressible: true
	    },
	    	"x-shader/x-vertex": {
	    	compressible: true
	    }
	    };

	    /*!
	     * mime-db
	     * Copyright(c) 2014 Jonathan Ong
	     * Copyright(c) 2015-2022 Douglas Christopher Wilson
	     * MIT Licensed
	     */

	    var mimeDb;
	    var hasRequiredMimeDb;

	    function requireMimeDb () {
	    	if (hasRequiredMimeDb) return mimeDb;
	    	hasRequiredMimeDb = 1;
	    	/**
	    	 * Module exports.
	    	 */

	    	mimeDb = require$$0;
	    	return mimeDb;
	    }

	    /*!
	     * mime-types
	     * Copyright(c) 2014 Jonathan Ong
	     * Copyright(c) 2015 Douglas Christopher Wilson
	     * MIT Licensed
	     */

	    var hasRequiredMimeTypes;

	    function requireMimeTypes () {
	    	if (hasRequiredMimeTypes) return mimeTypes;
	    	hasRequiredMimeTypes = 1;
	    	(function (exports) {

	    		/**
	    		 * Module dependencies.
	    		 * @private
	    		 */

	    		var db = requireMimeDb();
	    		var extname = require$$1__default$2["default"].extname;

	    		/**
	    		 * Module variables.
	    		 * @private
	    		 */

	    		var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
	    		var TEXT_TYPE_REGEXP = /^text\//i;

	    		/**
	    		 * Module exports.
	    		 * @public
	    		 */

	    		exports.charset = charset;
	    		exports.charsets = { lookup: charset };
	    		exports.contentType = contentType;
	    		exports.extension = extension;
	    		exports.extensions = Object.create(null);
	    		exports.lookup = lookup;
	    		exports.types = Object.create(null);

	    		// Populate the extensions/types maps
	    		populateMaps(exports.extensions, exports.types);

	    		/**
	    		 * Get the default charset for a MIME type.
	    		 *
	    		 * @param {string} type
	    		 * @return {boolean|string}
	    		 */

	    		function charset (type) {
	    		  if (!type || typeof type !== 'string') {
	    		    return false
	    		  }

	    		  // TODO: use media-typer
	    		  var match = EXTRACT_TYPE_REGEXP.exec(type);
	    		  var mime = match && db[match[1].toLowerCase()];

	    		  if (mime && mime.charset) {
	    		    return mime.charset
	    		  }

	    		  // default text/* to utf-8
	    		  if (match && TEXT_TYPE_REGEXP.test(match[1])) {
	    		    return 'UTF-8'
	    		  }

	    		  return false
	    		}

	    		/**
	    		 * Create a full Content-Type header given a MIME type or extension.
	    		 *
	    		 * @param {string} str
	    		 * @return {boolean|string}
	    		 */

	    		function contentType (str) {
	    		  // TODO: should this even be in this module?
	    		  if (!str || typeof str !== 'string') {
	    		    return false
	    		  }

	    		  var mime = str.indexOf('/') === -1
	    		    ? exports.lookup(str)
	    		    : str;

	    		  if (!mime) {
	    		    return false
	    		  }

	    		  // TODO: use content-type or other module
	    		  if (mime.indexOf('charset') === -1) {
	    		    var charset = exports.charset(mime);
	    		    if (charset) mime += '; charset=' + charset.toLowerCase();
	    		  }

	    		  return mime
	    		}

	    		/**
	    		 * Get the default extension for a MIME type.
	    		 *
	    		 * @param {string} type
	    		 * @return {boolean|string}
	    		 */

	    		function extension (type) {
	    		  if (!type || typeof type !== 'string') {
	    		    return false
	    		  }

	    		  // TODO: use media-typer
	    		  var match = EXTRACT_TYPE_REGEXP.exec(type);

	    		  // get extensions
	    		  var exts = match && exports.extensions[match[1].toLowerCase()];

	    		  if (!exts || !exts.length) {
	    		    return false
	    		  }

	    		  return exts[0]
	    		}

	    		/**
	    		 * Lookup the MIME type for a file path/extension.
	    		 *
	    		 * @param {string} path
	    		 * @return {boolean|string}
	    		 */

	    		function lookup (path) {
	    		  if (!path || typeof path !== 'string') {
	    		    return false
	    		  }

	    		  // get the extension ("ext" or ".ext" or full path)
	    		  var extension = extname('x.' + path)
	    		    .toLowerCase()
	    		    .substr(1);

	    		  if (!extension) {
	    		    return false
	    		  }

	    		  return exports.types[extension] || false
	    		}

	    		/**
	    		 * Populate the extensions and types maps.
	    		 * @private
	    		 */

	    		function populateMaps (extensions, types) {
	    		  // source preference (least -> most)
	    		  var preference = ['nginx', 'apache', undefined, 'iana'];

	    		  Object.keys(db).forEach(function forEachMimeType (type) {
	    		    var mime = db[type];
	    		    var exts = mime.extensions;

	    		    if (!exts || !exts.length) {
	    		      return
	    		    }

	    		    // mime -> extensions
	    		    extensions[type] = exts;

	    		    // extension -> mime
	    		    for (var i = 0; i < exts.length; i++) {
	    		      var extension = exts[i];

	    		      if (types[extension]) {
	    		        var from = preference.indexOf(db[types[extension]].source);
	    		        var to = preference.indexOf(mime.source);

	    		        if (types[extension] !== 'application/octet-stream' &&
	    		          (from > to || (from === to && types[extension].substr(0, 12) === 'application/'))) {
	    		          // skip the remapping
	    		          continue
	    		        }
	    		      }

	    		      // set the extension -> mime
	    		      types[extension] = type;
	    		    }
	    		  });
	    		} 
	    	} (mimeTypes));
	    	return mimeTypes;
	    }

	    var defer_1;
	    var hasRequiredDefer;

	    function requireDefer () {
	    	if (hasRequiredDefer) return defer_1;
	    	hasRequiredDefer = 1;
	    	defer_1 = defer;

	    	/**
	    	 * Runs provided function on next iteration of the event loop
	    	 *
	    	 * @param {function} fn - function to run
	    	 */
	    	function defer(fn)
	    	{
	    	  var nextTick$1 = typeof setImmediate == 'function'
	    	    ? setImmediate
	    	    : (
	    	      typeof process == 'object' && typeof nextTick == 'function'
	    	      ? nextTick
	    	      : null
	    	    );

	    	  if (nextTick$1)
	    	  {
	    	    nextTick$1(fn);
	    	  }
	    	  else
	    	  {
	    	    setTimeout(fn, 0);
	    	  }
	    	}
	    	return defer_1;
	    }

	    var async_1;
	    var hasRequiredAsync;

	    function requireAsync () {
	    	if (hasRequiredAsync) return async_1;
	    	hasRequiredAsync = 1;
	    	var defer = requireDefer();

	    	// API
	    	async_1 = async;

	    	/**
	    	 * Runs provided callback asynchronously
	    	 * even if callback itself is not
	    	 *
	    	 * @param   {function} callback - callback to invoke
	    	 * @returns {function} - augmented callback
	    	 */
	    	function async(callback)
	    	{
	    	  var isAsync = false;

	    	  // check if async happened
	    	  defer(function() { isAsync = true; });

	    	  return function async_callback(err, result)
	    	  {
	    	    if (isAsync)
	    	    {
	    	      callback(err, result);
	    	    }
	    	    else
	    	    {
	    	      defer(function nextTick_callback()
	    	      {
	    	        callback(err, result);
	    	      });
	    	    }
	    	  };
	    	}
	    	return async_1;
	    }

	    var abort_1;
	    var hasRequiredAbort;

	    function requireAbort () {
	    	if (hasRequiredAbort) return abort_1;
	    	hasRequiredAbort = 1;
	    	// API
	    	abort_1 = abort;

	    	/**
	    	 * Aborts leftover active jobs
	    	 *
	    	 * @param {object} state - current state object
	    	 */
	    	function abort(state)
	    	{
	    	  Object.keys(state.jobs).forEach(clean.bind(state));

	    	  // reset leftover jobs
	    	  state.jobs = {};
	    	}

	    	/**
	    	 * Cleans up leftover job by invoking abort function for the provided job id
	    	 *
	    	 * @this  state
	    	 * @param {string|number} key - job id to abort
	    	 */
	    	function clean(key)
	    	{
	    	  if (typeof this.jobs[key] == 'function')
	    	  {
	    	    this.jobs[key]();
	    	  }
	    	}
	    	return abort_1;
	    }

	    var iterate_1;
	    var hasRequiredIterate;

	    function requireIterate () {
	    	if (hasRequiredIterate) return iterate_1;
	    	hasRequiredIterate = 1;
	    	var async = requireAsync()
	    	  , abort = requireAbort()
	    	  ;

	    	// API
	    	iterate_1 = iterate;

	    	/**
	    	 * Iterates over each job object
	    	 *
	    	 * @param {array|object} list - array or object (named list) to iterate over
	    	 * @param {function} iterator - iterator to run
	    	 * @param {object} state - current job status
	    	 * @param {function} callback - invoked when all elements processed
	    	 */
	    	function iterate(list, iterator, state, callback)
	    	{
	    	  // store current index
	    	  var key = state['keyedList'] ? state['keyedList'][state.index] : state.index;

	    	  state.jobs[key] = runJob(iterator, key, list[key], function(error, output)
	    	  {
	    	    // don't repeat yourself
	    	    // skip secondary callbacks
	    	    if (!(key in state.jobs))
	    	    {
	    	      return;
	    	    }

	    	    // clean up jobs
	    	    delete state.jobs[key];

	    	    if (error)
	    	    {
	    	      // don't process rest of the results
	    	      // stop still active jobs
	    	      // and reset the list
	    	      abort(state);
	    	    }
	    	    else
	    	    {
	    	      state.results[key] = output;
	    	    }

	    	    // return salvaged results
	    	    callback(error, state.results);
	    	  });
	    	}

	    	/**
	    	 * Runs iterator over provided job element
	    	 *
	    	 * @param   {function} iterator - iterator to invoke
	    	 * @param   {string|number} key - key/index of the element in the list of jobs
	    	 * @param   {mixed} item - job description
	    	 * @param   {function} callback - invoked after iterator is done with the job
	    	 * @returns {function|mixed} - job abort function or something else
	    	 */
	    	function runJob(iterator, key, item, callback)
	    	{
	    	  var aborter;

	    	  // allow shortcut if iterator expects only two arguments
	    	  if (iterator.length == 2)
	    	  {
	    	    aborter = iterator(item, async(callback));
	    	  }
	    	  // otherwise go with full three arguments
	    	  else
	    	  {
	    	    aborter = iterator(item, key, async(callback));
	    	  }

	    	  return aborter;
	    	}
	    	return iterate_1;
	    }

	    var state_1;
	    var hasRequiredState;

	    function requireState () {
	    	if (hasRequiredState) return state_1;
	    	hasRequiredState = 1;
	    	// API
	    	state_1 = state;

	    	/**
	    	 * Creates initial state object
	    	 * for iteration over list
	    	 *
	    	 * @param   {array|object} list - list to iterate over
	    	 * @param   {function|null} sortMethod - function to use for keys sort,
	    	 *                                     or `null` to keep them as is
	    	 * @returns {object} - initial state object
	    	 */
	    	function state(list, sortMethod)
	    	{
	    	  var isNamedList = !Array.isArray(list)
	    	    , initState =
	    	    {
	    	      index    : 0,
	    	      keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
	    	      jobs     : {},
	    	      results  : isNamedList ? {} : [],
	    	      size     : isNamedList ? Object.keys(list).length : list.length
	    	    }
	    	    ;

	    	  if (sortMethod)
	    	  {
	    	    // sort array keys based on it's values
	    	    // sort object's keys just on own merit
	    	    initState.keyedList.sort(isNamedList ? sortMethod : function(a, b)
	    	    {
	    	      return sortMethod(list[a], list[b]);
	    	    });
	    	  }

	    	  return initState;
	    	}
	    	return state_1;
	    }

	    var terminator_1;
	    var hasRequiredTerminator;

	    function requireTerminator () {
	    	if (hasRequiredTerminator) return terminator_1;
	    	hasRequiredTerminator = 1;
	    	var abort = requireAbort()
	    	  , async = requireAsync()
	    	  ;

	    	// API
	    	terminator_1 = terminator;

	    	/**
	    	 * Terminates jobs in the attached state context
	    	 *
	    	 * @this  AsyncKitState#
	    	 * @param {function} callback - final callback to invoke after termination
	    	 */
	    	function terminator(callback)
	    	{
	    	  if (!Object.keys(this.jobs).length)
	    	  {
	    	    return;
	    	  }

	    	  // fast forward iteration index
	    	  this.index = this.size;

	    	  // abort jobs
	    	  abort(this);

	    	  // send back results we have so far
	    	  async(callback)(null, this.results);
	    	}
	    	return terminator_1;
	    }

	    var parallel_1;
	    var hasRequiredParallel;

	    function requireParallel () {
	    	if (hasRequiredParallel) return parallel_1;
	    	hasRequiredParallel = 1;
	    	var iterate    = requireIterate()
	    	  , initState  = requireState()
	    	  , terminator = requireTerminator()
	    	  ;

	    	// Public API
	    	parallel_1 = parallel;

	    	/**
	    	 * Runs iterator over provided array elements in parallel
	    	 *
	    	 * @param   {array|object} list - array or object (named list) to iterate over
	    	 * @param   {function} iterator - iterator to run
	    	 * @param   {function} callback - invoked when all elements processed
	    	 * @returns {function} - jobs terminator
	    	 */
	    	function parallel(list, iterator, callback)
	    	{
	    	  var state = initState(list);

	    	  while (state.index < (state['keyedList'] || list).length)
	    	  {
	    	    iterate(list, iterator, state, function(error, result)
	    	    {
	    	      if (error)
	    	      {
	    	        callback(error, result);
	    	        return;
	    	      }

	    	      // looks like it's the last one
	    	      if (Object.keys(state.jobs).length === 0)
	    	      {
	    	        callback(null, state.results);
	    	        return;
	    	      }
	    	    });

	    	    state.index++;
	    	  }

	    	  return terminator.bind(state, callback);
	    	}
	    	return parallel_1;
	    }

	    var serialOrdered = {exports: {}};

	    var hasRequiredSerialOrdered;

	    function requireSerialOrdered () {
	    	if (hasRequiredSerialOrdered) return serialOrdered.exports;
	    	hasRequiredSerialOrdered = 1;
	    	var iterate    = requireIterate()
	    	  , initState  = requireState()
	    	  , terminator = requireTerminator()
	    	  ;

	    	// Public API
	    	serialOrdered.exports = serialOrdered$1;
	    	// sorting helpers
	    	serialOrdered.exports.ascending  = ascending;
	    	serialOrdered.exports.descending = descending;

	    	/**
	    	 * Runs iterator over provided sorted array elements in series
	    	 *
	    	 * @param   {array|object} list - array or object (named list) to iterate over
	    	 * @param   {function} iterator - iterator to run
	    	 * @param   {function} sortMethod - custom sort function
	    	 * @param   {function} callback - invoked when all elements processed
	    	 * @returns {function} - jobs terminator
	    	 */
	    	function serialOrdered$1(list, iterator, sortMethod, callback)
	    	{
	    	  var state = initState(list, sortMethod);

	    	  iterate(list, iterator, state, function iteratorHandler(error, result)
	    	  {
	    	    if (error)
	    	    {
	    	      callback(error, result);
	    	      return;
	    	    }

	    	    state.index++;

	    	    // are we there yet?
	    	    if (state.index < (state['keyedList'] || list).length)
	    	    {
	    	      iterate(list, iterator, state, iteratorHandler);
	    	      return;
	    	    }

	    	    // done here
	    	    callback(null, state.results);
	    	  });

	    	  return terminator.bind(state, callback);
	    	}

	    	/*
	    	 * -- Sort methods
	    	 */

	    	/**
	    	 * sort helper to sort array elements in ascending order
	    	 *
	    	 * @param   {mixed} a - an item to compare
	    	 * @param   {mixed} b - an item to compare
	    	 * @returns {number} - comparison result
	    	 */
	    	function ascending(a, b)
	    	{
	    	  return a < b ? -1 : a > b ? 1 : 0;
	    	}

	    	/**
	    	 * sort helper to sort array elements in descending order
	    	 *
	    	 * @param   {mixed} a - an item to compare
	    	 * @param   {mixed} b - an item to compare
	    	 * @returns {number} - comparison result
	    	 */
	    	function descending(a, b)
	    	{
	    	  return -1 * ascending(a, b);
	    	}
	    	return serialOrdered.exports;
	    }

	    var serial_1;
	    var hasRequiredSerial;

	    function requireSerial () {
	    	if (hasRequiredSerial) return serial_1;
	    	hasRequiredSerial = 1;
	    	var serialOrdered = requireSerialOrdered();

	    	// Public API
	    	serial_1 = serial;

	    	/**
	    	 * Runs iterator over provided array elements in series
	    	 *
	    	 * @param   {array|object} list - array or object (named list) to iterate over
	    	 * @param   {function} iterator - iterator to run
	    	 * @param   {function} callback - invoked when all elements processed
	    	 * @returns {function} - jobs terminator
	    	 */
	    	function serial(list, iterator, callback)
	    	{
	    	  return serialOrdered(list, iterator, null, callback);
	    	}
	    	return serial_1;
	    }

	    var asynckit;
	    var hasRequiredAsynckit;

	    function requireAsynckit () {
	    	if (hasRequiredAsynckit) return asynckit;
	    	hasRequiredAsynckit = 1;
	    	asynckit =
	    	{
	    	  parallel      : requireParallel(),
	    	  serial        : requireSerial(),
	    	  serialOrdered : requireSerialOrdered()
	    	};
	    	return asynckit;
	    }

	    var populate;
	    var hasRequiredPopulate;

	    function requirePopulate () {
	    	if (hasRequiredPopulate) return populate;
	    	hasRequiredPopulate = 1;
	    	// populates missing values
	    	populate = function(dst, src) {

	    	  Object.keys(src).forEach(function(prop)
	    	  {
	    	    dst[prop] = dst[prop] || src[prop];
	    	  });

	    	  return dst;
	    	};
	    	return populate;
	    }

	    var form_data;
	    var hasRequiredForm_data;

	    function requireForm_data () {
	    	if (hasRequiredForm_data) return form_data;
	    	hasRequiredForm_data = 1;
	    	var CombinedStream = requireCombined_stream();
	    	var util = require$$1__default["default"];
	    	var path = require$$1__default$2["default"];
	    	var http = require$$1__default$1["default"];
	    	var https = require$$2__default["default"];
	    	var parseUrl = require$$0__default$2["default"].parse;
	    	var fs = require$$6__default["default"];
	    	var Stream = require$$3__default["default"].Stream;
	    	var mime = requireMimeTypes();
	    	var asynckit = requireAsynckit();
	    	var populate = requirePopulate();

	    	// Public API
	    	form_data = FormData;

	    	// make it a Stream
	    	util.inherits(FormData, CombinedStream);

	    	/**
	    	 * Create readable "multipart/form-data" streams.
	    	 * Can be used to submit forms
	    	 * and file uploads to other web applications.
	    	 *
	    	 * @constructor
	    	 * @param {Object} options - Properties to be added/overriden for FormData and CombinedStream
	    	 */
	    	function FormData(options) {
	    	  if (!(this instanceof FormData)) {
	    	    return new FormData(options);
	    	  }

	    	  this._overheadLength = 0;
	    	  this._valueLength = 0;
	    	  this._valuesToMeasure = [];

	    	  CombinedStream.call(this);

	    	  options = options || {};
	    	  for (var option in options) {
	    	    this[option] = options[option];
	    	  }
	    	}

	    	FormData.LINE_BREAK = '\r\n';
	    	FormData.DEFAULT_CONTENT_TYPE = 'application/octet-stream';

	    	FormData.prototype.append = function(field, value, options) {

	    	  options = options || {};

	    	  // allow filename as single option
	    	  if (typeof options == 'string') {
	    	    options = {filename: options};
	    	  }

	    	  var append = CombinedStream.prototype.append.bind(this);

	    	  // all that streamy business can't handle numbers
	    	  if (typeof value == 'number') {
	    	    value = '' + value;
	    	  }

	    	  // https://github.com/felixge/node-form-data/issues/38
	    	  if (util.isArray(value)) {
	    	    // Please convert your array into string
	    	    // the way web server expects it
	    	    this._error(new Error('Arrays are not supported.'));
	    	    return;
	    	  }

	    	  var header = this._multiPartHeader(field, value, options);
	    	  var footer = this._multiPartFooter();

	    	  append(header);
	    	  append(value);
	    	  append(footer);

	    	  // pass along options.knownLength
	    	  this._trackLength(header, value, options);
	    	};

	    	FormData.prototype._trackLength = function(header, value, options) {
	    	  var valueLength = 0;

	    	  // used w/ getLengthSync(), when length is known.
	    	  // e.g. for streaming directly from a remote server,
	    	  // w/ a known file a size, and not wanting to wait for
	    	  // incoming file to finish to get its size.
	    	  if (options.knownLength != null) {
	    	    valueLength += +options.knownLength;
	    	  } else if (isBuffer(value)) {
	    	    valueLength = value.length;
	    	  } else if (typeof value === 'string') {
	    	    valueLength = Buffer.byteLength(value);
	    	  }

	    	  this._valueLength += valueLength;

	    	  // @check why add CRLF? does this account for custom/multiple CRLFs?
	    	  this._overheadLength +=
	    	    Buffer.byteLength(header) +
	    	    FormData.LINE_BREAK.length;

	    	  // empty or either doesn't have path or not an http response or not a stream
	    	  if (!value || ( !value.path && !(value.readable && value.hasOwnProperty('httpVersion')) && !(value instanceof Stream))) {
	    	    return;
	    	  }

	    	  // no need to bother with the length
	    	  if (!options.knownLength) {
	    	    this._valuesToMeasure.push(value);
	    	  }
	    	};

	    	FormData.prototype._lengthRetriever = function(value, callback) {

	    	  if (value.hasOwnProperty('fd')) {

	    	    // take read range into a account
	    	    // `end` = Infinity > read file till the end
	    	    //
	    	    // TODO: Looks like there is bug in Node fs.createReadStream
	    	    // it doesn't respect `end` options without `start` options
	    	    // Fix it when node fixes it.
	    	    // https://github.com/joyent/node/issues/7819
	    	    if (value.end != undefined && value.end != Infinity && value.start != undefined) {

	    	      // when end specified
	    	      // no need to calculate range
	    	      // inclusive, starts with 0
	    	      callback(null, value.end + 1 - (value.start ? value.start : 0));

	    	    // not that fast snoopy
	    	    } else {
	    	      // still need to fetch file size from fs
	    	      fs.stat(value.path, function(err, stat) {

	    	        var fileSize;

	    	        if (err) {
	    	          callback(err);
	    	          return;
	    	        }

	    	        // update final size based on the range options
	    	        fileSize = stat.size - (value.start ? value.start : 0);
	    	        callback(null, fileSize);
	    	      });
	    	    }

	    	  // or http response
	    	  } else if (value.hasOwnProperty('httpVersion')) {
	    	    callback(null, +value.headers['content-length']);

	    	  // or request stream http://github.com/mikeal/request
	    	  } else if (value.hasOwnProperty('httpModule')) {
	    	    // wait till response come back
	    	    value.on('response', function(response) {
	    	      value.pause();
	    	      callback(null, +response.headers['content-length']);
	    	    });
	    	    value.resume();

	    	  // something else
	    	  } else {
	    	    callback('Unknown stream');
	    	  }
	    	};

	    	FormData.prototype._multiPartHeader = function(field, value, options) {
	    	  // custom header specified (as string)?
	    	  // it becomes responsible for boundary
	    	  // (e.g. to handle extra CRLFs on .NET servers)
	    	  if (typeof options.header == 'string') {
	    	    return options.header;
	    	  }

	    	  var contentDisposition = this._getContentDisposition(value, options);
	    	  var contentType = this._getContentType(value, options);

	    	  var contents = '';
	    	  var headers  = {
	    	    // add custom disposition as third element or keep it two elements if not
	    	    'Content-Disposition': ['form-data', 'name="' + field + '"'].concat(contentDisposition || []),
	    	    // if no content type. allow it to be empty array
	    	    'Content-Type': [].concat(contentType || [])
	    	  };

	    	  // allow custom headers.
	    	  if (typeof options.header == 'object') {
	    	    populate(headers, options.header);
	    	  }

	    	  var header;
	    	  for (var prop in headers) {
	    	    if (!headers.hasOwnProperty(prop)) continue;
	    	    header = headers[prop];

	    	    // skip nullish headers.
	    	    if (header == null) {
	    	      continue;
	    	    }

	    	    // convert all headers to arrays.
	    	    if (!Array.isArray(header)) {
	    	      header = [header];
	    	    }

	    	    // add non-empty headers.
	    	    if (header.length) {
	    	      contents += prop + ': ' + header.join('; ') + FormData.LINE_BREAK;
	    	    }
	    	  }

	    	  return '--' + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK;
	    	};

	    	FormData.prototype._getContentDisposition = function(value, options) {

	    	  var filename
	    	    , contentDisposition
	    	    ;

	    	  if (typeof options.filepath === 'string') {
	    	    // custom filepath for relative paths
	    	    filename = path.normalize(options.filepath).replace(/\\/g, '/');
	    	  } else if (options.filename || value.name || value.path) {
	    	    // custom filename take precedence
	    	    // formidable and the browser add a name property
	    	    // fs- and request- streams have path property
	    	    filename = path.basename(options.filename || value.name || value.path);
	    	  } else if (value.readable && value.hasOwnProperty('httpVersion')) {
	    	    // or try http response
	    	    filename = path.basename(value.client._httpMessage.path || '');
	    	  }

	    	  if (filename) {
	    	    contentDisposition = 'filename="' + filename + '"';
	    	  }

	    	  return contentDisposition;
	    	};

	    	FormData.prototype._getContentType = function(value, options) {

	    	  // use custom content-type above all
	    	  var contentType = options.contentType;

	    	  // or try `name` from formidable, browser
	    	  if (!contentType && value.name) {
	    	    contentType = mime.lookup(value.name);
	    	  }

	    	  // or try `path` from fs-, request- streams
	    	  if (!contentType && value.path) {
	    	    contentType = mime.lookup(value.path);
	    	  }

	    	  // or if it's http-reponse
	    	  if (!contentType && value.readable && value.hasOwnProperty('httpVersion')) {
	    	    contentType = value.headers['content-type'];
	    	  }

	    	  // or guess it from the filepath or filename
	    	  if (!contentType && (options.filepath || options.filename)) {
	    	    contentType = mime.lookup(options.filepath || options.filename);
	    	  }

	    	  // fallback to the default content type if `value` is not simple value
	    	  if (!contentType && typeof value == 'object') {
	    	    contentType = FormData.DEFAULT_CONTENT_TYPE;
	    	  }

	    	  return contentType;
	    	};

	    	FormData.prototype._multiPartFooter = function() {
	    	  return function(next) {
	    	    var footer = FormData.LINE_BREAK;

	    	    var lastPart = (this._streams.length === 0);
	    	    if (lastPart) {
	    	      footer += this._lastBoundary();
	    	    }

	    	    next(footer);
	    	  }.bind(this);
	    	};

	    	FormData.prototype._lastBoundary = function() {
	    	  return '--' + this.getBoundary() + '--' + FormData.LINE_BREAK;
	    	};

	    	FormData.prototype.getHeaders = function(userHeaders) {
	    	  var header;
	    	  var formHeaders = {
	    	    'content-type': 'multipart/form-data; boundary=' + this.getBoundary()
	    	  };

	    	  for (header in userHeaders) {
	    	    if (userHeaders.hasOwnProperty(header)) {
	    	      formHeaders[header.toLowerCase()] = userHeaders[header];
	    	    }
	    	  }

	    	  return formHeaders;
	    	};

	    	FormData.prototype.setBoundary = function(boundary) {
	    	  this._boundary = boundary;
	    	};

	    	FormData.prototype.getBoundary = function() {
	    	  if (!this._boundary) {
	    	    this._generateBoundary();
	    	  }

	    	  return this._boundary;
	    	};

	    	FormData.prototype.getBuffer = function() {
	    	  var dataBuffer = new Buffer.alloc( 0 );
	    	  var boundary = this.getBoundary();

	    	  // Create the form content. Add Line breaks to the end of data.
	    	  for (var i = 0, len = this._streams.length; i < len; i++) {
	    	    if (typeof this._streams[i] !== 'function') {

	    	      // Add content to the buffer.
	    	      if(isBuffer(this._streams[i])) {
	    	        dataBuffer = Buffer.concat( [dataBuffer, this._streams[i]]);
	    	      }else {
	    	        dataBuffer = Buffer.concat( [dataBuffer, Buffer.from(this._streams[i])]);
	    	      }

	    	      // Add break after content.
	    	      if (typeof this._streams[i] !== 'string' || this._streams[i].substring( 2, boundary.length + 2 ) !== boundary) {
	    	        dataBuffer = Buffer.concat( [dataBuffer, Buffer.from(FormData.LINE_BREAK)] );
	    	      }
	    	    }
	    	  }

	    	  // Add the footer and return the Buffer object.
	    	  return Buffer.concat( [dataBuffer, Buffer.from(this._lastBoundary())] );
	    	};

	    	FormData.prototype._generateBoundary = function() {
	    	  // This generates a 50 character boundary similar to those used by Firefox.
	    	  // They are optimized for boyer-moore parsing.
	    	  var boundary = '--------------------------';
	    	  for (var i = 0; i < 24; i++) {
	    	    boundary += Math.floor(Math.random() * 10).toString(16);
	    	  }

	    	  this._boundary = boundary;
	    	};

	    	// Note: getLengthSync DOESN'T calculate streams length
	    	// As workaround one can calculate file size manually
	    	// and add it as knownLength option
	    	FormData.prototype.getLengthSync = function() {
	    	  var knownLength = this._overheadLength + this._valueLength;

	    	  // Don't get confused, there are 3 "internal" streams for each keyval pair
	    	  // so it basically checks if there is any value added to the form
	    	  if (this._streams.length) {
	    	    knownLength += this._lastBoundary().length;
	    	  }

	    	  // https://github.com/form-data/form-data/issues/40
	    	  if (!this.hasKnownLength()) {
	    	    // Some async length retrievers are present
	    	    // therefore synchronous length calculation is false.
	    	    // Please use getLength(callback) to get proper length
	    	    this._error(new Error('Cannot calculate proper length in synchronous way.'));
	    	  }

	    	  return knownLength;
	    	};

	    	// Public API to check if length of added values is known
	    	// https://github.com/form-data/form-data/issues/196
	    	// https://github.com/form-data/form-data/issues/262
	    	FormData.prototype.hasKnownLength = function() {
	    	  var hasKnownLength = true;

	    	  if (this._valuesToMeasure.length) {
	    	    hasKnownLength = false;
	    	  }

	    	  return hasKnownLength;
	    	};

	    	FormData.prototype.getLength = function(cb) {
	    	  var knownLength = this._overheadLength + this._valueLength;

	    	  if (this._streams.length) {
	    	    knownLength += this._lastBoundary().length;
	    	  }

	    	  if (!this._valuesToMeasure.length) {
	    	    nextTick(cb.bind(this, null, knownLength));
	    	    return;
	    	  }

	    	  asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
	    	    if (err) {
	    	      cb(err);
	    	      return;
	    	    }

	    	    values.forEach(function(length) {
	    	      knownLength += length;
	    	    });

	    	    cb(null, knownLength);
	    	  });
	    	};

	    	FormData.prototype.submit = function(params, cb) {
	    	  var request
	    	    , options
	    	    , defaults = {method: 'post'}
	    	    ;

	    	  // parse provided url if it's string
	    	  // or treat it as options object
	    	  if (typeof params == 'string') {

	    	    params = parseUrl(params);
	    	    options = populate({
	    	      port: params.port,
	    	      path: params.pathname,
	    	      host: params.hostname,
	    	      protocol: params.protocol
	    	    }, defaults);

	    	  // use custom params
	    	  } else {

	    	    options = populate(params, defaults);
	    	    // if no port provided use default one
	    	    if (!options.port) {
	    	      options.port = options.protocol == 'https:' ? 443 : 80;
	    	    }
	    	  }

	    	  // put that good code in getHeaders to some use
	    	  options.headers = this.getHeaders(params.headers);

	    	  // https if specified, fallback to http in any other case
	    	  if (options.protocol == 'https:') {
	    	    request = https.request(options);
	    	  } else {
	    	    request = http.request(options);
	    	  }

	    	  // get content length and fire away
	    	  this.getLength(function(err, length) {
	    	    if (err && err !== 'Unknown stream') {
	    	      this._error(err);
	    	      return;
	    	    }

	    	    // add content length
	    	    if (length) {
	    	      request.setHeader('Content-Length', length);
	    	    }

	    	    this.pipe(request);
	    	    if (cb) {
	    	      var onResponse;

	    	      var callback = function (error, responce) {
	    	        request.removeListener('error', callback);
	    	        request.removeListener('response', onResponse);

	    	        return cb.call(this, error, responce);
	    	      };

	    	      onResponse = callback.bind(this, null);

	    	      request.on('error', callback);
	    	      request.on('response', onResponse);
	    	    }
	    	  }.bind(this));

	    	  return request;
	    	};

	    	FormData.prototype._error = function(err) {
	    	  if (!this.error) {
	    	    this.error = err;
	    	    this.pause();
	    	    this.emit('error', err);
	    	  }
	    	};

	    	FormData.prototype.toString = function () {
	    	  return '[object FormData]';
	    	};
	    	return form_data;
	    }

	    var FormData$1;
	    var hasRequiredFormData;

	    function requireFormData () {
	    	if (hasRequiredFormData) return FormData$1;
	    	hasRequiredFormData = 1;
	    	// eslint-disable-next-line strict
	    	FormData$1 = requireForm_data();
	    	return FormData$1;
	    }

	    var defaults_1;
	    var hasRequiredDefaults;

	    function requireDefaults () {
	    	if (hasRequiredDefaults) return defaults_1;
	    	hasRequiredDefaults = 1;

	    	var utils = requireUtils();
	    	var normalizeHeaderName = requireNormalizeHeaderName();
	    	var AxiosError = requireAxiosError();
	    	var transitionalDefaults = requireTransitional();
	    	var toFormData = requireToFormData();

	    	var DEFAULT_CONTENT_TYPE = {
	    	  'Content-Type': 'application/x-www-form-urlencoded'
	    	};

	    	function setContentTypeIfUnset(headers, value) {
	    	  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
	    	    headers['Content-Type'] = value;
	    	  }
	    	}

	    	function getDefaultAdapter() {
	    	  var adapter;
	    	  if (typeof XMLHttpRequest !== 'undefined') {
	    	    // For browsers use XHR adapter
	    	    adapter = requireXhr();
	    	  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
	    	    // For node use HTTP adapter
	    	    adapter = requireHttp();
	    	  }
	    	  return adapter;
	    	}

	    	function stringifySafely(rawValue, parser, encoder) {
	    	  if (utils.isString(rawValue)) {
	    	    try {
	    	      (parser || JSON.parse)(rawValue);
	    	      return utils.trim(rawValue);
	    	    } catch (e) {
	    	      if (e.name !== 'SyntaxError') {
	    	        throw e;
	    	      }
	    	    }
	    	  }

	    	  return (encoder || JSON.stringify)(rawValue);
	    	}

	    	var defaults = {

	    	  transitional: transitionalDefaults,

	    	  adapter: getDefaultAdapter(),

	    	  transformRequest: [function transformRequest(data, headers) {
	    	    normalizeHeaderName(headers, 'Accept');
	    	    normalizeHeaderName(headers, 'Content-Type');

	    	    if (utils.isFormData(data) ||
	    	      utils.isArrayBuffer(data) ||
	    	      utils.isBuffer(data) ||
	    	      utils.isStream(data) ||
	    	      utils.isFile(data) ||
	    	      utils.isBlob(data)
	    	    ) {
	    	      return data;
	    	    }
	    	    if (utils.isArrayBufferView(data)) {
	    	      return data.buffer;
	    	    }
	    	    if (utils.isURLSearchParams(data)) {
	    	      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
	    	      return data.toString();
	    	    }

	    	    var isObjectPayload = utils.isObject(data);
	    	    var contentType = headers && headers['Content-Type'];

	    	    var isFileList;

	    	    if ((isFileList = utils.isFileList(data)) || (isObjectPayload && contentType === 'multipart/form-data')) {
	    	      var _FormData = this.env && this.env.FormData;
	    	      return toFormData(isFileList ? {'files[]': data} : data, _FormData && new _FormData());
	    	    } else if (isObjectPayload || contentType === 'application/json') {
	    	      setContentTypeIfUnset(headers, 'application/json');
	    	      return stringifySafely(data);
	    	    }

	    	    return data;
	    	  }],

	    	  transformResponse: [function transformResponse(data) {
	    	    var transitional = this.transitional || defaults.transitional;
	    	    var silentJSONParsing = transitional && transitional.silentJSONParsing;
	    	    var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
	    	    var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';

	    	    if (strictJSONParsing || (forcedJSONParsing && utils.isString(data) && data.length)) {
	    	      try {
	    	        return JSON.parse(data);
	    	      } catch (e) {
	    	        if (strictJSONParsing) {
	    	          if (e.name === 'SyntaxError') {
	    	            throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
	    	          }
	    	          throw e;
	    	        }
	    	      }
	    	    }

	    	    return data;
	    	  }],

	    	  /**
	    	   * A timeout in milliseconds to abort a request. If set to 0 (default) a
	    	   * timeout is not created.
	    	   */
	    	  timeout: 0,

	    	  xsrfCookieName: 'XSRF-TOKEN',
	    	  xsrfHeaderName: 'X-XSRF-TOKEN',

	    	  maxContentLength: -1,
	    	  maxBodyLength: -1,

	    	  env: {
	    	    FormData: requireFormData()
	    	  },

	    	  validateStatus: function validateStatus(status) {
	    	    return status >= 200 && status < 300;
	    	  },

	    	  headers: {
	    	    common: {
	    	      'Accept': 'application/json, text/plain, */*'
	    	    }
	    	  }
	    	};

	    	utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
	    	  defaults.headers[method] = {};
	    	});

	    	utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
	    	  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
	    	});

	    	defaults_1 = defaults;
	    	return defaults_1;
	    }

	    var transformData;
	    var hasRequiredTransformData;

	    function requireTransformData () {
	    	if (hasRequiredTransformData) return transformData;
	    	hasRequiredTransformData = 1;

	    	var utils = requireUtils();
	    	var defaults = requireDefaults();

	    	/**
	    	 * Transform the data for a request or a response
	    	 *
	    	 * @param {Object|String} data The data to be transformed
	    	 * @param {Array} headers The headers for the request or response
	    	 * @param {Array|Function} fns A single function or Array of functions
	    	 * @returns {*} The resulting transformed data
	    	 */
	    	transformData = function transformData(data, headers, fns) {
	    	  var context = this || defaults;
	    	  /*eslint no-param-reassign:0*/
	    	  utils.forEach(fns, function transform(fn) {
	    	    data = fn.call(context, data, headers);
	    	  });

	    	  return data;
	    	};
	    	return transformData;
	    }

	    var isCancel;
	    var hasRequiredIsCancel;

	    function requireIsCancel () {
	    	if (hasRequiredIsCancel) return isCancel;
	    	hasRequiredIsCancel = 1;

	    	isCancel = function isCancel(value) {
	    	  return !!(value && value.__CANCEL__);
	    	};
	    	return isCancel;
	    }

	    var dispatchRequest;
	    var hasRequiredDispatchRequest;

	    function requireDispatchRequest () {
	    	if (hasRequiredDispatchRequest) return dispatchRequest;
	    	hasRequiredDispatchRequest = 1;

	    	var utils = requireUtils();
	    	var transformData = requireTransformData();
	    	var isCancel = requireIsCancel();
	    	var defaults = requireDefaults();
	    	var CanceledError = requireCanceledError();

	    	/**
	    	 * Throws a `CanceledError` if cancellation has been requested.
	    	 */
	    	function throwIfCancellationRequested(config) {
	    	  if (config.cancelToken) {
	    	    config.cancelToken.throwIfRequested();
	    	  }

	    	  if (config.signal && config.signal.aborted) {
	    	    throw new CanceledError();
	    	  }
	    	}

	    	/**
	    	 * Dispatch a request to the server using the configured adapter.
	    	 *
	    	 * @param {object} config The config that is to be used for the request
	    	 * @returns {Promise} The Promise to be fulfilled
	    	 */
	    	dispatchRequest = function dispatchRequest(config) {
	    	  throwIfCancellationRequested(config);

	    	  // Ensure headers exist
	    	  config.headers = config.headers || {};

	    	  // Transform request data
	    	  config.data = transformData.call(
	    	    config,
	    	    config.data,
	    	    config.headers,
	    	    config.transformRequest
	    	  );

	    	  // Flatten headers
	    	  config.headers = utils.merge(
	    	    config.headers.common || {},
	    	    config.headers[config.method] || {},
	    	    config.headers
	    	  );

	    	  utils.forEach(
	    	    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
	    	    function cleanHeaderConfig(method) {
	    	      delete config.headers[method];
	    	    }
	    	  );

	    	  var adapter = config.adapter || defaults.adapter;

	    	  return adapter(config).then(function onAdapterResolution(response) {
	    	    throwIfCancellationRequested(config);

	    	    // Transform response data
	    	    response.data = transformData.call(
	    	      config,
	    	      response.data,
	    	      response.headers,
	    	      config.transformResponse
	    	    );

	    	    return response;
	    	  }, function onAdapterRejection(reason) {
	    	    if (!isCancel(reason)) {
	    	      throwIfCancellationRequested(config);

	    	      // Transform response data
	    	      if (reason && reason.response) {
	    	        reason.response.data = transformData.call(
	    	          config,
	    	          reason.response.data,
	    	          reason.response.headers,
	    	          config.transformResponse
	    	        );
	    	      }
	    	    }

	    	    return Promise.reject(reason);
	    	  });
	    	};
	    	return dispatchRequest;
	    }

	    var mergeConfig;
	    var hasRequiredMergeConfig;

	    function requireMergeConfig () {
	    	if (hasRequiredMergeConfig) return mergeConfig;
	    	hasRequiredMergeConfig = 1;

	    	var utils = requireUtils();

	    	/**
	    	 * Config-specific merge-function which creates a new config-object
	    	 * by merging two configuration objects together.
	    	 *
	    	 * @param {Object} config1
	    	 * @param {Object} config2
	    	 * @returns {Object} New object resulting from merging config2 to config1
	    	 */
	    	mergeConfig = function mergeConfig(config1, config2) {
	    	  // eslint-disable-next-line no-param-reassign
	    	  config2 = config2 || {};
	    	  var config = {};

	    	  function getMergedValue(target, source) {
	    	    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
	    	      return utils.merge(target, source);
	    	    } else if (utils.isPlainObject(source)) {
	    	      return utils.merge({}, source);
	    	    } else if (utils.isArray(source)) {
	    	      return source.slice();
	    	    }
	    	    return source;
	    	  }

	    	  // eslint-disable-next-line consistent-return
	    	  function mergeDeepProperties(prop) {
	    	    if (!utils.isUndefined(config2[prop])) {
	    	      return getMergedValue(config1[prop], config2[prop]);
	    	    } else if (!utils.isUndefined(config1[prop])) {
	    	      return getMergedValue(undefined, config1[prop]);
	    	    }
	    	  }

	    	  // eslint-disable-next-line consistent-return
	    	  function valueFromConfig2(prop) {
	    	    if (!utils.isUndefined(config2[prop])) {
	    	      return getMergedValue(undefined, config2[prop]);
	    	    }
	    	  }

	    	  // eslint-disable-next-line consistent-return
	    	  function defaultToConfig2(prop) {
	    	    if (!utils.isUndefined(config2[prop])) {
	    	      return getMergedValue(undefined, config2[prop]);
	    	    } else if (!utils.isUndefined(config1[prop])) {
	    	      return getMergedValue(undefined, config1[prop]);
	    	    }
	    	  }

	    	  // eslint-disable-next-line consistent-return
	    	  function mergeDirectKeys(prop) {
	    	    if (prop in config2) {
	    	      return getMergedValue(config1[prop], config2[prop]);
	    	    } else if (prop in config1) {
	    	      return getMergedValue(undefined, config1[prop]);
	    	    }
	    	  }

	    	  var mergeMap = {
	    	    'url': valueFromConfig2,
	    	    'method': valueFromConfig2,
	    	    'data': valueFromConfig2,
	    	    'baseURL': defaultToConfig2,
	    	    'transformRequest': defaultToConfig2,
	    	    'transformResponse': defaultToConfig2,
	    	    'paramsSerializer': defaultToConfig2,
	    	    'timeout': defaultToConfig2,
	    	    'timeoutMessage': defaultToConfig2,
	    	    'withCredentials': defaultToConfig2,
	    	    'adapter': defaultToConfig2,
	    	    'responseType': defaultToConfig2,
	    	    'xsrfCookieName': defaultToConfig2,
	    	    'xsrfHeaderName': defaultToConfig2,
	    	    'onUploadProgress': defaultToConfig2,
	    	    'onDownloadProgress': defaultToConfig2,
	    	    'decompress': defaultToConfig2,
	    	    'maxContentLength': defaultToConfig2,
	    	    'maxBodyLength': defaultToConfig2,
	    	    'beforeRedirect': defaultToConfig2,
	    	    'transport': defaultToConfig2,
	    	    'httpAgent': defaultToConfig2,
	    	    'httpsAgent': defaultToConfig2,
	    	    'cancelToken': defaultToConfig2,
	    	    'socketPath': defaultToConfig2,
	    	    'responseEncoding': defaultToConfig2,
	    	    'validateStatus': mergeDirectKeys
	    	  };

	    	  utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
	    	    var merge = mergeMap[prop] || mergeDeepProperties;
	    	    var configValue = merge(prop);
	    	    (utils.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);
	    	  });

	    	  return config;
	    	};
	    	return mergeConfig;
	    }

	    var validator;
	    var hasRequiredValidator;

	    function requireValidator () {
	    	if (hasRequiredValidator) return validator;
	    	hasRequiredValidator = 1;

	    	var VERSION = requireData().version;
	    	var AxiosError = requireAxiosError();

	    	var validators = {};

	    	// eslint-disable-next-line func-names
	    	['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function(type, i) {
	    	  validators[type] = function validator(thing) {
	    	    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
	    	  };
	    	});

	    	var deprecatedWarnings = {};

	    	/**
	    	 * Transitional option validator
	    	 * @param {function|boolean?} validator - set to false if the transitional option has been removed
	    	 * @param {string?} version - deprecated version / removed since version
	    	 * @param {string?} message - some message with additional info
	    	 * @returns {function}
	    	 */
	    	validators.transitional = function transitional(validator, version, message) {
	    	  function formatMessage(opt, desc) {
	    	    return '[Axios v' + VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
	    	  }

	    	  // eslint-disable-next-line func-names
	    	  return function(value, opt, opts) {
	    	    if (validator === false) {
	    	      throw new AxiosError(
	    	        formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),
	    	        AxiosError.ERR_DEPRECATED
	    	      );
	    	    }

	    	    if (version && !deprecatedWarnings[opt]) {
	    	      deprecatedWarnings[opt] = true;
	    	      // eslint-disable-next-line no-console
	    	      console.warn(
	    	        formatMessage(
	    	          opt,
	    	          ' has been deprecated since v' + version + ' and will be removed in the near future'
	    	        )
	    	      );
	    	    }

	    	    return validator ? validator(value, opt, opts) : true;
	    	  };
	    	};

	    	/**
	    	 * Assert object's properties type
	    	 * @param {object} options
	    	 * @param {object} schema
	    	 * @param {boolean?} allowUnknown
	    	 */

	    	function assertOptions(options, schema, allowUnknown) {
	    	  if (typeof options !== 'object') {
	    	    throw new AxiosError('options must be an object', AxiosError.ERR_BAD_OPTION_VALUE);
	    	  }
	    	  var keys = Object.keys(options);
	    	  var i = keys.length;
	    	  while (i-- > 0) {
	    	    var opt = keys[i];
	    	    var validator = schema[opt];
	    	    if (validator) {
	    	      var value = options[opt];
	    	      var result = value === undefined || validator(value, opt, options);
	    	      if (result !== true) {
	    	        throw new AxiosError('option ' + opt + ' must be ' + result, AxiosError.ERR_BAD_OPTION_VALUE);
	    	      }
	    	      continue;
	    	    }
	    	    if (allowUnknown !== true) {
	    	      throw new AxiosError('Unknown option ' + opt, AxiosError.ERR_BAD_OPTION);
	    	    }
	    	  }
	    	}

	    	validator = {
	    	  assertOptions: assertOptions,
	    	  validators: validators
	    	};
	    	return validator;
	    }

	    var Axios_1;
	    var hasRequiredAxios$2;

	    function requireAxios$2 () {
	    	if (hasRequiredAxios$2) return Axios_1;
	    	hasRequiredAxios$2 = 1;

	    	var utils = requireUtils();
	    	var buildURL = requireBuildURL();
	    	var InterceptorManager = requireInterceptorManager();
	    	var dispatchRequest = requireDispatchRequest();
	    	var mergeConfig = requireMergeConfig();
	    	var buildFullPath = requireBuildFullPath();
	    	var validator = requireValidator();

	    	var validators = validator.validators;
	    	/**
	    	 * Create a new instance of Axios
	    	 *
	    	 * @param {Object} instanceConfig The default config for the instance
	    	 */
	    	function Axios(instanceConfig) {
	    	  this.defaults = instanceConfig;
	    	  this.interceptors = {
	    	    request: new InterceptorManager(),
	    	    response: new InterceptorManager()
	    	  };
	    	}

	    	/**
	    	 * Dispatch a request
	    	 *
	    	 * @param {Object} config The config specific for this request (merged with this.defaults)
	    	 */
	    	Axios.prototype.request = function request(configOrUrl, config) {
	    	  /*eslint no-param-reassign:0*/
	    	  // Allow for axios('example/url'[, config]) a la fetch API
	    	  if (typeof configOrUrl === 'string') {
	    	    config = config || {};
	    	    config.url = configOrUrl;
	    	  } else {
	    	    config = configOrUrl || {};
	    	  }

	    	  config = mergeConfig(this.defaults, config);

	    	  // Set config.method
	    	  if (config.method) {
	    	    config.method = config.method.toLowerCase();
	    	  } else if (this.defaults.method) {
	    	    config.method = this.defaults.method.toLowerCase();
	    	  } else {
	    	    config.method = 'get';
	    	  }

	    	  var transitional = config.transitional;

	    	  if (transitional !== undefined) {
	    	    validator.assertOptions(transitional, {
	    	      silentJSONParsing: validators.transitional(validators.boolean),
	    	      forcedJSONParsing: validators.transitional(validators.boolean),
	    	      clarifyTimeoutError: validators.transitional(validators.boolean)
	    	    }, false);
	    	  }

	    	  // filter out skipped interceptors
	    	  var requestInterceptorChain = [];
	    	  var synchronousRequestInterceptors = true;
	    	  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
	    	    if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
	    	      return;
	    	    }

	    	    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

	    	    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
	    	  });

	    	  var responseInterceptorChain = [];
	    	  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
	    	    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
	    	  });

	    	  var promise;

	    	  if (!synchronousRequestInterceptors) {
	    	    var chain = [dispatchRequest, undefined];

	    	    Array.prototype.unshift.apply(chain, requestInterceptorChain);
	    	    chain = chain.concat(responseInterceptorChain);

	    	    promise = Promise.resolve(config);
	    	    while (chain.length) {
	    	      promise = promise.then(chain.shift(), chain.shift());
	    	    }

	    	    return promise;
	    	  }


	    	  var newConfig = config;
	    	  while (requestInterceptorChain.length) {
	    	    var onFulfilled = requestInterceptorChain.shift();
	    	    var onRejected = requestInterceptorChain.shift();
	    	    try {
	    	      newConfig = onFulfilled(newConfig);
	    	    } catch (error) {
	    	      onRejected(error);
	    	      break;
	    	    }
	    	  }

	    	  try {
	    	    promise = dispatchRequest(newConfig);
	    	  } catch (error) {
	    	    return Promise.reject(error);
	    	  }

	    	  while (responseInterceptorChain.length) {
	    	    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
	    	  }

	    	  return promise;
	    	};

	    	Axios.prototype.getUri = function getUri(config) {
	    	  config = mergeConfig(this.defaults, config);
	    	  var fullPath = buildFullPath(config.baseURL, config.url);
	    	  return buildURL(fullPath, config.params, config.paramsSerializer);
	    	};

	    	// Provide aliases for supported request methods
	    	utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
	    	  /*eslint func-names:0*/
	    	  Axios.prototype[method] = function(url, config) {
	    	    return this.request(mergeConfig(config || {}, {
	    	      method: method,
	    	      url: url,
	    	      data: (config || {}).data
	    	    }));
	    	  };
	    	});

	    	utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
	    	  /*eslint func-names:0*/

	    	  function generateHTTPMethod(isForm) {
	    	    return function httpMethod(url, data, config) {
	    	      return this.request(mergeConfig(config || {}, {
	    	        method: method,
	    	        headers: isForm ? {
	    	          'Content-Type': 'multipart/form-data'
	    	        } : {},
	    	        url: url,
	    	        data: data
	    	      }));
	    	    };
	    	  }

	    	  Axios.prototype[method] = generateHTTPMethod();

	    	  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);
	    	});

	    	Axios_1 = Axios;
	    	return Axios_1;
	    }

	    var CancelToken_1;
	    var hasRequiredCancelToken;

	    function requireCancelToken () {
	    	if (hasRequiredCancelToken) return CancelToken_1;
	    	hasRequiredCancelToken = 1;

	    	var CanceledError = requireCanceledError();

	    	/**
	    	 * A `CancelToken` is an object that can be used to request cancellation of an operation.
	    	 *
	    	 * @class
	    	 * @param {Function} executor The executor function.
	    	 */
	    	function CancelToken(executor) {
	    	  if (typeof executor !== 'function') {
	    	    throw new TypeError('executor must be a function.');
	    	  }

	    	  var resolvePromise;

	    	  this.promise = new Promise(function promiseExecutor(resolve) {
	    	    resolvePromise = resolve;
	    	  });

	    	  var token = this;

	    	  // eslint-disable-next-line func-names
	    	  this.promise.then(function(cancel) {
	    	    if (!token._listeners) return;

	    	    var i;
	    	    var l = token._listeners.length;

	    	    for (i = 0; i < l; i++) {
	    	      token._listeners[i](cancel);
	    	    }
	    	    token._listeners = null;
	    	  });

	    	  // eslint-disable-next-line func-names
	    	  this.promise.then = function(onfulfilled) {
	    	    var _resolve;
	    	    // eslint-disable-next-line func-names
	    	    var promise = new Promise(function(resolve) {
	    	      token.subscribe(resolve);
	    	      _resolve = resolve;
	    	    }).then(onfulfilled);

	    	    promise.cancel = function reject() {
	    	      token.unsubscribe(_resolve);
	    	    };

	    	    return promise;
	    	  };

	    	  executor(function cancel(message) {
	    	    if (token.reason) {
	    	      // Cancellation has already been requested
	    	      return;
	    	    }

	    	    token.reason = new CanceledError(message);
	    	    resolvePromise(token.reason);
	    	  });
	    	}

	    	/**
	    	 * Throws a `CanceledError` if cancellation has been requested.
	    	 */
	    	CancelToken.prototype.throwIfRequested = function throwIfRequested() {
	    	  if (this.reason) {
	    	    throw this.reason;
	    	  }
	    	};

	    	/**
	    	 * Subscribe to the cancel signal
	    	 */

	    	CancelToken.prototype.subscribe = function subscribe(listener) {
	    	  if (this.reason) {
	    	    listener(this.reason);
	    	    return;
	    	  }

	    	  if (this._listeners) {
	    	    this._listeners.push(listener);
	    	  } else {
	    	    this._listeners = [listener];
	    	  }
	    	};

	    	/**
	    	 * Unsubscribe from the cancel signal
	    	 */

	    	CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
	    	  if (!this._listeners) {
	    	    return;
	    	  }
	    	  var index = this._listeners.indexOf(listener);
	    	  if (index !== -1) {
	    	    this._listeners.splice(index, 1);
	    	  }
	    	};

	    	/**
	    	 * Returns an object that contains a new `CancelToken` and a function that, when called,
	    	 * cancels the `CancelToken`.
	    	 */
	    	CancelToken.source = function source() {
	    	  var cancel;
	    	  var token = new CancelToken(function executor(c) {
	    	    cancel = c;
	    	  });
	    	  return {
	    	    token: token,
	    	    cancel: cancel
	    	  };
	    	};

	    	CancelToken_1 = CancelToken;
	    	return CancelToken_1;
	    }

	    var spread;
	    var hasRequiredSpread;

	    function requireSpread () {
	    	if (hasRequiredSpread) return spread;
	    	hasRequiredSpread = 1;

	    	/**
	    	 * Syntactic sugar for invoking a function and expanding an array for arguments.
	    	 *
	    	 * Common use case would be to use `Function.prototype.apply`.
	    	 *
	    	 *  ```js
	    	 *  function f(x, y, z) {}
	    	 *  var args = [1, 2, 3];
	    	 *  f.apply(null, args);
	    	 *  ```
	    	 *
	    	 * With `spread` this example can be re-written.
	    	 *
	    	 *  ```js
	    	 *  spread(function(x, y, z) {})([1, 2, 3]);
	    	 *  ```
	    	 *
	    	 * @param {Function} callback
	    	 * @returns {Function}
	    	 */
	    	spread = function spread(callback) {
	    	  return function wrap(arr) {
	    	    return callback.apply(null, arr);
	    	  };
	    	};
	    	return spread;
	    }

	    var isAxiosError;
	    var hasRequiredIsAxiosError;

	    function requireIsAxiosError () {
	    	if (hasRequiredIsAxiosError) return isAxiosError;
	    	hasRequiredIsAxiosError = 1;

	    	var utils = requireUtils();

	    	/**
	    	 * Determines whether the payload is an error thrown by Axios
	    	 *
	    	 * @param {*} payload The value to test
	    	 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
	    	 */
	    	isAxiosError = function isAxiosError(payload) {
	    	  return utils.isObject(payload) && (payload.isAxiosError === true);
	    	};
	    	return isAxiosError;
	    }

	    var hasRequiredAxios$1;

	    function requireAxios$1 () {
	    	if (hasRequiredAxios$1) return axios$1.exports;
	    	hasRequiredAxios$1 = 1;

	    	var utils = requireUtils();
	    	var bind = requireBind();
	    	var Axios = requireAxios$2();
	    	var mergeConfig = requireMergeConfig();
	    	var defaults = requireDefaults();

	    	/**
	    	 * Create an instance of Axios
	    	 *
	    	 * @param {Object} defaultConfig The default config for the instance
	    	 * @return {Axios} A new instance of Axios
	    	 */
	    	function createInstance(defaultConfig) {
	    	  var context = new Axios(defaultConfig);
	    	  var instance = bind(Axios.prototype.request, context);

	    	  // Copy axios.prototype to instance
	    	  utils.extend(instance, Axios.prototype, context);

	    	  // Copy context to instance
	    	  utils.extend(instance, context);

	    	  // Factory for creating new instances
	    	  instance.create = function create(instanceConfig) {
	    	    return createInstance(mergeConfig(defaultConfig, instanceConfig));
	    	  };

	    	  return instance;
	    	}

	    	// Create the default instance to be exported
	    	var axios = createInstance(defaults);

	    	// Expose Axios class to allow class inheritance
	    	axios.Axios = Axios;

	    	// Expose Cancel & CancelToken
	    	axios.CanceledError = requireCanceledError();
	    	axios.CancelToken = requireCancelToken();
	    	axios.isCancel = requireIsCancel();
	    	axios.VERSION = requireData().version;
	    	axios.toFormData = requireToFormData();

	    	// Expose AxiosError class
	    	axios.AxiosError = requireAxiosError();

	    	// alias for CanceledError for backward compatibility
	    	axios.Cancel = axios.CanceledError;

	    	// Expose all/spread
	    	axios.all = function all(promises) {
	    	  return Promise.all(promises);
	    	};
	    	axios.spread = requireSpread();

	    	// Expose isAxiosError
	    	axios.isAxiosError = requireIsAxiosError();

	    	axios$1.exports = axios;

	    	// Allow use of default import syntax in TypeScript
	    	axios$1.exports.default = axios;
	    	return axios$1.exports;
	    }

	    var axios;
	    var hasRequiredAxios;

	    function requireAxios () {
	    	if (hasRequiredAxios) return axios;
	    	hasRequiredAxios = 1;
	    	axios = requireAxios$1();
	    	return axios;
	    }

	    (function (module, exports) {
	    	(function (global, factory) {
	    	    module.exports = factory() ;
	    	}(commonjsGlobal$1, (function () {
	    	    /*! *****************************************************************************
	    	    Copyright (c) Microsoft Corporation.

	    	    Permission to use, copy, modify, and/or distribute this software for any
	    	    purpose with or without fee is hereby granted.

	    	    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
	    	    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
	    	    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
	    	    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
	    	    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
	    	    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
	    	    PERFORMANCE OF THIS SOFTWARE.
	    	    ***************************************************************************** */

	    	    function __awaiter(thisArg, _arguments, P, generator) {
	    	        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    	        return new (P || (P = Promise))(function (resolve, reject) {
	    	            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	    	            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	    	            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	    	            step((generator = generator.apply(thisArg, _arguments || [])).next());
	    	        });
	    	    }

	    	    const axios = requireAxios();
	    	    class HttpRequest {
	    	        constructor(baseUrl, params) {
	    	            this.request = axios.create({
	    	                baseURL: baseUrl,
	    	                timeout: (params === null || params === void 0 ? void 0 : params.timeout) ? params === null || params === void 0 ? void 0 : params.timeout : 30000,
	    	                timeoutErrorMessage: (params === null || params === void 0 ? void 0 : params.timeoutErrorMessage)
	    	                    ? params === null || params === void 0 ? void 0 : params.timeoutErrorMessage
	    	                    : "",
	    	            });
	    	            this.request.interceptors.request.use((config) => __awaiter(this, void 0, void 0, function* () {
	    	                if (params === null || params === void 0 ? void 0 : params.header) {
	    	                    let header;
	    	                    if (typeof params.header === "function")
	    	                        header = yield params.header(config);
	    	                    else
	    	                        header = params.header;
	    	                    for (const i in header) {
	    	                        if (!config.headers) {
	    	                            // @ts-ignore
	    	                            config.headers = {};
	    	                        }
	    	                        if (typeof header[i] === "function") {
	    	                            config.headers[i] = header[i]();
	    	                        }
	    	                        else {
	    	                            config.headers[i] = header[i];
	    	                        }
	    	                    }
	    	                }
	    	                return config;
	    	            }), function (error) {
	    	                // 
	    	                return Promise.reject(error);
	    	            });
	    	            // 
	    	            this.request.interceptors.response.use(function (response) {
	    	                return __awaiter(this, void 0, void 0, function* () {
	    	                    // 
	    	                    if (params === null || params === void 0 ? void 0 : params.responseHandel) {
	    	                        return yield params.responseHandel(response);
	    	                    }
	    	                    else {
	    	                        return response.data;
	    	                    }
	    	                });
	    	            }, function (error) {
	    	                if (params === null || params === void 0 ? void 0 : params.errorHandel) {
	    	                    return params.errorHandel(error);
	    	                }
	    	                else {
	    	                    return Promise.reject(error);
	    	                }
	    	            });
	    	        }
	    	    }

	    	    return HttpRequest;

	    	})));
	    	
	    } (requestSdk_min));

	    var requestSdk_minExports = requestSdk_min.exports;
	    var HttpRequest = /*@__PURE__*/getDefaultExportFromCjs(requestSdk_minExports);

	    var serviceapi = (baseUrl) => new HttpRequest(`${baseUrl}/serviceapi`).request;

	    var Network;
	    (function (Network) {
	        Network["Testnet"] = "testnet";
	        Network["Mainnet"] = "mainnet";
	    })(Network || (Network = {}));

	    const ShowMoneyBaseUrlMirror = {
	        [Network.Testnet]: "https://testmvc.showmoney.app",
	        [Network.Mainnet]: "https://api.show3.io",
	    };
	    const MetaSvBaseUrlMirror = {
	        [Network.Testnet]: "https://testmvc.showmoney.app/metasv",
	        [Network.Mainnet]: "https://api.show3.io/metasv",
	    };

	    class BaseApi {
	        constructor(params) {
	            var _a, _b, _c, _d;
	            this.showMoneyBaseUrl = '';
	            this.metaSvBaseUrl = '';
	            this.network = Network.Mainnet;
	            if ((_a = params === null || params === void 0 ? void 0 : params.base) === null || _a === void 0 ? void 0 : _a.network)
	                this.network = params.base.network;
	            if ((_b = params === null || params === void 0 ? void 0 : params.base) === null || _b === void 0 ? void 0 : _b.showMoneyBaseUrl)
	                this.showMoneyBaseUrl = (_c = params === null || params === void 0 ? void 0 : params.base) === null || _c === void 0 ? void 0 : _c.showMoneyBaseUrl;
	            if ((_d = params === null || params === void 0 ? void 0 : params.base) === null || _d === void 0 ? void 0 : _d.metaSvBaseUrl)
	                this.metaSvBaseUrl = params.base.metaSvBaseUrl;
	        }
	        getMetaSvBaseUrl(params) {
	            return (params === null || params === void 0 ? void 0 : params.metaSvBaseUrl)
	                ? params.metaSvBaseUrl
	                : (params === null || params === void 0 ? void 0 : params.network)
	                    ? MetaSvBaseUrlMirror[params.network]
	                    : this.metaSvBaseUrl
	                        ? this.metaSvBaseUrl
	                        : MetaSvBaseUrlMirror[this.network];
	        }
	        getShowMoneyBaseUrl(params) {
	            return (params === null || params === void 0 ? void 0 : params.showMoneyBaseUrl)
	                ? params.showMoneyBaseUrl
	                : (params === null || params === void 0 ? void 0 : params.network)
	                    ? ShowMoneyBaseUrlMirror[params.network]
	                    : this.showMoneyBaseUrl
	                        ? this.showMoneyBaseUrl
	                        : ShowMoneyBaseUrlMirror[this.network];
	        }
	    }

	    var metaSvSignature = (baseUrl) => new HttpRequest(`${baseUrl}/metasv-signature`).request;

	    class Util extends BaseApi {
	        constructor(params) {
	            super(params);
	        }
	        getMetaSvSignature(path, params) {
	            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
	                const res = yield metaSvSignature(this.getShowMoneyBaseUrl(params))
	                    .post("/signature", { path })
	                    .catch((error) => {
	                    reject(error);
	                });
	                if ((res === null || res === void 0 ? void 0 : res.code) === 0) {
	                    resolve(res.data);
	                }
	            }));
	        }
	    }

	    var metasvRequst = (baseUrl, showMoneyBaseUrl) => new HttpRequest(`${baseUrl}`, {
	        header: (config) => {
	            return new Promise((resolve, reject) => __awaiter(void 0, void 0, void 0, function* () {
	                const signature = yield new Util({
	                    base: {
	                        showMoneyBaseUrl: `https://api.show3.io`,
	                    },
	                })
	                    .getMetaSvSignature(config.url)
	                    .catch((error) => {
	                    reject(error);
	                });
	                if (signature) {
	                    const headers = Object.assign(Object.assign({}, config.headers), { "Content-Type": "application/json", "MetaSV-Timestamp": signature.timestamp, "MetaSV-Client-Pubkey": signature.publicKey, "MetaSV-Nonce": signature.nonce, "MetaSV-Signature": signature.signEncoded });
	                    resolve(headers);
	                }
	            }));
	        },
	    }).request;

	    class Address extends BaseApi {
	        constructor(params) {
	            super(params);
	        }
	        getMetaId(address, params) {
	            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
	                const res = yield serviceapi(this.getShowMoneyBaseUrl(params))
	                    .post("/api/v1/metago/getMetaIdByZoreAddress", {
	                    data: JSON.stringify({
	                        zeroAddress: address,
	                    }),
	                })
	                    .catch((error) => {
	                    reject(error);
	                });
	                if ((res === null || res === void 0 ? void 0 : res.code) === 200) {
	                    resolve(res.result.rootTxId);
	                }
	                else if ((res === null || res === void 0 ? void 0 : res.code) === 601) {
	                    resolve("");
	                }
	            }));
	        }
	        getUtxos(params, option) {
	            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
	                const res = yield metasvRequst(this.getMetaSvBaseUrl(option), this.getShowMoneyBaseUrl(option))
	                    .get(`/address/${params.address}/utxo`)
	                    .catch((error) => {
	                    reject(error);
	                });
	                if (res) {
	                    const utxos = [];
	                    if (Array.isArray(res)) {
	                        res.forEach((item) => {
	                            item.script = mvc__default["default"].Script.fromAddress(item.address).toHex();
	                            item.amount = +item.value / 1e8;
	                            item.vout = item.outIndex;
	                            item.txIndex = item.outIndex;
	                            item.satoshis = item.value;
	                            item.outputIndex = item.outIndex;
	                            item.txId = item.txid;
	                            item.addressIndex = params.addressIndex;
	                            item.addressType = params.addressType;
	                            utxos.push(item);
	                        });
	                    }
	                    return utxos;
	                }
	            }));
	        }
	        getProtocols(protocolsTxId, protocolType, option) {
	            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
	                const res = yield serviceapi(this.getShowMoneyBaseUrl(option))
	                    .post("/api/v1/protocol/getProtocolDataList", {
	                    data: JSON.stringify({
	                        protocolTxId: protocolsTxId,
	                        nodeName: protocolType,
	                    }),
	                })
	                    .catch((error) => {
	                    reject(error);
	                });
	                if (res.code === 200) {
	                    resolve(res.result.data);
	                }
	                else {
	                    resolve([]);
	                }
	            }));
	        }
	    }

	    var aggregationRequst = (baseUrl) => new HttpRequest(`${baseUrl}/aggregation`).request;

	    class MetaId extends BaseApi {
	        constructor(params) {
	            super(params);
	        }
	        getUserInfo(metaId, params) {
	            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
	                const res = yield aggregationRequst(this.getShowMoneyBaseUrl(params))
	                    .get(`/v2/app/user/getUserInfo/${metaId}`)
	                    .catch((error) => {
	                    reject(error);
	                });
	                if ((res === null || res === void 0 ? void 0 : res.code) === 0) {
	                    if (res.data.evmAddress) {
	                        res.data.evmAddress = JSON.parse(res.data.evmAddress);
	                    }
	                    resolve(res.data);
	                }
	            }));
	        }
	        getAccount(metaId, params) {
	            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
	                const res = yield serviceapi(this.getShowMoneyBaseUrl(params))
	                    .post("/api/v1/showService/getOwnShowAccount", {
	                    data: JSON.stringify({
	                        showId: metaId,
	                    }),
	                })
	                    .catch((error) => {
	                    reject(error);
	                });
	                if (res.code === 200) {
	                    return res.result;
	                }
	                else if (res.code === 601) {
	                    return null;
	                }
	            }));
	        }
	        getNewBrfcNodeBaseInfo(xpub, parentTxId, option) {
	            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
	                const res = yield serviceapi(this.getShowMoneyBaseUrl(option))
	                    .post("/api/v1/showService/getPublicKeyForNewNode", {
	                    data: JSON.stringify({ xpub, parentTxId, count: 30 }),
	                })
	                    .catch((error) => {
	                    reject(error);
	                });
	                if (res.code === 200) {
	                    resolve(res.result.data);
	                }
	                else if (res.code === 601) {
	                    return null;
	                }
	            }));
	        }
	        GetMetafileBySha256(params, option) {
	            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
	                const { sha256 } = params, _params = __rest(params, ["sha256"]);
	                const res = yield aggregationRequst(this.getShowMoneyBaseUrl(option))
	                    .get(`/v2/app/metaFile/getMetaFileByHash/${sha256}`, {
	                    params: _params,
	                })
	                    .catch((error) => {
	                    reject(error);
	                });
	                if (res.code === 0 &&
	                    res.data.results.items &&
	                    res.data.results.items.length) {
	                    resolve(res.data.results.items);
	                }
	                else {
	                    resolve([]);
	                }
	            }));
	        }
	    }

	    var metaIdBaseRequst = (baseUrl) => new HttpRequest(`${baseUrl}/metaid-base`).request;

	    class Tx extends BaseApi {
	        constructor(params) {
	            super(params);
	            this.chainInfos = [];
	            this.brfcs = [];
	        }
	        broadcast(hex, params) {
	            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
	                const res = yield metasvRequst(this.getMetaSvBaseUrl(params), this.getShowMoneyBaseUrl())
	                    .post(`/tx/broadcast`, { hex })
	                    .catch((error) => {
	                    reject(error);
	                });
	                if (res === null || res === void 0 ? void 0 : res.txid) {
	                    yield this.sendRawTx(hex);
	                    resolve(res === null || res === void 0 ? void 0 : res.txid);
	                }
	                else {
	                    let message = typeof res.message === "string"
	                        ? res.message
	                        : JSON.parse(res.message).message;
	                    reject({
	                        message: message,
	                    });
	                }
	            }));
	        }
	        sendRawTx(hex, params) {
	            return __awaiter(this, void 0, void 0, function* () {
	                return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
	                    const res = yield metaIdBaseRequst(this.getShowMoneyBaseUrl(params))
	                        .post("/v1/meta/upload/raw", {
	                        raw: hex,
	                        type: 1,
	                    })
	                        .catch((error) => {
	                        reject(error);
	                    });
	                    if (res) {
	                        resolve(res);
	                    }
	                }));
	            });
	        }
	        getChain(txId, params) {
	            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
	                const item = this.chainInfos.find((item) => item.txId === txId);
	                if (item) {
	                    resolve(item.chain);
	                    return;
	                }
	                else {
	                    const res = yield metaIdBaseRequst(this.getShowMoneyBaseUrl(params))
	                        .get(`/v1/meta/${txId}/info/chain`)
	                        .catch((error) => {
	                        reject(error);
	                    });
	                    if ((res === null || res === void 0 ? void 0 : res.code) === 0) {
	                        resolve(res.data.chainFlag || "mvc");
	                    }
	                }
	            }));
	        }
	        getBrfcs(params, option) {
	            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
	                const res = yield serviceapi(this.getMetaSvBaseUrl(option))
	                    .post("/api/v1/protocol/getProtocolDataList", {
	                    data: JSON.stringify({
	                        protocolTxId: params.protocolTxId,
	                        nodeName: params.nodename,
	                    }),
	                })
	                    .catch((error) => {
	                    reject(error);
	                });
	                if (res.code === 200) {
	                    resolve(res.result.data || []);
	                }
	            }));
	        }
	        getBrfc(params, option) {
	            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
	                try {
	                    let brfc = this.brfcs.find((item) => item.nodeName === params.nodename &&
	                        item.parentTxId === item.parentTxId &&
	                        item.data === params.brfcId);
	                    if (!brfc) {
	                        const brfcs = yield (yield this.getBrfcs(params, option)).filter((item) => item.data === params.brfcId);
	                        brfc = brfcs[0];
	                        if (brfc) {
	                            this.brfcs.push(brfc);
	                        }
	                    }
	                    resolve(brfc);
	                }
	                catch (error) {
	                    reject(error);
	                }
	            }));
	        }
	        getTx(txId, option) {
	            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
	                const res = yield metaIdBaseRequst(this.getShowMoneyBaseUrl(option))
	                    .get(`/v1/meta/${txId}/info`)
	                    .catch((error) => {
	                    reject(error);
	                });
	                if ((res === null || res === void 0 ? void 0 : res.code) === 0) {
	                    resolve(res.data);
	                }
	            }));
	        }
	    }

	    var tool = (baseUrl) => new HttpRequest(`${baseUrl}/tool/api`).request;

	    class Tool extends BaseApi {
	        constructor(params) {
	            super(params);
	        }
	        // utxos
	        getUtxos(params, option) {
	            return (tool(this.getShowMoneyBaseUrl(option)).get('/utxos', { params }));
	        }
	    }

	    //import { mvc } from "meta-contract";
	    class Utxo extends BaseApi {
	        constructor(params) {
	            super(params);
	            // utxo
	            this.usedUtxos = [];
	        }
	        find(param, options) {
	            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
	                const res = yield metasvRequst(this.getMetaSvBaseUrl(options), this.getShowMoneyBaseUrl(options)).get(`/xpubLite/${param.xpub}/utxo`);
	                if (res) {
	                    const otherUsedUtxosRes = yield new Tool({
	                        base: {
	                            showMoneyBaseUrl: this.getShowMoneyBaseUrl(options),
	                        },
	                    }).getUtxos({
	                        page: 1,
	                        pageSize: 99,
	                    });
	                    const usedUtxos = [...this.usedUtxos, ...otherUsedUtxosRes[0]];
	                    // utxo
	                    let utxos = res.filter((item) => {
	                        if (usedUtxos.some((_item) => _item.txId === item.txid || _item.address === item.address)) {
	                            return false;
	                        }
	                        else {
	                            return item;
	                        }
	                    });
	                    const resultUtxos = [];
	                    let amount = 0;
	                    for (let i = 0; i < utxos.length; i++) {
	                        utxos[i].script = mvc__default["default"].Script.fromAddress(utxos[i].address).toHex();
	                        utxos[i].amount = +utxos[i] / 1e8;
	                        utxos[i].vout = +utxos[i].txIndex;
	                        utxos[i].satoshis = +utxos[i].value;
	                        utxos[i].outputIndex = +utxos[i].txIndex;
	                        utxos[i].txId = +utxos[i].txid;
	                        resultUtxos.push(utxos[i]);
	                        amount += utxos.satoshis;
	                        if (param.minAmount && amount >= param.minAmount) {
	                            break;
	                        }
	                    }
	                    resolve(resultUtxos);
	                }
	            }));
	        }
	        getInitUtxo(params, option) {
	            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
	                const res = yield metasvRequst(this.getMetaSvBaseUrl(option), this.getShowMoneyBaseUrl(option))
	                    .post(`/nodemvc/api/v1/pri/wallet/sendInitSatsForMetaSV`, {
	                    address: params.address,
	                    xpub: params.xpub,
	                }, {
	                    headers: {
	                        "Content-Type": "application/json",
	                        accessKey: params.token,
	                        timestamp: new Date().getTime(),
	                        userName: params.userName,
	                    },
	                })
	                    .catch((error) => {
	                    reject(error);
	                });
	                if (res.code === 0) {
	                    const initUtxo = res.result || {};
	                    let result = Object.assign(Object.assign({}, initUtxo), { outputIndex: +initUtxo.index, satoshis: +initUtxo.amount, value: +initUtxo.amount, amount: +initUtxo.amount * 1e-8, address: initUtxo.toAddress, script: initUtxo.scriptPubkey, addressType: 0, addressIndex: 0 });
	                    resolve(result);
	                }
	            }));
	        }
	    }

	    //import { mvc } from "meta-contract";
	    class Xpub extends BaseApi {
	        constructor(params) {
	            super(params);
	        }
	        getBalance(xpub, params) {
	            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
	                const res = yield metasvRequst(this.getMetaSvBaseUrl(params), this.getShowMoneyBaseUrl(params))
	                    .get(`/xpubLite/${xpub}/balance`)
	                    .catch((error) => {
	                    reject(error);
	                });
	                if (res) {
	                    resolve(res.balance);
	                }
	            }));
	        }
	        getUtxo(xpub, params) {
	            const utxos = [];
	            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
	                const res = yield metasvRequst(this.getMetaSvBaseUrl(params), this.getShowMoneyBaseUrl(params))
	                    .get(`/xpubLite/${xpub}/utxo`)
	                    .catch((error) => {
	                    reject(error);
	                });
	                if (res.length) {
	                    res.forEach((item) => {
	                        item.script = mvc__default["default"].Script.fromAddress(item.address).toHex();
	                        item.amount = +item.value / 1e8;
	                        item.vout = item.txIndex;
	                        // sensible need satoshis,outputIndex,txId
	                        item.satoshis = item.value;
	                        item.outputIndex = item.txIndex;
	                        item.txId = item.txid;
	                        utxos.push(item);
	                    });
	                    resolve(utxos);
	                }
	            }));
	        }
	    }

	    class MetaIdProvider {
	        constructor(params) {
	            this.address = new Address(params);
	            this.metaId = new MetaId(params);
	            this.tx = new Tx(params);
	            this.utxo = new Utxo(params);
	            this.xpub = new Xpub(params);
	        }
	    }

	    exports.Address = Address;
	    exports.MetaId = MetaId;
	    exports.MetaIdProvider = MetaIdProvider;
	    exports.Tx = Tx;
	    exports.Utxo = Utxo;
	    exports.Xpub = Xpub;

	    Object.defineProperty(exports, '__esModule', { value: true });

	}));
	
} (metaidProviderSdk_min, metaidProviderSdk_min.exports));

/* eslint-disable @typescript-eslint/no-explicit-any */
// import ENV from '@/configs/env'
/**
 * @description: 
 * @param {type} 
 * @return:
 */
var ContentType;
(function (ContentType) {
    ContentType["json"] = "application/json;charset=UTF-8";
    ContentType["form"] = "application/x-www-form-urlencoded; charset=UTF-8";
})(ContentType || (ContentType = {}));
/**
 * @description:  request  method 
 * @param {type} 
 * @return:
 */
var HttpMethod;
(function (HttpMethod) {
    HttpMethod["get"] = "GET";
    HttpMethod["post"] = "POST";
})(HttpMethod || (HttpMethod = {}));

var requestSdk_min = {exports: {}};

var axios$2 = {exports: {}};

var bind$2 = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};

var bind$1 = bind$2;

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

// eslint-disable-next-line func-names
var kindOf = (function(cache) {
  // eslint-disable-next-line func-names
  return function(thing) {
    var str = toString.call(thing);
    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
  };
})(Object.create(null));

function kindOfTest(type) {
  type = type.toLowerCase();
  return function isKindOf(thing) {
    return kindOf(thing) === type;
  };
}

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return Array.isArray(val);
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
var isArrayBuffer = kindOfTest('ArrayBuffer');


/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a plain Object
 *
 * @param {Object} val The value to test
 * @return {boolean} True if value is a plain Object, otherwise false
 */
function isPlainObject(val) {
  if (kindOf(val) !== 'object') {
    return false;
  }

  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}

/**
 * Determine if a value is a Date
 *
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
var isDate = kindOfTest('Date');

/**
 * Determine if a value is a File
 *
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
var isFile = kindOfTest('File');

/**
 * Determine if a value is a Blob
 *
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
var isBlob = kindOfTest('Blob');

/**
 * Determine if a value is a FileList
 *
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
var isFileList = kindOfTest('FileList');

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} thing The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(thing) {
  var pattern = '[object FormData]';
  return thing && (
    (typeof FormData === 'function' && thing instanceof FormData) ||
    toString.call(thing) === pattern ||
    (isFunction(thing.toString) && thing.toString() === pattern)
  );
}

/**
 * Determine if a value is a URLSearchParams object
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
var isURLSearchParams = kindOfTest('URLSearchParams');

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                           navigator.product === 'NativeScript' ||
                                           navigator.product === 'NS')) {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge({}, val);
    } else if (isArray(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind$1(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 * @return {string} content value without BOM
 */
function stripBOM(content) {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
}

/**
 * Inherit the prototype methods from one constructor into another
 * @param {function} constructor
 * @param {function} superConstructor
 * @param {object} [props]
 * @param {object} [descriptors]
 */

function inherits(constructor, superConstructor, props, descriptors) {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors);
  constructor.prototype.constructor = constructor;
  props && Object.assign(constructor.prototype, props);
}

/**
 * Resolve object with deep prototype chain to a flat object
 * @param {Object} sourceObj source object
 * @param {Object} [destObj]
 * @param {Function} [filter]
 * @returns {Object}
 */

function toFlatObject(sourceObj, destObj, filter) {
  var props;
  var i;
  var prop;
  var merged = {};

  destObj = destObj || {};

  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if (!merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = Object.getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);

  return destObj;
}

/*
 * determines whether a string ends with the characters of a specified string
 * @param {String} str
 * @param {String} searchString
 * @param {Number} [position= 0]
 * @returns {boolean}
 */
function endsWith(str, searchString, position) {
  str = String(str);
  if (position === undefined || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  var lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
}


/**
 * Returns new array from array like object
 * @param {*} [thing]
 * @returns {Array}
 */
function toArray(thing) {
  if (!thing) return null;
  var i = thing.length;
  if (isUndefined(i)) return null;
  var arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
}

// eslint-disable-next-line func-names
var isTypedArray = (function(TypedArray) {
  // eslint-disable-next-line func-names
  return function(thing) {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== 'undefined' && Object.getPrototypeOf(Uint8Array));

var utils$9 = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isPlainObject: isPlainObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim,
  stripBOM: stripBOM,
  inherits: inherits,
  toFlatObject: toFlatObject,
  kindOf: kindOf,
  kindOfTest: kindOfTest,
  endsWith: endsWith,
  toArray: toArray,
  isTypedArray: isTypedArray,
  isFileList: isFileList
};

var utils$8 = utils$9;

function encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
var buildURL$1 = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils$8.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils$8.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils$8.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils$8.forEach(val, function parseValue(v) {
        if (utils$8.isDate(v)) {
          v = v.toISOString();
        } else if (utils$8.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    var hashmarkIndex = url.indexOf('#');
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }

    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};

var utils$7 = utils$9;

function InterceptorManager$1() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager$1.prototype.use = function use(fulfilled, rejected, options) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected,
    synchronous: options ? options.synchronous : false,
    runWhen: options ? options.runWhen : null
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager$1.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager$1.prototype.forEach = function forEach(fn) {
  utils$7.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

var InterceptorManager_1 = InterceptorManager$1;

// shim for using process in browser
// based off https://github.com/defunctzombie/node-process/blob/master/browser.js

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
var cachedSetTimeout = defaultSetTimout;
var cachedClearTimeout = defaultClearTimeout;
if (typeof global$1.setTimeout === 'function') {
    cachedSetTimeout = setTimeout;
}
if (typeof global$1.clearTimeout === 'function') {
    cachedClearTimeout = clearTimeout;
}

function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}
function nextTick(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
}
// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
var title = 'browser';
var platform = 'browser';
var browser$2 = true;
var env = {};
var argv = [];
var version = ''; // empty string to avoid regexp issues
var versions = {};
var release = {};
var config = {};

function noop() {}

var on = noop;
var addListener = noop;
var once = noop;
var off = noop;
var removeListener = noop;
var removeAllListeners = noop;
var emit = noop;

function binding(name) {
    throw new Error('process.binding is not supported');
}

function cwd () { return '/' }
function chdir (dir) {
    throw new Error('process.chdir is not supported');
}function umask() { return 0; }

// from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
var performance = global$1.performance || {};
var performanceNow =
  performance.now        ||
  performance.mozNow     ||
  performance.msNow      ||
  performance.oNow       ||
  performance.webkitNow  ||
  function(){ return (new Date()).getTime() };

// generate timestamp or delta
// see http://nodejs.org/api/process.html#process_process_hrtime
function hrtime(previousTimestamp){
  var clocktime = performanceNow.call(performance)*1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor((clocktime%1)*1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds<0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds,nanoseconds]
}

var startTime = new Date();
function uptime() {
  var currentTime = new Date();
  var dif = currentTime - startTime;
  return dif / 1000;
}

var process = {
  nextTick: nextTick,
  title: title,
  browser: browser$2,
  env: env,
  argv: argv,
  version: version,
  versions: versions,
  on: on,
  addListener: addListener,
  once: once,
  off: off,
  removeListener: removeListener,
  removeAllListeners: removeAllListeners,
  emit: emit,
  binding: binding,
  cwd: cwd,
  chdir: chdir,
  umask: umask,
  hrtime: hrtime,
  platform: platform,
  release: release,
  config: config,
  uptime: uptime
};

var utils$6 = utils$9;

var normalizeHeaderName$1 = function normalizeHeaderName(headers, normalizedName) {
  utils$6.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};

var AxiosError_1;
var hasRequiredAxiosError;

function requireAxiosError () {
	if (hasRequiredAxiosError) return AxiosError_1;
	hasRequiredAxiosError = 1;

	var utils = utils$9;

	/**
	 * Create an Error with the specified message, config, error code, request and response.
	 *
	 * @param {string} message The error message.
	 * @param {string} [code] The error code (for example, 'ECONNABORTED').
	 * @param {Object} [config] The config.
	 * @param {Object} [request] The request.
	 * @param {Object} [response] The response.
	 * @returns {Error} The created error.
	 */
	function AxiosError(message, code, config, request, response) {
	  Error.call(this);
	  this.message = message;
	  this.name = 'AxiosError';
	  code && (this.code = code);
	  config && (this.config = config);
	  request && (this.request = request);
	  response && (this.response = response);
	}

	utils.inherits(AxiosError, Error, {
	  toJSON: function toJSON() {
	    return {
	      // Standard
	      message: this.message,
	      name: this.name,
	      // Microsoft
	      description: this.description,
	      number: this.number,
	      // Mozilla
	      fileName: this.fileName,
	      lineNumber: this.lineNumber,
	      columnNumber: this.columnNumber,
	      stack: this.stack,
	      // Axios
	      config: this.config,
	      code: this.code,
	      status: this.response && this.response.status ? this.response.status : null
	    };
	  }
	});

	var prototype = AxiosError.prototype;
	var descriptors = {};

	[
	  'ERR_BAD_OPTION_VALUE',
	  'ERR_BAD_OPTION',
	  'ECONNABORTED',
	  'ETIMEDOUT',
	  'ERR_NETWORK',
	  'ERR_FR_TOO_MANY_REDIRECTS',
	  'ERR_DEPRECATED',
	  'ERR_BAD_RESPONSE',
	  'ERR_BAD_REQUEST',
	  'ERR_CANCELED'
	// eslint-disable-next-line func-names
	].forEach(function(code) {
	  descriptors[code] = {value: code};
	});

	Object.defineProperties(AxiosError, descriptors);
	Object.defineProperty(prototype, 'isAxiosError', {value: true});

	// eslint-disable-next-line func-names
	AxiosError.from = function(error, code, config, request, response, customProps) {
	  var axiosError = Object.create(prototype);

	  utils.toFlatObject(error, axiosError, function filter(obj) {
	    return obj !== Error.prototype;
	  });

	  AxiosError.call(axiosError, error.message, code, config, request, response);

	  axiosError.name = error.name;

	  customProps && Object.assign(axiosError, customProps);

	  return axiosError;
	};

	AxiosError_1 = AxiosError;
	return AxiosError_1;
}

var transitional = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

var toFormData_1;
var hasRequiredToFormData;

function requireToFormData () {
	if (hasRequiredToFormData) return toFormData_1;
	hasRequiredToFormData = 1;

	var utils = utils$9;

	/**
	 * Convert a data object to FormData
	 * @param {Object} obj
	 * @param {?Object} [formData]
	 * @returns {Object}
	 **/

	function toFormData(obj, formData) {
	  // eslint-disable-next-line no-param-reassign
	  formData = formData || new FormData();

	  var stack = [];

	  function convertValue(value) {
	    if (value === null) return '';

	    if (utils.isDate(value)) {
	      return value.toISOString();
	    }

	    if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {
	      return typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);
	    }

	    return value;
	  }

	  function build(data, parentKey) {
	    if (utils.isPlainObject(data) || utils.isArray(data)) {
	      if (stack.indexOf(data) !== -1) {
	        throw Error('Circular reference detected in ' + parentKey);
	      }

	      stack.push(data);

	      utils.forEach(data, function each(value, key) {
	        if (utils.isUndefined(value)) return;
	        var fullKey = parentKey ? parentKey + '.' + key : key;
	        var arr;

	        if (value && !parentKey && typeof value === 'object') {
	          if (utils.endsWith(key, '{}')) {
	            // eslint-disable-next-line no-param-reassign
	            value = JSON.stringify(value);
	          } else if (utils.endsWith(key, '[]') && (arr = utils.toArray(value))) {
	            // eslint-disable-next-line func-names
	            arr.forEach(function(el) {
	              !utils.isUndefined(el) && formData.append(fullKey, convertValue(el));
	            });
	            return;
	          }
	        }

	        build(value, fullKey);
	      });

	      stack.pop();
	    } else {
	      formData.append(parentKey, convertValue(data));
	    }
	  }

	  build(obj);

	  return formData;
	}

	toFormData_1 = toFormData;
	return toFormData_1;
}

var settle;
var hasRequiredSettle;

function requireSettle () {
	if (hasRequiredSettle) return settle;
	hasRequiredSettle = 1;

	var AxiosError = requireAxiosError();

	/**
	 * Resolve or reject a Promise based on response status.
	 *
	 * @param {Function} resolve A function that resolves the promise.
	 * @param {Function} reject A function that rejects the promise.
	 * @param {object} response The response.
	 */
	settle = function settle(resolve, reject, response) {
	  var validateStatus = response.config.validateStatus;
	  if (!response.status || !validateStatus || validateStatus(response.status)) {
	    resolve(response);
	  } else {
	    reject(new AxiosError(
	      'Request failed with status code ' + response.status,
	      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
	      response.config,
	      response.request,
	      response
	    ));
	  }
	};
	return settle;
}

var cookies;
var hasRequiredCookies;

function requireCookies () {
	if (hasRequiredCookies) return cookies;
	hasRequiredCookies = 1;

	var utils = utils$9;

	cookies = (
	  utils.isStandardBrowserEnv() ?

	  // Standard browser envs support document.cookie
	    (function standardBrowserEnv() {
	      return {
	        write: function write(name, value, expires, path, domain, secure) {
	          var cookie = [];
	          cookie.push(name + '=' + encodeURIComponent(value));

	          if (utils.isNumber(expires)) {
	            cookie.push('expires=' + new Date(expires).toGMTString());
	          }

	          if (utils.isString(path)) {
	            cookie.push('path=' + path);
	          }

	          if (utils.isString(domain)) {
	            cookie.push('domain=' + domain);
	          }

	          if (secure === true) {
	            cookie.push('secure');
	          }

	          document.cookie = cookie.join('; ');
	        },

	        read: function read(name) {
	          var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
	          return (match ? decodeURIComponent(match[3]) : null);
	        },

	        remove: function remove(name) {
	          this.write(name, '', Date.now() - 86400000);
	        }
	      };
	    })() :

	  // Non standard browser env (web workers, react-native) lack needed support.
	    (function nonStandardBrowserEnv() {
	      return {
	        write: function write() {},
	        read: function read() { return null; },
	        remove: function remove() {}
	      };
	    })()
	);
	return cookies;
}

/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
var isAbsoluteURL$1 = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
};

/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
var combineURLs$1 = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
};

var isAbsoluteURL = isAbsoluteURL$1;
var combineURLs = combineURLs$1;

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */
var buildFullPath$1 = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
};

var parseHeaders;
var hasRequiredParseHeaders;

function requireParseHeaders () {
	if (hasRequiredParseHeaders) return parseHeaders;
	hasRequiredParseHeaders = 1;

	var utils = utils$9;

	// Headers whose duplicates are ignored by node
	// c.f. https://nodejs.org/api/http.html#http_message_headers
	var ignoreDuplicateOf = [
	  'age', 'authorization', 'content-length', 'content-type', 'etag',
	  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
	  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
	  'referer', 'retry-after', 'user-agent'
	];

	/**
	 * Parse headers into an object
	 *
	 * ```
	 * Date: Wed, 27 Aug 2014 08:58:49 GMT
	 * Content-Type: application/json
	 * Connection: keep-alive
	 * Transfer-Encoding: chunked
	 * ```
	 *
	 * @param {String} headers Headers needing to be parsed
	 * @returns {Object} Headers parsed into an object
	 */
	parseHeaders = function parseHeaders(headers) {
	  var parsed = {};
	  var key;
	  var val;
	  var i;

	  if (!headers) { return parsed; }

	  utils.forEach(headers.split('\n'), function parser(line) {
	    i = line.indexOf(':');
	    key = utils.trim(line.substr(0, i)).toLowerCase();
	    val = utils.trim(line.substr(i + 1));

	    if (key) {
	      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
	        return;
	      }
	      if (key === 'set-cookie') {
	        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
	      } else {
	        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
	      }
	    }
	  });

	  return parsed;
	};
	return parseHeaders;
}

var isURLSameOrigin;
var hasRequiredIsURLSameOrigin;

function requireIsURLSameOrigin () {
	if (hasRequiredIsURLSameOrigin) return isURLSameOrigin;
	hasRequiredIsURLSameOrigin = 1;

	var utils = utils$9;

	isURLSameOrigin = (
	  utils.isStandardBrowserEnv() ?

	  // Standard browser envs have full support of the APIs needed to test
	  // whether the request URL is of the same origin as current location.
	    (function standardBrowserEnv() {
	      var msie = /(msie|trident)/i.test(navigator.userAgent);
	      var urlParsingNode = document.createElement('a');
	      var originURL;

	      /**
	    * Parse a URL to discover it's components
	    *
	    * @param {String} url The URL to be parsed
	    * @returns {Object}
	    */
	      function resolveURL(url) {
	        var href = url;

	        if (msie) {
	        // IE needs attribute set twice to normalize properties
	          urlParsingNode.setAttribute('href', href);
	          href = urlParsingNode.href;
	        }

	        urlParsingNode.setAttribute('href', href);

	        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
	        return {
	          href: urlParsingNode.href,
	          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
	          host: urlParsingNode.host,
	          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
	          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
	          hostname: urlParsingNode.hostname,
	          port: urlParsingNode.port,
	          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
	            urlParsingNode.pathname :
	            '/' + urlParsingNode.pathname
	        };
	      }

	      originURL = resolveURL(window.location.href);

	      /**
	    * Determine if a URL shares the same origin as the current location
	    *
	    * @param {String} requestURL The URL to test
	    * @returns {boolean} True if URL shares the same origin, otherwise false
	    */
	      return function isURLSameOrigin(requestURL) {
	        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
	        return (parsed.protocol === originURL.protocol &&
	            parsed.host === originURL.host);
	      };
	    })() :

	  // Non standard browser envs (web workers, react-native) lack needed support.
	    (function nonStandardBrowserEnv() {
	      return function isURLSameOrigin() {
	        return true;
	      };
	    })()
	);
	return isURLSameOrigin;
}

var CanceledError_1;
var hasRequiredCanceledError;

function requireCanceledError () {
	if (hasRequiredCanceledError) return CanceledError_1;
	hasRequiredCanceledError = 1;

	var AxiosError = requireAxiosError();
	var utils = utils$9;

	/**
	 * A `CanceledError` is an object that is thrown when an operation is canceled.
	 *
	 * @class
	 * @param {string=} message The message.
	 */
	function CanceledError(message) {
	  // eslint-disable-next-line no-eq-null,eqeqeq
	  AxiosError.call(this, message == null ? 'canceled' : message, AxiosError.ERR_CANCELED);
	  this.name = 'CanceledError';
	}

	utils.inherits(CanceledError, AxiosError, {
	  __CANCEL__: true
	});

	CanceledError_1 = CanceledError;
	return CanceledError_1;
}

var parseProtocol;
var hasRequiredParseProtocol;

function requireParseProtocol () {
	if (hasRequiredParseProtocol) return parseProtocol;
	hasRequiredParseProtocol = 1;

	parseProtocol = function parseProtocol(url) {
	  var match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
	  return match && match[1] || '';
	};
	return parseProtocol;
}

var xhr;
var hasRequiredXhr;

function requireXhr () {
	if (hasRequiredXhr) return xhr;
	hasRequiredXhr = 1;

	var utils = utils$9;
	var settle = requireSettle();
	var cookies = requireCookies();
	var buildURL = buildURL$1;
	var buildFullPath = buildFullPath$1;
	var parseHeaders = requireParseHeaders();
	var isURLSameOrigin = requireIsURLSameOrigin();
	var transitionalDefaults = transitional;
	var AxiosError = requireAxiosError();
	var CanceledError = requireCanceledError();
	var parseProtocol = requireParseProtocol();

	xhr = function xhrAdapter(config) {
	  return new Promise(function dispatchXhrRequest(resolve, reject) {
	    var requestData = config.data;
	    var requestHeaders = config.headers;
	    var responseType = config.responseType;
	    var onCanceled;
	    function done() {
	      if (config.cancelToken) {
	        config.cancelToken.unsubscribe(onCanceled);
	      }

	      if (config.signal) {
	        config.signal.removeEventListener('abort', onCanceled);
	      }
	    }

	    if (utils.isFormData(requestData) && utils.isStandardBrowserEnv()) {
	      delete requestHeaders['Content-Type']; // Let the browser set it
	    }

	    var request = new XMLHttpRequest();

	    // HTTP basic authentication
	    if (config.auth) {
	      var username = config.auth.username || '';
	      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
	      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
	    }

	    var fullPath = buildFullPath(config.baseURL, config.url);

	    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

	    // Set the request timeout in MS
	    request.timeout = config.timeout;

	    function onloadend() {
	      if (!request) {
	        return;
	      }
	      // Prepare the response
	      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
	      var responseData = !responseType || responseType === 'text' ||  responseType === 'json' ?
	        request.responseText : request.response;
	      var response = {
	        data: responseData,
	        status: request.status,
	        statusText: request.statusText,
	        headers: responseHeaders,
	        config: config,
	        request: request
	      };

	      settle(function _resolve(value) {
	        resolve(value);
	        done();
	      }, function _reject(err) {
	        reject(err);
	        done();
	      }, response);

	      // Clean up request
	      request = null;
	    }

	    if ('onloadend' in request) {
	      // Use onloadend if available
	      request.onloadend = onloadend;
	    } else {
	      // Listen for ready state to emulate onloadend
	      request.onreadystatechange = function handleLoad() {
	        if (!request || request.readyState !== 4) {
	          return;
	        }

	        // The request errored out and we didn't get a response, this will be
	        // handled by onerror instead
	        // With one exception: request that using file: protocol, most browsers
	        // will return status as 0 even though it's a successful request
	        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
	          return;
	        }
	        // readystate handler is calling before onerror or ontimeout handlers,
	        // so we should call onloadend on the next 'tick'
	        setTimeout(onloadend);
	      };
	    }

	    // Handle browser request cancellation (as opposed to a manual cancellation)
	    request.onabort = function handleAbort() {
	      if (!request) {
	        return;
	      }

	      reject(new AxiosError('Request aborted', AxiosError.ECONNABORTED, config, request));

	      // Clean up request
	      request = null;
	    };

	    // Handle low level network errors
	    request.onerror = function handleError() {
	      // Real errors are hidden from us by the browser
	      // onerror should only fire if it's a network error
	      reject(new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request, request));

	      // Clean up request
	      request = null;
	    };

	    // Handle timeout
	    request.ontimeout = function handleTimeout() {
	      var timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';
	      var transitional = config.transitional || transitionalDefaults;
	      if (config.timeoutErrorMessage) {
	        timeoutErrorMessage = config.timeoutErrorMessage;
	      }
	      reject(new AxiosError(
	        timeoutErrorMessage,
	        transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
	        config,
	        request));

	      // Clean up request
	      request = null;
	    };

	    // Add xsrf header
	    // This is only done if running in a standard browser environment.
	    // Specifically not if we're in a web worker, or react-native.
	    if (utils.isStandardBrowserEnv()) {
	      // Add xsrf header
	      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
	        cookies.read(config.xsrfCookieName) :
	        undefined;

	      if (xsrfValue) {
	        requestHeaders[config.xsrfHeaderName] = xsrfValue;
	      }
	    }

	    // Add headers to the request
	    if ('setRequestHeader' in request) {
	      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
	        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
	          // Remove Content-Type if data is undefined
	          delete requestHeaders[key];
	        } else {
	          // Otherwise add header to the request
	          request.setRequestHeader(key, val);
	        }
	      });
	    }

	    // Add withCredentials to request if needed
	    if (!utils.isUndefined(config.withCredentials)) {
	      request.withCredentials = !!config.withCredentials;
	    }

	    // Add responseType to request if needed
	    if (responseType && responseType !== 'json') {
	      request.responseType = config.responseType;
	    }

	    // Handle progress if needed
	    if (typeof config.onDownloadProgress === 'function') {
	      request.addEventListener('progress', config.onDownloadProgress);
	    }

	    // Not all browsers support upload events
	    if (typeof config.onUploadProgress === 'function' && request.upload) {
	      request.upload.addEventListener('progress', config.onUploadProgress);
	    }

	    if (config.cancelToken || config.signal) {
	      // Handle cancellation
	      // eslint-disable-next-line func-names
	      onCanceled = function(cancel) {
	        if (!request) {
	          return;
	        }
	        reject(!cancel || (cancel && cancel.type) ? new CanceledError() : cancel);
	        request.abort();
	        request = null;
	      };

	      config.cancelToken && config.cancelToken.subscribe(onCanceled);
	      if (config.signal) {
	        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);
	      }
	    }

	    if (!requestData) {
	      requestData = null;
	    }

	    var protocol = parseProtocol(fullPath);

	    if (protocol && [ 'http', 'https', 'file' ].indexOf(protocol) === -1) {
	      reject(new AxiosError('Unsupported protocol ' + protocol + ':', AxiosError.ERR_BAD_REQUEST, config));
	      return;
	    }


	    // Send the request
	    request.send(requestData);
	  });
	};
	return xhr;
}

var followRedirects = {exports: {}};

var src = {exports: {}};

var browser$1 = {exports: {}};

/**
 * Helpers.
 */

var ms;
var hasRequiredMs;

function requireMs () {
	if (hasRequiredMs) return ms;
	hasRequiredMs = 1;
	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var w = d * 7;
	var y = d * 365.25;

	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} [options]
	 * @throws {Error} throw an error if val is not a non-empty string or a number
	 * @return {String|Number}
	 * @api public
	 */

	ms = function(val, options) {
	  options = options || {};
	  var type = typeof val;
	  if (type === 'string' && val.length > 0) {
	    return parse(val);
	  } else if (type === 'number' && isFinite(val)) {
	    return options.long ? fmtLong(val) : fmtShort(val);
	  }
	  throw new Error(
	    'val is not a non-empty string or a valid number. val=' +
	      JSON.stringify(val)
	  );
	};

	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */

	function parse(str) {
	  str = String(str);
	  if (str.length > 100) {
	    return;
	  }
	  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
	    str
	  );
	  if (!match) {
	    return;
	  }
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y;
	    case 'weeks':
	    case 'week':
	    case 'w':
	      return n * w;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s;
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n;
	    default:
	      return undefined;
	  }
	}

	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function fmtShort(ms) {
	  var msAbs = Math.abs(ms);
	  if (msAbs >= d) {
	    return Math.round(ms / d) + 'd';
	  }
	  if (msAbs >= h) {
	    return Math.round(ms / h) + 'h';
	  }
	  if (msAbs >= m) {
	    return Math.round(ms / m) + 'm';
	  }
	  if (msAbs >= s) {
	    return Math.round(ms / s) + 's';
	  }
	  return ms + 'ms';
	}

	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function fmtLong(ms) {
	  var msAbs = Math.abs(ms);
	  if (msAbs >= d) {
	    return plural(ms, msAbs, d, 'day');
	  }
	  if (msAbs >= h) {
	    return plural(ms, msAbs, h, 'hour');
	  }
	  if (msAbs >= m) {
	    return plural(ms, msAbs, m, 'minute');
	  }
	  if (msAbs >= s) {
	    return plural(ms, msAbs, s, 'second');
	  }
	  return ms + ' ms';
	}

	/**
	 * Pluralization helper.
	 */

	function plural(ms, msAbs, n, name) {
	  var isPlural = msAbs >= n * 1.5;
	  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
	}
	return ms;
}

var common;
var hasRequiredCommon;

function requireCommon () {
	if (hasRequiredCommon) return common;
	hasRequiredCommon = 1;
	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 */

	function setup(env) {
		createDebug.debug = createDebug;
		createDebug.default = createDebug;
		createDebug.coerce = coerce;
		createDebug.disable = disable;
		createDebug.enable = enable;
		createDebug.enabled = enabled;
		createDebug.humanize = requireMs();
		createDebug.destroy = destroy;

		Object.keys(env).forEach(key => {
			createDebug[key] = env[key];
		});

		/**
		* The currently active debug mode names, and names to skip.
		*/

		createDebug.names = [];
		createDebug.skips = [];

		/**
		* Map of special "%n" handling functions, for the debug "format" argument.
		*
		* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
		*/
		createDebug.formatters = {};

		/**
		* Selects a color for a debug namespace
		* @param {String} namespace The namespace string for the debug instance to be colored
		* @return {Number|String} An ANSI color code for the given namespace
		* @api private
		*/
		function selectColor(namespace) {
			let hash = 0;

			for (let i = 0; i < namespace.length; i++) {
				hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
				hash |= 0; // Convert to 32bit integer
			}

			return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
		}
		createDebug.selectColor = selectColor;

		/**
		* Create a debugger with the given `namespace`.
		*
		* @param {String} namespace
		* @return {Function}
		* @api public
		*/
		function createDebug(namespace) {
			let prevTime;
			let enableOverride = null;
			let namespacesCache;
			let enabledCache;

			function debug(...args) {
				// Disabled?
				if (!debug.enabled) {
					return;
				}

				const self = debug;

				// Set `diff` timestamp
				const curr = Number(new Date());
				const ms = curr - (prevTime || curr);
				self.diff = ms;
				self.prev = prevTime;
				self.curr = curr;
				prevTime = curr;

				args[0] = createDebug.coerce(args[0]);

				if (typeof args[0] !== 'string') {
					// Anything else let's inspect with %O
					args.unshift('%O');
				}

				// Apply any `formatters` transformations
				let index = 0;
				args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
					// If we encounter an escaped % then don't increase the array index
					if (match === '%%') {
						return '%';
					}
					index++;
					const formatter = createDebug.formatters[format];
					if (typeof formatter === 'function') {
						const val = args[index];
						match = formatter.call(self, val);

						// Now we need to remove `args[index]` since it's inlined in the `format`
						args.splice(index, 1);
						index--;
					}
					return match;
				});

				// Apply env-specific formatting (colors, etc.)
				createDebug.formatArgs.call(self, args);

				const logFn = self.log || createDebug.log;
				logFn.apply(self, args);
			}

			debug.namespace = namespace;
			debug.useColors = createDebug.useColors();
			debug.color = createDebug.selectColor(namespace);
			debug.extend = extend;
			debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

			Object.defineProperty(debug, 'enabled', {
				enumerable: true,
				configurable: false,
				get: () => {
					if (enableOverride !== null) {
						return enableOverride;
					}
					if (namespacesCache !== createDebug.namespaces) {
						namespacesCache = createDebug.namespaces;
						enabledCache = createDebug.enabled(namespace);
					}

					return enabledCache;
				},
				set: v => {
					enableOverride = v;
				}
			});

			// Env-specific initialization logic for debug instances
			if (typeof createDebug.init === 'function') {
				createDebug.init(debug);
			}

			return debug;
		}

		function extend(namespace, delimiter) {
			const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
			newDebug.log = this.log;
			return newDebug;
		}

		/**
		* Enables a debug mode by namespaces. This can include modes
		* separated by a colon and wildcards.
		*
		* @param {String} namespaces
		* @api public
		*/
		function enable(namespaces) {
			createDebug.save(namespaces);
			createDebug.namespaces = namespaces;

			createDebug.names = [];
			createDebug.skips = [];

			let i;
			const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
			const len = split.length;

			for (i = 0; i < len; i++) {
				if (!split[i]) {
					// ignore empty strings
					continue;
				}

				namespaces = split[i].replace(/\*/g, '.*?');

				if (namespaces[0] === '-') {
					createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
				} else {
					createDebug.names.push(new RegExp('^' + namespaces + '$'));
				}
			}
		}

		/**
		* Disable debug output.
		*
		* @return {String} namespaces
		* @api public
		*/
		function disable() {
			const namespaces = [
				...createDebug.names.map(toNamespace),
				...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
			].join(',');
			createDebug.enable('');
			return namespaces;
		}

		/**
		* Returns true if the given mode name is enabled, false otherwise.
		*
		* @param {String} name
		* @return {Boolean}
		* @api public
		*/
		function enabled(name) {
			if (name[name.length - 1] === '*') {
				return true;
			}

			let i;
			let len;

			for (i = 0, len = createDebug.skips.length; i < len; i++) {
				if (createDebug.skips[i].test(name)) {
					return false;
				}
			}

			for (i = 0, len = createDebug.names.length; i < len; i++) {
				if (createDebug.names[i].test(name)) {
					return true;
				}
			}

			return false;
		}

		/**
		* Convert regexp to namespace
		*
		* @param {RegExp} regxep
		* @return {String} namespace
		* @api private
		*/
		function toNamespace(regexp) {
			return regexp.toString()
				.substring(2, regexp.toString().length - 2)
				.replace(/\.\*\?$/, '*');
		}

		/**
		* Coerce `val`.
		*
		* @param {Mixed} val
		* @return {Mixed}
		* @api private
		*/
		function coerce(val) {
			if (val instanceof Error) {
				return val.stack || val.message;
			}
			return val;
		}

		/**
		* XXX DO NOT USE. This is a temporary stub function.
		* XXX It WILL be removed in the next major release.
		*/
		function destroy() {
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}

		createDebug.enable(createDebug.load());

		return createDebug;
	}

	common = setup;
	return common;
}

var hasRequiredBrowser$1;

function requireBrowser$1 () {
	if (hasRequiredBrowser$1) return browser$1.exports;
	hasRequiredBrowser$1 = 1;
	(function (module, exports) {
		/**
		 * This is the web browser implementation of `debug()`.
		 */

		exports.formatArgs = formatArgs;
		exports.save = save;
		exports.load = load;
		exports.useColors = useColors;
		exports.storage = localstorage();
		exports.destroy = (() => {
			let warned = false;

			return () => {
				if (!warned) {
					warned = true;
					console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
				}
			};
		})();

		/**
		 * Colors.
		 */

		exports.colors = [
			'#0000CC',
			'#0000FF',
			'#0033CC',
			'#0033FF',
			'#0066CC',
			'#0066FF',
			'#0099CC',
			'#0099FF',
			'#00CC00',
			'#00CC33',
			'#00CC66',
			'#00CC99',
			'#00CCCC',
			'#00CCFF',
			'#3300CC',
			'#3300FF',
			'#3333CC',
			'#3333FF',
			'#3366CC',
			'#3366FF',
			'#3399CC',
			'#3399FF',
			'#33CC00',
			'#33CC33',
			'#33CC66',
			'#33CC99',
			'#33CCCC',
			'#33CCFF',
			'#6600CC',
			'#6600FF',
			'#6633CC',
			'#6633FF',
			'#66CC00',
			'#66CC33',
			'#9900CC',
			'#9900FF',
			'#9933CC',
			'#9933FF',
			'#99CC00',
			'#99CC33',
			'#CC0000',
			'#CC0033',
			'#CC0066',
			'#CC0099',
			'#CC00CC',
			'#CC00FF',
			'#CC3300',
			'#CC3333',
			'#CC3366',
			'#CC3399',
			'#CC33CC',
			'#CC33FF',
			'#CC6600',
			'#CC6633',
			'#CC9900',
			'#CC9933',
			'#CCCC00',
			'#CCCC33',
			'#FF0000',
			'#FF0033',
			'#FF0066',
			'#FF0099',
			'#FF00CC',
			'#FF00FF',
			'#FF3300',
			'#FF3333',
			'#FF3366',
			'#FF3399',
			'#FF33CC',
			'#FF33FF',
			'#FF6600',
			'#FF6633',
			'#FF9900',
			'#FF9933',
			'#FFCC00',
			'#FFCC33'
		];

		/**
		 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
		 * and the Firebug extension (any Firefox version) are known
		 * to support "%c" CSS customizations.
		 *
		 * TODO: add a `localStorage` variable to explicitly enable/disable colors
		 */

		// eslint-disable-next-line complexity
		function useColors() {
			// NB: In an Electron preload script, document will be defined but not fully
			// initialized. Since we know we're in Chrome, we'll just detect this case
			// explicitly
			if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
				return true;
			}

			// Internet Explorer and Edge do not support colors.
			if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
				return false;
			}

			// Is webkit? http://stackoverflow.com/a/16459606/376773
			// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
			return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
				// Is firebug? http://stackoverflow.com/a/398120/376773
				(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
				// Is firefox >= v31?
				// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
				(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
				// Double check webkit in userAgent just in case we are in a worker
				(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
		}

		/**
		 * Colorize log arguments if enabled.
		 *
		 * @api public
		 */

		function formatArgs(args) {
			args[0] = (this.useColors ? '%c' : '') +
				this.namespace +
				(this.useColors ? ' %c' : ' ') +
				args[0] +
				(this.useColors ? '%c ' : ' ') +
				'+' + module.exports.humanize(this.diff);

			if (!this.useColors) {
				return;
			}

			const c = 'color: ' + this.color;
			args.splice(1, 0, c, 'color: inherit');

			// The final "%c" is somewhat tricky, because there could be other
			// arguments passed either before or after the %c, so we need to
			// figure out the correct index to insert the CSS into
			let index = 0;
			let lastC = 0;
			args[0].replace(/%[a-zA-Z%]/g, match => {
				if (match === '%%') {
					return;
				}
				index++;
				if (match === '%c') {
					// We only are interested in the *last* %c
					// (the user may have provided their own)
					lastC = index;
				}
			});

			args.splice(lastC, 0, c);
		}

		/**
		 * Invokes `console.debug()` when available.
		 * No-op when `console.debug` is not a "function".
		 * If `console.debug` is not available, falls back
		 * to `console.log`.
		 *
		 * @api public
		 */
		exports.log = console.debug || console.log || (() => {});

		/**
		 * Save `namespaces`.
		 *
		 * @param {String} namespaces
		 * @api private
		 */
		function save(namespaces) {
			try {
				if (namespaces) {
					exports.storage.setItem('debug', namespaces);
				} else {
					exports.storage.removeItem('debug');
				}
			} catch (error) {
				// Swallow
				// XXX (@Qix-) should we be logging these?
			}
		}

		/**
		 * Load `namespaces`.
		 *
		 * @return {String} returns the previously persisted debug modes
		 * @api private
		 */
		function load() {
			let r;
			try {
				r = exports.storage.getItem('debug');
			} catch (error) {
				// Swallow
				// XXX (@Qix-) should we be logging these?
			}

			// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
			if (!r && typeof process !== 'undefined' && 'env' in process) {
				r = process.env.DEBUG;
			}

			return r;
		}

		/**
		 * Localstorage attempts to return the localstorage.
		 *
		 * This is necessary because safari throws
		 * when a user disables cookies/localstorage
		 * and you attempt to access it.
		 *
		 * @return {LocalStorage}
		 * @api private
		 */

		function localstorage() {
			try {
				// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
				// The Browser also has localStorage in the global context.
				return localStorage;
			} catch (error) {
				// Swallow
				// XXX (@Qix-) should we be logging these?
			}
		}

		module.exports = requireCommon()(exports);

		const {formatters} = module.exports;

		/**
		 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
		 */

		formatters.j = function (v) {
			try {
				return JSON.stringify(v);
			} catch (error) {
				return '[UnexpectedJSONParseError]: ' + error.message;
			}
		}; 
	} (browser$1, browser$1.exports));
	return browser$1.exports;
}

var node = {exports: {}};

/* eslint-env browser */

var browser;
var hasRequiredBrowser;

function requireBrowser () {
	if (hasRequiredBrowser) return browser;
	hasRequiredBrowser = 1;

	function getChromeVersion() {
		const matches = /(Chrome|Chromium)\/(?<chromeVersion>\d+)\./.exec(navigator.userAgent);

		if (!matches) {
			return;
		}

		return Number.parseInt(matches.groups.chromeVersion, 10);
	}

	const colorSupport = getChromeVersion() >= 69 ? {
		level: 1,
		hasBasic: true,
		has256: false,
		has16m: false
	} : false;

	browser = {
		stdout: colorSupport,
		stderr: colorSupport
	};
	return browser;
}

var hasRequiredNode;

function requireNode () {
	if (hasRequiredNode) return node.exports;
	hasRequiredNode = 1;
	(function (module, exports) {
		const tty = require$$5$1;
		const util = require$$1$2;

		/**
		 * This is the Node.js implementation of `debug()`.
		 */

		exports.init = init;
		exports.log = log;
		exports.formatArgs = formatArgs;
		exports.save = save;
		exports.load = load;
		exports.useColors = useColors;
		exports.destroy = util.deprecate(
			() => {},
			'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
		);

		/**
		 * Colors.
		 */

		exports.colors = [6, 2, 3, 4, 5, 1];

		try {
			// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
			// eslint-disable-next-line import/no-extraneous-dependencies
			const supportsColor = requireBrowser();

			if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
				exports.colors = [
					20,
					21,
					26,
					27,
					32,
					33,
					38,
					39,
					40,
					41,
					42,
					43,
					44,
					45,
					56,
					57,
					62,
					63,
					68,
					69,
					74,
					75,
					76,
					77,
					78,
					79,
					80,
					81,
					92,
					93,
					98,
					99,
					112,
					113,
					128,
					129,
					134,
					135,
					148,
					149,
					160,
					161,
					162,
					163,
					164,
					165,
					166,
					167,
					168,
					169,
					170,
					171,
					172,
					173,
					178,
					179,
					184,
					185,
					196,
					197,
					198,
					199,
					200,
					201,
					202,
					203,
					204,
					205,
					206,
					207,
					208,
					209,
					214,
					215,
					220,
					221
				];
			}
		} catch (error) {
			// Swallow - we only care if `supports-color` is available; it doesn't have to be.
		}

		/**
		 * Build up the default `inspectOpts` object from the environment variables.
		 *
		 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
		 */

		exports.inspectOpts = Object.keys(process.env).filter(key => {
			return /^debug_/i.test(key);
		}).reduce((obj, key) => {
			// Camel-case
			const prop = key
				.substring(6)
				.toLowerCase()
				.replace(/_([a-z])/g, (_, k) => {
					return k.toUpperCase();
				});

			// Coerce string value into JS value
			let val = process.env[key];
			if (/^(yes|on|true|enabled)$/i.test(val)) {
				val = true;
			} else if (/^(no|off|false|disabled)$/i.test(val)) {
				val = false;
			} else if (val === 'null') {
				val = null;
			} else {
				val = Number(val);
			}

			obj[prop] = val;
			return obj;
		}, {});

		/**
		 * Is stdout a TTY? Colored output is enabled when `true`.
		 */

		function useColors() {
			return 'colors' in exports.inspectOpts ?
				Boolean(exports.inspectOpts.colors) :
				tty.isatty(process.stderr.fd);
		}

		/**
		 * Adds ANSI color escape codes if enabled.
		 *
		 * @api public
		 */

		function formatArgs(args) {
			const {namespace: name, useColors} = this;

			if (useColors) {
				const c = this.color;
				const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
				const prefix = `  ${colorCode};1m${name} \u001B[0m`;

				args[0] = prefix + args[0].split('\n').join('\n' + prefix);
				args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
			} else {
				args[0] = getDate() + name + ' ' + args[0];
			}
		}

		function getDate() {
			if (exports.inspectOpts.hideDate) {
				return '';
			}
			return new Date().toISOString() + ' ';
		}

		/**
		 * Invokes `util.format()` with the specified arguments and writes to stderr.
		 */

		function log(...args) {
			return process.stderr.write(util.format(...args) + '\n');
		}

		/**
		 * Save `namespaces`.
		 *
		 * @param {String} namespaces
		 * @api private
		 */
		function save(namespaces) {
			if (namespaces) {
				process.env.DEBUG = namespaces;
			} else {
				// If you set a process.env field to null or undefined, it gets cast to the
				// string 'null' or 'undefined'. Just delete instead.
				delete process.env.DEBUG;
			}
		}

		/**
		 * Load `namespaces`.
		 *
		 * @return {String} returns the previously persisted debug modes
		 * @api private
		 */

		function load() {
			return process.env.DEBUG;
		}

		/**
		 * Init logic for `debug` instances.
		 *
		 * Create a new `inspectOpts` object in case `useColors` is set
		 * differently for a particular `debug` instance.
		 */

		function init(debug) {
			debug.inspectOpts = {};

			const keys = Object.keys(exports.inspectOpts);
			for (let i = 0; i < keys.length; i++) {
				debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
			}
		}

		module.exports = requireCommon()(exports);

		const {formatters} = module.exports;

		/**
		 * Map %o to `util.inspect()`, all on a single line.
		 */

		formatters.o = function (v) {
			this.inspectOpts.colors = this.useColors;
			return util.inspect(v, this.inspectOpts)
				.split('\n')
				.map(str => str.trim())
				.join(' ');
		};

		/**
		 * Map %O to `util.inspect()`, allowing multiple lines if needed.
		 */

		formatters.O = function (v) {
			this.inspectOpts.colors = this.useColors;
			return util.inspect(v, this.inspectOpts);
		}; 
	} (node, node.exports));
	return node.exports;
}

var hasRequiredSrc;

function requireSrc () {
	if (hasRequiredSrc) return src.exports;
	hasRequiredSrc = 1;
	if (typeof process === 'undefined' || process.type === 'renderer' || browser$3 === true || process.__nwjs) {
		src.exports = requireBrowser$1();
	} else {
		src.exports = requireNode();
	}
	return src.exports;
}

var debug_1;
var hasRequiredDebug;

function requireDebug () {
	if (hasRequiredDebug) return debug_1;
	hasRequiredDebug = 1;
	var debug;

	debug_1 = function () {
	  if (!debug) {
	    try {
	      /* eslint global-require: off */
	      debug = requireSrc()("follow-redirects");
	    }
	    catch (error) { /* */ }
	    if (typeof debug !== "function") {
	      debug = function () { /* */ };
	    }
	  }
	  debug.apply(null, arguments);
	};
	return debug_1;
}

var hasRequiredFollowRedirects;

function requireFollowRedirects () {
	if (hasRequiredFollowRedirects) return followRedirects.exports;
	hasRequiredFollowRedirects = 1;
	var url = require$$2$2;
	var URL = url.URL;
	var http = require$$0$6;
	var https = require$$1$1;
	var Writable = require$$3$1.Writable;
	var assert = require$$0$4;
	var debug = requireDebug();

	// Create handlers that pass events from native requests
	var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
	var eventHandlers = Object.create(null);
	events.forEach(function (event) {
	  eventHandlers[event] = function (arg1, arg2, arg3) {
	    this._redirectable.emit(event, arg1, arg2, arg3);
	  };
	});

	var InvalidUrlError = createErrorType(
	  "ERR_INVALID_URL",
	  "Invalid URL",
	  TypeError
	);
	// Error types with codes
	var RedirectionError = createErrorType(
	  "ERR_FR_REDIRECTION_FAILURE",
	  "Redirected request failed"
	);
	var TooManyRedirectsError = createErrorType(
	  "ERR_FR_TOO_MANY_REDIRECTS",
	  "Maximum number of redirects exceeded"
	);
	var MaxBodyLengthExceededError = createErrorType(
	  "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
	  "Request body larger than maxBodyLength limit"
	);
	var WriteAfterEndError = createErrorType(
	  "ERR_STREAM_WRITE_AFTER_END",
	  "write after end"
	);

	// An HTTP(S) request that can be redirected
	function RedirectableRequest(options, responseCallback) {
	  // Initialize the request
	  Writable.call(this);
	  this._sanitizeOptions(options);
	  this._options = options;
	  this._ended = false;
	  this._ending = false;
	  this._redirectCount = 0;
	  this._redirects = [];
	  this._requestBodyLength = 0;
	  this._requestBodyBuffers = [];

	  // Attach a callback if passed
	  if (responseCallback) {
	    this.on("response", responseCallback);
	  }

	  // React to responses of native requests
	  var self = this;
	  this._onNativeResponse = function (response) {
	    self._processResponse(response);
	  };

	  // Perform the first request
	  this._performRequest();
	}
	RedirectableRequest.prototype = Object.create(Writable.prototype);

	RedirectableRequest.prototype.abort = function () {
	  abortRequest(this._currentRequest);
	  this.emit("abort");
	};

	// Writes buffered data to the current native request
	RedirectableRequest.prototype.write = function (data, encoding, callback) {
	  // Writing is not allowed if end has been called
	  if (this._ending) {
	    throw new WriteAfterEndError();
	  }

	  // Validate input and shift parameters if necessary
	  if (!isString(data) && !isBuffer(data)) {
	    throw new TypeError("data should be a string, Buffer or Uint8Array");
	  }
	  if (isFunction(encoding)) {
	    callback = encoding;
	    encoding = null;
	  }

	  // Ignore empty buffers, since writing them doesn't invoke the callback
	  // https://github.com/nodejs/node/issues/22066
	  if (data.length === 0) {
	    if (callback) {
	      callback();
	    }
	    return;
	  }
	  // Only write when we don't exceed the maximum body length
	  if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
	    this._requestBodyLength += data.length;
	    this._requestBodyBuffers.push({ data: data, encoding: encoding });
	    this._currentRequest.write(data, encoding, callback);
	  }
	  // Error when we exceed the maximum body length
	  else {
	    this.emit("error", new MaxBodyLengthExceededError());
	    this.abort();
	  }
	};

	// Ends the current native request
	RedirectableRequest.prototype.end = function (data, encoding, callback) {
	  // Shift parameters if necessary
	  if (isFunction(data)) {
	    callback = data;
	    data = encoding = null;
	  }
	  else if (isFunction(encoding)) {
	    callback = encoding;
	    encoding = null;
	  }

	  // Write data if needed and end
	  if (!data) {
	    this._ended = this._ending = true;
	    this._currentRequest.end(null, null, callback);
	  }
	  else {
	    var self = this;
	    var currentRequest = this._currentRequest;
	    this.write(data, encoding, function () {
	      self._ended = true;
	      currentRequest.end(null, null, callback);
	    });
	    this._ending = true;
	  }
	};

	// Sets a header value on the current native request
	RedirectableRequest.prototype.setHeader = function (name, value) {
	  this._options.headers[name] = value;
	  this._currentRequest.setHeader(name, value);
	};

	// Clears a header value on the current native request
	RedirectableRequest.prototype.removeHeader = function (name) {
	  delete this._options.headers[name];
	  this._currentRequest.removeHeader(name);
	};

	// Global timeout for all underlying requests
	RedirectableRequest.prototype.setTimeout = function (msecs, callback) {
	  var self = this;

	  // Destroys the socket on timeout
	  function destroyOnTimeout(socket) {
	    socket.setTimeout(msecs);
	    socket.removeListener("timeout", socket.destroy);
	    socket.addListener("timeout", socket.destroy);
	  }

	  // Sets up a timer to trigger a timeout event
	  function startTimer(socket) {
	    if (self._timeout) {
	      clearTimeout(self._timeout);
	    }
	    self._timeout = setTimeout(function () {
	      self.emit("timeout");
	      clearTimer();
	    }, msecs);
	    destroyOnTimeout(socket);
	  }

	  // Stops a timeout from triggering
	  function clearTimer() {
	    // Clear the timeout
	    if (self._timeout) {
	      clearTimeout(self._timeout);
	      self._timeout = null;
	    }

	    // Clean up all attached listeners
	    self.removeListener("abort", clearTimer);
	    self.removeListener("error", clearTimer);
	    self.removeListener("response", clearTimer);
	    if (callback) {
	      self.removeListener("timeout", callback);
	    }
	    if (!self.socket) {
	      self._currentRequest.removeListener("socket", startTimer);
	    }
	  }

	  // Attach callback if passed
	  if (callback) {
	    this.on("timeout", callback);
	  }

	  // Start the timer if or when the socket is opened
	  if (this.socket) {
	    startTimer(this.socket);
	  }
	  else {
	    this._currentRequest.once("socket", startTimer);
	  }

	  // Clean up on events
	  this.on("socket", destroyOnTimeout);
	  this.on("abort", clearTimer);
	  this.on("error", clearTimer);
	  this.on("response", clearTimer);

	  return this;
	};

	// Proxy all other public ClientRequest methods
	[
	  "flushHeaders", "getHeader",
	  "setNoDelay", "setSocketKeepAlive",
	].forEach(function (method) {
	  RedirectableRequest.prototype[method] = function (a, b) {
	    return this._currentRequest[method](a, b);
	  };
	});

	// Proxy all public ClientRequest properties
	["aborted", "connection", "socket"].forEach(function (property) {
	  Object.defineProperty(RedirectableRequest.prototype, property, {
	    get: function () { return this._currentRequest[property]; },
	  });
	});

	RedirectableRequest.prototype._sanitizeOptions = function (options) {
	  // Ensure headers are always present
	  if (!options.headers) {
	    options.headers = {};
	  }

	  // Since http.request treats host as an alias of hostname,
	  // but the url module interprets host as hostname plus port,
	  // eliminate the host property to avoid confusion.
	  if (options.host) {
	    // Use hostname if set, because it has precedence
	    if (!options.hostname) {
	      options.hostname = options.host;
	    }
	    delete options.host;
	  }

	  // Complete the URL object when necessary
	  if (!options.pathname && options.path) {
	    var searchPos = options.path.indexOf("?");
	    if (searchPos < 0) {
	      options.pathname = options.path;
	    }
	    else {
	      options.pathname = options.path.substring(0, searchPos);
	      options.search = options.path.substring(searchPos);
	    }
	  }
	};


	// Executes the next native request (initial or redirect)
	RedirectableRequest.prototype._performRequest = function () {
	  // Load the native protocol
	  var protocol = this._options.protocol;
	  var nativeProtocol = this._options.nativeProtocols[protocol];
	  if (!nativeProtocol) {
	    this.emit("error", new TypeError("Unsupported protocol " + protocol));
	    return;
	  }

	  // If specified, use the agent corresponding to the protocol
	  // (HTTP and HTTPS use different types of agents)
	  if (this._options.agents) {
	    var scheme = protocol.slice(0, -1);
	    this._options.agent = this._options.agents[scheme];
	  }

	  // Create the native request and set up its event handlers
	  var request = this._currentRequest =
	        nativeProtocol.request(this._options, this._onNativeResponse);
	  request._redirectable = this;
	  for (var event of events) {
	    request.on(event, eventHandlers[event]);
	  }

	  // RFC72305.3.1: When making a request directly to an origin server, []
	  // a client MUST send only the absolute path [] as the request-target.
	  this._currentUrl = /^\//.test(this._options.path) ?
	    url.format(this._options) :
	    // When making a request to a proxy, []
	    // a client MUST send the target URI in absolute-form [].
	    this._options.path;

	  // End a redirected request
	  // (The first request must be ended explicitly with RedirectableRequest#end)
	  if (this._isRedirect) {
	    // Write the request entity and end
	    var i = 0;
	    var self = this;
	    var buffers = this._requestBodyBuffers;
	    (function writeNext(error) {
	      // Only write if this request has not been redirected yet
	      /* istanbul ignore else */
	      if (request === self._currentRequest) {
	        // Report any write errors
	        /* istanbul ignore if */
	        if (error) {
	          self.emit("error", error);
	        }
	        // Write the next buffer if there are still left
	        else if (i < buffers.length) {
	          var buffer = buffers[i++];
	          /* istanbul ignore else */
	          if (!request.finished) {
	            request.write(buffer.data, buffer.encoding, writeNext);
	          }
	        }
	        // End the request if `end` has been called on us
	        else if (self._ended) {
	          request.end();
	        }
	      }
	    }());
	  }
	};

	// Processes a response from the current native request
	RedirectableRequest.prototype._processResponse = function (response) {
	  // Store the redirected response
	  var statusCode = response.statusCode;
	  if (this._options.trackRedirects) {
	    this._redirects.push({
	      url: this._currentUrl,
	      headers: response.headers,
	      statusCode: statusCode,
	    });
	  }

	  // RFC72316.4: The 3xx (Redirection) class of status code indicates
	  // that further action needs to be taken by the user agent in order to
	  // fulfill the request. If a Location header field is provided,
	  // the user agent MAY automatically redirect its request to the URI
	  // referenced by the Location field value,
	  // even if the specific status code is not understood.

	  // If the response is not a redirect; return it as-is
	  var location = response.headers.location;
	  if (!location || this._options.followRedirects === false ||
	      statusCode < 300 || statusCode >= 400) {
	    response.responseUrl = this._currentUrl;
	    response.redirects = this._redirects;
	    this.emit("response", response);

	    // Clean up
	    this._requestBodyBuffers = [];
	    return;
	  }

	  // The response is a redirect, so abort the current request
	  abortRequest(this._currentRequest);
	  // Discard the remainder of the response to avoid waiting for data
	  response.destroy();

	  // RFC72316.4: A client SHOULD detect and intervene
	  // in cyclical redirections (i.e., "infinite" redirection loops).
	  if (++this._redirectCount > this._options.maxRedirects) {
	    this.emit("error", new TooManyRedirectsError());
	    return;
	  }

	  // Store the request headers if applicable
	  var requestHeaders;
	  var beforeRedirect = this._options.beforeRedirect;
	  if (beforeRedirect) {
	    requestHeaders = Object.assign({
	      // The Host header was set by nativeProtocol.request
	      Host: response.req.getHeader("host"),
	    }, this._options.headers);
	  }

	  // RFC72316.4: Automatic redirection needs to done with
	  // care for methods not known to be safe, []
	  // RFC72316.4.23: For historical reasons, a user agent MAY change
	  // the request method from POST to GET for the subsequent request.
	  var method = this._options.method;
	  if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" ||
	      // RFC72316.4.4: The 303 (See Other) status code indicates that
	      // the server is redirecting the user agent to a different resource []
	      // A user agent can perform a retrieval request targeting that URI
	      // (a GET or HEAD request if using HTTP) []
	      (statusCode === 303) && !/^(?:GET|HEAD)$/.test(this._options.method)) {
	    this._options.method = "GET";
	    // Drop a possible entity and headers related to it
	    this._requestBodyBuffers = [];
	    removeMatchingHeaders(/^content-/i, this._options.headers);
	  }

	  // Drop the Host header, as the redirect might lead to a different host
	  var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);

	  // If the redirect is relative, carry over the host of the last request
	  var currentUrlParts = url.parse(this._currentUrl);
	  var currentHost = currentHostHeader || currentUrlParts.host;
	  var currentUrl = /^\w+:/.test(location) ? this._currentUrl :
	    url.format(Object.assign(currentUrlParts, { host: currentHost }));

	  // Determine the URL of the redirection
	  var redirectUrl;
	  try {
	    redirectUrl = url.resolve(currentUrl, location);
	  }
	  catch (cause) {
	    this.emit("error", new RedirectionError({ cause: cause }));
	    return;
	  }

	  // Create the redirected request
	  debug("redirecting to", redirectUrl);
	  this._isRedirect = true;
	  var redirectUrlParts = url.parse(redirectUrl);
	  Object.assign(this._options, redirectUrlParts);

	  // Drop confidential headers when redirecting to a less secure protocol
	  // or to a different domain that is not a superdomain
	  if (redirectUrlParts.protocol !== currentUrlParts.protocol &&
	     redirectUrlParts.protocol !== "https:" ||
	     redirectUrlParts.host !== currentHost &&
	     !isSubdomain(redirectUrlParts.host, currentHost)) {
	    removeMatchingHeaders(/^(?:authorization|cookie)$/i, this._options.headers);
	  }

	  // Evaluate the beforeRedirect callback
	  if (isFunction(beforeRedirect)) {
	    var responseDetails = {
	      headers: response.headers,
	      statusCode: statusCode,
	    };
	    var requestDetails = {
	      url: currentUrl,
	      method: method,
	      headers: requestHeaders,
	    };
	    try {
	      beforeRedirect(this._options, responseDetails, requestDetails);
	    }
	    catch (err) {
	      this.emit("error", err);
	      return;
	    }
	    this._sanitizeOptions(this._options);
	  }

	  // Perform the redirected request
	  try {
	    this._performRequest();
	  }
	  catch (cause) {
	    this.emit("error", new RedirectionError({ cause: cause }));
	  }
	};

	// Wraps the key/value object of protocols with redirect functionality
	function wrap(protocols) {
	  // Default settings
	  var exports = {
	    maxRedirects: 21,
	    maxBodyLength: 10 * 1024 * 1024,
	  };

	  // Wrap each protocol
	  var nativeProtocols = {};
	  Object.keys(protocols).forEach(function (scheme) {
	    var protocol = scheme + ":";
	    var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
	    var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);

	    // Executes a request, following redirects
	    function request(input, options, callback) {
	      // Parse parameters
	      if (isString(input)) {
	        var parsed;
	        try {
	          parsed = urlToOptions(new URL(input));
	        }
	        catch (err) {
	          /* istanbul ignore next */
	          parsed = url.parse(input);
	        }
	        if (!isString(parsed.protocol)) {
	          throw new InvalidUrlError({ input });
	        }
	        input = parsed;
	      }
	      else if (URL && (input instanceof URL)) {
	        input = urlToOptions(input);
	      }
	      else {
	        callback = options;
	        options = input;
	        input = { protocol: protocol };
	      }
	      if (isFunction(options)) {
	        callback = options;
	        options = null;
	      }

	      // Set defaults
	      options = Object.assign({
	        maxRedirects: exports.maxRedirects,
	        maxBodyLength: exports.maxBodyLength,
	      }, input, options);
	      options.nativeProtocols = nativeProtocols;
	      if (!isString(options.host) && !isString(options.hostname)) {
	        options.hostname = "::1";
	      }

	      assert.equal(options.protocol, protocol, "protocol mismatch");
	      debug("options", options);
	      return new RedirectableRequest(options, callback);
	    }

	    // Executes a GET request, following redirects
	    function get(input, options, callback) {
	      var wrappedRequest = wrappedProtocol.request(input, options, callback);
	      wrappedRequest.end();
	      return wrappedRequest;
	    }

	    // Expose the properties on the wrapped protocol
	    Object.defineProperties(wrappedProtocol, {
	      request: { value: request, configurable: true, enumerable: true, writable: true },
	      get: { value: get, configurable: true, enumerable: true, writable: true },
	    });
	  });
	  return exports;
	}

	/* istanbul ignore next */
	function noop() { /* empty */ }

	// from https://github.com/nodejs/node/blob/master/lib/internal/url.js
	function urlToOptions(urlObject) {
	  var options = {
	    protocol: urlObject.protocol,
	    hostname: urlObject.hostname.startsWith("[") ?
	      /* istanbul ignore next */
	      urlObject.hostname.slice(1, -1) :
	      urlObject.hostname,
	    hash: urlObject.hash,
	    search: urlObject.search,
	    pathname: urlObject.pathname,
	    path: urlObject.pathname + urlObject.search,
	    href: urlObject.href,
	  };
	  if (urlObject.port !== "") {
	    options.port = Number(urlObject.port);
	  }
	  return options;
	}

	function removeMatchingHeaders(regex, headers) {
	  var lastValue;
	  for (var header in headers) {
	    if (regex.test(header)) {
	      lastValue = headers[header];
	      delete headers[header];
	    }
	  }
	  return (lastValue === null || typeof lastValue === "undefined") ?
	    undefined : String(lastValue).trim();
	}

	function createErrorType(code, message, baseClass) {
	  // Create constructor
	  function CustomError(properties) {
	    Error.captureStackTrace(this, this.constructor);
	    Object.assign(this, properties || {});
	    this.code = code;
	    this.message = this.cause ? message + ": " + this.cause.message : message;
	  }

	  // Attach constructor and set default properties
	  CustomError.prototype = new (baseClass || Error)();
	  CustomError.prototype.constructor = CustomError;
	  CustomError.prototype.name = "Error [" + code + "]";
	  return CustomError;
	}

	function abortRequest(request) {
	  for (var event of events) {
	    request.removeListener(event, eventHandlers[event]);
	  }
	  request.on("error", noop);
	  request.abort();
	}

	function isSubdomain(subdomain, domain) {
	  assert(isString(subdomain) && isString(domain));
	  var dot = subdomain.length - domain.length - 1;
	  return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
	}

	function isString(value) {
	  return typeof value === "string" || value instanceof String;
	}

	function isFunction(value) {
	  return typeof value === "function";
	}

	function isBuffer(value) {
	  return typeof value === "object" && ("length" in value);
	}

	// Exports
	followRedirects.exports = wrap({ http: http, https: https });
	followRedirects.exports.wrap = wrap;
	return followRedirects.exports;
}

var data;
var hasRequiredData;

function requireData () {
	if (hasRequiredData) return data;
	hasRequiredData = 1;
	data = {
	  "version": "0.27.2"
	};
	return data;
}

var http_1;
var hasRequiredHttp;

function requireHttp () {
	if (hasRequiredHttp) return http_1;
	hasRequiredHttp = 1;

	var utils = utils$9;
	var settle = requireSettle();
	var buildFullPath = buildFullPath$1;
	var buildURL = buildURL$1;
	var http = require$$0$6;
	var https = require$$1$1;
	var httpFollow = requireFollowRedirects().http;
	var httpsFollow = requireFollowRedirects().https;
	var url = require$$2$2;
	var zlib = require$$8$1;
	var VERSION = requireData().version;
	var transitionalDefaults = transitional;
	var AxiosError = requireAxiosError();
	var CanceledError = requireCanceledError();

	var isHttps = /https:?/;

	var supportedProtocols = [ 'http:', 'https:', 'file:' ];

	/**
	 *
	 * @param {http.ClientRequestArgs} options
	 * @param {AxiosProxyConfig} proxy
	 * @param {string} location
	 */
	function setProxy(options, proxy, location) {
	  options.hostname = proxy.host;
	  options.host = proxy.host;
	  options.port = proxy.port;
	  options.path = location;

	  // Basic proxy authorization
	  if (proxy.auth) {
	    var base64 = Buffer.from(proxy.auth.username + ':' + proxy.auth.password, 'utf8').toString('base64');
	    options.headers['Proxy-Authorization'] = 'Basic ' + base64;
	  }

	  // If a proxy is used, any redirects must also pass through the proxy
	  options.beforeRedirect = function beforeRedirect(redirection) {
	    redirection.headers.host = redirection.host;
	    setProxy(redirection, proxy, redirection.href);
	  };
	}

	/*eslint consistent-return:0*/
	http_1 = function httpAdapter(config) {
	  return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) {
	    var onCanceled;
	    function done() {
	      if (config.cancelToken) {
	        config.cancelToken.unsubscribe(onCanceled);
	      }

	      if (config.signal) {
	        config.signal.removeEventListener('abort', onCanceled);
	      }
	    }
	    var resolve = function resolve(value) {
	      done();
	      resolvePromise(value);
	    };
	    var rejected = false;
	    var reject = function reject(value) {
	      done();
	      rejected = true;
	      rejectPromise(value);
	    };
	    var data = config.data;
	    var headers = config.headers;
	    var headerNames = {};

	    Object.keys(headers).forEach(function storeLowerName(name) {
	      headerNames[name.toLowerCase()] = name;
	    });

	    // Set User-Agent (required by some servers)
	    // See https://github.com/axios/axios/issues/69
	    if ('user-agent' in headerNames) {
	      // User-Agent is specified; handle case where no UA header is desired
	      if (!headers[headerNames['user-agent']]) {
	        delete headers[headerNames['user-agent']];
	      }
	      // Otherwise, use specified value
	    } else {
	      // Only set header if it hasn't been set in config
	      headers['User-Agent'] = 'axios/' + VERSION;
	    }

	    // support for https://www.npmjs.com/package/form-data api
	    if (utils.isFormData(data) && utils.isFunction(data.getHeaders)) {
	      Object.assign(headers, data.getHeaders());
	    } else if (data && !utils.isStream(data)) {
	      if (isBuffer$2(data)) ; else if (utils.isArrayBuffer(data)) {
	        data = Buffer.from(new Uint8Array(data));
	      } else if (utils.isString(data)) {
	        data = Buffer.from(data, 'utf-8');
	      } else {
	        return reject(new AxiosError(
	          'Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream',
	          AxiosError.ERR_BAD_REQUEST,
	          config
	        ));
	      }

	      if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {
	        return reject(new AxiosError(
	          'Request body larger than maxBodyLength limit',
	          AxiosError.ERR_BAD_REQUEST,
	          config
	        ));
	      }

	      // Add Content-Length header if data exists
	      if (!headerNames['content-length']) {
	        headers['Content-Length'] = data.length;
	      }
	    }

	    // HTTP basic authentication
	    var auth = undefined;
	    if (config.auth) {
	      var username = config.auth.username || '';
	      var password = config.auth.password || '';
	      auth = username + ':' + password;
	    }

	    // Parse url
	    var fullPath = buildFullPath(config.baseURL, config.url);
	    var parsed = url.parse(fullPath);
	    var protocol = parsed.protocol || supportedProtocols[0];

	    if (supportedProtocols.indexOf(protocol) === -1) {
	      return reject(new AxiosError(
	        'Unsupported protocol ' + protocol,
	        AxiosError.ERR_BAD_REQUEST,
	        config
	      ));
	    }

	    if (!auth && parsed.auth) {
	      var urlAuth = parsed.auth.split(':');
	      var urlUsername = urlAuth[0] || '';
	      var urlPassword = urlAuth[1] || '';
	      auth = urlUsername + ':' + urlPassword;
	    }

	    if (auth && headerNames.authorization) {
	      delete headers[headerNames.authorization];
	    }

	    var isHttpsRequest = isHttps.test(protocol);
	    var agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;

	    try {
	      buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\?/, '');
	    } catch (err) {
	      var customErr = new Error(err.message);
	      customErr.config = config;
	      customErr.url = config.url;
	      customErr.exists = true;
	      reject(customErr);
	    }

	    var options = {
	      path: buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\?/, ''),
	      method: config.method.toUpperCase(),
	      headers: headers,
	      agent: agent,
	      agents: { http: config.httpAgent, https: config.httpsAgent },
	      auth: auth
	    };

	    if (config.socketPath) {
	      options.socketPath = config.socketPath;
	    } else {
	      options.hostname = parsed.hostname;
	      options.port = parsed.port;
	    }

	    var proxy = config.proxy;
	    if (!proxy && proxy !== false) {
	      var proxyEnv = protocol.slice(0, -1) + '_proxy';
	      var proxyUrl = process.env[proxyEnv] || process.env[proxyEnv.toUpperCase()];
	      if (proxyUrl) {
	        var parsedProxyUrl = url.parse(proxyUrl);
	        var noProxyEnv = process.env.no_proxy || process.env.NO_PROXY;
	        var shouldProxy = true;

	        if (noProxyEnv) {
	          var noProxy = noProxyEnv.split(',').map(function trim(s) {
	            return s.trim();
	          });

	          shouldProxy = !noProxy.some(function proxyMatch(proxyElement) {
	            if (!proxyElement) {
	              return false;
	            }
	            if (proxyElement === '*') {
	              return true;
	            }
	            if (proxyElement[0] === '.' &&
	                parsed.hostname.substr(parsed.hostname.length - proxyElement.length) === proxyElement) {
	              return true;
	            }

	            return parsed.hostname === proxyElement;
	          });
	        }

	        if (shouldProxy) {
	          proxy = {
	            host: parsedProxyUrl.hostname,
	            port: parsedProxyUrl.port,
	            protocol: parsedProxyUrl.protocol
	          };

	          if (parsedProxyUrl.auth) {
	            var proxyUrlAuth = parsedProxyUrl.auth.split(':');
	            proxy.auth = {
	              username: proxyUrlAuth[0],
	              password: proxyUrlAuth[1]
	            };
	          }
	        }
	      }
	    }

	    if (proxy) {
	      options.headers.host = parsed.hostname + (parsed.port ? ':' + parsed.port : '');
	      setProxy(options, proxy, protocol + '//' + parsed.hostname + (parsed.port ? ':' + parsed.port : '') + options.path);
	    }

	    var transport;
	    var isHttpsProxy = isHttpsRequest && (proxy ? isHttps.test(proxy.protocol) : true);
	    if (config.transport) {
	      transport = config.transport;
	    } else if (config.maxRedirects === 0) {
	      transport = isHttpsProxy ? https : http;
	    } else {
	      if (config.maxRedirects) {
	        options.maxRedirects = config.maxRedirects;
	      }
	      if (config.beforeRedirect) {
	        options.beforeRedirect = config.beforeRedirect;
	      }
	      transport = isHttpsProxy ? httpsFollow : httpFollow;
	    }

	    if (config.maxBodyLength > -1) {
	      options.maxBodyLength = config.maxBodyLength;
	    }

	    if (config.insecureHTTPParser) {
	      options.insecureHTTPParser = config.insecureHTTPParser;
	    }

	    // Create the request
	    var req = transport.request(options, function handleResponse(res) {
	      if (req.aborted) return;

	      // uncompress the response body transparently if required
	      var stream = res;

	      // return the last request in case of redirects
	      var lastRequest = res.req || req;


	      // if no content, is HEAD request or decompress disabled we should not decompress
	      if (res.statusCode !== 204 && lastRequest.method !== 'HEAD' && config.decompress !== false) {
	        switch (res.headers['content-encoding']) {
	        /*eslint default-case:0*/
	        case 'gzip':
	        case 'compress':
	        case 'deflate':
	        // add the unzipper to the body stream processing pipeline
	          stream = stream.pipe(zlib.createUnzip());

	          // remove the content-encoding in order to not confuse downstream operations
	          delete res.headers['content-encoding'];
	          break;
	        }
	      }

	      var response = {
	        status: res.statusCode,
	        statusText: res.statusMessage,
	        headers: res.headers,
	        config: config,
	        request: lastRequest
	      };

	      if (config.responseType === 'stream') {
	        response.data = stream;
	        settle(resolve, reject, response);
	      } else {
	        var responseBuffer = [];
	        var totalResponseBytes = 0;
	        stream.on('data', function handleStreamData(chunk) {
	          responseBuffer.push(chunk);
	          totalResponseBytes += chunk.length;

	          // make sure the content length is not over the maxContentLength if specified
	          if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
	            // stream.destoy() emit aborted event before calling reject() on Node.js v16
	            rejected = true;
	            stream.destroy();
	            reject(new AxiosError('maxContentLength size of ' + config.maxContentLength + ' exceeded',
	              AxiosError.ERR_BAD_RESPONSE, config, lastRequest));
	          }
	        });

	        stream.on('aborted', function handlerStreamAborted() {
	          if (rejected) {
	            return;
	          }
	          stream.destroy();
	          reject(new AxiosError(
	            'maxContentLength size of ' + config.maxContentLength + ' exceeded',
	            AxiosError.ERR_BAD_RESPONSE,
	            config,
	            lastRequest
	          ));
	        });

	        stream.on('error', function handleStreamError(err) {
	          if (req.aborted) return;
	          reject(AxiosError.from(err, null, config, lastRequest));
	        });

	        stream.on('end', function handleStreamEnd() {
	          try {
	            var responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
	            if (config.responseType !== 'arraybuffer') {
	              responseData = responseData.toString(config.responseEncoding);
	              if (!config.responseEncoding || config.responseEncoding === 'utf8') {
	                responseData = utils.stripBOM(responseData);
	              }
	            }
	            response.data = responseData;
	          } catch (err) {
	            reject(AxiosError.from(err, null, config, response.request, response));
	          }
	          settle(resolve, reject, response);
	        });
	      }
	    });

	    // Handle errors
	    req.on('error', function handleRequestError(err) {
	      // @todo remove
	      // if (req.aborted && err.code !== AxiosError.ERR_FR_TOO_MANY_REDIRECTS) return;
	      reject(AxiosError.from(err, null, config, req));
	    });

	    // set tcp keep alive to prevent drop connection by peer
	    req.on('socket', function handleRequestSocket(socket) {
	      // default interval of sending ack packet is 1 minute
	      socket.setKeepAlive(true, 1000 * 60);
	    });

	    // Handle request timeout
	    if (config.timeout) {
	      // This is forcing a int timeout to avoid problems if the `req` interface doesn't handle other types.
	      var timeout = parseInt(config.timeout, 10);

	      if (isNaN(timeout)) {
	        reject(new AxiosError(
	          'error trying to parse `config.timeout` to int',
	          AxiosError.ERR_BAD_OPTION_VALUE,
	          config,
	          req
	        ));

	        return;
	      }

	      // Sometime, the response will be very slow, and does not respond, the connect event will be block by event loop system.
	      // And timer callback will be fired, and abort() will be invoked before connection, then get "socket hang up" and code ECONNRESET.
	      // At this time, if we have a large number of request, nodejs will hang up some socket on background. and the number will up and up.
	      // And then these socket which be hang up will devoring CPU little by little.
	      // ClientRequest.setTimeout will be fired on the specify milliseconds, and can make sure that abort() will be fired after connect.
	      req.setTimeout(timeout, function handleRequestTimeout() {
	        req.abort();
	        var transitional = config.transitional || transitionalDefaults;
	        reject(new AxiosError(
	          'timeout of ' + timeout + 'ms exceeded',
	          transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
	          config,
	          req
	        ));
	      });
	    }

	    if (config.cancelToken || config.signal) {
	      // Handle cancellation
	      // eslint-disable-next-line func-names
	      onCanceled = function(cancel) {
	        if (req.aborted) return;

	        req.abort();
	        reject(!cancel || (cancel && cancel.type) ? new CanceledError() : cancel);
	      };

	      config.cancelToken && config.cancelToken.subscribe(onCanceled);
	      if (config.signal) {
	        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);
	      }
	    }


	    // Send the request
	    if (utils.isStream(data)) {
	      data.on('error', function handleStreamError(err) {
	        reject(AxiosError.from(err, config, null, req));
	      }).pipe(req);
	    } else {
	      req.end(data);
	    }
	  });
	};
	return http_1;
}

var delayed_stream;
var hasRequiredDelayed_stream;

function requireDelayed_stream () {
	if (hasRequiredDelayed_stream) return delayed_stream;
	hasRequiredDelayed_stream = 1;
	var Stream = require$$3$1.Stream;
	var util = require$$1$2;

	delayed_stream = DelayedStream;
	function DelayedStream() {
	  this.source = null;
	  this.dataSize = 0;
	  this.maxDataSize = 1024 * 1024;
	  this.pauseStream = true;

	  this._maxDataSizeExceeded = false;
	  this._released = false;
	  this._bufferedEvents = [];
	}
	util.inherits(DelayedStream, Stream);

	DelayedStream.create = function(source, options) {
	  var delayedStream = new this();

	  options = options || {};
	  for (var option in options) {
	    delayedStream[option] = options[option];
	  }

	  delayedStream.source = source;

	  var realEmit = source.emit;
	  source.emit = function() {
	    delayedStream._handleEmit(arguments);
	    return realEmit.apply(source, arguments);
	  };

	  source.on('error', function() {});
	  if (delayedStream.pauseStream) {
	    source.pause();
	  }

	  return delayedStream;
	};

	Object.defineProperty(DelayedStream.prototype, 'readable', {
	  configurable: true,
	  enumerable: true,
	  get: function() {
	    return this.source.readable;
	  }
	});

	DelayedStream.prototype.setEncoding = function() {
	  return this.source.setEncoding.apply(this.source, arguments);
	};

	DelayedStream.prototype.resume = function() {
	  if (!this._released) {
	    this.release();
	  }

	  this.source.resume();
	};

	DelayedStream.prototype.pause = function() {
	  this.source.pause();
	};

	DelayedStream.prototype.release = function() {
	  this._released = true;

	  this._bufferedEvents.forEach(function(args) {
	    this.emit.apply(this, args);
	  }.bind(this));
	  this._bufferedEvents = [];
	};

	DelayedStream.prototype.pipe = function() {
	  var r = Stream.prototype.pipe.apply(this, arguments);
	  this.resume();
	  return r;
	};

	DelayedStream.prototype._handleEmit = function(args) {
	  if (this._released) {
	    this.emit.apply(this, args);
	    return;
	  }

	  if (args[0] === 'data') {
	    this.dataSize += args[1].length;
	    this._checkIfMaxDataSizeExceeded();
	  }

	  this._bufferedEvents.push(args);
	};

	DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
	  if (this._maxDataSizeExceeded) {
	    return;
	  }

	  if (this.dataSize <= this.maxDataSize) {
	    return;
	  }

	  this._maxDataSizeExceeded = true;
	  var message =
	    'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.';
	  this.emit('error', new Error(message));
	};
	return delayed_stream;
}

var combined_stream;
var hasRequiredCombined_stream;

function requireCombined_stream () {
	if (hasRequiredCombined_stream) return combined_stream;
	hasRequiredCombined_stream = 1;
	var util = require$$1$2;
	var Stream = require$$3$1.Stream;
	var DelayedStream = requireDelayed_stream();

	combined_stream = CombinedStream;
	function CombinedStream() {
	  this.writable = false;
	  this.readable = true;
	  this.dataSize = 0;
	  this.maxDataSize = 2 * 1024 * 1024;
	  this.pauseStreams = true;

	  this._released = false;
	  this._streams = [];
	  this._currentStream = null;
	  this._insideLoop = false;
	  this._pendingNext = false;
	}
	util.inherits(CombinedStream, Stream);

	CombinedStream.create = function(options) {
	  var combinedStream = new this();

	  options = options || {};
	  for (var option in options) {
	    combinedStream[option] = options[option];
	  }

	  return combinedStream;
	};

	CombinedStream.isStreamLike = function(stream) {
	  return (typeof stream !== 'function')
	    && (typeof stream !== 'string')
	    && (typeof stream !== 'boolean')
	    && (typeof stream !== 'number')
	    && (!isBuffer$2(stream));
	};

	CombinedStream.prototype.append = function(stream) {
	  var isStreamLike = CombinedStream.isStreamLike(stream);

	  if (isStreamLike) {
	    if (!(stream instanceof DelayedStream)) {
	      var newStream = DelayedStream.create(stream, {
	        maxDataSize: Infinity,
	        pauseStream: this.pauseStreams,
	      });
	      stream.on('data', this._checkDataSize.bind(this));
	      stream = newStream;
	    }

	    this._handleErrors(stream);

	    if (this.pauseStreams) {
	      stream.pause();
	    }
	  }

	  this._streams.push(stream);
	  return this;
	};

	CombinedStream.prototype.pipe = function(dest, options) {
	  Stream.prototype.pipe.call(this, dest, options);
	  this.resume();
	  return dest;
	};

	CombinedStream.prototype._getNext = function() {
	  this._currentStream = null;

	  if (this._insideLoop) {
	    this._pendingNext = true;
	    return; // defer call
	  }

	  this._insideLoop = true;
	  try {
	    do {
	      this._pendingNext = false;
	      this._realGetNext();
	    } while (this._pendingNext);
	  } finally {
	    this._insideLoop = false;
	  }
	};

	CombinedStream.prototype._realGetNext = function() {
	  var stream = this._streams.shift();


	  if (typeof stream == 'undefined') {
	    this.end();
	    return;
	  }

	  if (typeof stream !== 'function') {
	    this._pipeNext(stream);
	    return;
	  }

	  var getStream = stream;
	  getStream(function(stream) {
	    var isStreamLike = CombinedStream.isStreamLike(stream);
	    if (isStreamLike) {
	      stream.on('data', this._checkDataSize.bind(this));
	      this._handleErrors(stream);
	    }

	    this._pipeNext(stream);
	  }.bind(this));
	};

	CombinedStream.prototype._pipeNext = function(stream) {
	  this._currentStream = stream;

	  var isStreamLike = CombinedStream.isStreamLike(stream);
	  if (isStreamLike) {
	    stream.on('end', this._getNext.bind(this));
	    stream.pipe(this, {end: false});
	    return;
	  }

	  var value = stream;
	  this.write(value);
	  this._getNext();
	};

	CombinedStream.prototype._handleErrors = function(stream) {
	  var self = this;
	  stream.on('error', function(err) {
	    self._emitError(err);
	  });
	};

	CombinedStream.prototype.write = function(data) {
	  this.emit('data', data);
	};

	CombinedStream.prototype.pause = function() {
	  if (!this.pauseStreams) {
	    return;
	  }

	  if(this.pauseStreams && this._currentStream && typeof(this._currentStream.pause) == 'function') this._currentStream.pause();
	  this.emit('pause');
	};

	CombinedStream.prototype.resume = function() {
	  if (!this._released) {
	    this._released = true;
	    this.writable = true;
	    this._getNext();
	  }

	  if(this.pauseStreams && this._currentStream && typeof(this._currentStream.resume) == 'function') this._currentStream.resume();
	  this.emit('resume');
	};

	CombinedStream.prototype.end = function() {
	  this._reset();
	  this.emit('end');
	};

	CombinedStream.prototype.destroy = function() {
	  this._reset();
	  this.emit('close');
	};

	CombinedStream.prototype._reset = function() {
	  this.writable = false;
	  this._streams = [];
	  this._currentStream = null;
	};

	CombinedStream.prototype._checkDataSize = function() {
	  this._updateDataSize();
	  if (this.dataSize <= this.maxDataSize) {
	    return;
	  }

	  var message =
	    'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.';
	  this._emitError(new Error(message));
	};

	CombinedStream.prototype._updateDataSize = function() {
	  this.dataSize = 0;

	  var self = this;
	  this._streams.forEach(function(stream) {
	    if (!stream.dataSize) {
	      return;
	    }

	    self.dataSize += stream.dataSize;
	  });

	  if (this._currentStream && this._currentStream.dataSize) {
	    this.dataSize += this._currentStream.dataSize;
	  }
	};

	CombinedStream.prototype._emitError = function(err) {
	  this._reset();
	  this.emit('error', err);
	};
	return combined_stream;
}

var mimeTypes = {};

var require$$0 = {
	"application/1d-interleaved-parityfec": {
	source: "iana"
},
	"application/3gpdash-qoe-report+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/3gpp-ims+xml": {
	source: "iana",
	compressible: true
},
	"application/3gpphal+json": {
	source: "iana",
	compressible: true
},
	"application/3gpphalforms+json": {
	source: "iana",
	compressible: true
},
	"application/a2l": {
	source: "iana"
},
	"application/ace+cbor": {
	source: "iana"
},
	"application/activemessage": {
	source: "iana"
},
	"application/activity+json": {
	source: "iana",
	compressible: true
},
	"application/alto-costmap+json": {
	source: "iana",
	compressible: true
},
	"application/alto-costmapfilter+json": {
	source: "iana",
	compressible: true
},
	"application/alto-directory+json": {
	source: "iana",
	compressible: true
},
	"application/alto-endpointcost+json": {
	source: "iana",
	compressible: true
},
	"application/alto-endpointcostparams+json": {
	source: "iana",
	compressible: true
},
	"application/alto-endpointprop+json": {
	source: "iana",
	compressible: true
},
	"application/alto-endpointpropparams+json": {
	source: "iana",
	compressible: true
},
	"application/alto-error+json": {
	source: "iana",
	compressible: true
},
	"application/alto-networkmap+json": {
	source: "iana",
	compressible: true
},
	"application/alto-networkmapfilter+json": {
	source: "iana",
	compressible: true
},
	"application/alto-updatestreamcontrol+json": {
	source: "iana",
	compressible: true
},
	"application/alto-updatestreamparams+json": {
	source: "iana",
	compressible: true
},
	"application/aml": {
	source: "iana"
},
	"application/andrew-inset": {
	source: "iana",
	extensions: [
		"ez"
	]
},
	"application/applefile": {
	source: "iana"
},
	"application/applixware": {
	source: "apache",
	extensions: [
		"aw"
	]
},
	"application/at+jwt": {
	source: "iana"
},
	"application/atf": {
	source: "iana"
},
	"application/atfx": {
	source: "iana"
},
	"application/atom+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"atom"
	]
},
	"application/atomcat+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"atomcat"
	]
},
	"application/atomdeleted+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"atomdeleted"
	]
},
	"application/atomicmail": {
	source: "iana"
},
	"application/atomsvc+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"atomsvc"
	]
},
	"application/atsc-dwd+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"dwd"
	]
},
	"application/atsc-dynamic-event-message": {
	source: "iana"
},
	"application/atsc-held+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"held"
	]
},
	"application/atsc-rdt+json": {
	source: "iana",
	compressible: true
},
	"application/atsc-rsat+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rsat"
	]
},
	"application/atxml": {
	source: "iana"
},
	"application/auth-policy+xml": {
	source: "iana",
	compressible: true
},
	"application/bacnet-xdd+zip": {
	source: "iana",
	compressible: false
},
	"application/batch-smtp": {
	source: "iana"
},
	"application/bdoc": {
	compressible: false,
	extensions: [
		"bdoc"
	]
},
	"application/beep+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/calendar+json": {
	source: "iana",
	compressible: true
},
	"application/calendar+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xcs"
	]
},
	"application/call-completion": {
	source: "iana"
},
	"application/cals-1840": {
	source: "iana"
},
	"application/captive+json": {
	source: "iana",
	compressible: true
},
	"application/cbor": {
	source: "iana"
},
	"application/cbor-seq": {
	source: "iana"
},
	"application/cccex": {
	source: "iana"
},
	"application/ccmp+xml": {
	source: "iana",
	compressible: true
},
	"application/ccxml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"ccxml"
	]
},
	"application/cdfx+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"cdfx"
	]
},
	"application/cdmi-capability": {
	source: "iana",
	extensions: [
		"cdmia"
	]
},
	"application/cdmi-container": {
	source: "iana",
	extensions: [
		"cdmic"
	]
},
	"application/cdmi-domain": {
	source: "iana",
	extensions: [
		"cdmid"
	]
},
	"application/cdmi-object": {
	source: "iana",
	extensions: [
		"cdmio"
	]
},
	"application/cdmi-queue": {
	source: "iana",
	extensions: [
		"cdmiq"
	]
},
	"application/cdni": {
	source: "iana"
},
	"application/cea": {
	source: "iana"
},
	"application/cea-2018+xml": {
	source: "iana",
	compressible: true
},
	"application/cellml+xml": {
	source: "iana",
	compressible: true
},
	"application/cfw": {
	source: "iana"
},
	"application/city+json": {
	source: "iana",
	compressible: true
},
	"application/clr": {
	source: "iana"
},
	"application/clue+xml": {
	source: "iana",
	compressible: true
},
	"application/clue_info+xml": {
	source: "iana",
	compressible: true
},
	"application/cms": {
	source: "iana"
},
	"application/cnrp+xml": {
	source: "iana",
	compressible: true
},
	"application/coap-group+json": {
	source: "iana",
	compressible: true
},
	"application/coap-payload": {
	source: "iana"
},
	"application/commonground": {
	source: "iana"
},
	"application/conference-info+xml": {
	source: "iana",
	compressible: true
},
	"application/cose": {
	source: "iana"
},
	"application/cose-key": {
	source: "iana"
},
	"application/cose-key-set": {
	source: "iana"
},
	"application/cpl+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"cpl"
	]
},
	"application/csrattrs": {
	source: "iana"
},
	"application/csta+xml": {
	source: "iana",
	compressible: true
},
	"application/cstadata+xml": {
	source: "iana",
	compressible: true
},
	"application/csvm+json": {
	source: "iana",
	compressible: true
},
	"application/cu-seeme": {
	source: "apache",
	extensions: [
		"cu"
	]
},
	"application/cwt": {
	source: "iana"
},
	"application/cybercash": {
	source: "iana"
},
	"application/dart": {
	compressible: true
},
	"application/dash+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mpd"
	]
},
	"application/dash-patch+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mpp"
	]
},
	"application/dashdelta": {
	source: "iana"
},
	"application/davmount+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"davmount"
	]
},
	"application/dca-rft": {
	source: "iana"
},
	"application/dcd": {
	source: "iana"
},
	"application/dec-dx": {
	source: "iana"
},
	"application/dialog-info+xml": {
	source: "iana",
	compressible: true
},
	"application/dicom": {
	source: "iana"
},
	"application/dicom+json": {
	source: "iana",
	compressible: true
},
	"application/dicom+xml": {
	source: "iana",
	compressible: true
},
	"application/dii": {
	source: "iana"
},
	"application/dit": {
	source: "iana"
},
	"application/dns": {
	source: "iana"
},
	"application/dns+json": {
	source: "iana",
	compressible: true
},
	"application/dns-message": {
	source: "iana"
},
	"application/docbook+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"dbk"
	]
},
	"application/dots+cbor": {
	source: "iana"
},
	"application/dskpp+xml": {
	source: "iana",
	compressible: true
},
	"application/dssc+der": {
	source: "iana",
	extensions: [
		"dssc"
	]
},
	"application/dssc+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xdssc"
	]
},
	"application/dvcs": {
	source: "iana"
},
	"application/ecmascript": {
	source: "iana",
	compressible: true,
	extensions: [
		"es",
		"ecma"
	]
},
	"application/edi-consent": {
	source: "iana"
},
	"application/edi-x12": {
	source: "iana",
	compressible: false
},
	"application/edifact": {
	source: "iana",
	compressible: false
},
	"application/efi": {
	source: "iana"
},
	"application/elm+json": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/elm+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.cap+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/emergencycalldata.comment+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.control+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.deviceinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.ecall.msd": {
	source: "iana"
},
	"application/emergencycalldata.providerinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.serviceinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.subscriberinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.veds+xml": {
	source: "iana",
	compressible: true
},
	"application/emma+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"emma"
	]
},
	"application/emotionml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"emotionml"
	]
},
	"application/encaprtp": {
	source: "iana"
},
	"application/epp+xml": {
	source: "iana",
	compressible: true
},
	"application/epub+zip": {
	source: "iana",
	compressible: false,
	extensions: [
		"epub"
	]
},
	"application/eshop": {
	source: "iana"
},
	"application/exi": {
	source: "iana",
	extensions: [
		"exi"
	]
},
	"application/expect-ct-report+json": {
	source: "iana",
	compressible: true
},
	"application/express": {
	source: "iana",
	extensions: [
		"exp"
	]
},
	"application/fastinfoset": {
	source: "iana"
},
	"application/fastsoap": {
	source: "iana"
},
	"application/fdt+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"fdt"
	]
},
	"application/fhir+json": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/fhir+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/fido.trusted-apps+json": {
	compressible: true
},
	"application/fits": {
	source: "iana"
},
	"application/flexfec": {
	source: "iana"
},
	"application/font-sfnt": {
	source: "iana"
},
	"application/font-tdpfr": {
	source: "iana",
	extensions: [
		"pfr"
	]
},
	"application/font-woff": {
	source: "iana",
	compressible: false
},
	"application/framework-attributes+xml": {
	source: "iana",
	compressible: true
},
	"application/geo+json": {
	source: "iana",
	compressible: true,
	extensions: [
		"geojson"
	]
},
	"application/geo+json-seq": {
	source: "iana"
},
	"application/geopackage+sqlite3": {
	source: "iana"
},
	"application/geoxacml+xml": {
	source: "iana",
	compressible: true
},
	"application/gltf-buffer": {
	source: "iana"
},
	"application/gml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"gml"
	]
},
	"application/gpx+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"gpx"
	]
},
	"application/gxf": {
	source: "apache",
	extensions: [
		"gxf"
	]
},
	"application/gzip": {
	source: "iana",
	compressible: false,
	extensions: [
		"gz"
	]
},
	"application/h224": {
	source: "iana"
},
	"application/held+xml": {
	source: "iana",
	compressible: true
},
	"application/hjson": {
	extensions: [
		"hjson"
	]
},
	"application/http": {
	source: "iana"
},
	"application/hyperstudio": {
	source: "iana",
	extensions: [
		"stk"
	]
},
	"application/ibe-key-request+xml": {
	source: "iana",
	compressible: true
},
	"application/ibe-pkg-reply+xml": {
	source: "iana",
	compressible: true
},
	"application/ibe-pp-data": {
	source: "iana"
},
	"application/iges": {
	source: "iana"
},
	"application/im-iscomposing+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/index": {
	source: "iana"
},
	"application/index.cmd": {
	source: "iana"
},
	"application/index.obj": {
	source: "iana"
},
	"application/index.response": {
	source: "iana"
},
	"application/index.vnd": {
	source: "iana"
},
	"application/inkml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"ink",
		"inkml"
	]
},
	"application/iotp": {
	source: "iana"
},
	"application/ipfix": {
	source: "iana",
	extensions: [
		"ipfix"
	]
},
	"application/ipp": {
	source: "iana"
},
	"application/isup": {
	source: "iana"
},
	"application/its+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"its"
	]
},
	"application/java-archive": {
	source: "apache",
	compressible: false,
	extensions: [
		"jar",
		"war",
		"ear"
	]
},
	"application/java-serialized-object": {
	source: "apache",
	compressible: false,
	extensions: [
		"ser"
	]
},
	"application/java-vm": {
	source: "apache",
	compressible: false,
	extensions: [
		"class"
	]
},
	"application/javascript": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"js",
		"mjs"
	]
},
	"application/jf2feed+json": {
	source: "iana",
	compressible: true
},
	"application/jose": {
	source: "iana"
},
	"application/jose+json": {
	source: "iana",
	compressible: true
},
	"application/jrd+json": {
	source: "iana",
	compressible: true
},
	"application/jscalendar+json": {
	source: "iana",
	compressible: true
},
	"application/json": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"json",
		"map"
	]
},
	"application/json-patch+json": {
	source: "iana",
	compressible: true
},
	"application/json-seq": {
	source: "iana"
},
	"application/json5": {
	extensions: [
		"json5"
	]
},
	"application/jsonml+json": {
	source: "apache",
	compressible: true,
	extensions: [
		"jsonml"
	]
},
	"application/jwk+json": {
	source: "iana",
	compressible: true
},
	"application/jwk-set+json": {
	source: "iana",
	compressible: true
},
	"application/jwt": {
	source: "iana"
},
	"application/kpml-request+xml": {
	source: "iana",
	compressible: true
},
	"application/kpml-response+xml": {
	source: "iana",
	compressible: true
},
	"application/ld+json": {
	source: "iana",
	compressible: true,
	extensions: [
		"jsonld"
	]
},
	"application/lgr+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"lgr"
	]
},
	"application/link-format": {
	source: "iana"
},
	"application/load-control+xml": {
	source: "iana",
	compressible: true
},
	"application/lost+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"lostxml"
	]
},
	"application/lostsync+xml": {
	source: "iana",
	compressible: true
},
	"application/lpf+zip": {
	source: "iana",
	compressible: false
},
	"application/lxf": {
	source: "iana"
},
	"application/mac-binhex40": {
	source: "iana",
	extensions: [
		"hqx"
	]
},
	"application/mac-compactpro": {
	source: "apache",
	extensions: [
		"cpt"
	]
},
	"application/macwriteii": {
	source: "iana"
},
	"application/mads+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mads"
	]
},
	"application/manifest+json": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"webmanifest"
	]
},
	"application/marc": {
	source: "iana",
	extensions: [
		"mrc"
	]
},
	"application/marcxml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mrcx"
	]
},
	"application/mathematica": {
	source: "iana",
	extensions: [
		"ma",
		"nb",
		"mb"
	]
},
	"application/mathml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mathml"
	]
},
	"application/mathml-content+xml": {
	source: "iana",
	compressible: true
},
	"application/mathml-presentation+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-associated-procedure-description+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-deregister+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-envelope+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-msk+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-msk-response+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-protection-description+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-reception-report+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-register+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-register-response+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-schedule+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-user-service-description+xml": {
	source: "iana",
	compressible: true
},
	"application/mbox": {
	source: "iana",
	extensions: [
		"mbox"
	]
},
	"application/media-policy-dataset+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mpf"
	]
},
	"application/media_control+xml": {
	source: "iana",
	compressible: true
},
	"application/mediaservercontrol+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mscml"
	]
},
	"application/merge-patch+json": {
	source: "iana",
	compressible: true
},
	"application/metalink+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"metalink"
	]
},
	"application/metalink4+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"meta4"
	]
},
	"application/mets+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mets"
	]
},
	"application/mf4": {
	source: "iana"
},
	"application/mikey": {
	source: "iana"
},
	"application/mipc": {
	source: "iana"
},
	"application/missing-blocks+cbor-seq": {
	source: "iana"
},
	"application/mmt-aei+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"maei"
	]
},
	"application/mmt-usd+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"musd"
	]
},
	"application/mods+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mods"
	]
},
	"application/moss-keys": {
	source: "iana"
},
	"application/moss-signature": {
	source: "iana"
},
	"application/mosskey-data": {
	source: "iana"
},
	"application/mosskey-request": {
	source: "iana"
},
	"application/mp21": {
	source: "iana",
	extensions: [
		"m21",
		"mp21"
	]
},
	"application/mp4": {
	source: "iana",
	extensions: [
		"mp4s",
		"m4p"
	]
},
	"application/mpeg4-generic": {
	source: "iana"
},
	"application/mpeg4-iod": {
	source: "iana"
},
	"application/mpeg4-iod-xmt": {
	source: "iana"
},
	"application/mrb-consumer+xml": {
	source: "iana",
	compressible: true
},
	"application/mrb-publish+xml": {
	source: "iana",
	compressible: true
},
	"application/msc-ivr+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/msc-mixer+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/msword": {
	source: "iana",
	compressible: false,
	extensions: [
		"doc",
		"dot"
	]
},
	"application/mud+json": {
	source: "iana",
	compressible: true
},
	"application/multipart-core": {
	source: "iana"
},
	"application/mxf": {
	source: "iana",
	extensions: [
		"mxf"
	]
},
	"application/n-quads": {
	source: "iana",
	extensions: [
		"nq"
	]
},
	"application/n-triples": {
	source: "iana",
	extensions: [
		"nt"
	]
},
	"application/nasdata": {
	source: "iana"
},
	"application/news-checkgroups": {
	source: "iana",
	charset: "US-ASCII"
},
	"application/news-groupinfo": {
	source: "iana",
	charset: "US-ASCII"
},
	"application/news-transmission": {
	source: "iana"
},
	"application/nlsml+xml": {
	source: "iana",
	compressible: true
},
	"application/node": {
	source: "iana",
	extensions: [
		"cjs"
	]
},
	"application/nss": {
	source: "iana"
},
	"application/oauth-authz-req+jwt": {
	source: "iana"
},
	"application/oblivious-dns-message": {
	source: "iana"
},
	"application/ocsp-request": {
	source: "iana"
},
	"application/ocsp-response": {
	source: "iana"
},
	"application/octet-stream": {
	source: "iana",
	compressible: false,
	extensions: [
		"bin",
		"dms",
		"lrf",
		"mar",
		"so",
		"dist",
		"distz",
		"pkg",
		"bpk",
		"dump",
		"elc",
		"deploy",
		"exe",
		"dll",
		"deb",
		"dmg",
		"iso",
		"img",
		"msi",
		"msp",
		"msm",
		"buffer"
	]
},
	"application/oda": {
	source: "iana",
	extensions: [
		"oda"
	]
},
	"application/odm+xml": {
	source: "iana",
	compressible: true
},
	"application/odx": {
	source: "iana"
},
	"application/oebps-package+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"opf"
	]
},
	"application/ogg": {
	source: "iana",
	compressible: false,
	extensions: [
		"ogx"
	]
},
	"application/omdoc+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"omdoc"
	]
},
	"application/onenote": {
	source: "apache",
	extensions: [
		"onetoc",
		"onetoc2",
		"onetmp",
		"onepkg"
	]
},
	"application/opc-nodeset+xml": {
	source: "iana",
	compressible: true
},
	"application/oscore": {
	source: "iana"
},
	"application/oxps": {
	source: "iana",
	extensions: [
		"oxps"
	]
},
	"application/p21": {
	source: "iana"
},
	"application/p21+zip": {
	source: "iana",
	compressible: false
},
	"application/p2p-overlay+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"relo"
	]
},
	"application/parityfec": {
	source: "iana"
},
	"application/passport": {
	source: "iana"
},
	"application/patch-ops-error+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xer"
	]
},
	"application/pdf": {
	source: "iana",
	compressible: false,
	extensions: [
		"pdf"
	]
},
	"application/pdx": {
	source: "iana"
},
	"application/pem-certificate-chain": {
	source: "iana"
},
	"application/pgp-encrypted": {
	source: "iana",
	compressible: false,
	extensions: [
		"pgp"
	]
},
	"application/pgp-keys": {
	source: "iana",
	extensions: [
		"asc"
	]
},
	"application/pgp-signature": {
	source: "iana",
	extensions: [
		"asc",
		"sig"
	]
},
	"application/pics-rules": {
	source: "apache",
	extensions: [
		"prf"
	]
},
	"application/pidf+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/pidf-diff+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/pkcs10": {
	source: "iana",
	extensions: [
		"p10"
	]
},
	"application/pkcs12": {
	source: "iana"
},
	"application/pkcs7-mime": {
	source: "iana",
	extensions: [
		"p7m",
		"p7c"
	]
},
	"application/pkcs7-signature": {
	source: "iana",
	extensions: [
		"p7s"
	]
},
	"application/pkcs8": {
	source: "iana",
	extensions: [
		"p8"
	]
},
	"application/pkcs8-encrypted": {
	source: "iana"
},
	"application/pkix-attr-cert": {
	source: "iana",
	extensions: [
		"ac"
	]
},
	"application/pkix-cert": {
	source: "iana",
	extensions: [
		"cer"
	]
},
	"application/pkix-crl": {
	source: "iana",
	extensions: [
		"crl"
	]
},
	"application/pkix-pkipath": {
	source: "iana",
	extensions: [
		"pkipath"
	]
},
	"application/pkixcmp": {
	source: "iana",
	extensions: [
		"pki"
	]
},
	"application/pls+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"pls"
	]
},
	"application/poc-settings+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/postscript": {
	source: "iana",
	compressible: true,
	extensions: [
		"ai",
		"eps",
		"ps"
	]
},
	"application/ppsp-tracker+json": {
	source: "iana",
	compressible: true
},
	"application/problem+json": {
	source: "iana",
	compressible: true
},
	"application/problem+xml": {
	source: "iana",
	compressible: true
},
	"application/provenance+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"provx"
	]
},
	"application/prs.alvestrand.titrax-sheet": {
	source: "iana"
},
	"application/prs.cww": {
	source: "iana",
	extensions: [
		"cww"
	]
},
	"application/prs.cyn": {
	source: "iana",
	charset: "7-BIT"
},
	"application/prs.hpub+zip": {
	source: "iana",
	compressible: false
},
	"application/prs.nprend": {
	source: "iana"
},
	"application/prs.plucker": {
	source: "iana"
},
	"application/prs.rdf-xml-crypt": {
	source: "iana"
},
	"application/prs.xsf+xml": {
	source: "iana",
	compressible: true
},
	"application/pskc+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"pskcxml"
	]
},
	"application/pvd+json": {
	source: "iana",
	compressible: true
},
	"application/qsig": {
	source: "iana"
},
	"application/raml+yaml": {
	compressible: true,
	extensions: [
		"raml"
	]
},
	"application/raptorfec": {
	source: "iana"
},
	"application/rdap+json": {
	source: "iana",
	compressible: true
},
	"application/rdf+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rdf",
		"owl"
	]
},
	"application/reginfo+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rif"
	]
},
	"application/relax-ng-compact-syntax": {
	source: "iana",
	extensions: [
		"rnc"
	]
},
	"application/remote-printing": {
	source: "iana"
},
	"application/reputon+json": {
	source: "iana",
	compressible: true
},
	"application/resource-lists+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rl"
	]
},
	"application/resource-lists-diff+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rld"
	]
},
	"application/rfc+xml": {
	source: "iana",
	compressible: true
},
	"application/riscos": {
	source: "iana"
},
	"application/rlmi+xml": {
	source: "iana",
	compressible: true
},
	"application/rls-services+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rs"
	]
},
	"application/route-apd+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rapd"
	]
},
	"application/route-s-tsid+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"sls"
	]
},
	"application/route-usd+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rusd"
	]
},
	"application/rpki-ghostbusters": {
	source: "iana",
	extensions: [
		"gbr"
	]
},
	"application/rpki-manifest": {
	source: "iana",
	extensions: [
		"mft"
	]
},
	"application/rpki-publication": {
	source: "iana"
},
	"application/rpki-roa": {
	source: "iana",
	extensions: [
		"roa"
	]
},
	"application/rpki-updown": {
	source: "iana"
},
	"application/rsd+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"rsd"
	]
},
	"application/rss+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"rss"
	]
},
	"application/rtf": {
	source: "iana",
	compressible: true,
	extensions: [
		"rtf"
	]
},
	"application/rtploopback": {
	source: "iana"
},
	"application/rtx": {
	source: "iana"
},
	"application/samlassertion+xml": {
	source: "iana",
	compressible: true
},
	"application/samlmetadata+xml": {
	source: "iana",
	compressible: true
},
	"application/sarif+json": {
	source: "iana",
	compressible: true
},
	"application/sarif-external-properties+json": {
	source: "iana",
	compressible: true
},
	"application/sbe": {
	source: "iana"
},
	"application/sbml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"sbml"
	]
},
	"application/scaip+xml": {
	source: "iana",
	compressible: true
},
	"application/scim+json": {
	source: "iana",
	compressible: true
},
	"application/scvp-cv-request": {
	source: "iana",
	extensions: [
		"scq"
	]
},
	"application/scvp-cv-response": {
	source: "iana",
	extensions: [
		"scs"
	]
},
	"application/scvp-vp-request": {
	source: "iana",
	extensions: [
		"spq"
	]
},
	"application/scvp-vp-response": {
	source: "iana",
	extensions: [
		"spp"
	]
},
	"application/sdp": {
	source: "iana",
	extensions: [
		"sdp"
	]
},
	"application/secevent+jwt": {
	source: "iana"
},
	"application/senml+cbor": {
	source: "iana"
},
	"application/senml+json": {
	source: "iana",
	compressible: true
},
	"application/senml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"senmlx"
	]
},
	"application/senml-etch+cbor": {
	source: "iana"
},
	"application/senml-etch+json": {
	source: "iana",
	compressible: true
},
	"application/senml-exi": {
	source: "iana"
},
	"application/sensml+cbor": {
	source: "iana"
},
	"application/sensml+json": {
	source: "iana",
	compressible: true
},
	"application/sensml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"sensmlx"
	]
},
	"application/sensml-exi": {
	source: "iana"
},
	"application/sep+xml": {
	source: "iana",
	compressible: true
},
	"application/sep-exi": {
	source: "iana"
},
	"application/session-info": {
	source: "iana"
},
	"application/set-payment": {
	source: "iana"
},
	"application/set-payment-initiation": {
	source: "iana",
	extensions: [
		"setpay"
	]
},
	"application/set-registration": {
	source: "iana"
},
	"application/set-registration-initiation": {
	source: "iana",
	extensions: [
		"setreg"
	]
},
	"application/sgml": {
	source: "iana"
},
	"application/sgml-open-catalog": {
	source: "iana"
},
	"application/shf+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"shf"
	]
},
	"application/sieve": {
	source: "iana",
	extensions: [
		"siv",
		"sieve"
	]
},
	"application/simple-filter+xml": {
	source: "iana",
	compressible: true
},
	"application/simple-message-summary": {
	source: "iana"
},
	"application/simplesymbolcontainer": {
	source: "iana"
},
	"application/sipc": {
	source: "iana"
},
	"application/slate": {
	source: "iana"
},
	"application/smil": {
	source: "iana"
},
	"application/smil+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"smi",
		"smil"
	]
},
	"application/smpte336m": {
	source: "iana"
},
	"application/soap+fastinfoset": {
	source: "iana"
},
	"application/soap+xml": {
	source: "iana",
	compressible: true
},
	"application/sparql-query": {
	source: "iana",
	extensions: [
		"rq"
	]
},
	"application/sparql-results+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"srx"
	]
},
	"application/spdx+json": {
	source: "iana",
	compressible: true
},
	"application/spirits-event+xml": {
	source: "iana",
	compressible: true
},
	"application/sql": {
	source: "iana"
},
	"application/srgs": {
	source: "iana",
	extensions: [
		"gram"
	]
},
	"application/srgs+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"grxml"
	]
},
	"application/sru+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"sru"
	]
},
	"application/ssdl+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"ssdl"
	]
},
	"application/ssml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"ssml"
	]
},
	"application/stix+json": {
	source: "iana",
	compressible: true
},
	"application/swid+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"swidtag"
	]
},
	"application/tamp-apex-update": {
	source: "iana"
},
	"application/tamp-apex-update-confirm": {
	source: "iana"
},
	"application/tamp-community-update": {
	source: "iana"
},
	"application/tamp-community-update-confirm": {
	source: "iana"
},
	"application/tamp-error": {
	source: "iana"
},
	"application/tamp-sequence-adjust": {
	source: "iana"
},
	"application/tamp-sequence-adjust-confirm": {
	source: "iana"
},
	"application/tamp-status-query": {
	source: "iana"
},
	"application/tamp-status-response": {
	source: "iana"
},
	"application/tamp-update": {
	source: "iana"
},
	"application/tamp-update-confirm": {
	source: "iana"
},
	"application/tar": {
	compressible: true
},
	"application/taxii+json": {
	source: "iana",
	compressible: true
},
	"application/td+json": {
	source: "iana",
	compressible: true
},
	"application/tei+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"tei",
		"teicorpus"
	]
},
	"application/tetra_isi": {
	source: "iana"
},
	"application/thraud+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"tfi"
	]
},
	"application/timestamp-query": {
	source: "iana"
},
	"application/timestamp-reply": {
	source: "iana"
},
	"application/timestamped-data": {
	source: "iana",
	extensions: [
		"tsd"
	]
},
	"application/tlsrpt+gzip": {
	source: "iana"
},
	"application/tlsrpt+json": {
	source: "iana",
	compressible: true
},
	"application/tnauthlist": {
	source: "iana"
},
	"application/token-introspection+jwt": {
	source: "iana"
},
	"application/toml": {
	compressible: true,
	extensions: [
		"toml"
	]
},
	"application/trickle-ice-sdpfrag": {
	source: "iana"
},
	"application/trig": {
	source: "iana",
	extensions: [
		"trig"
	]
},
	"application/ttml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"ttml"
	]
},
	"application/tve-trigger": {
	source: "iana"
},
	"application/tzif": {
	source: "iana"
},
	"application/tzif-leap": {
	source: "iana"
},
	"application/ubjson": {
	compressible: false,
	extensions: [
		"ubj"
	]
},
	"application/ulpfec": {
	source: "iana"
},
	"application/urc-grpsheet+xml": {
	source: "iana",
	compressible: true
},
	"application/urc-ressheet+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rsheet"
	]
},
	"application/urc-targetdesc+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"td"
	]
},
	"application/urc-uisocketdesc+xml": {
	source: "iana",
	compressible: true
},
	"application/vcard+json": {
	source: "iana",
	compressible: true
},
	"application/vcard+xml": {
	source: "iana",
	compressible: true
},
	"application/vemmi": {
	source: "iana"
},
	"application/vividence.scriptfile": {
	source: "apache"
},
	"application/vnd.1000minds.decision-model+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"1km"
	]
},
	"application/vnd.3gpp-prose+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp-prose-pc3ch+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp-v2x-local-service-information": {
	source: "iana"
},
	"application/vnd.3gpp.5gnas": {
	source: "iana"
},
	"application/vnd.3gpp.access-transfer-events+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.bsf+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.gmop+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.gtpc": {
	source: "iana"
},
	"application/vnd.3gpp.interworking-data": {
	source: "iana"
},
	"application/vnd.3gpp.lpp": {
	source: "iana"
},
	"application/vnd.3gpp.mc-signalling-ear": {
	source: "iana"
},
	"application/vnd.3gpp.mcdata-affiliation-command+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcdata-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcdata-payload": {
	source: "iana"
},
	"application/vnd.3gpp.mcdata-service-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcdata-signalling": {
	source: "iana"
},
	"application/vnd.3gpp.mcdata-ue-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcdata-user-profile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-affiliation-command+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-floor-request+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-location-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-service-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-signed+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-ue-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-ue-init-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-user-profile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-affiliation-command+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-affiliation-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-location-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-service-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-transmission-request+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-ue-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-user-profile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mid-call+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.ngap": {
	source: "iana"
},
	"application/vnd.3gpp.pfcp": {
	source: "iana"
},
	"application/vnd.3gpp.pic-bw-large": {
	source: "iana",
	extensions: [
		"plb"
	]
},
	"application/vnd.3gpp.pic-bw-small": {
	source: "iana",
	extensions: [
		"psb"
	]
},
	"application/vnd.3gpp.pic-bw-var": {
	source: "iana",
	extensions: [
		"pvb"
	]
},
	"application/vnd.3gpp.s1ap": {
	source: "iana"
},
	"application/vnd.3gpp.sms": {
	source: "iana"
},
	"application/vnd.3gpp.sms+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.srvcc-ext+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.srvcc-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.state-and-event-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.ussd+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp2.bcmcsinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp2.sms": {
	source: "iana"
},
	"application/vnd.3gpp2.tcap": {
	source: "iana",
	extensions: [
		"tcap"
	]
},
	"application/vnd.3lightssoftware.imagescal": {
	source: "iana"
},
	"application/vnd.3m.post-it-notes": {
	source: "iana",
	extensions: [
		"pwn"
	]
},
	"application/vnd.accpac.simply.aso": {
	source: "iana",
	extensions: [
		"aso"
	]
},
	"application/vnd.accpac.simply.imp": {
	source: "iana",
	extensions: [
		"imp"
	]
},
	"application/vnd.acucobol": {
	source: "iana",
	extensions: [
		"acu"
	]
},
	"application/vnd.acucorp": {
	source: "iana",
	extensions: [
		"atc",
		"acutc"
	]
},
	"application/vnd.adobe.air-application-installer-package+zip": {
	source: "apache",
	compressible: false,
	extensions: [
		"air"
	]
},
	"application/vnd.adobe.flash.movie": {
	source: "iana"
},
	"application/vnd.adobe.formscentral.fcdt": {
	source: "iana",
	extensions: [
		"fcdt"
	]
},
	"application/vnd.adobe.fxp": {
	source: "iana",
	extensions: [
		"fxp",
		"fxpl"
	]
},
	"application/vnd.adobe.partial-upload": {
	source: "iana"
},
	"application/vnd.adobe.xdp+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xdp"
	]
},
	"application/vnd.adobe.xfdf": {
	source: "iana",
	extensions: [
		"xfdf"
	]
},
	"application/vnd.aether.imp": {
	source: "iana"
},
	"application/vnd.afpc.afplinedata": {
	source: "iana"
},
	"application/vnd.afpc.afplinedata-pagedef": {
	source: "iana"
},
	"application/vnd.afpc.cmoca-cmresource": {
	source: "iana"
},
	"application/vnd.afpc.foca-charset": {
	source: "iana"
},
	"application/vnd.afpc.foca-codedfont": {
	source: "iana"
},
	"application/vnd.afpc.foca-codepage": {
	source: "iana"
},
	"application/vnd.afpc.modca": {
	source: "iana"
},
	"application/vnd.afpc.modca-cmtable": {
	source: "iana"
},
	"application/vnd.afpc.modca-formdef": {
	source: "iana"
},
	"application/vnd.afpc.modca-mediummap": {
	source: "iana"
},
	"application/vnd.afpc.modca-objectcontainer": {
	source: "iana"
},
	"application/vnd.afpc.modca-overlay": {
	source: "iana"
},
	"application/vnd.afpc.modca-pagesegment": {
	source: "iana"
},
	"application/vnd.age": {
	source: "iana",
	extensions: [
		"age"
	]
},
	"application/vnd.ah-barcode": {
	source: "iana"
},
	"application/vnd.ahead.space": {
	source: "iana",
	extensions: [
		"ahead"
	]
},
	"application/vnd.airzip.filesecure.azf": {
	source: "iana",
	extensions: [
		"azf"
	]
},
	"application/vnd.airzip.filesecure.azs": {
	source: "iana",
	extensions: [
		"azs"
	]
},
	"application/vnd.amadeus+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.amazon.ebook": {
	source: "apache",
	extensions: [
		"azw"
	]
},
	"application/vnd.amazon.mobi8-ebook": {
	source: "iana"
},
	"application/vnd.americandynamics.acc": {
	source: "iana",
	extensions: [
		"acc"
	]
},
	"application/vnd.amiga.ami": {
	source: "iana",
	extensions: [
		"ami"
	]
},
	"application/vnd.amundsen.maze+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.android.ota": {
	source: "iana"
},
	"application/vnd.android.package-archive": {
	source: "apache",
	compressible: false,
	extensions: [
		"apk"
	]
},
	"application/vnd.anki": {
	source: "iana"
},
	"application/vnd.anser-web-certificate-issue-initiation": {
	source: "iana",
	extensions: [
		"cii"
	]
},
	"application/vnd.anser-web-funds-transfer-initiation": {
	source: "apache",
	extensions: [
		"fti"
	]
},
	"application/vnd.antix.game-component": {
	source: "iana",
	extensions: [
		"atx"
	]
},
	"application/vnd.apache.arrow.file": {
	source: "iana"
},
	"application/vnd.apache.arrow.stream": {
	source: "iana"
},
	"application/vnd.apache.thrift.binary": {
	source: "iana"
},
	"application/vnd.apache.thrift.compact": {
	source: "iana"
},
	"application/vnd.apache.thrift.json": {
	source: "iana"
},
	"application/vnd.api+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.aplextor.warrp+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.apothekende.reservation+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.apple.installer+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mpkg"
	]
},
	"application/vnd.apple.keynote": {
	source: "iana",
	extensions: [
		"key"
	]
},
	"application/vnd.apple.mpegurl": {
	source: "iana",
	extensions: [
		"m3u8"
	]
},
	"application/vnd.apple.numbers": {
	source: "iana",
	extensions: [
		"numbers"
	]
},
	"application/vnd.apple.pages": {
	source: "iana",
	extensions: [
		"pages"
	]
},
	"application/vnd.apple.pkpass": {
	compressible: false,
	extensions: [
		"pkpass"
	]
},
	"application/vnd.arastra.swi": {
	source: "iana"
},
	"application/vnd.aristanetworks.swi": {
	source: "iana",
	extensions: [
		"swi"
	]
},
	"application/vnd.artisan+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.artsquare": {
	source: "iana"
},
	"application/vnd.astraea-software.iota": {
	source: "iana",
	extensions: [
		"iota"
	]
},
	"application/vnd.audiograph": {
	source: "iana",
	extensions: [
		"aep"
	]
},
	"application/vnd.autopackage": {
	source: "iana"
},
	"application/vnd.avalon+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.avistar+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.balsamiq.bmml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"bmml"
	]
},
	"application/vnd.balsamiq.bmpr": {
	source: "iana"
},
	"application/vnd.banana-accounting": {
	source: "iana"
},
	"application/vnd.bbf.usp.error": {
	source: "iana"
},
	"application/vnd.bbf.usp.msg": {
	source: "iana"
},
	"application/vnd.bbf.usp.msg+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.bekitzur-stech+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.bint.med-content": {
	source: "iana"
},
	"application/vnd.biopax.rdf+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.blink-idb-value-wrapper": {
	source: "iana"
},
	"application/vnd.blueice.multipass": {
	source: "iana",
	extensions: [
		"mpm"
	]
},
	"application/vnd.bluetooth.ep.oob": {
	source: "iana"
},
	"application/vnd.bluetooth.le.oob": {
	source: "iana"
},
	"application/vnd.bmi": {
	source: "iana",
	extensions: [
		"bmi"
	]
},
	"application/vnd.bpf": {
	source: "iana"
},
	"application/vnd.bpf3": {
	source: "iana"
},
	"application/vnd.businessobjects": {
	source: "iana",
	extensions: [
		"rep"
	]
},
	"application/vnd.byu.uapi+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.cab-jscript": {
	source: "iana"
},
	"application/vnd.canon-cpdl": {
	source: "iana"
},
	"application/vnd.canon-lips": {
	source: "iana"
},
	"application/vnd.capasystems-pg+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.cendio.thinlinc.clientconf": {
	source: "iana"
},
	"application/vnd.century-systems.tcp_stream": {
	source: "iana"
},
	"application/vnd.chemdraw+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"cdxml"
	]
},
	"application/vnd.chess-pgn": {
	source: "iana"
},
	"application/vnd.chipnuts.karaoke-mmd": {
	source: "iana",
	extensions: [
		"mmd"
	]
},
	"application/vnd.ciedi": {
	source: "iana"
},
	"application/vnd.cinderella": {
	source: "iana",
	extensions: [
		"cdy"
	]
},
	"application/vnd.cirpack.isdn-ext": {
	source: "iana"
},
	"application/vnd.citationstyles.style+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"csl"
	]
},
	"application/vnd.claymore": {
	source: "iana",
	extensions: [
		"cla"
	]
},
	"application/vnd.cloanto.rp9": {
	source: "iana",
	extensions: [
		"rp9"
	]
},
	"application/vnd.clonk.c4group": {
	source: "iana",
	extensions: [
		"c4g",
		"c4d",
		"c4f",
		"c4p",
		"c4u"
	]
},
	"application/vnd.cluetrust.cartomobile-config": {
	source: "iana",
	extensions: [
		"c11amc"
	]
},
	"application/vnd.cluetrust.cartomobile-config-pkg": {
	source: "iana",
	extensions: [
		"c11amz"
	]
},
	"application/vnd.coffeescript": {
	source: "iana"
},
	"application/vnd.collabio.xodocuments.document": {
	source: "iana"
},
	"application/vnd.collabio.xodocuments.document-template": {
	source: "iana"
},
	"application/vnd.collabio.xodocuments.presentation": {
	source: "iana"
},
	"application/vnd.collabio.xodocuments.presentation-template": {
	source: "iana"
},
	"application/vnd.collabio.xodocuments.spreadsheet": {
	source: "iana"
},
	"application/vnd.collabio.xodocuments.spreadsheet-template": {
	source: "iana"
},
	"application/vnd.collection+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.collection.doc+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.collection.next+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.comicbook+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.comicbook-rar": {
	source: "iana"
},
	"application/vnd.commerce-battelle": {
	source: "iana"
},
	"application/vnd.commonspace": {
	source: "iana",
	extensions: [
		"csp"
	]
},
	"application/vnd.contact.cmsg": {
	source: "iana",
	extensions: [
		"cdbcmsg"
	]
},
	"application/vnd.coreos.ignition+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.cosmocaller": {
	source: "iana",
	extensions: [
		"cmc"
	]
},
	"application/vnd.crick.clicker": {
	source: "iana",
	extensions: [
		"clkx"
	]
},
	"application/vnd.crick.clicker.keyboard": {
	source: "iana",
	extensions: [
		"clkk"
	]
},
	"application/vnd.crick.clicker.palette": {
	source: "iana",
	extensions: [
		"clkp"
	]
},
	"application/vnd.crick.clicker.template": {
	source: "iana",
	extensions: [
		"clkt"
	]
},
	"application/vnd.crick.clicker.wordbank": {
	source: "iana",
	extensions: [
		"clkw"
	]
},
	"application/vnd.criticaltools.wbs+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"wbs"
	]
},
	"application/vnd.cryptii.pipe+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.crypto-shade-file": {
	source: "iana"
},
	"application/vnd.cryptomator.encrypted": {
	source: "iana"
},
	"application/vnd.cryptomator.vault": {
	source: "iana"
},
	"application/vnd.ctc-posml": {
	source: "iana",
	extensions: [
		"pml"
	]
},
	"application/vnd.ctct.ws+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.cups-pdf": {
	source: "iana"
},
	"application/vnd.cups-postscript": {
	source: "iana"
},
	"application/vnd.cups-ppd": {
	source: "iana",
	extensions: [
		"ppd"
	]
},
	"application/vnd.cups-raster": {
	source: "iana"
},
	"application/vnd.cups-raw": {
	source: "iana"
},
	"application/vnd.curl": {
	source: "iana"
},
	"application/vnd.curl.car": {
	source: "apache",
	extensions: [
		"car"
	]
},
	"application/vnd.curl.pcurl": {
	source: "apache",
	extensions: [
		"pcurl"
	]
},
	"application/vnd.cyan.dean.root+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.cybank": {
	source: "iana"
},
	"application/vnd.cyclonedx+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.cyclonedx+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.d2l.coursepackage1p0+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.d3m-dataset": {
	source: "iana"
},
	"application/vnd.d3m-problem": {
	source: "iana"
},
	"application/vnd.dart": {
	source: "iana",
	compressible: true,
	extensions: [
		"dart"
	]
},
	"application/vnd.data-vision.rdz": {
	source: "iana",
	extensions: [
		"rdz"
	]
},
	"application/vnd.datapackage+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.dataresource+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.dbf": {
	source: "iana",
	extensions: [
		"dbf"
	]
},
	"application/vnd.debian.binary-package": {
	source: "iana"
},
	"application/vnd.dece.data": {
	source: "iana",
	extensions: [
		"uvf",
		"uvvf",
		"uvd",
		"uvvd"
	]
},
	"application/vnd.dece.ttml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"uvt",
		"uvvt"
	]
},
	"application/vnd.dece.unspecified": {
	source: "iana",
	extensions: [
		"uvx",
		"uvvx"
	]
},
	"application/vnd.dece.zip": {
	source: "iana",
	extensions: [
		"uvz",
		"uvvz"
	]
},
	"application/vnd.denovo.fcselayout-link": {
	source: "iana",
	extensions: [
		"fe_launch"
	]
},
	"application/vnd.desmume.movie": {
	source: "iana"
},
	"application/vnd.dir-bi.plate-dl-nosuffix": {
	source: "iana"
},
	"application/vnd.dm.delegation+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dna": {
	source: "iana",
	extensions: [
		"dna"
	]
},
	"application/vnd.document+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.dolby.mlp": {
	source: "apache",
	extensions: [
		"mlp"
	]
},
	"application/vnd.dolby.mobile.1": {
	source: "iana"
},
	"application/vnd.dolby.mobile.2": {
	source: "iana"
},
	"application/vnd.doremir.scorecloud-binary-document": {
	source: "iana"
},
	"application/vnd.dpgraph": {
	source: "iana",
	extensions: [
		"dpg"
	]
},
	"application/vnd.dreamfactory": {
	source: "iana",
	extensions: [
		"dfac"
	]
},
	"application/vnd.drive+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ds-keypoint": {
	source: "apache",
	extensions: [
		"kpxx"
	]
},
	"application/vnd.dtg.local": {
	source: "iana"
},
	"application/vnd.dtg.local.flash": {
	source: "iana"
},
	"application/vnd.dtg.local.html": {
	source: "iana"
},
	"application/vnd.dvb.ait": {
	source: "iana",
	extensions: [
		"ait"
	]
},
	"application/vnd.dvb.dvbisl+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.dvbj": {
	source: "iana"
},
	"application/vnd.dvb.esgcontainer": {
	source: "iana"
},
	"application/vnd.dvb.ipdcdftnotifaccess": {
	source: "iana"
},
	"application/vnd.dvb.ipdcesgaccess": {
	source: "iana"
},
	"application/vnd.dvb.ipdcesgaccess2": {
	source: "iana"
},
	"application/vnd.dvb.ipdcesgpdd": {
	source: "iana"
},
	"application/vnd.dvb.ipdcroaming": {
	source: "iana"
},
	"application/vnd.dvb.iptv.alfec-base": {
	source: "iana"
},
	"application/vnd.dvb.iptv.alfec-enhancement": {
	source: "iana"
},
	"application/vnd.dvb.notif-aggregate-root+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.notif-container+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.notif-generic+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.notif-ia-msglist+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.notif-ia-registration-request+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.notif-ia-registration-response+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.notif-init+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.pfr": {
	source: "iana"
},
	"application/vnd.dvb.service": {
	source: "iana",
	extensions: [
		"svc"
	]
},
	"application/vnd.dxr": {
	source: "iana"
},
	"application/vnd.dynageo": {
	source: "iana",
	extensions: [
		"geo"
	]
},
	"application/vnd.dzr": {
	source: "iana"
},
	"application/vnd.easykaraoke.cdgdownload": {
	source: "iana"
},
	"application/vnd.ecdis-update": {
	source: "iana"
},
	"application/vnd.ecip.rlp": {
	source: "iana"
},
	"application/vnd.eclipse.ditto+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ecowin.chart": {
	source: "iana",
	extensions: [
		"mag"
	]
},
	"application/vnd.ecowin.filerequest": {
	source: "iana"
},
	"application/vnd.ecowin.fileupdate": {
	source: "iana"
},
	"application/vnd.ecowin.series": {
	source: "iana"
},
	"application/vnd.ecowin.seriesrequest": {
	source: "iana"
},
	"application/vnd.ecowin.seriesupdate": {
	source: "iana"
},
	"application/vnd.efi.img": {
	source: "iana"
},
	"application/vnd.efi.iso": {
	source: "iana"
},
	"application/vnd.emclient.accessrequest+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.enliven": {
	source: "iana",
	extensions: [
		"nml"
	]
},
	"application/vnd.enphase.envoy": {
	source: "iana"
},
	"application/vnd.eprints.data+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.epson.esf": {
	source: "iana",
	extensions: [
		"esf"
	]
},
	"application/vnd.epson.msf": {
	source: "iana",
	extensions: [
		"msf"
	]
},
	"application/vnd.epson.quickanime": {
	source: "iana",
	extensions: [
		"qam"
	]
},
	"application/vnd.epson.salt": {
	source: "iana",
	extensions: [
		"slt"
	]
},
	"application/vnd.epson.ssf": {
	source: "iana",
	extensions: [
		"ssf"
	]
},
	"application/vnd.ericsson.quickcall": {
	source: "iana"
},
	"application/vnd.espass-espass+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.eszigno3+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"es3",
		"et3"
	]
},
	"application/vnd.etsi.aoc+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.asic-e+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.etsi.asic-s+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.etsi.cug+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvcommand+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvdiscovery+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvprofile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvsad-bc+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvsad-cod+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvsad-npvr+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvservice+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvsync+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvueprofile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.mcid+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.mheg5": {
	source: "iana"
},
	"application/vnd.etsi.overload-control-policy-dataset+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.pstn+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.sci+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.simservs+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.timestamp-token": {
	source: "iana"
},
	"application/vnd.etsi.tsl+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.tsl.der": {
	source: "iana"
},
	"application/vnd.eu.kasparian.car+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.eudora.data": {
	source: "iana"
},
	"application/vnd.evolv.ecig.profile": {
	source: "iana"
},
	"application/vnd.evolv.ecig.settings": {
	source: "iana"
},
	"application/vnd.evolv.ecig.theme": {
	source: "iana"
},
	"application/vnd.exstream-empower+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.exstream-package": {
	source: "iana"
},
	"application/vnd.ezpix-album": {
	source: "iana",
	extensions: [
		"ez2"
	]
},
	"application/vnd.ezpix-package": {
	source: "iana",
	extensions: [
		"ez3"
	]
},
	"application/vnd.f-secure.mobile": {
	source: "iana"
},
	"application/vnd.familysearch.gedcom+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.fastcopy-disk-image": {
	source: "iana"
},
	"application/vnd.fdf": {
	source: "iana",
	extensions: [
		"fdf"
	]
},
	"application/vnd.fdsn.mseed": {
	source: "iana",
	extensions: [
		"mseed"
	]
},
	"application/vnd.fdsn.seed": {
	source: "iana",
	extensions: [
		"seed",
		"dataless"
	]
},
	"application/vnd.ffsns": {
	source: "iana"
},
	"application/vnd.ficlab.flb+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.filmit.zfc": {
	source: "iana"
},
	"application/vnd.fints": {
	source: "iana"
},
	"application/vnd.firemonkeys.cloudcell": {
	source: "iana"
},
	"application/vnd.flographit": {
	source: "iana",
	extensions: [
		"gph"
	]
},
	"application/vnd.fluxtime.clip": {
	source: "iana",
	extensions: [
		"ftc"
	]
},
	"application/vnd.font-fontforge-sfd": {
	source: "iana"
},
	"application/vnd.framemaker": {
	source: "iana",
	extensions: [
		"fm",
		"frame",
		"maker",
		"book"
	]
},
	"application/vnd.frogans.fnc": {
	source: "iana",
	extensions: [
		"fnc"
	]
},
	"application/vnd.frogans.ltf": {
	source: "iana",
	extensions: [
		"ltf"
	]
},
	"application/vnd.fsc.weblaunch": {
	source: "iana",
	extensions: [
		"fsc"
	]
},
	"application/vnd.fujifilm.fb.docuworks": {
	source: "iana"
},
	"application/vnd.fujifilm.fb.docuworks.binder": {
	source: "iana"
},
	"application/vnd.fujifilm.fb.docuworks.container": {
	source: "iana"
},
	"application/vnd.fujifilm.fb.jfi+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.fujitsu.oasys": {
	source: "iana",
	extensions: [
		"oas"
	]
},
	"application/vnd.fujitsu.oasys2": {
	source: "iana",
	extensions: [
		"oa2"
	]
},
	"application/vnd.fujitsu.oasys3": {
	source: "iana",
	extensions: [
		"oa3"
	]
},
	"application/vnd.fujitsu.oasysgp": {
	source: "iana",
	extensions: [
		"fg5"
	]
},
	"application/vnd.fujitsu.oasysprs": {
	source: "iana",
	extensions: [
		"bh2"
	]
},
	"application/vnd.fujixerox.art-ex": {
	source: "iana"
},
	"application/vnd.fujixerox.art4": {
	source: "iana"
},
	"application/vnd.fujixerox.ddd": {
	source: "iana",
	extensions: [
		"ddd"
	]
},
	"application/vnd.fujixerox.docuworks": {
	source: "iana",
	extensions: [
		"xdw"
	]
},
	"application/vnd.fujixerox.docuworks.binder": {
	source: "iana",
	extensions: [
		"xbd"
	]
},
	"application/vnd.fujixerox.docuworks.container": {
	source: "iana"
},
	"application/vnd.fujixerox.hbpl": {
	source: "iana"
},
	"application/vnd.fut-misnet": {
	source: "iana"
},
	"application/vnd.futoin+cbor": {
	source: "iana"
},
	"application/vnd.futoin+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.fuzzysheet": {
	source: "iana",
	extensions: [
		"fzs"
	]
},
	"application/vnd.genomatix.tuxedo": {
	source: "iana",
	extensions: [
		"txd"
	]
},
	"application/vnd.gentics.grd+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.geo+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.geocube+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.geogebra.file": {
	source: "iana",
	extensions: [
		"ggb"
	]
},
	"application/vnd.geogebra.slides": {
	source: "iana"
},
	"application/vnd.geogebra.tool": {
	source: "iana",
	extensions: [
		"ggt"
	]
},
	"application/vnd.geometry-explorer": {
	source: "iana",
	extensions: [
		"gex",
		"gre"
	]
},
	"application/vnd.geonext": {
	source: "iana",
	extensions: [
		"gxt"
	]
},
	"application/vnd.geoplan": {
	source: "iana",
	extensions: [
		"g2w"
	]
},
	"application/vnd.geospace": {
	source: "iana",
	extensions: [
		"g3w"
	]
},
	"application/vnd.gerber": {
	source: "iana"
},
	"application/vnd.globalplatform.card-content-mgt": {
	source: "iana"
},
	"application/vnd.globalplatform.card-content-mgt-response": {
	source: "iana"
},
	"application/vnd.gmx": {
	source: "iana",
	extensions: [
		"gmx"
	]
},
	"application/vnd.google-apps.document": {
	compressible: false,
	extensions: [
		"gdoc"
	]
},
	"application/vnd.google-apps.presentation": {
	compressible: false,
	extensions: [
		"gslides"
	]
},
	"application/vnd.google-apps.spreadsheet": {
	compressible: false,
	extensions: [
		"gsheet"
	]
},
	"application/vnd.google-earth.kml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"kml"
	]
},
	"application/vnd.google-earth.kmz": {
	source: "iana",
	compressible: false,
	extensions: [
		"kmz"
	]
},
	"application/vnd.gov.sk.e-form+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.gov.sk.e-form+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.gov.sk.xmldatacontainer+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.grafeq": {
	source: "iana",
	extensions: [
		"gqf",
		"gqs"
	]
},
	"application/vnd.gridmp": {
	source: "iana"
},
	"application/vnd.groove-account": {
	source: "iana",
	extensions: [
		"gac"
	]
},
	"application/vnd.groove-help": {
	source: "iana",
	extensions: [
		"ghf"
	]
},
	"application/vnd.groove-identity-message": {
	source: "iana",
	extensions: [
		"gim"
	]
},
	"application/vnd.groove-injector": {
	source: "iana",
	extensions: [
		"grv"
	]
},
	"application/vnd.groove-tool-message": {
	source: "iana",
	extensions: [
		"gtm"
	]
},
	"application/vnd.groove-tool-template": {
	source: "iana",
	extensions: [
		"tpl"
	]
},
	"application/vnd.groove-vcard": {
	source: "iana",
	extensions: [
		"vcg"
	]
},
	"application/vnd.hal+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.hal+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"hal"
	]
},
	"application/vnd.handheld-entertainment+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"zmm"
	]
},
	"application/vnd.hbci": {
	source: "iana",
	extensions: [
		"hbci"
	]
},
	"application/vnd.hc+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.hcl-bireports": {
	source: "iana"
},
	"application/vnd.hdt": {
	source: "iana"
},
	"application/vnd.heroku+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.hhe.lesson-player": {
	source: "iana",
	extensions: [
		"les"
	]
},
	"application/vnd.hl7cda+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/vnd.hl7v2+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/vnd.hp-hpgl": {
	source: "iana",
	extensions: [
		"hpgl"
	]
},
	"application/vnd.hp-hpid": {
	source: "iana",
	extensions: [
		"hpid"
	]
},
	"application/vnd.hp-hps": {
	source: "iana",
	extensions: [
		"hps"
	]
},
	"application/vnd.hp-jlyt": {
	source: "iana",
	extensions: [
		"jlt"
	]
},
	"application/vnd.hp-pcl": {
	source: "iana",
	extensions: [
		"pcl"
	]
},
	"application/vnd.hp-pclxl": {
	source: "iana",
	extensions: [
		"pclxl"
	]
},
	"application/vnd.httphone": {
	source: "iana"
},
	"application/vnd.hydrostatix.sof-data": {
	source: "iana",
	extensions: [
		"sfd-hdstx"
	]
},
	"application/vnd.hyper+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.hyper-item+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.hyperdrive+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.hzn-3d-crossword": {
	source: "iana"
},
	"application/vnd.ibm.afplinedata": {
	source: "iana"
},
	"application/vnd.ibm.electronic-media": {
	source: "iana"
},
	"application/vnd.ibm.minipay": {
	source: "iana",
	extensions: [
		"mpy"
	]
},
	"application/vnd.ibm.modcap": {
	source: "iana",
	extensions: [
		"afp",
		"listafp",
		"list3820"
	]
},
	"application/vnd.ibm.rights-management": {
	source: "iana",
	extensions: [
		"irm"
	]
},
	"application/vnd.ibm.secure-container": {
	source: "iana",
	extensions: [
		"sc"
	]
},
	"application/vnd.iccprofile": {
	source: "iana",
	extensions: [
		"icc",
		"icm"
	]
},
	"application/vnd.ieee.1905": {
	source: "iana"
},
	"application/vnd.igloader": {
	source: "iana",
	extensions: [
		"igl"
	]
},
	"application/vnd.imagemeter.folder+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.imagemeter.image+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.immervision-ivp": {
	source: "iana",
	extensions: [
		"ivp"
	]
},
	"application/vnd.immervision-ivu": {
	source: "iana",
	extensions: [
		"ivu"
	]
},
	"application/vnd.ims.imsccv1p1": {
	source: "iana"
},
	"application/vnd.ims.imsccv1p2": {
	source: "iana"
},
	"application/vnd.ims.imsccv1p3": {
	source: "iana"
},
	"application/vnd.ims.lis.v2.result+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ims.lti.v2.toolconsumerprofile+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ims.lti.v2.toolproxy+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ims.lti.v2.toolproxy.id+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ims.lti.v2.toolsettings+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ims.lti.v2.toolsettings.simple+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.informedcontrol.rms+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.informix-visionary": {
	source: "iana"
},
	"application/vnd.infotech.project": {
	source: "iana"
},
	"application/vnd.infotech.project+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.innopath.wamp.notification": {
	source: "iana"
},
	"application/vnd.insors.igm": {
	source: "iana",
	extensions: [
		"igm"
	]
},
	"application/vnd.intercon.formnet": {
	source: "iana",
	extensions: [
		"xpw",
		"xpx"
	]
},
	"application/vnd.intergeo": {
	source: "iana",
	extensions: [
		"i2g"
	]
},
	"application/vnd.intertrust.digibox": {
	source: "iana"
},
	"application/vnd.intertrust.nncp": {
	source: "iana"
},
	"application/vnd.intu.qbo": {
	source: "iana",
	extensions: [
		"qbo"
	]
},
	"application/vnd.intu.qfx": {
	source: "iana",
	extensions: [
		"qfx"
	]
},
	"application/vnd.iptc.g2.catalogitem+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.iptc.g2.conceptitem+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.iptc.g2.knowledgeitem+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.iptc.g2.newsitem+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.iptc.g2.newsmessage+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.iptc.g2.packageitem+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.iptc.g2.planningitem+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.ipunplugged.rcprofile": {
	source: "iana",
	extensions: [
		"rcprofile"
	]
},
	"application/vnd.irepository.package+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"irp"
	]
},
	"application/vnd.is-xpr": {
	source: "iana",
	extensions: [
		"xpr"
	]
},
	"application/vnd.isac.fcs": {
	source: "iana",
	extensions: [
		"fcs"
	]
},
	"application/vnd.iso11783-10+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.jam": {
	source: "iana",
	extensions: [
		"jam"
	]
},
	"application/vnd.japannet-directory-service": {
	source: "iana"
},
	"application/vnd.japannet-jpnstore-wakeup": {
	source: "iana"
},
	"application/vnd.japannet-payment-wakeup": {
	source: "iana"
},
	"application/vnd.japannet-registration": {
	source: "iana"
},
	"application/vnd.japannet-registration-wakeup": {
	source: "iana"
},
	"application/vnd.japannet-setstore-wakeup": {
	source: "iana"
},
	"application/vnd.japannet-verification": {
	source: "iana"
},
	"application/vnd.japannet-verification-wakeup": {
	source: "iana"
},
	"application/vnd.jcp.javame.midlet-rms": {
	source: "iana",
	extensions: [
		"rms"
	]
},
	"application/vnd.jisp": {
	source: "iana",
	extensions: [
		"jisp"
	]
},
	"application/vnd.joost.joda-archive": {
	source: "iana",
	extensions: [
		"joda"
	]
},
	"application/vnd.jsk.isdn-ngn": {
	source: "iana"
},
	"application/vnd.kahootz": {
	source: "iana",
	extensions: [
		"ktz",
		"ktr"
	]
},
	"application/vnd.kde.karbon": {
	source: "iana",
	extensions: [
		"karbon"
	]
},
	"application/vnd.kde.kchart": {
	source: "iana",
	extensions: [
		"chrt"
	]
},
	"application/vnd.kde.kformula": {
	source: "iana",
	extensions: [
		"kfo"
	]
},
	"application/vnd.kde.kivio": {
	source: "iana",
	extensions: [
		"flw"
	]
},
	"application/vnd.kde.kontour": {
	source: "iana",
	extensions: [
		"kon"
	]
},
	"application/vnd.kde.kpresenter": {
	source: "iana",
	extensions: [
		"kpr",
		"kpt"
	]
},
	"application/vnd.kde.kspread": {
	source: "iana",
	extensions: [
		"ksp"
	]
},
	"application/vnd.kde.kword": {
	source: "iana",
	extensions: [
		"kwd",
		"kwt"
	]
},
	"application/vnd.kenameaapp": {
	source: "iana",
	extensions: [
		"htke"
	]
},
	"application/vnd.kidspiration": {
	source: "iana",
	extensions: [
		"kia"
	]
},
	"application/vnd.kinar": {
	source: "iana",
	extensions: [
		"kne",
		"knp"
	]
},
	"application/vnd.koan": {
	source: "iana",
	extensions: [
		"skp",
		"skd",
		"skt",
		"skm"
	]
},
	"application/vnd.kodak-descriptor": {
	source: "iana",
	extensions: [
		"sse"
	]
},
	"application/vnd.las": {
	source: "iana"
},
	"application/vnd.las.las+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.las.las+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"lasxml"
	]
},
	"application/vnd.laszip": {
	source: "iana"
},
	"application/vnd.leap+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.liberty-request+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.llamagraphics.life-balance.desktop": {
	source: "iana",
	extensions: [
		"lbd"
	]
},
	"application/vnd.llamagraphics.life-balance.exchange+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"lbe"
	]
},
	"application/vnd.logipipe.circuit+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.loom": {
	source: "iana"
},
	"application/vnd.lotus-1-2-3": {
	source: "iana",
	extensions: [
		"123"
	]
},
	"application/vnd.lotus-approach": {
	source: "iana",
	extensions: [
		"apr"
	]
},
	"application/vnd.lotus-freelance": {
	source: "iana",
	extensions: [
		"pre"
	]
},
	"application/vnd.lotus-notes": {
	source: "iana",
	extensions: [
		"nsf"
	]
},
	"application/vnd.lotus-organizer": {
	source: "iana",
	extensions: [
		"org"
	]
},
	"application/vnd.lotus-screencam": {
	source: "iana",
	extensions: [
		"scm"
	]
},
	"application/vnd.lotus-wordpro": {
	source: "iana",
	extensions: [
		"lwp"
	]
},
	"application/vnd.macports.portpkg": {
	source: "iana",
	extensions: [
		"portpkg"
	]
},
	"application/vnd.mapbox-vector-tile": {
	source: "iana",
	extensions: [
		"mvt"
	]
},
	"application/vnd.marlin.drm.actiontoken+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.marlin.drm.conftoken+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.marlin.drm.license+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.marlin.drm.mdcf": {
	source: "iana"
},
	"application/vnd.mason+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.maxar.archive.3tz+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.maxmind.maxmind-db": {
	source: "iana"
},
	"application/vnd.mcd": {
	source: "iana",
	extensions: [
		"mcd"
	]
},
	"application/vnd.medcalcdata": {
	source: "iana",
	extensions: [
		"mc1"
	]
},
	"application/vnd.mediastation.cdkey": {
	source: "iana",
	extensions: [
		"cdkey"
	]
},
	"application/vnd.meridian-slingshot": {
	source: "iana"
},
	"application/vnd.mfer": {
	source: "iana",
	extensions: [
		"mwf"
	]
},
	"application/vnd.mfmp": {
	source: "iana",
	extensions: [
		"mfm"
	]
},
	"application/vnd.micro+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.micrografx.flo": {
	source: "iana",
	extensions: [
		"flo"
	]
},
	"application/vnd.micrografx.igx": {
	source: "iana",
	extensions: [
		"igx"
	]
},
	"application/vnd.microsoft.portable-executable": {
	source: "iana"
},
	"application/vnd.microsoft.windows.thumbnail-cache": {
	source: "iana"
},
	"application/vnd.miele+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.mif": {
	source: "iana",
	extensions: [
		"mif"
	]
},
	"application/vnd.minisoft-hp3000-save": {
	source: "iana"
},
	"application/vnd.mitsubishi.misty-guard.trustweb": {
	source: "iana"
},
	"application/vnd.mobius.daf": {
	source: "iana",
	extensions: [
		"daf"
	]
},
	"application/vnd.mobius.dis": {
	source: "iana",
	extensions: [
		"dis"
	]
},
	"application/vnd.mobius.mbk": {
	source: "iana",
	extensions: [
		"mbk"
	]
},
	"application/vnd.mobius.mqy": {
	source: "iana",
	extensions: [
		"mqy"
	]
},
	"application/vnd.mobius.msl": {
	source: "iana",
	extensions: [
		"msl"
	]
},
	"application/vnd.mobius.plc": {
	source: "iana",
	extensions: [
		"plc"
	]
},
	"application/vnd.mobius.txf": {
	source: "iana",
	extensions: [
		"txf"
	]
},
	"application/vnd.mophun.application": {
	source: "iana",
	extensions: [
		"mpn"
	]
},
	"application/vnd.mophun.certificate": {
	source: "iana",
	extensions: [
		"mpc"
	]
},
	"application/vnd.motorola.flexsuite": {
	source: "iana"
},
	"application/vnd.motorola.flexsuite.adsi": {
	source: "iana"
},
	"application/vnd.motorola.flexsuite.fis": {
	source: "iana"
},
	"application/vnd.motorola.flexsuite.gotap": {
	source: "iana"
},
	"application/vnd.motorola.flexsuite.kmr": {
	source: "iana"
},
	"application/vnd.motorola.flexsuite.ttc": {
	source: "iana"
},
	"application/vnd.motorola.flexsuite.wem": {
	source: "iana"
},
	"application/vnd.motorola.iprm": {
	source: "iana"
},
	"application/vnd.mozilla.xul+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xul"
	]
},
	"application/vnd.ms-3mfdocument": {
	source: "iana"
},
	"application/vnd.ms-artgalry": {
	source: "iana",
	extensions: [
		"cil"
	]
},
	"application/vnd.ms-asf": {
	source: "iana"
},
	"application/vnd.ms-cab-compressed": {
	source: "iana",
	extensions: [
		"cab"
	]
},
	"application/vnd.ms-color.iccprofile": {
	source: "apache"
},
	"application/vnd.ms-excel": {
	source: "iana",
	compressible: false,
	extensions: [
		"xls",
		"xlm",
		"xla",
		"xlc",
		"xlt",
		"xlw"
	]
},
	"application/vnd.ms-excel.addin.macroenabled.12": {
	source: "iana",
	extensions: [
		"xlam"
	]
},
	"application/vnd.ms-excel.sheet.binary.macroenabled.12": {
	source: "iana",
	extensions: [
		"xlsb"
	]
},
	"application/vnd.ms-excel.sheet.macroenabled.12": {
	source: "iana",
	extensions: [
		"xlsm"
	]
},
	"application/vnd.ms-excel.template.macroenabled.12": {
	source: "iana",
	extensions: [
		"xltm"
	]
},
	"application/vnd.ms-fontobject": {
	source: "iana",
	compressible: true,
	extensions: [
		"eot"
	]
},
	"application/vnd.ms-htmlhelp": {
	source: "iana",
	extensions: [
		"chm"
	]
},
	"application/vnd.ms-ims": {
	source: "iana",
	extensions: [
		"ims"
	]
},
	"application/vnd.ms-lrm": {
	source: "iana",
	extensions: [
		"lrm"
	]
},
	"application/vnd.ms-office.activex+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.ms-officetheme": {
	source: "iana",
	extensions: [
		"thmx"
	]
},
	"application/vnd.ms-opentype": {
	source: "apache",
	compressible: true
},
	"application/vnd.ms-outlook": {
	compressible: false,
	extensions: [
		"msg"
	]
},
	"application/vnd.ms-package.obfuscated-opentype": {
	source: "apache"
},
	"application/vnd.ms-pki.seccat": {
	source: "apache",
	extensions: [
		"cat"
	]
},
	"application/vnd.ms-pki.stl": {
	source: "apache",
	extensions: [
		"stl"
	]
},
	"application/vnd.ms-playready.initiator+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.ms-powerpoint": {
	source: "iana",
	compressible: false,
	extensions: [
		"ppt",
		"pps",
		"pot"
	]
},
	"application/vnd.ms-powerpoint.addin.macroenabled.12": {
	source: "iana",
	extensions: [
		"ppam"
	]
},
	"application/vnd.ms-powerpoint.presentation.macroenabled.12": {
	source: "iana",
	extensions: [
		"pptm"
	]
},
	"application/vnd.ms-powerpoint.slide.macroenabled.12": {
	source: "iana",
	extensions: [
		"sldm"
	]
},
	"application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
	source: "iana",
	extensions: [
		"ppsm"
	]
},
	"application/vnd.ms-powerpoint.template.macroenabled.12": {
	source: "iana",
	extensions: [
		"potm"
	]
},
	"application/vnd.ms-printdevicecapabilities+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.ms-printing.printticket+xml": {
	source: "apache",
	compressible: true
},
	"application/vnd.ms-printschematicket+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.ms-project": {
	source: "iana",
	extensions: [
		"mpp",
		"mpt"
	]
},
	"application/vnd.ms-tnef": {
	source: "iana"
},
	"application/vnd.ms-windows.devicepairing": {
	source: "iana"
},
	"application/vnd.ms-windows.nwprinting.oob": {
	source: "iana"
},
	"application/vnd.ms-windows.printerpairing": {
	source: "iana"
},
	"application/vnd.ms-windows.wsd.oob": {
	source: "iana"
},
	"application/vnd.ms-wmdrm.lic-chlg-req": {
	source: "iana"
},
	"application/vnd.ms-wmdrm.lic-resp": {
	source: "iana"
},
	"application/vnd.ms-wmdrm.meter-chlg-req": {
	source: "iana"
},
	"application/vnd.ms-wmdrm.meter-resp": {
	source: "iana"
},
	"application/vnd.ms-word.document.macroenabled.12": {
	source: "iana",
	extensions: [
		"docm"
	]
},
	"application/vnd.ms-word.template.macroenabled.12": {
	source: "iana",
	extensions: [
		"dotm"
	]
},
	"application/vnd.ms-works": {
	source: "iana",
	extensions: [
		"wps",
		"wks",
		"wcm",
		"wdb"
	]
},
	"application/vnd.ms-wpl": {
	source: "iana",
	extensions: [
		"wpl"
	]
},
	"application/vnd.ms-xpsdocument": {
	source: "iana",
	compressible: false,
	extensions: [
		"xps"
	]
},
	"application/vnd.msa-disk-image": {
	source: "iana"
},
	"application/vnd.mseq": {
	source: "iana",
	extensions: [
		"mseq"
	]
},
	"application/vnd.msign": {
	source: "iana"
},
	"application/vnd.multiad.creator": {
	source: "iana"
},
	"application/vnd.multiad.creator.cif": {
	source: "iana"
},
	"application/vnd.music-niff": {
	source: "iana"
},
	"application/vnd.musician": {
	source: "iana",
	extensions: [
		"mus"
	]
},
	"application/vnd.muvee.style": {
	source: "iana",
	extensions: [
		"msty"
	]
},
	"application/vnd.mynfc": {
	source: "iana",
	extensions: [
		"taglet"
	]
},
	"application/vnd.nacamar.ybrid+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ncd.control": {
	source: "iana"
},
	"application/vnd.ncd.reference": {
	source: "iana"
},
	"application/vnd.nearst.inv+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.nebumind.line": {
	source: "iana"
},
	"application/vnd.nervana": {
	source: "iana"
},
	"application/vnd.netfpx": {
	source: "iana"
},
	"application/vnd.neurolanguage.nlu": {
	source: "iana",
	extensions: [
		"nlu"
	]
},
	"application/vnd.nimn": {
	source: "iana"
},
	"application/vnd.nintendo.nitro.rom": {
	source: "iana"
},
	"application/vnd.nintendo.snes.rom": {
	source: "iana"
},
	"application/vnd.nitf": {
	source: "iana",
	extensions: [
		"ntf",
		"nitf"
	]
},
	"application/vnd.noblenet-directory": {
	source: "iana",
	extensions: [
		"nnd"
	]
},
	"application/vnd.noblenet-sealer": {
	source: "iana",
	extensions: [
		"nns"
	]
},
	"application/vnd.noblenet-web": {
	source: "iana",
	extensions: [
		"nnw"
	]
},
	"application/vnd.nokia.catalogs": {
	source: "iana"
},
	"application/vnd.nokia.conml+wbxml": {
	source: "iana"
},
	"application/vnd.nokia.conml+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.nokia.iptv.config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.nokia.isds-radio-presets": {
	source: "iana"
},
	"application/vnd.nokia.landmark+wbxml": {
	source: "iana"
},
	"application/vnd.nokia.landmark+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.nokia.landmarkcollection+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.nokia.n-gage.ac+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"ac"
	]
},
	"application/vnd.nokia.n-gage.data": {
	source: "iana",
	extensions: [
		"ngdat"
	]
},
	"application/vnd.nokia.n-gage.symbian.install": {
	source: "iana",
	extensions: [
		"n-gage"
	]
},
	"application/vnd.nokia.ncd": {
	source: "iana"
},
	"application/vnd.nokia.pcd+wbxml": {
	source: "iana"
},
	"application/vnd.nokia.pcd+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.nokia.radio-preset": {
	source: "iana",
	extensions: [
		"rpst"
	]
},
	"application/vnd.nokia.radio-presets": {
	source: "iana",
	extensions: [
		"rpss"
	]
},
	"application/vnd.novadigm.edm": {
	source: "iana",
	extensions: [
		"edm"
	]
},
	"application/vnd.novadigm.edx": {
	source: "iana",
	extensions: [
		"edx"
	]
},
	"application/vnd.novadigm.ext": {
	source: "iana",
	extensions: [
		"ext"
	]
},
	"application/vnd.ntt-local.content-share": {
	source: "iana"
},
	"application/vnd.ntt-local.file-transfer": {
	source: "iana"
},
	"application/vnd.ntt-local.ogw_remote-access": {
	source: "iana"
},
	"application/vnd.ntt-local.sip-ta_remote": {
	source: "iana"
},
	"application/vnd.ntt-local.sip-ta_tcp_stream": {
	source: "iana"
},
	"application/vnd.oasis.opendocument.chart": {
	source: "iana",
	extensions: [
		"odc"
	]
},
	"application/vnd.oasis.opendocument.chart-template": {
	source: "iana",
	extensions: [
		"otc"
	]
},
	"application/vnd.oasis.opendocument.database": {
	source: "iana",
	extensions: [
		"odb"
	]
},
	"application/vnd.oasis.opendocument.formula": {
	source: "iana",
	extensions: [
		"odf"
	]
},
	"application/vnd.oasis.opendocument.formula-template": {
	source: "iana",
	extensions: [
		"odft"
	]
},
	"application/vnd.oasis.opendocument.graphics": {
	source: "iana",
	compressible: false,
	extensions: [
		"odg"
	]
},
	"application/vnd.oasis.opendocument.graphics-template": {
	source: "iana",
	extensions: [
		"otg"
	]
},
	"application/vnd.oasis.opendocument.image": {
	source: "iana",
	extensions: [
		"odi"
	]
},
	"application/vnd.oasis.opendocument.image-template": {
	source: "iana",
	extensions: [
		"oti"
	]
},
	"application/vnd.oasis.opendocument.presentation": {
	source: "iana",
	compressible: false,
	extensions: [
		"odp"
	]
},
	"application/vnd.oasis.opendocument.presentation-template": {
	source: "iana",
	extensions: [
		"otp"
	]
},
	"application/vnd.oasis.opendocument.spreadsheet": {
	source: "iana",
	compressible: false,
	extensions: [
		"ods"
	]
},
	"application/vnd.oasis.opendocument.spreadsheet-template": {
	source: "iana",
	extensions: [
		"ots"
	]
},
	"application/vnd.oasis.opendocument.text": {
	source: "iana",
	compressible: false,
	extensions: [
		"odt"
	]
},
	"application/vnd.oasis.opendocument.text-master": {
	source: "iana",
	extensions: [
		"odm"
	]
},
	"application/vnd.oasis.opendocument.text-template": {
	source: "iana",
	extensions: [
		"ott"
	]
},
	"application/vnd.oasis.opendocument.text-web": {
	source: "iana",
	extensions: [
		"oth"
	]
},
	"application/vnd.obn": {
	source: "iana"
},
	"application/vnd.ocf+cbor": {
	source: "iana"
},
	"application/vnd.oci.image.manifest.v1+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.oftn.l10n+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.contentaccessdownload+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.contentaccessstreaming+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.cspg-hexbinary": {
	source: "iana"
},
	"application/vnd.oipf.dae.svg+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.dae.xhtml+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.mippvcontrolmessage+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.pae.gem": {
	source: "iana"
},
	"application/vnd.oipf.spdiscovery+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.spdlist+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.ueprofile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.userprofile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.olpc-sugar": {
	source: "iana",
	extensions: [
		"xo"
	]
},
	"application/vnd.oma-scws-config": {
	source: "iana"
},
	"application/vnd.oma-scws-http-request": {
	source: "iana"
},
	"application/vnd.oma-scws-http-response": {
	source: "iana"
},
	"application/vnd.oma.bcast.associated-procedure-parameter+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.drm-trigger+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.imd+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.ltkm": {
	source: "iana"
},
	"application/vnd.oma.bcast.notification+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.provisioningtrigger": {
	source: "iana"
},
	"application/vnd.oma.bcast.sgboot": {
	source: "iana"
},
	"application/vnd.oma.bcast.sgdd+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.sgdu": {
	source: "iana"
},
	"application/vnd.oma.bcast.simple-symbol-container": {
	source: "iana"
},
	"application/vnd.oma.bcast.smartcard-trigger+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.sprov+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.stkm": {
	source: "iana"
},
	"application/vnd.oma.cab-address-book+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.cab-feature-handler+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.cab-pcc+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.cab-subs-invite+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.cab-user-prefs+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.dcd": {
	source: "iana"
},
	"application/vnd.oma.dcdc": {
	source: "iana"
},
	"application/vnd.oma.dd2+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"dd2"
	]
},
	"application/vnd.oma.drm.risd+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.group-usage-list+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.lwm2m+cbor": {
	source: "iana"
},
	"application/vnd.oma.lwm2m+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.lwm2m+tlv": {
	source: "iana"
},
	"application/vnd.oma.pal+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.poc.detailed-progress-report+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.poc.final-report+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.poc.groups+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.poc.invocation-descriptor+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.poc.optimized-progress-report+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.push": {
	source: "iana"
},
	"application/vnd.oma.scidm.messages+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.xcap-directory+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.omads-email+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/vnd.omads-file+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/vnd.omads-folder+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/vnd.omaloc-supl-init": {
	source: "iana"
},
	"application/vnd.onepager": {
	source: "iana"
},
	"application/vnd.onepagertamp": {
	source: "iana"
},
	"application/vnd.onepagertamx": {
	source: "iana"
},
	"application/vnd.onepagertat": {
	source: "iana"
},
	"application/vnd.onepagertatp": {
	source: "iana"
},
	"application/vnd.onepagertatx": {
	source: "iana"
},
	"application/vnd.openblox.game+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"obgx"
	]
},
	"application/vnd.openblox.game-binary": {
	source: "iana"
},
	"application/vnd.openeye.oeb": {
	source: "iana"
},
	"application/vnd.openofficeorg.extension": {
	source: "apache",
	extensions: [
		"oxt"
	]
},
	"application/vnd.openstreetmap.data+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"osm"
	]
},
	"application/vnd.opentimestamps.ots": {
	source: "iana"
},
	"application/vnd.openxmlformats-officedocument.custom-properties+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawing+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.extended-properties+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.presentation": {
	source: "iana",
	compressible: false,
	extensions: [
		"pptx"
	]
},
	"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.slide": {
	source: "iana",
	extensions: [
		"sldx"
	]
},
	"application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
	source: "iana",
	extensions: [
		"ppsx"
	]
},
	"application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.template": {
	source: "iana",
	extensions: [
		"potx"
	]
},
	"application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
	source: "iana",
	compressible: false,
	extensions: [
		"xlsx"
	]
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
	source: "iana",
	extensions: [
		"xltx"
	]
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.theme+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.themeoverride+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.vmldrawing": {
	source: "iana"
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
	source: "iana",
	compressible: false,
	extensions: [
		"docx"
	]
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
	source: "iana",
	extensions: [
		"dotx"
	]
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-package.core-properties+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-package.relationships+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oracle.resource+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.orange.indata": {
	source: "iana"
},
	"application/vnd.osa.netdeploy": {
	source: "iana"
},
	"application/vnd.osgeo.mapguide.package": {
	source: "iana",
	extensions: [
		"mgp"
	]
},
	"application/vnd.osgi.bundle": {
	source: "iana"
},
	"application/vnd.osgi.dp": {
	source: "iana",
	extensions: [
		"dp"
	]
},
	"application/vnd.osgi.subsystem": {
	source: "iana",
	extensions: [
		"esa"
	]
},
	"application/vnd.otps.ct-kip+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oxli.countgraph": {
	source: "iana"
},
	"application/vnd.pagerduty+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.palm": {
	source: "iana",
	extensions: [
		"pdb",
		"pqa",
		"oprc"
	]
},
	"application/vnd.panoply": {
	source: "iana"
},
	"application/vnd.paos.xml": {
	source: "iana"
},
	"application/vnd.patentdive": {
	source: "iana"
},
	"application/vnd.patientecommsdoc": {
	source: "iana"
},
	"application/vnd.pawaafile": {
	source: "iana",
	extensions: [
		"paw"
	]
},
	"application/vnd.pcos": {
	source: "iana"
},
	"application/vnd.pg.format": {
	source: "iana",
	extensions: [
		"str"
	]
},
	"application/vnd.pg.osasli": {
	source: "iana",
	extensions: [
		"ei6"
	]
},
	"application/vnd.piaccess.application-licence": {
	source: "iana"
},
	"application/vnd.picsel": {
	source: "iana",
	extensions: [
		"efif"
	]
},
	"application/vnd.pmi.widget": {
	source: "iana",
	extensions: [
		"wg"
	]
},
	"application/vnd.poc.group-advertisement+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.pocketlearn": {
	source: "iana",
	extensions: [
		"plf"
	]
},
	"application/vnd.powerbuilder6": {
	source: "iana",
	extensions: [
		"pbd"
	]
},
	"application/vnd.powerbuilder6-s": {
	source: "iana"
},
	"application/vnd.powerbuilder7": {
	source: "iana"
},
	"application/vnd.powerbuilder7-s": {
	source: "iana"
},
	"application/vnd.powerbuilder75": {
	source: "iana"
},
	"application/vnd.powerbuilder75-s": {
	source: "iana"
},
	"application/vnd.preminet": {
	source: "iana"
},
	"application/vnd.previewsystems.box": {
	source: "iana",
	extensions: [
		"box"
	]
},
	"application/vnd.proteus.magazine": {
	source: "iana",
	extensions: [
		"mgz"
	]
},
	"application/vnd.psfs": {
	source: "iana"
},
	"application/vnd.publishare-delta-tree": {
	source: "iana",
	extensions: [
		"qps"
	]
},
	"application/vnd.pvi.ptid1": {
	source: "iana",
	extensions: [
		"ptid"
	]
},
	"application/vnd.pwg-multiplexed": {
	source: "iana"
},
	"application/vnd.pwg-xhtml-print+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.qualcomm.brew-app-res": {
	source: "iana"
},
	"application/vnd.quarantainenet": {
	source: "iana"
},
	"application/vnd.quark.quarkxpress": {
	source: "iana",
	extensions: [
		"qxd",
		"qxt",
		"qwd",
		"qwt",
		"qxl",
		"qxb"
	]
},
	"application/vnd.quobject-quoxdocument": {
	source: "iana"
},
	"application/vnd.radisys.moml+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-audit+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-audit-conf+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-audit-conn+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-audit-dialog+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-audit-stream+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-conf+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog-base+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog-fax-detect+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog-group+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog-speech+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog-transform+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.rainstor.data": {
	source: "iana"
},
	"application/vnd.rapid": {
	source: "iana"
},
	"application/vnd.rar": {
	source: "iana",
	extensions: [
		"rar"
	]
},
	"application/vnd.realvnc.bed": {
	source: "iana",
	extensions: [
		"bed"
	]
},
	"application/vnd.recordare.musicxml": {
	source: "iana",
	extensions: [
		"mxl"
	]
},
	"application/vnd.recordare.musicxml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"musicxml"
	]
},
	"application/vnd.renlearn.rlprint": {
	source: "iana"
},
	"application/vnd.resilient.logic": {
	source: "iana"
},
	"application/vnd.restful+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.rig.cryptonote": {
	source: "iana",
	extensions: [
		"cryptonote"
	]
},
	"application/vnd.rim.cod": {
	source: "apache",
	extensions: [
		"cod"
	]
},
	"application/vnd.rn-realmedia": {
	source: "apache",
	extensions: [
		"rm"
	]
},
	"application/vnd.rn-realmedia-vbr": {
	source: "apache",
	extensions: [
		"rmvb"
	]
},
	"application/vnd.route66.link66+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"link66"
	]
},
	"application/vnd.rs-274x": {
	source: "iana"
},
	"application/vnd.ruckus.download": {
	source: "iana"
},
	"application/vnd.s3sms": {
	source: "iana"
},
	"application/vnd.sailingtracker.track": {
	source: "iana",
	extensions: [
		"st"
	]
},
	"application/vnd.sar": {
	source: "iana"
},
	"application/vnd.sbm.cid": {
	source: "iana"
},
	"application/vnd.sbm.mid2": {
	source: "iana"
},
	"application/vnd.scribus": {
	source: "iana"
},
	"application/vnd.sealed.3df": {
	source: "iana"
},
	"application/vnd.sealed.csf": {
	source: "iana"
},
	"application/vnd.sealed.doc": {
	source: "iana"
},
	"application/vnd.sealed.eml": {
	source: "iana"
},
	"application/vnd.sealed.mht": {
	source: "iana"
},
	"application/vnd.sealed.net": {
	source: "iana"
},
	"application/vnd.sealed.ppt": {
	source: "iana"
},
	"application/vnd.sealed.tiff": {
	source: "iana"
},
	"application/vnd.sealed.xls": {
	source: "iana"
},
	"application/vnd.sealedmedia.softseal.html": {
	source: "iana"
},
	"application/vnd.sealedmedia.softseal.pdf": {
	source: "iana"
},
	"application/vnd.seemail": {
	source: "iana",
	extensions: [
		"see"
	]
},
	"application/vnd.seis+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.sema": {
	source: "iana",
	extensions: [
		"sema"
	]
},
	"application/vnd.semd": {
	source: "iana",
	extensions: [
		"semd"
	]
},
	"application/vnd.semf": {
	source: "iana",
	extensions: [
		"semf"
	]
},
	"application/vnd.shade-save-file": {
	source: "iana"
},
	"application/vnd.shana.informed.formdata": {
	source: "iana",
	extensions: [
		"ifm"
	]
},
	"application/vnd.shana.informed.formtemplate": {
	source: "iana",
	extensions: [
		"itp"
	]
},
	"application/vnd.shana.informed.interchange": {
	source: "iana",
	extensions: [
		"iif"
	]
},
	"application/vnd.shana.informed.package": {
	source: "iana",
	extensions: [
		"ipk"
	]
},
	"application/vnd.shootproof+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.shopkick+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.shp": {
	source: "iana"
},
	"application/vnd.shx": {
	source: "iana"
},
	"application/vnd.sigrok.session": {
	source: "iana"
},
	"application/vnd.simtech-mindmapper": {
	source: "iana",
	extensions: [
		"twd",
		"twds"
	]
},
	"application/vnd.siren+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.smaf": {
	source: "iana",
	extensions: [
		"mmf"
	]
},
	"application/vnd.smart.notebook": {
	source: "iana"
},
	"application/vnd.smart.teacher": {
	source: "iana",
	extensions: [
		"teacher"
	]
},
	"application/vnd.snesdev-page-table": {
	source: "iana"
},
	"application/vnd.software602.filler.form+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"fo"
	]
},
	"application/vnd.software602.filler.form-xml-zip": {
	source: "iana"
},
	"application/vnd.solent.sdkm+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"sdkm",
		"sdkd"
	]
},
	"application/vnd.spotfire.dxp": {
	source: "iana",
	extensions: [
		"dxp"
	]
},
	"application/vnd.spotfire.sfs": {
	source: "iana",
	extensions: [
		"sfs"
	]
},
	"application/vnd.sqlite3": {
	source: "iana"
},
	"application/vnd.sss-cod": {
	source: "iana"
},
	"application/vnd.sss-dtf": {
	source: "iana"
},
	"application/vnd.sss-ntf": {
	source: "iana"
},
	"application/vnd.stardivision.calc": {
	source: "apache",
	extensions: [
		"sdc"
	]
},
	"application/vnd.stardivision.draw": {
	source: "apache",
	extensions: [
		"sda"
	]
},
	"application/vnd.stardivision.impress": {
	source: "apache",
	extensions: [
		"sdd"
	]
},
	"application/vnd.stardivision.math": {
	source: "apache",
	extensions: [
		"smf"
	]
},
	"application/vnd.stardivision.writer": {
	source: "apache",
	extensions: [
		"sdw",
		"vor"
	]
},
	"application/vnd.stardivision.writer-global": {
	source: "apache",
	extensions: [
		"sgl"
	]
},
	"application/vnd.stepmania.package": {
	source: "iana",
	extensions: [
		"smzip"
	]
},
	"application/vnd.stepmania.stepchart": {
	source: "iana",
	extensions: [
		"sm"
	]
},
	"application/vnd.street-stream": {
	source: "iana"
},
	"application/vnd.sun.wadl+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"wadl"
	]
},
	"application/vnd.sun.xml.calc": {
	source: "apache",
	extensions: [
		"sxc"
	]
},
	"application/vnd.sun.xml.calc.template": {
	source: "apache",
	extensions: [
		"stc"
	]
},
	"application/vnd.sun.xml.draw": {
	source: "apache",
	extensions: [
		"sxd"
	]
},
	"application/vnd.sun.xml.draw.template": {
	source: "apache",
	extensions: [
		"std"
	]
},
	"application/vnd.sun.xml.impress": {
	source: "apache",
	extensions: [
		"sxi"
	]
},
	"application/vnd.sun.xml.impress.template": {
	source: "apache",
	extensions: [
		"sti"
	]
},
	"application/vnd.sun.xml.math": {
	source: "apache",
	extensions: [
		"sxm"
	]
},
	"application/vnd.sun.xml.writer": {
	source: "apache",
	extensions: [
		"sxw"
	]
},
	"application/vnd.sun.xml.writer.global": {
	source: "apache",
	extensions: [
		"sxg"
	]
},
	"application/vnd.sun.xml.writer.template": {
	source: "apache",
	extensions: [
		"stw"
	]
},
	"application/vnd.sus-calendar": {
	source: "iana",
	extensions: [
		"sus",
		"susp"
	]
},
	"application/vnd.svd": {
	source: "iana",
	extensions: [
		"svd"
	]
},
	"application/vnd.swiftview-ics": {
	source: "iana"
},
	"application/vnd.sycle+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.syft+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.symbian.install": {
	source: "apache",
	extensions: [
		"sis",
		"sisx"
	]
},
	"application/vnd.syncml+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"xsm"
	]
},
	"application/vnd.syncml.dm+wbxml": {
	source: "iana",
	charset: "UTF-8",
	extensions: [
		"bdm"
	]
},
	"application/vnd.syncml.dm+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"xdm"
	]
},
	"application/vnd.syncml.dm.notification": {
	source: "iana"
},
	"application/vnd.syncml.dmddf+wbxml": {
	source: "iana"
},
	"application/vnd.syncml.dmddf+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"ddf"
	]
},
	"application/vnd.syncml.dmtnds+wbxml": {
	source: "iana"
},
	"application/vnd.syncml.dmtnds+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/vnd.syncml.ds.notification": {
	source: "iana"
},
	"application/vnd.tableschema+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.tao.intent-module-archive": {
	source: "iana",
	extensions: [
		"tao"
	]
},
	"application/vnd.tcpdump.pcap": {
	source: "iana",
	extensions: [
		"pcap",
		"cap",
		"dmp"
	]
},
	"application/vnd.think-cell.ppttc+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.tmd.mediaflex.api+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.tml": {
	source: "iana"
},
	"application/vnd.tmobile-livetv": {
	source: "iana",
	extensions: [
		"tmo"
	]
},
	"application/vnd.tri.onesource": {
	source: "iana"
},
	"application/vnd.trid.tpt": {
	source: "iana",
	extensions: [
		"tpt"
	]
},
	"application/vnd.triscape.mxs": {
	source: "iana",
	extensions: [
		"mxs"
	]
},
	"application/vnd.trueapp": {
	source: "iana",
	extensions: [
		"tra"
	]
},
	"application/vnd.truedoc": {
	source: "iana"
},
	"application/vnd.ubisoft.webplayer": {
	source: "iana"
},
	"application/vnd.ufdl": {
	source: "iana",
	extensions: [
		"ufd",
		"ufdl"
	]
},
	"application/vnd.uiq.theme": {
	source: "iana",
	extensions: [
		"utz"
	]
},
	"application/vnd.umajin": {
	source: "iana",
	extensions: [
		"umj"
	]
},
	"application/vnd.unity": {
	source: "iana",
	extensions: [
		"unityweb"
	]
},
	"application/vnd.uoml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"uoml"
	]
},
	"application/vnd.uplanet.alert": {
	source: "iana"
},
	"application/vnd.uplanet.alert-wbxml": {
	source: "iana"
},
	"application/vnd.uplanet.bearer-choice": {
	source: "iana"
},
	"application/vnd.uplanet.bearer-choice-wbxml": {
	source: "iana"
},
	"application/vnd.uplanet.cacheop": {
	source: "iana"
},
	"application/vnd.uplanet.cacheop-wbxml": {
	source: "iana"
},
	"application/vnd.uplanet.channel": {
	source: "iana"
},
	"application/vnd.uplanet.channel-wbxml": {
	source: "iana"
},
	"application/vnd.uplanet.list": {
	source: "iana"
},
	"application/vnd.uplanet.list-wbxml": {
	source: "iana"
},
	"application/vnd.uplanet.listcmd": {
	source: "iana"
},
	"application/vnd.uplanet.listcmd-wbxml": {
	source: "iana"
},
	"application/vnd.uplanet.signal": {
	source: "iana"
},
	"application/vnd.uri-map": {
	source: "iana"
},
	"application/vnd.valve.source.material": {
	source: "iana"
},
	"application/vnd.vcx": {
	source: "iana",
	extensions: [
		"vcx"
	]
},
	"application/vnd.vd-study": {
	source: "iana"
},
	"application/vnd.vectorworks": {
	source: "iana"
},
	"application/vnd.vel+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.verimatrix.vcas": {
	source: "iana"
},
	"application/vnd.veritone.aion+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.veryant.thin": {
	source: "iana"
},
	"application/vnd.ves.encrypted": {
	source: "iana"
},
	"application/vnd.vidsoft.vidconference": {
	source: "iana"
},
	"application/vnd.visio": {
	source: "iana",
	extensions: [
		"vsd",
		"vst",
		"vss",
		"vsw"
	]
},
	"application/vnd.visionary": {
	source: "iana",
	extensions: [
		"vis"
	]
},
	"application/vnd.vividence.scriptfile": {
	source: "iana"
},
	"application/vnd.vsf": {
	source: "iana",
	extensions: [
		"vsf"
	]
},
	"application/vnd.wap.sic": {
	source: "iana"
},
	"application/vnd.wap.slc": {
	source: "iana"
},
	"application/vnd.wap.wbxml": {
	source: "iana",
	charset: "UTF-8",
	extensions: [
		"wbxml"
	]
},
	"application/vnd.wap.wmlc": {
	source: "iana",
	extensions: [
		"wmlc"
	]
},
	"application/vnd.wap.wmlscriptc": {
	source: "iana",
	extensions: [
		"wmlsc"
	]
},
	"application/vnd.webturbo": {
	source: "iana",
	extensions: [
		"wtb"
	]
},
	"application/vnd.wfa.dpp": {
	source: "iana"
},
	"application/vnd.wfa.p2p": {
	source: "iana"
},
	"application/vnd.wfa.wsc": {
	source: "iana"
},
	"application/vnd.windows.devicepairing": {
	source: "iana"
},
	"application/vnd.wmc": {
	source: "iana"
},
	"application/vnd.wmf.bootstrap": {
	source: "iana"
},
	"application/vnd.wolfram.mathematica": {
	source: "iana"
},
	"application/vnd.wolfram.mathematica.package": {
	source: "iana"
},
	"application/vnd.wolfram.player": {
	source: "iana",
	extensions: [
		"nbp"
	]
},
	"application/vnd.wordperfect": {
	source: "iana",
	extensions: [
		"wpd"
	]
},
	"application/vnd.wqd": {
	source: "iana",
	extensions: [
		"wqd"
	]
},
	"application/vnd.wrq-hp3000-labelled": {
	source: "iana"
},
	"application/vnd.wt.stf": {
	source: "iana",
	extensions: [
		"stf"
	]
},
	"application/vnd.wv.csp+wbxml": {
	source: "iana"
},
	"application/vnd.wv.csp+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.wv.ssp+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.xacml+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.xara": {
	source: "iana",
	extensions: [
		"xar"
	]
},
	"application/vnd.xfdl": {
	source: "iana",
	extensions: [
		"xfdl"
	]
},
	"application/vnd.xfdl.webform": {
	source: "iana"
},
	"application/vnd.xmi+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.xmpie.cpkg": {
	source: "iana"
},
	"application/vnd.xmpie.dpkg": {
	source: "iana"
},
	"application/vnd.xmpie.plan": {
	source: "iana"
},
	"application/vnd.xmpie.ppkg": {
	source: "iana"
},
	"application/vnd.xmpie.xlim": {
	source: "iana"
},
	"application/vnd.yamaha.hv-dic": {
	source: "iana",
	extensions: [
		"hvd"
	]
},
	"application/vnd.yamaha.hv-script": {
	source: "iana",
	extensions: [
		"hvs"
	]
},
	"application/vnd.yamaha.hv-voice": {
	source: "iana",
	extensions: [
		"hvp"
	]
},
	"application/vnd.yamaha.openscoreformat": {
	source: "iana",
	extensions: [
		"osf"
	]
},
	"application/vnd.yamaha.openscoreformat.osfpvg+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"osfpvg"
	]
},
	"application/vnd.yamaha.remote-setup": {
	source: "iana"
},
	"application/vnd.yamaha.smaf-audio": {
	source: "iana",
	extensions: [
		"saf"
	]
},
	"application/vnd.yamaha.smaf-phrase": {
	source: "iana",
	extensions: [
		"spf"
	]
},
	"application/vnd.yamaha.through-ngn": {
	source: "iana"
},
	"application/vnd.yamaha.tunnel-udpencap": {
	source: "iana"
},
	"application/vnd.yaoweme": {
	source: "iana"
},
	"application/vnd.yellowriver-custom-menu": {
	source: "iana",
	extensions: [
		"cmp"
	]
},
	"application/vnd.youtube.yt": {
	source: "iana"
},
	"application/vnd.zul": {
	source: "iana",
	extensions: [
		"zir",
		"zirz"
	]
},
	"application/vnd.zzazz.deck+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"zaz"
	]
},
	"application/voicexml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"vxml"
	]
},
	"application/voucher-cms+json": {
	source: "iana",
	compressible: true
},
	"application/vq-rtcpxr": {
	source: "iana"
},
	"application/wasm": {
	source: "iana",
	compressible: true,
	extensions: [
		"wasm"
	]
},
	"application/watcherinfo+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"wif"
	]
},
	"application/webpush-options+json": {
	source: "iana",
	compressible: true
},
	"application/whoispp-query": {
	source: "iana"
},
	"application/whoispp-response": {
	source: "iana"
},
	"application/widget": {
	source: "iana",
	extensions: [
		"wgt"
	]
},
	"application/winhlp": {
	source: "apache",
	extensions: [
		"hlp"
	]
},
	"application/wita": {
	source: "iana"
},
	"application/wordperfect5.1": {
	source: "iana"
},
	"application/wsdl+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"wsdl"
	]
},
	"application/wspolicy+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"wspolicy"
	]
},
	"application/x-7z-compressed": {
	source: "apache",
	compressible: false,
	extensions: [
		"7z"
	]
},
	"application/x-abiword": {
	source: "apache",
	extensions: [
		"abw"
	]
},
	"application/x-ace-compressed": {
	source: "apache",
	extensions: [
		"ace"
	]
},
	"application/x-amf": {
	source: "apache"
},
	"application/x-apple-diskimage": {
	source: "apache",
	extensions: [
		"dmg"
	]
},
	"application/x-arj": {
	compressible: false,
	extensions: [
		"arj"
	]
},
	"application/x-authorware-bin": {
	source: "apache",
	extensions: [
		"aab",
		"x32",
		"u32",
		"vox"
	]
},
	"application/x-authorware-map": {
	source: "apache",
	extensions: [
		"aam"
	]
},
	"application/x-authorware-seg": {
	source: "apache",
	extensions: [
		"aas"
	]
},
	"application/x-bcpio": {
	source: "apache",
	extensions: [
		"bcpio"
	]
},
	"application/x-bdoc": {
	compressible: false,
	extensions: [
		"bdoc"
	]
},
	"application/x-bittorrent": {
	source: "apache",
	extensions: [
		"torrent"
	]
},
	"application/x-blorb": {
	source: "apache",
	extensions: [
		"blb",
		"blorb"
	]
},
	"application/x-bzip": {
	source: "apache",
	compressible: false,
	extensions: [
		"bz"
	]
},
	"application/x-bzip2": {
	source: "apache",
	compressible: false,
	extensions: [
		"bz2",
		"boz"
	]
},
	"application/x-cbr": {
	source: "apache",
	extensions: [
		"cbr",
		"cba",
		"cbt",
		"cbz",
		"cb7"
	]
},
	"application/x-cdlink": {
	source: "apache",
	extensions: [
		"vcd"
	]
},
	"application/x-cfs-compressed": {
	source: "apache",
	extensions: [
		"cfs"
	]
},
	"application/x-chat": {
	source: "apache",
	extensions: [
		"chat"
	]
},
	"application/x-chess-pgn": {
	source: "apache",
	extensions: [
		"pgn"
	]
},
	"application/x-chrome-extension": {
	extensions: [
		"crx"
	]
},
	"application/x-cocoa": {
	source: "nginx",
	extensions: [
		"cco"
	]
},
	"application/x-compress": {
	source: "apache"
},
	"application/x-conference": {
	source: "apache",
	extensions: [
		"nsc"
	]
},
	"application/x-cpio": {
	source: "apache",
	extensions: [
		"cpio"
	]
},
	"application/x-csh": {
	source: "apache",
	extensions: [
		"csh"
	]
},
	"application/x-deb": {
	compressible: false
},
	"application/x-debian-package": {
	source: "apache",
	extensions: [
		"deb",
		"udeb"
	]
},
	"application/x-dgc-compressed": {
	source: "apache",
	extensions: [
		"dgc"
	]
},
	"application/x-director": {
	source: "apache",
	extensions: [
		"dir",
		"dcr",
		"dxr",
		"cst",
		"cct",
		"cxt",
		"w3d",
		"fgd",
		"swa"
	]
},
	"application/x-doom": {
	source: "apache",
	extensions: [
		"wad"
	]
},
	"application/x-dtbncx+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"ncx"
	]
},
	"application/x-dtbook+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"dtb"
	]
},
	"application/x-dtbresource+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"res"
	]
},
	"application/x-dvi": {
	source: "apache",
	compressible: false,
	extensions: [
		"dvi"
	]
},
	"application/x-envoy": {
	source: "apache",
	extensions: [
		"evy"
	]
},
	"application/x-eva": {
	source: "apache",
	extensions: [
		"eva"
	]
},
	"application/x-font-bdf": {
	source: "apache",
	extensions: [
		"bdf"
	]
},
	"application/x-font-dos": {
	source: "apache"
},
	"application/x-font-framemaker": {
	source: "apache"
},
	"application/x-font-ghostscript": {
	source: "apache",
	extensions: [
		"gsf"
	]
},
	"application/x-font-libgrx": {
	source: "apache"
},
	"application/x-font-linux-psf": {
	source: "apache",
	extensions: [
		"psf"
	]
},
	"application/x-font-pcf": {
	source: "apache",
	extensions: [
		"pcf"
	]
},
	"application/x-font-snf": {
	source: "apache",
	extensions: [
		"snf"
	]
},
	"application/x-font-speedo": {
	source: "apache"
},
	"application/x-font-sunos-news": {
	source: "apache"
},
	"application/x-font-type1": {
	source: "apache",
	extensions: [
		"pfa",
		"pfb",
		"pfm",
		"afm"
	]
},
	"application/x-font-vfont": {
	source: "apache"
},
	"application/x-freearc": {
	source: "apache",
	extensions: [
		"arc"
	]
},
	"application/x-futuresplash": {
	source: "apache",
	extensions: [
		"spl"
	]
},
	"application/x-gca-compressed": {
	source: "apache",
	extensions: [
		"gca"
	]
},
	"application/x-glulx": {
	source: "apache",
	extensions: [
		"ulx"
	]
},
	"application/x-gnumeric": {
	source: "apache",
	extensions: [
		"gnumeric"
	]
},
	"application/x-gramps-xml": {
	source: "apache",
	extensions: [
		"gramps"
	]
},
	"application/x-gtar": {
	source: "apache",
	extensions: [
		"gtar"
	]
},
	"application/x-gzip": {
	source: "apache"
},
	"application/x-hdf": {
	source: "apache",
	extensions: [
		"hdf"
	]
},
	"application/x-httpd-php": {
	compressible: true,
	extensions: [
		"php"
	]
},
	"application/x-install-instructions": {
	source: "apache",
	extensions: [
		"install"
	]
},
	"application/x-iso9660-image": {
	source: "apache",
	extensions: [
		"iso"
	]
},
	"application/x-iwork-keynote-sffkey": {
	extensions: [
		"key"
	]
},
	"application/x-iwork-numbers-sffnumbers": {
	extensions: [
		"numbers"
	]
},
	"application/x-iwork-pages-sffpages": {
	extensions: [
		"pages"
	]
},
	"application/x-java-archive-diff": {
	source: "nginx",
	extensions: [
		"jardiff"
	]
},
	"application/x-java-jnlp-file": {
	source: "apache",
	compressible: false,
	extensions: [
		"jnlp"
	]
},
	"application/x-javascript": {
	compressible: true
},
	"application/x-keepass2": {
	extensions: [
		"kdbx"
	]
},
	"application/x-latex": {
	source: "apache",
	compressible: false,
	extensions: [
		"latex"
	]
},
	"application/x-lua-bytecode": {
	extensions: [
		"luac"
	]
},
	"application/x-lzh-compressed": {
	source: "apache",
	extensions: [
		"lzh",
		"lha"
	]
},
	"application/x-makeself": {
	source: "nginx",
	extensions: [
		"run"
	]
},
	"application/x-mie": {
	source: "apache",
	extensions: [
		"mie"
	]
},
	"application/x-mobipocket-ebook": {
	source: "apache",
	extensions: [
		"prc",
		"mobi"
	]
},
	"application/x-mpegurl": {
	compressible: false
},
	"application/x-ms-application": {
	source: "apache",
	extensions: [
		"application"
	]
},
	"application/x-ms-shortcut": {
	source: "apache",
	extensions: [
		"lnk"
	]
},
	"application/x-ms-wmd": {
	source: "apache",
	extensions: [
		"wmd"
	]
},
	"application/x-ms-wmz": {
	source: "apache",
	extensions: [
		"wmz"
	]
},
	"application/x-ms-xbap": {
	source: "apache",
	extensions: [
		"xbap"
	]
},
	"application/x-msaccess": {
	source: "apache",
	extensions: [
		"mdb"
	]
},
	"application/x-msbinder": {
	source: "apache",
	extensions: [
		"obd"
	]
},
	"application/x-mscardfile": {
	source: "apache",
	extensions: [
		"crd"
	]
},
	"application/x-msclip": {
	source: "apache",
	extensions: [
		"clp"
	]
},
	"application/x-msdos-program": {
	extensions: [
		"exe"
	]
},
	"application/x-msdownload": {
	source: "apache",
	extensions: [
		"exe",
		"dll",
		"com",
		"bat",
		"msi"
	]
},
	"application/x-msmediaview": {
	source: "apache",
	extensions: [
		"mvb",
		"m13",
		"m14"
	]
},
	"application/x-msmetafile": {
	source: "apache",
	extensions: [
		"wmf",
		"wmz",
		"emf",
		"emz"
	]
},
	"application/x-msmoney": {
	source: "apache",
	extensions: [
		"mny"
	]
},
	"application/x-mspublisher": {
	source: "apache",
	extensions: [
		"pub"
	]
},
	"application/x-msschedule": {
	source: "apache",
	extensions: [
		"scd"
	]
},
	"application/x-msterminal": {
	source: "apache",
	extensions: [
		"trm"
	]
},
	"application/x-mswrite": {
	source: "apache",
	extensions: [
		"wri"
	]
},
	"application/x-netcdf": {
	source: "apache",
	extensions: [
		"nc",
		"cdf"
	]
},
	"application/x-ns-proxy-autoconfig": {
	compressible: true,
	extensions: [
		"pac"
	]
},
	"application/x-nzb": {
	source: "apache",
	extensions: [
		"nzb"
	]
},
	"application/x-perl": {
	source: "nginx",
	extensions: [
		"pl",
		"pm"
	]
},
	"application/x-pilot": {
	source: "nginx",
	extensions: [
		"prc",
		"pdb"
	]
},
	"application/x-pkcs12": {
	source: "apache",
	compressible: false,
	extensions: [
		"p12",
		"pfx"
	]
},
	"application/x-pkcs7-certificates": {
	source: "apache",
	extensions: [
		"p7b",
		"spc"
	]
},
	"application/x-pkcs7-certreqresp": {
	source: "apache",
	extensions: [
		"p7r"
	]
},
	"application/x-pki-message": {
	source: "iana"
},
	"application/x-rar-compressed": {
	source: "apache",
	compressible: false,
	extensions: [
		"rar"
	]
},
	"application/x-redhat-package-manager": {
	source: "nginx",
	extensions: [
		"rpm"
	]
},
	"application/x-research-info-systems": {
	source: "apache",
	extensions: [
		"ris"
	]
},
	"application/x-sea": {
	source: "nginx",
	extensions: [
		"sea"
	]
},
	"application/x-sh": {
	source: "apache",
	compressible: true,
	extensions: [
		"sh"
	]
},
	"application/x-shar": {
	source: "apache",
	extensions: [
		"shar"
	]
},
	"application/x-shockwave-flash": {
	source: "apache",
	compressible: false,
	extensions: [
		"swf"
	]
},
	"application/x-silverlight-app": {
	source: "apache",
	extensions: [
		"xap"
	]
},
	"application/x-sql": {
	source: "apache",
	extensions: [
		"sql"
	]
},
	"application/x-stuffit": {
	source: "apache",
	compressible: false,
	extensions: [
		"sit"
	]
},
	"application/x-stuffitx": {
	source: "apache",
	extensions: [
		"sitx"
	]
},
	"application/x-subrip": {
	source: "apache",
	extensions: [
		"srt"
	]
},
	"application/x-sv4cpio": {
	source: "apache",
	extensions: [
		"sv4cpio"
	]
},
	"application/x-sv4crc": {
	source: "apache",
	extensions: [
		"sv4crc"
	]
},
	"application/x-t3vm-image": {
	source: "apache",
	extensions: [
		"t3"
	]
},
	"application/x-tads": {
	source: "apache",
	extensions: [
		"gam"
	]
},
	"application/x-tar": {
	source: "apache",
	compressible: true,
	extensions: [
		"tar"
	]
},
	"application/x-tcl": {
	source: "apache",
	extensions: [
		"tcl",
		"tk"
	]
},
	"application/x-tex": {
	source: "apache",
	extensions: [
		"tex"
	]
},
	"application/x-tex-tfm": {
	source: "apache",
	extensions: [
		"tfm"
	]
},
	"application/x-texinfo": {
	source: "apache",
	extensions: [
		"texinfo",
		"texi"
	]
},
	"application/x-tgif": {
	source: "apache",
	extensions: [
		"obj"
	]
},
	"application/x-ustar": {
	source: "apache",
	extensions: [
		"ustar"
	]
},
	"application/x-virtualbox-hdd": {
	compressible: true,
	extensions: [
		"hdd"
	]
},
	"application/x-virtualbox-ova": {
	compressible: true,
	extensions: [
		"ova"
	]
},
	"application/x-virtualbox-ovf": {
	compressible: true,
	extensions: [
		"ovf"
	]
},
	"application/x-virtualbox-vbox": {
	compressible: true,
	extensions: [
		"vbox"
	]
},
	"application/x-virtualbox-vbox-extpack": {
	compressible: false,
	extensions: [
		"vbox-extpack"
	]
},
	"application/x-virtualbox-vdi": {
	compressible: true,
	extensions: [
		"vdi"
	]
},
	"application/x-virtualbox-vhd": {
	compressible: true,
	extensions: [
		"vhd"
	]
},
	"application/x-virtualbox-vmdk": {
	compressible: true,
	extensions: [
		"vmdk"
	]
},
	"application/x-wais-source": {
	source: "apache",
	extensions: [
		"src"
	]
},
	"application/x-web-app-manifest+json": {
	compressible: true,
	extensions: [
		"webapp"
	]
},
	"application/x-www-form-urlencoded": {
	source: "iana",
	compressible: true
},
	"application/x-x509-ca-cert": {
	source: "iana",
	extensions: [
		"der",
		"crt",
		"pem"
	]
},
	"application/x-x509-ca-ra-cert": {
	source: "iana"
},
	"application/x-x509-next-ca-cert": {
	source: "iana"
},
	"application/x-xfig": {
	source: "apache",
	extensions: [
		"fig"
	]
},
	"application/x-xliff+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"xlf"
	]
},
	"application/x-xpinstall": {
	source: "apache",
	compressible: false,
	extensions: [
		"xpi"
	]
},
	"application/x-xz": {
	source: "apache",
	extensions: [
		"xz"
	]
},
	"application/x-zmachine": {
	source: "apache",
	extensions: [
		"z1",
		"z2",
		"z3",
		"z4",
		"z5",
		"z6",
		"z7",
		"z8"
	]
},
	"application/x400-bp": {
	source: "iana"
},
	"application/xacml+xml": {
	source: "iana",
	compressible: true
},
	"application/xaml+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"xaml"
	]
},
	"application/xcap-att+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xav"
	]
},
	"application/xcap-caps+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xca"
	]
},
	"application/xcap-diff+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xdf"
	]
},
	"application/xcap-el+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xel"
	]
},
	"application/xcap-error+xml": {
	source: "iana",
	compressible: true
},
	"application/xcap-ns+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xns"
	]
},
	"application/xcon-conference-info+xml": {
	source: "iana",
	compressible: true
},
	"application/xcon-conference-info-diff+xml": {
	source: "iana",
	compressible: true
},
	"application/xenc+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xenc"
	]
},
	"application/xhtml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xhtml",
		"xht"
	]
},
	"application/xhtml-voice+xml": {
	source: "apache",
	compressible: true
},
	"application/xliff+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xlf"
	]
},
	"application/xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xml",
		"xsl",
		"xsd",
		"rng"
	]
},
	"application/xml-dtd": {
	source: "iana",
	compressible: true,
	extensions: [
		"dtd"
	]
},
	"application/xml-external-parsed-entity": {
	source: "iana"
},
	"application/xml-patch+xml": {
	source: "iana",
	compressible: true
},
	"application/xmpp+xml": {
	source: "iana",
	compressible: true
},
	"application/xop+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xop"
	]
},
	"application/xproc+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"xpl"
	]
},
	"application/xslt+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xsl",
		"xslt"
	]
},
	"application/xspf+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"xspf"
	]
},
	"application/xv+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mxml",
		"xhvml",
		"xvml",
		"xvm"
	]
},
	"application/yang": {
	source: "iana",
	extensions: [
		"yang"
	]
},
	"application/yang-data+json": {
	source: "iana",
	compressible: true
},
	"application/yang-data+xml": {
	source: "iana",
	compressible: true
},
	"application/yang-patch+json": {
	source: "iana",
	compressible: true
},
	"application/yang-patch+xml": {
	source: "iana",
	compressible: true
},
	"application/yin+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"yin"
	]
},
	"application/zip": {
	source: "iana",
	compressible: false,
	extensions: [
		"zip"
	]
},
	"application/zlib": {
	source: "iana"
},
	"application/zstd": {
	source: "iana"
},
	"audio/1d-interleaved-parityfec": {
	source: "iana"
},
	"audio/32kadpcm": {
	source: "iana"
},
	"audio/3gpp": {
	source: "iana",
	compressible: false,
	extensions: [
		"3gpp"
	]
},
	"audio/3gpp2": {
	source: "iana"
},
	"audio/aac": {
	source: "iana"
},
	"audio/ac3": {
	source: "iana"
},
	"audio/adpcm": {
	source: "apache",
	extensions: [
		"adp"
	]
},
	"audio/amr": {
	source: "iana",
	extensions: [
		"amr"
	]
},
	"audio/amr-wb": {
	source: "iana"
},
	"audio/amr-wb+": {
	source: "iana"
},
	"audio/aptx": {
	source: "iana"
},
	"audio/asc": {
	source: "iana"
},
	"audio/atrac-advanced-lossless": {
	source: "iana"
},
	"audio/atrac-x": {
	source: "iana"
},
	"audio/atrac3": {
	source: "iana"
},
	"audio/basic": {
	source: "iana",
	compressible: false,
	extensions: [
		"au",
		"snd"
	]
},
	"audio/bv16": {
	source: "iana"
},
	"audio/bv32": {
	source: "iana"
},
	"audio/clearmode": {
	source: "iana"
},
	"audio/cn": {
	source: "iana"
},
	"audio/dat12": {
	source: "iana"
},
	"audio/dls": {
	source: "iana"
},
	"audio/dsr-es201108": {
	source: "iana"
},
	"audio/dsr-es202050": {
	source: "iana"
},
	"audio/dsr-es202211": {
	source: "iana"
},
	"audio/dsr-es202212": {
	source: "iana"
},
	"audio/dv": {
	source: "iana"
},
	"audio/dvi4": {
	source: "iana"
},
	"audio/eac3": {
	source: "iana"
},
	"audio/encaprtp": {
	source: "iana"
},
	"audio/evrc": {
	source: "iana"
},
	"audio/evrc-qcp": {
	source: "iana"
},
	"audio/evrc0": {
	source: "iana"
},
	"audio/evrc1": {
	source: "iana"
},
	"audio/evrcb": {
	source: "iana"
},
	"audio/evrcb0": {
	source: "iana"
},
	"audio/evrcb1": {
	source: "iana"
},
	"audio/evrcnw": {
	source: "iana"
},
	"audio/evrcnw0": {
	source: "iana"
},
	"audio/evrcnw1": {
	source: "iana"
},
	"audio/evrcwb": {
	source: "iana"
},
	"audio/evrcwb0": {
	source: "iana"
},
	"audio/evrcwb1": {
	source: "iana"
},
	"audio/evs": {
	source: "iana"
},
	"audio/flexfec": {
	source: "iana"
},
	"audio/fwdred": {
	source: "iana"
},
	"audio/g711-0": {
	source: "iana"
},
	"audio/g719": {
	source: "iana"
},
	"audio/g722": {
	source: "iana"
},
	"audio/g7221": {
	source: "iana"
},
	"audio/g723": {
	source: "iana"
},
	"audio/g726-16": {
	source: "iana"
},
	"audio/g726-24": {
	source: "iana"
},
	"audio/g726-32": {
	source: "iana"
},
	"audio/g726-40": {
	source: "iana"
},
	"audio/g728": {
	source: "iana"
},
	"audio/g729": {
	source: "iana"
},
	"audio/g7291": {
	source: "iana"
},
	"audio/g729d": {
	source: "iana"
},
	"audio/g729e": {
	source: "iana"
},
	"audio/gsm": {
	source: "iana"
},
	"audio/gsm-efr": {
	source: "iana"
},
	"audio/gsm-hr-08": {
	source: "iana"
},
	"audio/ilbc": {
	source: "iana"
},
	"audio/ip-mr_v2.5": {
	source: "iana"
},
	"audio/isac": {
	source: "apache"
},
	"audio/l16": {
	source: "iana"
},
	"audio/l20": {
	source: "iana"
},
	"audio/l24": {
	source: "iana",
	compressible: false
},
	"audio/l8": {
	source: "iana"
},
	"audio/lpc": {
	source: "iana"
},
	"audio/melp": {
	source: "iana"
},
	"audio/melp1200": {
	source: "iana"
},
	"audio/melp2400": {
	source: "iana"
},
	"audio/melp600": {
	source: "iana"
},
	"audio/mhas": {
	source: "iana"
},
	"audio/midi": {
	source: "apache",
	extensions: [
		"mid",
		"midi",
		"kar",
		"rmi"
	]
},
	"audio/mobile-xmf": {
	source: "iana",
	extensions: [
		"mxmf"
	]
},
	"audio/mp3": {
	compressible: false,
	extensions: [
		"mp3"
	]
},
	"audio/mp4": {
	source: "iana",
	compressible: false,
	extensions: [
		"m4a",
		"mp4a"
	]
},
	"audio/mp4a-latm": {
	source: "iana"
},
	"audio/mpa": {
	source: "iana"
},
	"audio/mpa-robust": {
	source: "iana"
},
	"audio/mpeg": {
	source: "iana",
	compressible: false,
	extensions: [
		"mpga",
		"mp2",
		"mp2a",
		"mp3",
		"m2a",
		"m3a"
	]
},
	"audio/mpeg4-generic": {
	source: "iana"
},
	"audio/musepack": {
	source: "apache"
},
	"audio/ogg": {
	source: "iana",
	compressible: false,
	extensions: [
		"oga",
		"ogg",
		"spx",
		"opus"
	]
},
	"audio/opus": {
	source: "iana"
},
	"audio/parityfec": {
	source: "iana"
},
	"audio/pcma": {
	source: "iana"
},
	"audio/pcma-wb": {
	source: "iana"
},
	"audio/pcmu": {
	source: "iana"
},
	"audio/pcmu-wb": {
	source: "iana"
},
	"audio/prs.sid": {
	source: "iana"
},
	"audio/qcelp": {
	source: "iana"
},
	"audio/raptorfec": {
	source: "iana"
},
	"audio/red": {
	source: "iana"
},
	"audio/rtp-enc-aescm128": {
	source: "iana"
},
	"audio/rtp-midi": {
	source: "iana"
},
	"audio/rtploopback": {
	source: "iana"
},
	"audio/rtx": {
	source: "iana"
},
	"audio/s3m": {
	source: "apache",
	extensions: [
		"s3m"
	]
},
	"audio/scip": {
	source: "iana"
},
	"audio/silk": {
	source: "apache",
	extensions: [
		"sil"
	]
},
	"audio/smv": {
	source: "iana"
},
	"audio/smv-qcp": {
	source: "iana"
},
	"audio/smv0": {
	source: "iana"
},
	"audio/sofa": {
	source: "iana"
},
	"audio/sp-midi": {
	source: "iana"
},
	"audio/speex": {
	source: "iana"
},
	"audio/t140c": {
	source: "iana"
},
	"audio/t38": {
	source: "iana"
},
	"audio/telephone-event": {
	source: "iana"
},
	"audio/tetra_acelp": {
	source: "iana"
},
	"audio/tetra_acelp_bb": {
	source: "iana"
},
	"audio/tone": {
	source: "iana"
},
	"audio/tsvcis": {
	source: "iana"
},
	"audio/uemclip": {
	source: "iana"
},
	"audio/ulpfec": {
	source: "iana"
},
	"audio/usac": {
	source: "iana"
},
	"audio/vdvi": {
	source: "iana"
},
	"audio/vmr-wb": {
	source: "iana"
},
	"audio/vnd.3gpp.iufp": {
	source: "iana"
},
	"audio/vnd.4sb": {
	source: "iana"
},
	"audio/vnd.audiokoz": {
	source: "iana"
},
	"audio/vnd.celp": {
	source: "iana"
},
	"audio/vnd.cisco.nse": {
	source: "iana"
},
	"audio/vnd.cmles.radio-events": {
	source: "iana"
},
	"audio/vnd.cns.anp1": {
	source: "iana"
},
	"audio/vnd.cns.inf1": {
	source: "iana"
},
	"audio/vnd.dece.audio": {
	source: "iana",
	extensions: [
		"uva",
		"uvva"
	]
},
	"audio/vnd.digital-winds": {
	source: "iana",
	extensions: [
		"eol"
	]
},
	"audio/vnd.dlna.adts": {
	source: "iana"
},
	"audio/vnd.dolby.heaac.1": {
	source: "iana"
},
	"audio/vnd.dolby.heaac.2": {
	source: "iana"
},
	"audio/vnd.dolby.mlp": {
	source: "iana"
},
	"audio/vnd.dolby.mps": {
	source: "iana"
},
	"audio/vnd.dolby.pl2": {
	source: "iana"
},
	"audio/vnd.dolby.pl2x": {
	source: "iana"
},
	"audio/vnd.dolby.pl2z": {
	source: "iana"
},
	"audio/vnd.dolby.pulse.1": {
	source: "iana"
},
	"audio/vnd.dra": {
	source: "iana",
	extensions: [
		"dra"
	]
},
	"audio/vnd.dts": {
	source: "iana",
	extensions: [
		"dts"
	]
},
	"audio/vnd.dts.hd": {
	source: "iana",
	extensions: [
		"dtshd"
	]
},
	"audio/vnd.dts.uhd": {
	source: "iana"
},
	"audio/vnd.dvb.file": {
	source: "iana"
},
	"audio/vnd.everad.plj": {
	source: "iana"
},
	"audio/vnd.hns.audio": {
	source: "iana"
},
	"audio/vnd.lucent.voice": {
	source: "iana",
	extensions: [
		"lvp"
	]
},
	"audio/vnd.ms-playready.media.pya": {
	source: "iana",
	extensions: [
		"pya"
	]
},
	"audio/vnd.nokia.mobile-xmf": {
	source: "iana"
},
	"audio/vnd.nortel.vbk": {
	source: "iana"
},
	"audio/vnd.nuera.ecelp4800": {
	source: "iana",
	extensions: [
		"ecelp4800"
	]
},
	"audio/vnd.nuera.ecelp7470": {
	source: "iana",
	extensions: [
		"ecelp7470"
	]
},
	"audio/vnd.nuera.ecelp9600": {
	source: "iana",
	extensions: [
		"ecelp9600"
	]
},
	"audio/vnd.octel.sbc": {
	source: "iana"
},
	"audio/vnd.presonus.multitrack": {
	source: "iana"
},
	"audio/vnd.qcelp": {
	source: "iana"
},
	"audio/vnd.rhetorex.32kadpcm": {
	source: "iana"
},
	"audio/vnd.rip": {
	source: "iana",
	extensions: [
		"rip"
	]
},
	"audio/vnd.rn-realaudio": {
	compressible: false
},
	"audio/vnd.sealedmedia.softseal.mpeg": {
	source: "iana"
},
	"audio/vnd.vmx.cvsd": {
	source: "iana"
},
	"audio/vnd.wave": {
	compressible: false
},
	"audio/vorbis": {
	source: "iana",
	compressible: false
},
	"audio/vorbis-config": {
	source: "iana"
},
	"audio/wav": {
	compressible: false,
	extensions: [
		"wav"
	]
},
	"audio/wave": {
	compressible: false,
	extensions: [
		"wav"
	]
},
	"audio/webm": {
	source: "apache",
	compressible: false,
	extensions: [
		"weba"
	]
},
	"audio/x-aac": {
	source: "apache",
	compressible: false,
	extensions: [
		"aac"
	]
},
	"audio/x-aiff": {
	source: "apache",
	extensions: [
		"aif",
		"aiff",
		"aifc"
	]
},
	"audio/x-caf": {
	source: "apache",
	compressible: false,
	extensions: [
		"caf"
	]
},
	"audio/x-flac": {
	source: "apache",
	extensions: [
		"flac"
	]
},
	"audio/x-m4a": {
	source: "nginx",
	extensions: [
		"m4a"
	]
},
	"audio/x-matroska": {
	source: "apache",
	extensions: [
		"mka"
	]
},
	"audio/x-mpegurl": {
	source: "apache",
	extensions: [
		"m3u"
	]
},
	"audio/x-ms-wax": {
	source: "apache",
	extensions: [
		"wax"
	]
},
	"audio/x-ms-wma": {
	source: "apache",
	extensions: [
		"wma"
	]
},
	"audio/x-pn-realaudio": {
	source: "apache",
	extensions: [
		"ram",
		"ra"
	]
},
	"audio/x-pn-realaudio-plugin": {
	source: "apache",
	extensions: [
		"rmp"
	]
},
	"audio/x-realaudio": {
	source: "nginx",
	extensions: [
		"ra"
	]
},
	"audio/x-tta": {
	source: "apache"
},
	"audio/x-wav": {
	source: "apache",
	extensions: [
		"wav"
	]
},
	"audio/xm": {
	source: "apache",
	extensions: [
		"xm"
	]
},
	"chemical/x-cdx": {
	source: "apache",
	extensions: [
		"cdx"
	]
},
	"chemical/x-cif": {
	source: "apache",
	extensions: [
		"cif"
	]
},
	"chemical/x-cmdf": {
	source: "apache",
	extensions: [
		"cmdf"
	]
},
	"chemical/x-cml": {
	source: "apache",
	extensions: [
		"cml"
	]
},
	"chemical/x-csml": {
	source: "apache",
	extensions: [
		"csml"
	]
},
	"chemical/x-pdb": {
	source: "apache"
},
	"chemical/x-xyz": {
	source: "apache",
	extensions: [
		"xyz"
	]
},
	"font/collection": {
	source: "iana",
	extensions: [
		"ttc"
	]
},
	"font/otf": {
	source: "iana",
	compressible: true,
	extensions: [
		"otf"
	]
},
	"font/sfnt": {
	source: "iana"
},
	"font/ttf": {
	source: "iana",
	compressible: true,
	extensions: [
		"ttf"
	]
},
	"font/woff": {
	source: "iana",
	extensions: [
		"woff"
	]
},
	"font/woff2": {
	source: "iana",
	extensions: [
		"woff2"
	]
},
	"image/aces": {
	source: "iana",
	extensions: [
		"exr"
	]
},
	"image/apng": {
	compressible: false,
	extensions: [
		"apng"
	]
},
	"image/avci": {
	source: "iana",
	extensions: [
		"avci"
	]
},
	"image/avcs": {
	source: "iana",
	extensions: [
		"avcs"
	]
},
	"image/avif": {
	source: "iana",
	compressible: false,
	extensions: [
		"avif"
	]
},
	"image/bmp": {
	source: "iana",
	compressible: true,
	extensions: [
		"bmp"
	]
},
	"image/cgm": {
	source: "iana",
	extensions: [
		"cgm"
	]
},
	"image/dicom-rle": {
	source: "iana",
	extensions: [
		"drle"
	]
},
	"image/emf": {
	source: "iana",
	extensions: [
		"emf"
	]
},
	"image/fits": {
	source: "iana",
	extensions: [
		"fits"
	]
},
	"image/g3fax": {
	source: "iana",
	extensions: [
		"g3"
	]
},
	"image/gif": {
	source: "iana",
	compressible: false,
	extensions: [
		"gif"
	]
},
	"image/heic": {
	source: "iana",
	extensions: [
		"heic"
	]
},
	"image/heic-sequence": {
	source: "iana",
	extensions: [
		"heics"
	]
},
	"image/heif": {
	source: "iana",
	extensions: [
		"heif"
	]
},
	"image/heif-sequence": {
	source: "iana",
	extensions: [
		"heifs"
	]
},
	"image/hej2k": {
	source: "iana",
	extensions: [
		"hej2"
	]
},
	"image/hsj2": {
	source: "iana",
	extensions: [
		"hsj2"
	]
},
	"image/ief": {
	source: "iana",
	extensions: [
		"ief"
	]
},
	"image/jls": {
	source: "iana",
	extensions: [
		"jls"
	]
},
	"image/jp2": {
	source: "iana",
	compressible: false,
	extensions: [
		"jp2",
		"jpg2"
	]
},
	"image/jpeg": {
	source: "iana",
	compressible: false,
	extensions: [
		"jpeg",
		"jpg",
		"jpe"
	]
},
	"image/jph": {
	source: "iana",
	extensions: [
		"jph"
	]
},
	"image/jphc": {
	source: "iana",
	extensions: [
		"jhc"
	]
},
	"image/jpm": {
	source: "iana",
	compressible: false,
	extensions: [
		"jpm"
	]
},
	"image/jpx": {
	source: "iana",
	compressible: false,
	extensions: [
		"jpx",
		"jpf"
	]
},
	"image/jxr": {
	source: "iana",
	extensions: [
		"jxr"
	]
},
	"image/jxra": {
	source: "iana",
	extensions: [
		"jxra"
	]
},
	"image/jxrs": {
	source: "iana",
	extensions: [
		"jxrs"
	]
},
	"image/jxs": {
	source: "iana",
	extensions: [
		"jxs"
	]
},
	"image/jxsc": {
	source: "iana",
	extensions: [
		"jxsc"
	]
},
	"image/jxsi": {
	source: "iana",
	extensions: [
		"jxsi"
	]
},
	"image/jxss": {
	source: "iana",
	extensions: [
		"jxss"
	]
},
	"image/ktx": {
	source: "iana",
	extensions: [
		"ktx"
	]
},
	"image/ktx2": {
	source: "iana",
	extensions: [
		"ktx2"
	]
},
	"image/naplps": {
	source: "iana"
},
	"image/pjpeg": {
	compressible: false
},
	"image/png": {
	source: "iana",
	compressible: false,
	extensions: [
		"png"
	]
},
	"image/prs.btif": {
	source: "iana",
	extensions: [
		"btif"
	]
},
	"image/prs.pti": {
	source: "iana",
	extensions: [
		"pti"
	]
},
	"image/pwg-raster": {
	source: "iana"
},
	"image/sgi": {
	source: "apache",
	extensions: [
		"sgi"
	]
},
	"image/svg+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"svg",
		"svgz"
	]
},
	"image/t38": {
	source: "iana",
	extensions: [
		"t38"
	]
},
	"image/tiff": {
	source: "iana",
	compressible: false,
	extensions: [
		"tif",
		"tiff"
	]
},
	"image/tiff-fx": {
	source: "iana",
	extensions: [
		"tfx"
	]
},
	"image/vnd.adobe.photoshop": {
	source: "iana",
	compressible: true,
	extensions: [
		"psd"
	]
},
	"image/vnd.airzip.accelerator.azv": {
	source: "iana",
	extensions: [
		"azv"
	]
},
	"image/vnd.cns.inf2": {
	source: "iana"
},
	"image/vnd.dece.graphic": {
	source: "iana",
	extensions: [
		"uvi",
		"uvvi",
		"uvg",
		"uvvg"
	]
},
	"image/vnd.djvu": {
	source: "iana",
	extensions: [
		"djvu",
		"djv"
	]
},
	"image/vnd.dvb.subtitle": {
	source: "iana",
	extensions: [
		"sub"
	]
},
	"image/vnd.dwg": {
	source: "iana",
	extensions: [
		"dwg"
	]
},
	"image/vnd.dxf": {
	source: "iana",
	extensions: [
		"dxf"
	]
},
	"image/vnd.fastbidsheet": {
	source: "iana",
	extensions: [
		"fbs"
	]
},
	"image/vnd.fpx": {
	source: "iana",
	extensions: [
		"fpx"
	]
},
	"image/vnd.fst": {
	source: "iana",
	extensions: [
		"fst"
	]
},
	"image/vnd.fujixerox.edmics-mmr": {
	source: "iana",
	extensions: [
		"mmr"
	]
},
	"image/vnd.fujixerox.edmics-rlc": {
	source: "iana",
	extensions: [
		"rlc"
	]
},
	"image/vnd.globalgraphics.pgb": {
	source: "iana"
},
	"image/vnd.microsoft.icon": {
	source: "iana",
	compressible: true,
	extensions: [
		"ico"
	]
},
	"image/vnd.mix": {
	source: "iana"
},
	"image/vnd.mozilla.apng": {
	source: "iana"
},
	"image/vnd.ms-dds": {
	compressible: true,
	extensions: [
		"dds"
	]
},
	"image/vnd.ms-modi": {
	source: "iana",
	extensions: [
		"mdi"
	]
},
	"image/vnd.ms-photo": {
	source: "apache",
	extensions: [
		"wdp"
	]
},
	"image/vnd.net-fpx": {
	source: "iana",
	extensions: [
		"npx"
	]
},
	"image/vnd.pco.b16": {
	source: "iana",
	extensions: [
		"b16"
	]
},
	"image/vnd.radiance": {
	source: "iana"
},
	"image/vnd.sealed.png": {
	source: "iana"
},
	"image/vnd.sealedmedia.softseal.gif": {
	source: "iana"
},
	"image/vnd.sealedmedia.softseal.jpg": {
	source: "iana"
},
	"image/vnd.svf": {
	source: "iana"
},
	"image/vnd.tencent.tap": {
	source: "iana",
	extensions: [
		"tap"
	]
},
	"image/vnd.valve.source.texture": {
	source: "iana",
	extensions: [
		"vtf"
	]
},
	"image/vnd.wap.wbmp": {
	source: "iana",
	extensions: [
		"wbmp"
	]
},
	"image/vnd.xiff": {
	source: "iana",
	extensions: [
		"xif"
	]
},
	"image/vnd.zbrush.pcx": {
	source: "iana",
	extensions: [
		"pcx"
	]
},
	"image/webp": {
	source: "apache",
	extensions: [
		"webp"
	]
},
	"image/wmf": {
	source: "iana",
	extensions: [
		"wmf"
	]
},
	"image/x-3ds": {
	source: "apache",
	extensions: [
		"3ds"
	]
},
	"image/x-cmu-raster": {
	source: "apache",
	extensions: [
		"ras"
	]
},
	"image/x-cmx": {
	source: "apache",
	extensions: [
		"cmx"
	]
},
	"image/x-freehand": {
	source: "apache",
	extensions: [
		"fh",
		"fhc",
		"fh4",
		"fh5",
		"fh7"
	]
},
	"image/x-icon": {
	source: "apache",
	compressible: true,
	extensions: [
		"ico"
	]
},
	"image/x-jng": {
	source: "nginx",
	extensions: [
		"jng"
	]
},
	"image/x-mrsid-image": {
	source: "apache",
	extensions: [
		"sid"
	]
},
	"image/x-ms-bmp": {
	source: "nginx",
	compressible: true,
	extensions: [
		"bmp"
	]
},
	"image/x-pcx": {
	source: "apache",
	extensions: [
		"pcx"
	]
},
	"image/x-pict": {
	source: "apache",
	extensions: [
		"pic",
		"pct"
	]
},
	"image/x-portable-anymap": {
	source: "apache",
	extensions: [
		"pnm"
	]
},
	"image/x-portable-bitmap": {
	source: "apache",
	extensions: [
		"pbm"
	]
},
	"image/x-portable-graymap": {
	source: "apache",
	extensions: [
		"pgm"
	]
},
	"image/x-portable-pixmap": {
	source: "apache",
	extensions: [
		"ppm"
	]
},
	"image/x-rgb": {
	source: "apache",
	extensions: [
		"rgb"
	]
},
	"image/x-tga": {
	source: "apache",
	extensions: [
		"tga"
	]
},
	"image/x-xbitmap": {
	source: "apache",
	extensions: [
		"xbm"
	]
},
	"image/x-xcf": {
	compressible: false
},
	"image/x-xpixmap": {
	source: "apache",
	extensions: [
		"xpm"
	]
},
	"image/x-xwindowdump": {
	source: "apache",
	extensions: [
		"xwd"
	]
},
	"message/cpim": {
	source: "iana"
},
	"message/delivery-status": {
	source: "iana"
},
	"message/disposition-notification": {
	source: "iana",
	extensions: [
		"disposition-notification"
	]
},
	"message/external-body": {
	source: "iana"
},
	"message/feedback-report": {
	source: "iana"
},
	"message/global": {
	source: "iana",
	extensions: [
		"u8msg"
	]
},
	"message/global-delivery-status": {
	source: "iana",
	extensions: [
		"u8dsn"
	]
},
	"message/global-disposition-notification": {
	source: "iana",
	extensions: [
		"u8mdn"
	]
},
	"message/global-headers": {
	source: "iana",
	extensions: [
		"u8hdr"
	]
},
	"message/http": {
	source: "iana",
	compressible: false
},
	"message/imdn+xml": {
	source: "iana",
	compressible: true
},
	"message/news": {
	source: "iana"
},
	"message/partial": {
	source: "iana",
	compressible: false
},
	"message/rfc822": {
	source: "iana",
	compressible: true,
	extensions: [
		"eml",
		"mime"
	]
},
	"message/s-http": {
	source: "iana"
},
	"message/sip": {
	source: "iana"
},
	"message/sipfrag": {
	source: "iana"
},
	"message/tracking-status": {
	source: "iana"
},
	"message/vnd.si.simp": {
	source: "iana"
},
	"message/vnd.wfa.wsc": {
	source: "iana",
	extensions: [
		"wsc"
	]
},
	"model/3mf": {
	source: "iana",
	extensions: [
		"3mf"
	]
},
	"model/e57": {
	source: "iana"
},
	"model/gltf+json": {
	source: "iana",
	compressible: true,
	extensions: [
		"gltf"
	]
},
	"model/gltf-binary": {
	source: "iana",
	compressible: true,
	extensions: [
		"glb"
	]
},
	"model/iges": {
	source: "iana",
	compressible: false,
	extensions: [
		"igs",
		"iges"
	]
},
	"model/mesh": {
	source: "iana",
	compressible: false,
	extensions: [
		"msh",
		"mesh",
		"silo"
	]
},
	"model/mtl": {
	source: "iana",
	extensions: [
		"mtl"
	]
},
	"model/obj": {
	source: "iana",
	extensions: [
		"obj"
	]
},
	"model/step": {
	source: "iana"
},
	"model/step+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"stpx"
	]
},
	"model/step+zip": {
	source: "iana",
	compressible: false,
	extensions: [
		"stpz"
	]
},
	"model/step-xml+zip": {
	source: "iana",
	compressible: false,
	extensions: [
		"stpxz"
	]
},
	"model/stl": {
	source: "iana",
	extensions: [
		"stl"
	]
},
	"model/vnd.collada+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"dae"
	]
},
	"model/vnd.dwf": {
	source: "iana",
	extensions: [
		"dwf"
	]
},
	"model/vnd.flatland.3dml": {
	source: "iana"
},
	"model/vnd.gdl": {
	source: "iana",
	extensions: [
		"gdl"
	]
},
	"model/vnd.gs-gdl": {
	source: "apache"
},
	"model/vnd.gs.gdl": {
	source: "iana"
},
	"model/vnd.gtw": {
	source: "iana",
	extensions: [
		"gtw"
	]
},
	"model/vnd.moml+xml": {
	source: "iana",
	compressible: true
},
	"model/vnd.mts": {
	source: "iana",
	extensions: [
		"mts"
	]
},
	"model/vnd.opengex": {
	source: "iana",
	extensions: [
		"ogex"
	]
},
	"model/vnd.parasolid.transmit.binary": {
	source: "iana",
	extensions: [
		"x_b"
	]
},
	"model/vnd.parasolid.transmit.text": {
	source: "iana",
	extensions: [
		"x_t"
	]
},
	"model/vnd.pytha.pyox": {
	source: "iana"
},
	"model/vnd.rosette.annotated-data-model": {
	source: "iana"
},
	"model/vnd.sap.vds": {
	source: "iana",
	extensions: [
		"vds"
	]
},
	"model/vnd.usdz+zip": {
	source: "iana",
	compressible: false,
	extensions: [
		"usdz"
	]
},
	"model/vnd.valve.source.compiled-map": {
	source: "iana",
	extensions: [
		"bsp"
	]
},
	"model/vnd.vtu": {
	source: "iana",
	extensions: [
		"vtu"
	]
},
	"model/vrml": {
	source: "iana",
	compressible: false,
	extensions: [
		"wrl",
		"vrml"
	]
},
	"model/x3d+binary": {
	source: "apache",
	compressible: false,
	extensions: [
		"x3db",
		"x3dbz"
	]
},
	"model/x3d+fastinfoset": {
	source: "iana",
	extensions: [
		"x3db"
	]
},
	"model/x3d+vrml": {
	source: "apache",
	compressible: false,
	extensions: [
		"x3dv",
		"x3dvz"
	]
},
	"model/x3d+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"x3d",
		"x3dz"
	]
},
	"model/x3d-vrml": {
	source: "iana",
	extensions: [
		"x3dv"
	]
},
	"multipart/alternative": {
	source: "iana",
	compressible: false
},
	"multipart/appledouble": {
	source: "iana"
},
	"multipart/byteranges": {
	source: "iana"
},
	"multipart/digest": {
	source: "iana"
},
	"multipart/encrypted": {
	source: "iana",
	compressible: false
},
	"multipart/form-data": {
	source: "iana",
	compressible: false
},
	"multipart/header-set": {
	source: "iana"
},
	"multipart/mixed": {
	source: "iana"
},
	"multipart/multilingual": {
	source: "iana"
},
	"multipart/parallel": {
	source: "iana"
},
	"multipart/related": {
	source: "iana",
	compressible: false
},
	"multipart/report": {
	source: "iana"
},
	"multipart/signed": {
	source: "iana",
	compressible: false
},
	"multipart/vnd.bint.med-plus": {
	source: "iana"
},
	"multipart/voice-message": {
	source: "iana"
},
	"multipart/x-mixed-replace": {
	source: "iana"
},
	"text/1d-interleaved-parityfec": {
	source: "iana"
},
	"text/cache-manifest": {
	source: "iana",
	compressible: true,
	extensions: [
		"appcache",
		"manifest"
	]
},
	"text/calendar": {
	source: "iana",
	extensions: [
		"ics",
		"ifb"
	]
},
	"text/calender": {
	compressible: true
},
	"text/cmd": {
	compressible: true
},
	"text/coffeescript": {
	extensions: [
		"coffee",
		"litcoffee"
	]
},
	"text/cql": {
	source: "iana"
},
	"text/cql-expression": {
	source: "iana"
},
	"text/cql-identifier": {
	source: "iana"
},
	"text/css": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"css"
	]
},
	"text/csv": {
	source: "iana",
	compressible: true,
	extensions: [
		"csv"
	]
},
	"text/csv-schema": {
	source: "iana"
},
	"text/directory": {
	source: "iana"
},
	"text/dns": {
	source: "iana"
},
	"text/ecmascript": {
	source: "iana"
},
	"text/encaprtp": {
	source: "iana"
},
	"text/enriched": {
	source: "iana"
},
	"text/fhirpath": {
	source: "iana"
},
	"text/flexfec": {
	source: "iana"
},
	"text/fwdred": {
	source: "iana"
},
	"text/gff3": {
	source: "iana"
},
	"text/grammar-ref-list": {
	source: "iana"
},
	"text/html": {
	source: "iana",
	compressible: true,
	extensions: [
		"html",
		"htm",
		"shtml"
	]
},
	"text/jade": {
	extensions: [
		"jade"
	]
},
	"text/javascript": {
	source: "iana",
	compressible: true
},
	"text/jcr-cnd": {
	source: "iana"
},
	"text/jsx": {
	compressible: true,
	extensions: [
		"jsx"
	]
},
	"text/less": {
	compressible: true,
	extensions: [
		"less"
	]
},
	"text/markdown": {
	source: "iana",
	compressible: true,
	extensions: [
		"markdown",
		"md"
	]
},
	"text/mathml": {
	source: "nginx",
	extensions: [
		"mml"
	]
},
	"text/mdx": {
	compressible: true,
	extensions: [
		"mdx"
	]
},
	"text/mizar": {
	source: "iana"
},
	"text/n3": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"n3"
	]
},
	"text/parameters": {
	source: "iana",
	charset: "UTF-8"
},
	"text/parityfec": {
	source: "iana"
},
	"text/plain": {
	source: "iana",
	compressible: true,
	extensions: [
		"txt",
		"text",
		"conf",
		"def",
		"list",
		"log",
		"in",
		"ini"
	]
},
	"text/provenance-notation": {
	source: "iana",
	charset: "UTF-8"
},
	"text/prs.fallenstein.rst": {
	source: "iana"
},
	"text/prs.lines.tag": {
	source: "iana",
	extensions: [
		"dsc"
	]
},
	"text/prs.prop.logic": {
	source: "iana"
},
	"text/raptorfec": {
	source: "iana"
},
	"text/red": {
	source: "iana"
},
	"text/rfc822-headers": {
	source: "iana"
},
	"text/richtext": {
	source: "iana",
	compressible: true,
	extensions: [
		"rtx"
	]
},
	"text/rtf": {
	source: "iana",
	compressible: true,
	extensions: [
		"rtf"
	]
},
	"text/rtp-enc-aescm128": {
	source: "iana"
},
	"text/rtploopback": {
	source: "iana"
},
	"text/rtx": {
	source: "iana"
},
	"text/sgml": {
	source: "iana",
	extensions: [
		"sgml",
		"sgm"
	]
},
	"text/shaclc": {
	source: "iana"
},
	"text/shex": {
	source: "iana",
	extensions: [
		"shex"
	]
},
	"text/slim": {
	extensions: [
		"slim",
		"slm"
	]
},
	"text/spdx": {
	source: "iana",
	extensions: [
		"spdx"
	]
},
	"text/strings": {
	source: "iana"
},
	"text/stylus": {
	extensions: [
		"stylus",
		"styl"
	]
},
	"text/t140": {
	source: "iana"
},
	"text/tab-separated-values": {
	source: "iana",
	compressible: true,
	extensions: [
		"tsv"
	]
},
	"text/troff": {
	source: "iana",
	extensions: [
		"t",
		"tr",
		"roff",
		"man",
		"me",
		"ms"
	]
},
	"text/turtle": {
	source: "iana",
	charset: "UTF-8",
	extensions: [
		"ttl"
	]
},
	"text/ulpfec": {
	source: "iana"
},
	"text/uri-list": {
	source: "iana",
	compressible: true,
	extensions: [
		"uri",
		"uris",
		"urls"
	]
},
	"text/vcard": {
	source: "iana",
	compressible: true,
	extensions: [
		"vcard"
	]
},
	"text/vnd.a": {
	source: "iana"
},
	"text/vnd.abc": {
	source: "iana"
},
	"text/vnd.ascii-art": {
	source: "iana"
},
	"text/vnd.curl": {
	source: "iana",
	extensions: [
		"curl"
	]
},
	"text/vnd.curl.dcurl": {
	source: "apache",
	extensions: [
		"dcurl"
	]
},
	"text/vnd.curl.mcurl": {
	source: "apache",
	extensions: [
		"mcurl"
	]
},
	"text/vnd.curl.scurl": {
	source: "apache",
	extensions: [
		"scurl"
	]
},
	"text/vnd.debian.copyright": {
	source: "iana",
	charset: "UTF-8"
},
	"text/vnd.dmclientscript": {
	source: "iana"
},
	"text/vnd.dvb.subtitle": {
	source: "iana",
	extensions: [
		"sub"
	]
},
	"text/vnd.esmertec.theme-descriptor": {
	source: "iana",
	charset: "UTF-8"
},
	"text/vnd.familysearch.gedcom": {
	source: "iana",
	extensions: [
		"ged"
	]
},
	"text/vnd.ficlab.flt": {
	source: "iana"
},
	"text/vnd.fly": {
	source: "iana",
	extensions: [
		"fly"
	]
},
	"text/vnd.fmi.flexstor": {
	source: "iana",
	extensions: [
		"flx"
	]
},
	"text/vnd.gml": {
	source: "iana"
},
	"text/vnd.graphviz": {
	source: "iana",
	extensions: [
		"gv"
	]
},
	"text/vnd.hans": {
	source: "iana"
},
	"text/vnd.hgl": {
	source: "iana"
},
	"text/vnd.in3d.3dml": {
	source: "iana",
	extensions: [
		"3dml"
	]
},
	"text/vnd.in3d.spot": {
	source: "iana",
	extensions: [
		"spot"
	]
},
	"text/vnd.iptc.newsml": {
	source: "iana"
},
	"text/vnd.iptc.nitf": {
	source: "iana"
},
	"text/vnd.latex-z": {
	source: "iana"
},
	"text/vnd.motorola.reflex": {
	source: "iana"
},
	"text/vnd.ms-mediapackage": {
	source: "iana"
},
	"text/vnd.net2phone.commcenter.command": {
	source: "iana"
},
	"text/vnd.radisys.msml-basic-layout": {
	source: "iana"
},
	"text/vnd.senx.warpscript": {
	source: "iana"
},
	"text/vnd.si.uricatalogue": {
	source: "iana"
},
	"text/vnd.sosi": {
	source: "iana"
},
	"text/vnd.sun.j2me.app-descriptor": {
	source: "iana",
	charset: "UTF-8",
	extensions: [
		"jad"
	]
},
	"text/vnd.trolltech.linguist": {
	source: "iana",
	charset: "UTF-8"
},
	"text/vnd.wap.si": {
	source: "iana"
},
	"text/vnd.wap.sl": {
	source: "iana"
},
	"text/vnd.wap.wml": {
	source: "iana",
	extensions: [
		"wml"
	]
},
	"text/vnd.wap.wmlscript": {
	source: "iana",
	extensions: [
		"wmls"
	]
},
	"text/vtt": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"vtt"
	]
},
	"text/x-asm": {
	source: "apache",
	extensions: [
		"s",
		"asm"
	]
},
	"text/x-c": {
	source: "apache",
	extensions: [
		"c",
		"cc",
		"cxx",
		"cpp",
		"h",
		"hh",
		"dic"
	]
},
	"text/x-component": {
	source: "nginx",
	extensions: [
		"htc"
	]
},
	"text/x-fortran": {
	source: "apache",
	extensions: [
		"f",
		"for",
		"f77",
		"f90"
	]
},
	"text/x-gwt-rpc": {
	compressible: true
},
	"text/x-handlebars-template": {
	extensions: [
		"hbs"
	]
},
	"text/x-java-source": {
	source: "apache",
	extensions: [
		"java"
	]
},
	"text/x-jquery-tmpl": {
	compressible: true
},
	"text/x-lua": {
	extensions: [
		"lua"
	]
},
	"text/x-markdown": {
	compressible: true,
	extensions: [
		"mkd"
	]
},
	"text/x-nfo": {
	source: "apache",
	extensions: [
		"nfo"
	]
},
	"text/x-opml": {
	source: "apache",
	extensions: [
		"opml"
	]
},
	"text/x-org": {
	compressible: true,
	extensions: [
		"org"
	]
},
	"text/x-pascal": {
	source: "apache",
	extensions: [
		"p",
		"pas"
	]
},
	"text/x-processing": {
	compressible: true,
	extensions: [
		"pde"
	]
},
	"text/x-sass": {
	extensions: [
		"sass"
	]
},
	"text/x-scss": {
	extensions: [
		"scss"
	]
},
	"text/x-setext": {
	source: "apache",
	extensions: [
		"etx"
	]
},
	"text/x-sfv": {
	source: "apache",
	extensions: [
		"sfv"
	]
},
	"text/x-suse-ymp": {
	compressible: true,
	extensions: [
		"ymp"
	]
},
	"text/x-uuencode": {
	source: "apache",
	extensions: [
		"uu"
	]
},
	"text/x-vcalendar": {
	source: "apache",
	extensions: [
		"vcs"
	]
},
	"text/x-vcard": {
	source: "apache",
	extensions: [
		"vcf"
	]
},
	"text/xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xml"
	]
},
	"text/xml-external-parsed-entity": {
	source: "iana"
},
	"text/yaml": {
	compressible: true,
	extensions: [
		"yaml",
		"yml"
	]
},
	"video/1d-interleaved-parityfec": {
	source: "iana"
},
	"video/3gpp": {
	source: "iana",
	extensions: [
		"3gp",
		"3gpp"
	]
},
	"video/3gpp-tt": {
	source: "iana"
},
	"video/3gpp2": {
	source: "iana",
	extensions: [
		"3g2"
	]
},
	"video/av1": {
	source: "iana"
},
	"video/bmpeg": {
	source: "iana"
},
	"video/bt656": {
	source: "iana"
},
	"video/celb": {
	source: "iana"
},
	"video/dv": {
	source: "iana"
},
	"video/encaprtp": {
	source: "iana"
},
	"video/ffv1": {
	source: "iana"
},
	"video/flexfec": {
	source: "iana"
},
	"video/h261": {
	source: "iana",
	extensions: [
		"h261"
	]
},
	"video/h263": {
	source: "iana",
	extensions: [
		"h263"
	]
},
	"video/h263-1998": {
	source: "iana"
},
	"video/h263-2000": {
	source: "iana"
},
	"video/h264": {
	source: "iana",
	extensions: [
		"h264"
	]
},
	"video/h264-rcdo": {
	source: "iana"
},
	"video/h264-svc": {
	source: "iana"
},
	"video/h265": {
	source: "iana"
},
	"video/iso.segment": {
	source: "iana",
	extensions: [
		"m4s"
	]
},
	"video/jpeg": {
	source: "iana",
	extensions: [
		"jpgv"
	]
},
	"video/jpeg2000": {
	source: "iana"
},
	"video/jpm": {
	source: "apache",
	extensions: [
		"jpm",
		"jpgm"
	]
},
	"video/jxsv": {
	source: "iana"
},
	"video/mj2": {
	source: "iana",
	extensions: [
		"mj2",
		"mjp2"
	]
},
	"video/mp1s": {
	source: "iana"
},
	"video/mp2p": {
	source: "iana"
},
	"video/mp2t": {
	source: "iana",
	extensions: [
		"ts"
	]
},
	"video/mp4": {
	source: "iana",
	compressible: false,
	extensions: [
		"mp4",
		"mp4v",
		"mpg4"
	]
},
	"video/mp4v-es": {
	source: "iana"
},
	"video/mpeg": {
	source: "iana",
	compressible: false,
	extensions: [
		"mpeg",
		"mpg",
		"mpe",
		"m1v",
		"m2v"
	]
},
	"video/mpeg4-generic": {
	source: "iana"
},
	"video/mpv": {
	source: "iana"
},
	"video/nv": {
	source: "iana"
},
	"video/ogg": {
	source: "iana",
	compressible: false,
	extensions: [
		"ogv"
	]
},
	"video/parityfec": {
	source: "iana"
},
	"video/pointer": {
	source: "iana"
},
	"video/quicktime": {
	source: "iana",
	compressible: false,
	extensions: [
		"qt",
		"mov"
	]
},
	"video/raptorfec": {
	source: "iana"
},
	"video/raw": {
	source: "iana"
},
	"video/rtp-enc-aescm128": {
	source: "iana"
},
	"video/rtploopback": {
	source: "iana"
},
	"video/rtx": {
	source: "iana"
},
	"video/scip": {
	source: "iana"
},
	"video/smpte291": {
	source: "iana"
},
	"video/smpte292m": {
	source: "iana"
},
	"video/ulpfec": {
	source: "iana"
},
	"video/vc1": {
	source: "iana"
},
	"video/vc2": {
	source: "iana"
},
	"video/vnd.cctv": {
	source: "iana"
},
	"video/vnd.dece.hd": {
	source: "iana",
	extensions: [
		"uvh",
		"uvvh"
	]
},
	"video/vnd.dece.mobile": {
	source: "iana",
	extensions: [
		"uvm",
		"uvvm"
	]
},
	"video/vnd.dece.mp4": {
	source: "iana"
},
	"video/vnd.dece.pd": {
	source: "iana",
	extensions: [
		"uvp",
		"uvvp"
	]
},
	"video/vnd.dece.sd": {
	source: "iana",
	extensions: [
		"uvs",
		"uvvs"
	]
},
	"video/vnd.dece.video": {
	source: "iana",
	extensions: [
		"uvv",
		"uvvv"
	]
},
	"video/vnd.directv.mpeg": {
	source: "iana"
},
	"video/vnd.directv.mpeg-tts": {
	source: "iana"
},
	"video/vnd.dlna.mpeg-tts": {
	source: "iana"
},
	"video/vnd.dvb.file": {
	source: "iana",
	extensions: [
		"dvb"
	]
},
	"video/vnd.fvt": {
	source: "iana",
	extensions: [
		"fvt"
	]
},
	"video/vnd.hns.video": {
	source: "iana"
},
	"video/vnd.iptvforum.1dparityfec-1010": {
	source: "iana"
},
	"video/vnd.iptvforum.1dparityfec-2005": {
	source: "iana"
},
	"video/vnd.iptvforum.2dparityfec-1010": {
	source: "iana"
},
	"video/vnd.iptvforum.2dparityfec-2005": {
	source: "iana"
},
	"video/vnd.iptvforum.ttsavc": {
	source: "iana"
},
	"video/vnd.iptvforum.ttsmpeg2": {
	source: "iana"
},
	"video/vnd.motorola.video": {
	source: "iana"
},
	"video/vnd.motorola.videop": {
	source: "iana"
},
	"video/vnd.mpegurl": {
	source: "iana",
	extensions: [
		"mxu",
		"m4u"
	]
},
	"video/vnd.ms-playready.media.pyv": {
	source: "iana",
	extensions: [
		"pyv"
	]
},
	"video/vnd.nokia.interleaved-multimedia": {
	source: "iana"
},
	"video/vnd.nokia.mp4vr": {
	source: "iana"
},
	"video/vnd.nokia.videovoip": {
	source: "iana"
},
	"video/vnd.objectvideo": {
	source: "iana"
},
	"video/vnd.radgamettools.bink": {
	source: "iana"
},
	"video/vnd.radgamettools.smacker": {
	source: "iana"
},
	"video/vnd.sealed.mpeg1": {
	source: "iana"
},
	"video/vnd.sealed.mpeg4": {
	source: "iana"
},
	"video/vnd.sealed.swf": {
	source: "iana"
},
	"video/vnd.sealedmedia.softseal.mov": {
	source: "iana"
},
	"video/vnd.uvvu.mp4": {
	source: "iana",
	extensions: [
		"uvu",
		"uvvu"
	]
},
	"video/vnd.vivo": {
	source: "iana",
	extensions: [
		"viv"
	]
},
	"video/vnd.youtube.yt": {
	source: "iana"
},
	"video/vp8": {
	source: "iana"
},
	"video/vp9": {
	source: "iana"
},
	"video/webm": {
	source: "apache",
	compressible: false,
	extensions: [
		"webm"
	]
},
	"video/x-f4v": {
	source: "apache",
	extensions: [
		"f4v"
	]
},
	"video/x-fli": {
	source: "apache",
	extensions: [
		"fli"
	]
},
	"video/x-flv": {
	source: "apache",
	compressible: false,
	extensions: [
		"flv"
	]
},
	"video/x-m4v": {
	source: "apache",
	extensions: [
		"m4v"
	]
},
	"video/x-matroska": {
	source: "apache",
	compressible: false,
	extensions: [
		"mkv",
		"mk3d",
		"mks"
	]
},
	"video/x-mng": {
	source: "apache",
	extensions: [
		"mng"
	]
},
	"video/x-ms-asf": {
	source: "apache",
	extensions: [
		"asf",
		"asx"
	]
},
	"video/x-ms-vob": {
	source: "apache",
	extensions: [
		"vob"
	]
},
	"video/x-ms-wm": {
	source: "apache",
	extensions: [
		"wm"
	]
},
	"video/x-ms-wmv": {
	source: "apache",
	compressible: false,
	extensions: [
		"wmv"
	]
},
	"video/x-ms-wmx": {
	source: "apache",
	extensions: [
		"wmx"
	]
},
	"video/x-ms-wvx": {
	source: "apache",
	extensions: [
		"wvx"
	]
},
	"video/x-msvideo": {
	source: "apache",
	extensions: [
		"avi"
	]
},
	"video/x-sgi-movie": {
	source: "apache",
	extensions: [
		"movie"
	]
},
	"video/x-smv": {
	source: "apache",
	extensions: [
		"smv"
	]
},
	"x-conference/x-cooltalk": {
	source: "apache",
	extensions: [
		"ice"
	]
},
	"x-shader/x-fragment": {
	compressible: true
},
	"x-shader/x-vertex": {
	compressible: true
}
};

/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */

var mimeDb;
var hasRequiredMimeDb;

function requireMimeDb () {
	if (hasRequiredMimeDb) return mimeDb;
	hasRequiredMimeDb = 1;
	/**
	 * Module exports.
	 */

	mimeDb = require$$0;
	return mimeDb;
}

/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */

var hasRequiredMimeTypes;

function requireMimeTypes () {
	if (hasRequiredMimeTypes) return mimeTypes;
	hasRequiredMimeTypes = 1;
	(function (exports) {

		/**
		 * Module dependencies.
		 * @private
		 */

		var db = requireMimeDb();
		var extname = require$$9$1.extname;

		/**
		 * Module variables.
		 * @private
		 */

		var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
		var TEXT_TYPE_REGEXP = /^text\//i;

		/**
		 * Module exports.
		 * @public
		 */

		exports.charset = charset;
		exports.charsets = { lookup: charset };
		exports.contentType = contentType;
		exports.extension = extension;
		exports.extensions = Object.create(null);
		exports.lookup = lookup;
		exports.types = Object.create(null);

		// Populate the extensions/types maps
		populateMaps(exports.extensions, exports.types);

		/**
		 * Get the default charset for a MIME type.
		 *
		 * @param {string} type
		 * @return {boolean|string}
		 */

		function charset (type) {
		  if (!type || typeof type !== 'string') {
		    return false
		  }

		  // TODO: use media-typer
		  var match = EXTRACT_TYPE_REGEXP.exec(type);
		  var mime = match && db[match[1].toLowerCase()];

		  if (mime && mime.charset) {
		    return mime.charset
		  }

		  // default text/* to utf-8
		  if (match && TEXT_TYPE_REGEXP.test(match[1])) {
		    return 'UTF-8'
		  }

		  return false
		}

		/**
		 * Create a full Content-Type header given a MIME type or extension.
		 *
		 * @param {string} str
		 * @return {boolean|string}
		 */

		function contentType (str) {
		  // TODO: should this even be in this module?
		  if (!str || typeof str !== 'string') {
		    return false
		  }

		  var mime = str.indexOf('/') === -1
		    ? exports.lookup(str)
		    : str;

		  if (!mime) {
		    return false
		  }

		  // TODO: use content-type or other module
		  if (mime.indexOf('charset') === -1) {
		    var charset = exports.charset(mime);
		    if (charset) mime += '; charset=' + charset.toLowerCase();
		  }

		  return mime
		}

		/**
		 * Get the default extension for a MIME type.
		 *
		 * @param {string} type
		 * @return {boolean|string}
		 */

		function extension (type) {
		  if (!type || typeof type !== 'string') {
		    return false
		  }

		  // TODO: use media-typer
		  var match = EXTRACT_TYPE_REGEXP.exec(type);

		  // get extensions
		  var exts = match && exports.extensions[match[1].toLowerCase()];

		  if (!exts || !exts.length) {
		    return false
		  }

		  return exts[0]
		}

		/**
		 * Lookup the MIME type for a file path/extension.
		 *
		 * @param {string} path
		 * @return {boolean|string}
		 */

		function lookup (path) {
		  if (!path || typeof path !== 'string') {
		    return false
		  }

		  // get the extension ("ext" or ".ext" or full path)
		  var extension = extname('x.' + path)
		    .toLowerCase()
		    .substr(1);

		  if (!extension) {
		    return false
		  }

		  return exports.types[extension] || false
		}

		/**
		 * Populate the extensions and types maps.
		 * @private
		 */

		function populateMaps (extensions, types) {
		  // source preference (least -> most)
		  var preference = ['nginx', 'apache', undefined, 'iana'];

		  Object.keys(db).forEach(function forEachMimeType (type) {
		    var mime = db[type];
		    var exts = mime.extensions;

		    if (!exts || !exts.length) {
		      return
		    }

		    // mime -> extensions
		    extensions[type] = exts;

		    // extension -> mime
		    for (var i = 0; i < exts.length; i++) {
		      var extension = exts[i];

		      if (types[extension]) {
		        var from = preference.indexOf(db[types[extension]].source);
		        var to = preference.indexOf(mime.source);

		        if (types[extension] !== 'application/octet-stream' &&
		          (from > to || (from === to && types[extension].substr(0, 12) === 'application/'))) {
		          // skip the remapping
		          continue
		        }
		      }

		      // set the extension -> mime
		      types[extension] = type;
		    }
		  });
		} 
	} (mimeTypes));
	return mimeTypes;
}

var defer_1;
var hasRequiredDefer;

function requireDefer () {
	if (hasRequiredDefer) return defer_1;
	hasRequiredDefer = 1;
	defer_1 = defer;

	/**
	 * Runs provided function on next iteration of the event loop
	 *
	 * @param {function} fn - function to run
	 */
	function defer(fn)
	{
	  var nextTick$1 = typeof setImmediate == 'function'
	    ? setImmediate
	    : (
	      typeof process == 'object' && typeof nextTick == 'function'
	      ? nextTick
	      : null
	    );

	  if (nextTick$1)
	  {
	    nextTick$1(fn);
	  }
	  else
	  {
	    setTimeout(fn, 0);
	  }
	}
	return defer_1;
}

var async_1;
var hasRequiredAsync;

function requireAsync () {
	if (hasRequiredAsync) return async_1;
	hasRequiredAsync = 1;
	var defer = requireDefer();

	// API
	async_1 = async;

	/**
	 * Runs provided callback asynchronously
	 * even if callback itself is not
	 *
	 * @param   {function} callback - callback to invoke
	 * @returns {function} - augmented callback
	 */
	function async(callback)
	{
	  var isAsync = false;

	  // check if async happened
	  defer(function() { isAsync = true; });

	  return function async_callback(err, result)
	  {
	    if (isAsync)
	    {
	      callback(err, result);
	    }
	    else
	    {
	      defer(function nextTick_callback()
	      {
	        callback(err, result);
	      });
	    }
	  };
	}
	return async_1;
}

var abort_1;
var hasRequiredAbort;

function requireAbort () {
	if (hasRequiredAbort) return abort_1;
	hasRequiredAbort = 1;
	// API
	abort_1 = abort;

	/**
	 * Aborts leftover active jobs
	 *
	 * @param {object} state - current state object
	 */
	function abort(state)
	{
	  Object.keys(state.jobs).forEach(clean.bind(state));

	  // reset leftover jobs
	  state.jobs = {};
	}

	/**
	 * Cleans up leftover job by invoking abort function for the provided job id
	 *
	 * @this  state
	 * @param {string|number} key - job id to abort
	 */
	function clean(key)
	{
	  if (typeof this.jobs[key] == 'function')
	  {
	    this.jobs[key]();
	  }
	}
	return abort_1;
}

var iterate_1;
var hasRequiredIterate;

function requireIterate () {
	if (hasRequiredIterate) return iterate_1;
	hasRequiredIterate = 1;
	var async = requireAsync()
	  , abort = requireAbort()
	  ;

	// API
	iterate_1 = iterate;

	/**
	 * Iterates over each job object
	 *
	 * @param {array|object} list - array or object (named list) to iterate over
	 * @param {function} iterator - iterator to run
	 * @param {object} state - current job status
	 * @param {function} callback - invoked when all elements processed
	 */
	function iterate(list, iterator, state, callback)
	{
	  // store current index
	  var key = state['keyedList'] ? state['keyedList'][state.index] : state.index;

	  state.jobs[key] = runJob(iterator, key, list[key], function(error, output)
	  {
	    // don't repeat yourself
	    // skip secondary callbacks
	    if (!(key in state.jobs))
	    {
	      return;
	    }

	    // clean up jobs
	    delete state.jobs[key];

	    if (error)
	    {
	      // don't process rest of the results
	      // stop still active jobs
	      // and reset the list
	      abort(state);
	    }
	    else
	    {
	      state.results[key] = output;
	    }

	    // return salvaged results
	    callback(error, state.results);
	  });
	}

	/**
	 * Runs iterator over provided job element
	 *
	 * @param   {function} iterator - iterator to invoke
	 * @param   {string|number} key - key/index of the element in the list of jobs
	 * @param   {mixed} item - job description
	 * @param   {function} callback - invoked after iterator is done with the job
	 * @returns {function|mixed} - job abort function or something else
	 */
	function runJob(iterator, key, item, callback)
	{
	  var aborter;

	  // allow shortcut if iterator expects only two arguments
	  if (iterator.length == 2)
	  {
	    aborter = iterator(item, async(callback));
	  }
	  // otherwise go with full three arguments
	  else
	  {
	    aborter = iterator(item, key, async(callback));
	  }

	  return aborter;
	}
	return iterate_1;
}

var state_1;
var hasRequiredState;

function requireState () {
	if (hasRequiredState) return state_1;
	hasRequiredState = 1;
	// API
	state_1 = state;

	/**
	 * Creates initial state object
	 * for iteration over list
	 *
	 * @param   {array|object} list - list to iterate over
	 * @param   {function|null} sortMethod - function to use for keys sort,
	 *                                     or `null` to keep them as is
	 * @returns {object} - initial state object
	 */
	function state(list, sortMethod)
	{
	  var isNamedList = !Array.isArray(list)
	    , initState =
	    {
	      index    : 0,
	      keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
	      jobs     : {},
	      results  : isNamedList ? {} : [],
	      size     : isNamedList ? Object.keys(list).length : list.length
	    }
	    ;

	  if (sortMethod)
	  {
	    // sort array keys based on it's values
	    // sort object's keys just on own merit
	    initState.keyedList.sort(isNamedList ? sortMethod : function(a, b)
	    {
	      return sortMethod(list[a], list[b]);
	    });
	  }

	  return initState;
	}
	return state_1;
}

var terminator_1;
var hasRequiredTerminator;

function requireTerminator () {
	if (hasRequiredTerminator) return terminator_1;
	hasRequiredTerminator = 1;
	var abort = requireAbort()
	  , async = requireAsync()
	  ;

	// API
	terminator_1 = terminator;

	/**
	 * Terminates jobs in the attached state context
	 *
	 * @this  AsyncKitState#
	 * @param {function} callback - final callback to invoke after termination
	 */
	function terminator(callback)
	{
	  if (!Object.keys(this.jobs).length)
	  {
	    return;
	  }

	  // fast forward iteration index
	  this.index = this.size;

	  // abort jobs
	  abort(this);

	  // send back results we have so far
	  async(callback)(null, this.results);
	}
	return terminator_1;
}

var parallel_1;
var hasRequiredParallel;

function requireParallel () {
	if (hasRequiredParallel) return parallel_1;
	hasRequiredParallel = 1;
	var iterate    = requireIterate()
	  , initState  = requireState()
	  , terminator = requireTerminator()
	  ;

	// Public API
	parallel_1 = parallel;

	/**
	 * Runs iterator over provided array elements in parallel
	 *
	 * @param   {array|object} list - array or object (named list) to iterate over
	 * @param   {function} iterator - iterator to run
	 * @param   {function} callback - invoked when all elements processed
	 * @returns {function} - jobs terminator
	 */
	function parallel(list, iterator, callback)
	{
	  var state = initState(list);

	  while (state.index < (state['keyedList'] || list).length)
	  {
	    iterate(list, iterator, state, function(error, result)
	    {
	      if (error)
	      {
	        callback(error, result);
	        return;
	      }

	      // looks like it's the last one
	      if (Object.keys(state.jobs).length === 0)
	      {
	        callback(null, state.results);
	        return;
	      }
	    });

	    state.index++;
	  }

	  return terminator.bind(state, callback);
	}
	return parallel_1;
}

var serialOrdered = {exports: {}};

var hasRequiredSerialOrdered;

function requireSerialOrdered () {
	if (hasRequiredSerialOrdered) return serialOrdered.exports;
	hasRequiredSerialOrdered = 1;
	var iterate    = requireIterate()
	  , initState  = requireState()
	  , terminator = requireTerminator()
	  ;

	// Public API
	serialOrdered.exports = serialOrdered$1;
	// sorting helpers
	serialOrdered.exports.ascending  = ascending;
	serialOrdered.exports.descending = descending;

	/**
	 * Runs iterator over provided sorted array elements in series
	 *
	 * @param   {array|object} list - array or object (named list) to iterate over
	 * @param   {function} iterator - iterator to run
	 * @param   {function} sortMethod - custom sort function
	 * @param   {function} callback - invoked when all elements processed
	 * @returns {function} - jobs terminator
	 */
	function serialOrdered$1(list, iterator, sortMethod, callback)
	{
	  var state = initState(list, sortMethod);

	  iterate(list, iterator, state, function iteratorHandler(error, result)
	  {
	    if (error)
	    {
	      callback(error, result);
	      return;
	    }

	    state.index++;

	    // are we there yet?
	    if (state.index < (state['keyedList'] || list).length)
	    {
	      iterate(list, iterator, state, iteratorHandler);
	      return;
	    }

	    // done here
	    callback(null, state.results);
	  });

	  return terminator.bind(state, callback);
	}

	/*
	 * -- Sort methods
	 */

	/**
	 * sort helper to sort array elements in ascending order
	 *
	 * @param   {mixed} a - an item to compare
	 * @param   {mixed} b - an item to compare
	 * @returns {number} - comparison result
	 */
	function ascending(a, b)
	{
	  return a < b ? -1 : a > b ? 1 : 0;
	}

	/**
	 * sort helper to sort array elements in descending order
	 *
	 * @param   {mixed} a - an item to compare
	 * @param   {mixed} b - an item to compare
	 * @returns {number} - comparison result
	 */
	function descending(a, b)
	{
	  return -1 * ascending(a, b);
	}
	return serialOrdered.exports;
}

var serial_1;
var hasRequiredSerial;

function requireSerial () {
	if (hasRequiredSerial) return serial_1;
	hasRequiredSerial = 1;
	var serialOrdered = requireSerialOrdered();

	// Public API
	serial_1 = serial;

	/**
	 * Runs iterator over provided array elements in series
	 *
	 * @param   {array|object} list - array or object (named list) to iterate over
	 * @param   {function} iterator - iterator to run
	 * @param   {function} callback - invoked when all elements processed
	 * @returns {function} - jobs terminator
	 */
	function serial(list, iterator, callback)
	{
	  return serialOrdered(list, iterator, null, callback);
	}
	return serial_1;
}

var asynckit;
var hasRequiredAsynckit;

function requireAsynckit () {
	if (hasRequiredAsynckit) return asynckit;
	hasRequiredAsynckit = 1;
	asynckit =
	{
	  parallel      : requireParallel(),
	  serial        : requireSerial(),
	  serialOrdered : requireSerialOrdered()
	};
	return asynckit;
}

var populate;
var hasRequiredPopulate;

function requirePopulate () {
	if (hasRequiredPopulate) return populate;
	hasRequiredPopulate = 1;
	// populates missing values
	populate = function(dst, src) {

	  Object.keys(src).forEach(function(prop)
	  {
	    dst[prop] = dst[prop] || src[prop];
	  });

	  return dst;
	};
	return populate;
}

var form_data;
var hasRequiredForm_data;

function requireForm_data () {
	if (hasRequiredForm_data) return form_data;
	hasRequiredForm_data = 1;
	var CombinedStream = requireCombined_stream();
	var util = require$$1$2;
	var path = require$$9$1;
	var http = require$$0$6;
	var https = require$$1$1;
	var parseUrl = require$$2$2.parse;
	var fs = require$$10;
	var Stream = require$$3$1.Stream;
	var mime = requireMimeTypes();
	var asynckit = requireAsynckit();
	var populate = requirePopulate();

	// Public API
	form_data = FormData;

	// make it a Stream
	util.inherits(FormData, CombinedStream);

	/**
	 * Create readable "multipart/form-data" streams.
	 * Can be used to submit forms
	 * and file uploads to other web applications.
	 *
	 * @constructor
	 * @param {Object} options - Properties to be added/overriden for FormData and CombinedStream
	 */
	function FormData(options) {
	  if (!(this instanceof FormData)) {
	    return new FormData(options);
	  }

	  this._overheadLength = 0;
	  this._valueLength = 0;
	  this._valuesToMeasure = [];

	  CombinedStream.call(this);

	  options = options || {};
	  for (var option in options) {
	    this[option] = options[option];
	  }
	}

	FormData.LINE_BREAK = '\r\n';
	FormData.DEFAULT_CONTENT_TYPE = 'application/octet-stream';

	FormData.prototype.append = function(field, value, options) {

	  options = options || {};

	  // allow filename as single option
	  if (typeof options == 'string') {
	    options = {filename: options};
	  }

	  var append = CombinedStream.prototype.append.bind(this);

	  // all that streamy business can't handle numbers
	  if (typeof value == 'number') {
	    value = '' + value;
	  }

	  // https://github.com/felixge/node-form-data/issues/38
	  if (util.isArray(value)) {
	    // Please convert your array into string
	    // the way web server expects it
	    this._error(new Error('Arrays are not supported.'));
	    return;
	  }

	  var header = this._multiPartHeader(field, value, options);
	  var footer = this._multiPartFooter();

	  append(header);
	  append(value);
	  append(footer);

	  // pass along options.knownLength
	  this._trackLength(header, value, options);
	};

	FormData.prototype._trackLength = function(header, value, options) {
	  var valueLength = 0;

	  // used w/ getLengthSync(), when length is known.
	  // e.g. for streaming directly from a remote server,
	  // w/ a known file a size, and not wanting to wait for
	  // incoming file to finish to get its size.
	  if (options.knownLength != null) {
	    valueLength += +options.knownLength;
	  } else if (isBuffer$2(value)) {
	    valueLength = value.length;
	  } else if (typeof value === 'string') {
	    valueLength = Buffer.byteLength(value);
	  }

	  this._valueLength += valueLength;

	  // @check why add CRLF? does this account for custom/multiple CRLFs?
	  this._overheadLength +=
	    Buffer.byteLength(header) +
	    FormData.LINE_BREAK.length;

	  // empty or either doesn't have path or not an http response or not a stream
	  if (!value || ( !value.path && !(value.readable && value.hasOwnProperty('httpVersion')) && !(value instanceof Stream))) {
	    return;
	  }

	  // no need to bother with the length
	  if (!options.knownLength) {
	    this._valuesToMeasure.push(value);
	  }
	};

	FormData.prototype._lengthRetriever = function(value, callback) {

	  if (value.hasOwnProperty('fd')) {

	    // take read range into a account
	    // `end` = Infinity > read file till the end
	    //
	    // TODO: Looks like there is bug in Node fs.createReadStream
	    // it doesn't respect `end` options without `start` options
	    // Fix it when node fixes it.
	    // https://github.com/joyent/node/issues/7819
	    if (value.end != undefined && value.end != Infinity && value.start != undefined) {

	      // when end specified
	      // no need to calculate range
	      // inclusive, starts with 0
	      callback(null, value.end + 1 - (value.start ? value.start : 0));

	    // not that fast snoopy
	    } else {
	      // still need to fetch file size from fs
	      fs.stat(value.path, function(err, stat) {

	        var fileSize;

	        if (err) {
	          callback(err);
	          return;
	        }

	        // update final size based on the range options
	        fileSize = stat.size - (value.start ? value.start : 0);
	        callback(null, fileSize);
	      });
	    }

	  // or http response
	  } else if (value.hasOwnProperty('httpVersion')) {
	    callback(null, +value.headers['content-length']);

	  // or request stream http://github.com/mikeal/request
	  } else if (value.hasOwnProperty('httpModule')) {
	    // wait till response come back
	    value.on('response', function(response) {
	      value.pause();
	      callback(null, +response.headers['content-length']);
	    });
	    value.resume();

	  // something else
	  } else {
	    callback('Unknown stream');
	  }
	};

	FormData.prototype._multiPartHeader = function(field, value, options) {
	  // custom header specified (as string)?
	  // it becomes responsible for boundary
	  // (e.g. to handle extra CRLFs on .NET servers)
	  if (typeof options.header == 'string') {
	    return options.header;
	  }

	  var contentDisposition = this._getContentDisposition(value, options);
	  var contentType = this._getContentType(value, options);

	  var contents = '';
	  var headers  = {
	    // add custom disposition as third element or keep it two elements if not
	    'Content-Disposition': ['form-data', 'name="' + field + '"'].concat(contentDisposition || []),
	    // if no content type. allow it to be empty array
	    'Content-Type': [].concat(contentType || [])
	  };

	  // allow custom headers.
	  if (typeof options.header == 'object') {
	    populate(headers, options.header);
	  }

	  var header;
	  for (var prop in headers) {
	    if (!headers.hasOwnProperty(prop)) continue;
	    header = headers[prop];

	    // skip nullish headers.
	    if (header == null) {
	      continue;
	    }

	    // convert all headers to arrays.
	    if (!Array.isArray(header)) {
	      header = [header];
	    }

	    // add non-empty headers.
	    if (header.length) {
	      contents += prop + ': ' + header.join('; ') + FormData.LINE_BREAK;
	    }
	  }

	  return '--' + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK;
	};

	FormData.prototype._getContentDisposition = function(value, options) {

	  var filename
	    , contentDisposition
	    ;

	  if (typeof options.filepath === 'string') {
	    // custom filepath for relative paths
	    filename = path.normalize(options.filepath).replace(/\\/g, '/');
	  } else if (options.filename || value.name || value.path) {
	    // custom filename take precedence
	    // formidable and the browser add a name property
	    // fs- and request- streams have path property
	    filename = path.basename(options.filename || value.name || value.path);
	  } else if (value.readable && value.hasOwnProperty('httpVersion')) {
	    // or try http response
	    filename = path.basename(value.client._httpMessage.path || '');
	  }

	  if (filename) {
	    contentDisposition = 'filename="' + filename + '"';
	  }

	  return contentDisposition;
	};

	FormData.prototype._getContentType = function(value, options) {

	  // use custom content-type above all
	  var contentType = options.contentType;

	  // or try `name` from formidable, browser
	  if (!contentType && value.name) {
	    contentType = mime.lookup(value.name);
	  }

	  // or try `path` from fs-, request- streams
	  if (!contentType && value.path) {
	    contentType = mime.lookup(value.path);
	  }

	  // or if it's http-reponse
	  if (!contentType && value.readable && value.hasOwnProperty('httpVersion')) {
	    contentType = value.headers['content-type'];
	  }

	  // or guess it from the filepath or filename
	  if (!contentType && (options.filepath || options.filename)) {
	    contentType = mime.lookup(options.filepath || options.filename);
	  }

	  // fallback to the default content type if `value` is not simple value
	  if (!contentType && typeof value == 'object') {
	    contentType = FormData.DEFAULT_CONTENT_TYPE;
	  }

	  return contentType;
	};

	FormData.prototype._multiPartFooter = function() {
	  return function(next) {
	    var footer = FormData.LINE_BREAK;

	    var lastPart = (this._streams.length === 0);
	    if (lastPart) {
	      footer += this._lastBoundary();
	    }

	    next(footer);
	  }.bind(this);
	};

	FormData.prototype._lastBoundary = function() {
	  return '--' + this.getBoundary() + '--' + FormData.LINE_BREAK;
	};

	FormData.prototype.getHeaders = function(userHeaders) {
	  var header;
	  var formHeaders = {
	    'content-type': 'multipart/form-data; boundary=' + this.getBoundary()
	  };

	  for (header in userHeaders) {
	    if (userHeaders.hasOwnProperty(header)) {
	      formHeaders[header.toLowerCase()] = userHeaders[header];
	    }
	  }

	  return formHeaders;
	};

	FormData.prototype.setBoundary = function(boundary) {
	  this._boundary = boundary;
	};

	FormData.prototype.getBoundary = function() {
	  if (!this._boundary) {
	    this._generateBoundary();
	  }

	  return this._boundary;
	};

	FormData.prototype.getBuffer = function() {
	  var dataBuffer = new Buffer.alloc( 0 );
	  var boundary = this.getBoundary();

	  // Create the form content. Add Line breaks to the end of data.
	  for (var i = 0, len = this._streams.length; i < len; i++) {
	    if (typeof this._streams[i] !== 'function') {

	      // Add content to the buffer.
	      if(isBuffer$2(this._streams[i])) {
	        dataBuffer = Buffer.concat( [dataBuffer, this._streams[i]]);
	      }else {
	        dataBuffer = Buffer.concat( [dataBuffer, Buffer.from(this._streams[i])]);
	      }

	      // Add break after content.
	      if (typeof this._streams[i] !== 'string' || this._streams[i].substring( 2, boundary.length + 2 ) !== boundary) {
	        dataBuffer = Buffer.concat( [dataBuffer, Buffer.from(FormData.LINE_BREAK)] );
	      }
	    }
	  }

	  // Add the footer and return the Buffer object.
	  return Buffer.concat( [dataBuffer, Buffer.from(this._lastBoundary())] );
	};

	FormData.prototype._generateBoundary = function() {
	  // This generates a 50 character boundary similar to those used by Firefox.
	  // They are optimized for boyer-moore parsing.
	  var boundary = '--------------------------';
	  for (var i = 0; i < 24; i++) {
	    boundary += Math.floor(Math.random() * 10).toString(16);
	  }

	  this._boundary = boundary;
	};

	// Note: getLengthSync DOESN'T calculate streams length
	// As workaround one can calculate file size manually
	// and add it as knownLength option
	FormData.prototype.getLengthSync = function() {
	  var knownLength = this._overheadLength + this._valueLength;

	  // Don't get confused, there are 3 "internal" streams for each keyval pair
	  // so it basically checks if there is any value added to the form
	  if (this._streams.length) {
	    knownLength += this._lastBoundary().length;
	  }

	  // https://github.com/form-data/form-data/issues/40
	  if (!this.hasKnownLength()) {
	    // Some async length retrievers are present
	    // therefore synchronous length calculation is false.
	    // Please use getLength(callback) to get proper length
	    this._error(new Error('Cannot calculate proper length in synchronous way.'));
	  }

	  return knownLength;
	};

	// Public API to check if length of added values is known
	// https://github.com/form-data/form-data/issues/196
	// https://github.com/form-data/form-data/issues/262
	FormData.prototype.hasKnownLength = function() {
	  var hasKnownLength = true;

	  if (this._valuesToMeasure.length) {
	    hasKnownLength = false;
	  }

	  return hasKnownLength;
	};

	FormData.prototype.getLength = function(cb) {
	  var knownLength = this._overheadLength + this._valueLength;

	  if (this._streams.length) {
	    knownLength += this._lastBoundary().length;
	  }

	  if (!this._valuesToMeasure.length) {
	    nextTick(cb.bind(this, null, knownLength));
	    return;
	  }

	  asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
	    if (err) {
	      cb(err);
	      return;
	    }

	    values.forEach(function(length) {
	      knownLength += length;
	    });

	    cb(null, knownLength);
	  });
	};

	FormData.prototype.submit = function(params, cb) {
	  var request
	    , options
	    , defaults = {method: 'post'}
	    ;

	  // parse provided url if it's string
	  // or treat it as options object
	  if (typeof params == 'string') {

	    params = parseUrl(params);
	    options = populate({
	      port: params.port,
	      path: params.pathname,
	      host: params.hostname,
	      protocol: params.protocol
	    }, defaults);

	  // use custom params
	  } else {

	    options = populate(params, defaults);
	    // if no port provided use default one
	    if (!options.port) {
	      options.port = options.protocol == 'https:' ? 443 : 80;
	    }
	  }

	  // put that good code in getHeaders to some use
	  options.headers = this.getHeaders(params.headers);

	  // https if specified, fallback to http in any other case
	  if (options.protocol == 'https:') {
	    request = https.request(options);
	  } else {
	    request = http.request(options);
	  }

	  // get content length and fire away
	  this.getLength(function(err, length) {
	    if (err && err !== 'Unknown stream') {
	      this._error(err);
	      return;
	    }

	    // add content length
	    if (length) {
	      request.setHeader('Content-Length', length);
	    }

	    this.pipe(request);
	    if (cb) {
	      var onResponse;

	      var callback = function (error, responce) {
	        request.removeListener('error', callback);
	        request.removeListener('response', onResponse);

	        return cb.call(this, error, responce);
	      };

	      onResponse = callback.bind(this, null);

	      request.on('error', callback);
	      request.on('response', onResponse);
	    }
	  }.bind(this));

	  return request;
	};

	FormData.prototype._error = function(err) {
	  if (!this.error) {
	    this.error = err;
	    this.pause();
	    this.emit('error', err);
	  }
	};

	FormData.prototype.toString = function () {
	  return '[object FormData]';
	};
	return form_data;
}

var FormData$1;
var hasRequiredFormData;

function requireFormData () {
	if (hasRequiredFormData) return FormData$1;
	hasRequiredFormData = 1;
	// eslint-disable-next-line strict
	FormData$1 = requireForm_data();
	return FormData$1;
}

var utils$5 = utils$9;
var normalizeHeaderName = normalizeHeaderName$1;
var AxiosError$1 = requireAxiosError();
var transitionalDefaults = transitional;
var toFormData = requireToFormData();

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils$5.isUndefined(headers) && utils$5.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = requireXhr();
  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // For node use HTTP adapter
    adapter = requireHttp();
  }
  return adapter;
}

function stringifySafely(rawValue, parser, encoder) {
  if (utils$5.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils$5.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

var defaults$3 = {

  transitional: transitionalDefaults,

  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');

    if (utils$5.isFormData(data) ||
      utils$5.isArrayBuffer(data) ||
      utils$5.isBuffer(data) ||
      utils$5.isStream(data) ||
      utils$5.isFile(data) ||
      utils$5.isBlob(data)
    ) {
      return data;
    }
    if (utils$5.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils$5.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }

    var isObjectPayload = utils$5.isObject(data);
    var contentType = headers && headers['Content-Type'];

    var isFileList;

    if ((isFileList = utils$5.isFileList(data)) || (isObjectPayload && contentType === 'multipart/form-data')) {
      var _FormData = this.env && this.env.FormData;
      return toFormData(isFileList ? {'files[]': data} : data, _FormData && new _FormData());
    } else if (isObjectPayload || contentType === 'application/json') {
      setContentTypeIfUnset(headers, 'application/json');
      return stringifySafely(data);
    }

    return data;
  }],

  transformResponse: [function transformResponse(data) {
    var transitional = this.transitional || defaults$3.transitional;
    var silentJSONParsing = transitional && transitional.silentJSONParsing;
    var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';

    if (strictJSONParsing || (forcedJSONParsing && utils$5.isString(data) && data.length)) {
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw AxiosError$1.from(e, AxiosError$1.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  env: {
    FormData: requireFormData()
  },

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },

  headers: {
    common: {
      'Accept': 'application/json, text/plain, */*'
    }
  }
};

utils$5.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults$3.headers[method] = {};
});

utils$5.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults$3.headers[method] = utils$5.merge(DEFAULT_CONTENT_TYPE);
});

var defaults_1 = defaults$3;

var utils$4 = utils$9;
var defaults$2 = defaults_1;

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
var transformData$1 = function transformData(data, headers, fns) {
  var context = this || defaults$2;
  /*eslint no-param-reassign:0*/
  utils$4.forEach(fns, function transform(fn) {
    data = fn.call(context, data, headers);
  });

  return data;
};

var isCancel$1;
var hasRequiredIsCancel;

function requireIsCancel () {
	if (hasRequiredIsCancel) return isCancel$1;
	hasRequiredIsCancel = 1;

	isCancel$1 = function isCancel(value) {
	  return !!(value && value.__CANCEL__);
	};
	return isCancel$1;
}

var utils$3 = utils$9;
var transformData = transformData$1;
var isCancel = requireIsCancel();
var defaults$1 = defaults_1;
var CanceledError = requireCanceledError();

/**
 * Throws a `CanceledError` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }

  if (config.signal && config.signal.aborted) {
    throw new CanceledError();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
var dispatchRequest$1 = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData.call(
    config,
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils$3.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers
  );

  utils$3.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults$1.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData.call(
      config,
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};

var utils$2 = utils$9;

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */
var mergeConfig$2 = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};

  function getMergedValue(target, source) {
    if (utils$2.isPlainObject(target) && utils$2.isPlainObject(source)) {
      return utils$2.merge(target, source);
    } else if (utils$2.isPlainObject(source)) {
      return utils$2.merge({}, source);
    } else if (utils$2.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  // eslint-disable-next-line consistent-return
  function mergeDeepProperties(prop) {
    if (!utils$2.isUndefined(config2[prop])) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (!utils$2.isUndefined(config1[prop])) {
      return getMergedValue(undefined, config1[prop]);
    }
  }

  // eslint-disable-next-line consistent-return
  function valueFromConfig2(prop) {
    if (!utils$2.isUndefined(config2[prop])) {
      return getMergedValue(undefined, config2[prop]);
    }
  }

  // eslint-disable-next-line consistent-return
  function defaultToConfig2(prop) {
    if (!utils$2.isUndefined(config2[prop])) {
      return getMergedValue(undefined, config2[prop]);
    } else if (!utils$2.isUndefined(config1[prop])) {
      return getMergedValue(undefined, config1[prop]);
    }
  }

  // eslint-disable-next-line consistent-return
  function mergeDirectKeys(prop) {
    if (prop in config2) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      return getMergedValue(undefined, config1[prop]);
    }
  }

  var mergeMap = {
    'url': valueFromConfig2,
    'method': valueFromConfig2,
    'data': valueFromConfig2,
    'baseURL': defaultToConfig2,
    'transformRequest': defaultToConfig2,
    'transformResponse': defaultToConfig2,
    'paramsSerializer': defaultToConfig2,
    'timeout': defaultToConfig2,
    'timeoutMessage': defaultToConfig2,
    'withCredentials': defaultToConfig2,
    'adapter': defaultToConfig2,
    'responseType': defaultToConfig2,
    'xsrfCookieName': defaultToConfig2,
    'xsrfHeaderName': defaultToConfig2,
    'onUploadProgress': defaultToConfig2,
    'onDownloadProgress': defaultToConfig2,
    'decompress': defaultToConfig2,
    'maxContentLength': defaultToConfig2,
    'maxBodyLength': defaultToConfig2,
    'beforeRedirect': defaultToConfig2,
    'transport': defaultToConfig2,
    'httpAgent': defaultToConfig2,
    'httpsAgent': defaultToConfig2,
    'cancelToken': defaultToConfig2,
    'socketPath': defaultToConfig2,
    'responseEncoding': defaultToConfig2,
    'validateStatus': mergeDirectKeys
  };

  utils$2.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
    var merge = mergeMap[prop] || mergeDeepProperties;
    var configValue = merge(prop);
    (utils$2.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);
  });

  return config;
};

var VERSION = requireData().version;
var AxiosError = requireAxiosError();

var validators$1 = {};

// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function(type, i) {
  validators$1[type] = function validator(thing) {
    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});

var deprecatedWarnings = {};

/**
 * Transitional option validator
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 * @returns {function}
 */
validators$1.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return '[Axios v' + VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }

  // eslint-disable-next-line func-names
  return function(value, opt, opts) {
    if (validator === false) {
      throw new AxiosError(
        formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),
        AxiosError.ERR_DEPRECATED
      );
    }

    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(
        formatMessage(
          opt,
          ' has been deprecated since v' + version + ' and will be removed in the near future'
        )
      );
    }

    return validator ? validator(value, opt, opts) : true;
  };
};

/**
 * Assert object's properties type
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 */

function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new AxiosError('options must be an object', AxiosError.ERR_BAD_OPTION_VALUE);
  }
  var keys = Object.keys(options);
  var i = keys.length;
  while (i-- > 0) {
    var opt = keys[i];
    var validator = schema[opt];
    if (validator) {
      var value = options[opt];
      var result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError('option ' + opt + ' must be ' + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError('Unknown option ' + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}

var validator$1 = {
  assertOptions: assertOptions,
  validators: validators$1
};

var utils$1 = utils$9;
var buildURL = buildURL$1;
var InterceptorManager = InterceptorManager_1;
var dispatchRequest = dispatchRequest$1;
var mergeConfig$1 = mergeConfig$2;
var buildFullPath = buildFullPath$1;
var validator = validator$1;

var validators = validator.validators;
/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios$1(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios$1.prototype.request = function request(configOrUrl, config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof configOrUrl === 'string') {
    config = config || {};
    config.url = configOrUrl;
  } else {
    config = configOrUrl || {};
  }

  config = mergeConfig$1(this.defaults, config);

  // Set config.method
  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = 'get';
  }

  var transitional = config.transitional;

  if (transitional !== undefined) {
    validator.assertOptions(transitional, {
      silentJSONParsing: validators.transitional(validators.boolean),
      forcedJSONParsing: validators.transitional(validators.boolean),
      clarifyTimeoutError: validators.transitional(validators.boolean)
    }, false);
  }

  // filter out skipped interceptors
  var requestInterceptorChain = [];
  var synchronousRequestInterceptors = true;
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
      return;
    }

    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  var responseInterceptorChain = [];
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
  });

  var promise;

  if (!synchronousRequestInterceptors) {
    var chain = [dispatchRequest, undefined];

    Array.prototype.unshift.apply(chain, requestInterceptorChain);
    chain = chain.concat(responseInterceptorChain);

    promise = Promise.resolve(config);
    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }

    return promise;
  }


  var newConfig = config;
  while (requestInterceptorChain.length) {
    var onFulfilled = requestInterceptorChain.shift();
    var onRejected = requestInterceptorChain.shift();
    try {
      newConfig = onFulfilled(newConfig);
    } catch (error) {
      onRejected(error);
      break;
    }
  }

  try {
    promise = dispatchRequest(newConfig);
  } catch (error) {
    return Promise.reject(error);
  }

  while (responseInterceptorChain.length) {
    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
  }

  return promise;
};

Axios$1.prototype.getUri = function getUri(config) {
  config = mergeConfig$1(this.defaults, config);
  var fullPath = buildFullPath(config.baseURL, config.url);
  return buildURL(fullPath, config.params, config.paramsSerializer);
};

// Provide aliases for supported request methods
utils$1.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios$1.prototype[method] = function(url, config) {
    return this.request(mergeConfig$1(config || {}, {
      method: method,
      url: url,
      data: (config || {}).data
    }));
  };
});

utils$1.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/

  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig$1(config || {}, {
        method: method,
        headers: isForm ? {
          'Content-Type': 'multipart/form-data'
        } : {},
        url: url,
        data: data
      }));
    };
  }

  Axios$1.prototype[method] = generateHTTPMethod();

  Axios$1.prototype[method + 'Form'] = generateHTTPMethod(true);
});

var Axios_1 = Axios$1;

var CancelToken_1;
var hasRequiredCancelToken;

function requireCancelToken () {
	if (hasRequiredCancelToken) return CancelToken_1;
	hasRequiredCancelToken = 1;

	var CanceledError = requireCanceledError();

	/**
	 * A `CancelToken` is an object that can be used to request cancellation of an operation.
	 *
	 * @class
	 * @param {Function} executor The executor function.
	 */
	function CancelToken(executor) {
	  if (typeof executor !== 'function') {
	    throw new TypeError('executor must be a function.');
	  }

	  var resolvePromise;

	  this.promise = new Promise(function promiseExecutor(resolve) {
	    resolvePromise = resolve;
	  });

	  var token = this;

	  // eslint-disable-next-line func-names
	  this.promise.then(function(cancel) {
	    if (!token._listeners) return;

	    var i;
	    var l = token._listeners.length;

	    for (i = 0; i < l; i++) {
	      token._listeners[i](cancel);
	    }
	    token._listeners = null;
	  });

	  // eslint-disable-next-line func-names
	  this.promise.then = function(onfulfilled) {
	    var _resolve;
	    // eslint-disable-next-line func-names
	    var promise = new Promise(function(resolve) {
	      token.subscribe(resolve);
	      _resolve = resolve;
	    }).then(onfulfilled);

	    promise.cancel = function reject() {
	      token.unsubscribe(_resolve);
	    };

	    return promise;
	  };

	  executor(function cancel(message) {
	    if (token.reason) {
	      // Cancellation has already been requested
	      return;
	    }

	    token.reason = new CanceledError(message);
	    resolvePromise(token.reason);
	  });
	}

	/**
	 * Throws a `CanceledError` if cancellation has been requested.
	 */
	CancelToken.prototype.throwIfRequested = function throwIfRequested() {
	  if (this.reason) {
	    throw this.reason;
	  }
	};

	/**
	 * Subscribe to the cancel signal
	 */

	CancelToken.prototype.subscribe = function subscribe(listener) {
	  if (this.reason) {
	    listener(this.reason);
	    return;
	  }

	  if (this._listeners) {
	    this._listeners.push(listener);
	  } else {
	    this._listeners = [listener];
	  }
	};

	/**
	 * Unsubscribe from the cancel signal
	 */

	CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
	  if (!this._listeners) {
	    return;
	  }
	  var index = this._listeners.indexOf(listener);
	  if (index !== -1) {
	    this._listeners.splice(index, 1);
	  }
	};

	/**
	 * Returns an object that contains a new `CancelToken` and a function that, when called,
	 * cancels the `CancelToken`.
	 */
	CancelToken.source = function source() {
	  var cancel;
	  var token = new CancelToken(function executor(c) {
	    cancel = c;
	  });
	  return {
	    token: token,
	    cancel: cancel
	  };
	};

	CancelToken_1 = CancelToken;
	return CancelToken_1;
}

var spread;
var hasRequiredSpread;

function requireSpread () {
	if (hasRequiredSpread) return spread;
	hasRequiredSpread = 1;

	/**
	 * Syntactic sugar for invoking a function and expanding an array for arguments.
	 *
	 * Common use case would be to use `Function.prototype.apply`.
	 *
	 *  ```js
	 *  function f(x, y, z) {}
	 *  var args = [1, 2, 3];
	 *  f.apply(null, args);
	 *  ```
	 *
	 * With `spread` this example can be re-written.
	 *
	 *  ```js
	 *  spread(function(x, y, z) {})([1, 2, 3]);
	 *  ```
	 *
	 * @param {Function} callback
	 * @returns {Function}
	 */
	spread = function spread(callback) {
	  return function wrap(arr) {
	    return callback.apply(null, arr);
	  };
	};
	return spread;
}

var isAxiosError;
var hasRequiredIsAxiosError;

function requireIsAxiosError () {
	if (hasRequiredIsAxiosError) return isAxiosError;
	hasRequiredIsAxiosError = 1;

	var utils = utils$9;

	/**
	 * Determines whether the payload is an error thrown by Axios
	 *
	 * @param {*} payload The value to test
	 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
	 */
	isAxiosError = function isAxiosError(payload) {
	  return utils.isObject(payload) && (payload.isAxiosError === true);
	};
	return isAxiosError;
}

var utils = utils$9;
var bind = bind$2;
var Axios = Axios_1;
var mergeConfig = mergeConfig$2;
var defaults = defaults_1;

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  // Factory for creating new instances
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };

  return instance;
}

// Create the default instance to be exported
var axios$1 = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios$1.Axios = Axios;

// Expose Cancel & CancelToken
axios$1.CanceledError = requireCanceledError();
axios$1.CancelToken = requireCancelToken();
axios$1.isCancel = requireIsCancel();
axios$1.VERSION = requireData().version;
axios$1.toFormData = requireToFormData();

// Expose AxiosError class
axios$1.AxiosError = requireAxiosError();

// alias for CanceledError for backward compatibility
axios$1.Cancel = axios$1.CanceledError;

// Expose all/spread
axios$1.all = function all(promises) {
  return Promise.all(promises);
};
axios$1.spread = requireSpread();

// Expose isAxiosError
axios$1.isAxiosError = requireIsAxiosError();

axios$2.exports = axios$1;

// Allow use of default import syntax in TypeScript
axios$2.exports.default = axios$1;

var axiosExports = axios$2.exports;

var axios = axiosExports;

(function (module, exports) {
	(function (global, factory) {
	    module.exports = factory() ;
	}(commonjsGlobal, (function () {
	    /*! *****************************************************************************
	    Copyright (c) Microsoft Corporation.

	    Permission to use, copy, modify, and/or distribute this software for any
	    purpose with or without fee is hereby granted.

	    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
	    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
	    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
	    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
	    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
	    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
	    PERFORMANCE OF THIS SOFTWARE.
	    ***************************************************************************** */

	    function __awaiter(thisArg, _arguments, P, generator) {
	        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	        return new (P || (P = Promise))(function (resolve, reject) {
	            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	            step((generator = generator.apply(thisArg, _arguments || [])).next());
	        });
	    }

	    const axios$1 = axios;
	    class HttpRequest {
	        constructor(baseUrl, params) {
	            this.request = axios$1.create({
	                baseURL: baseUrl,
	                timeout: (params === null || params === void 0 ? void 0 : params.timeout) ? params === null || params === void 0 ? void 0 : params.timeout : 30000,
	                timeoutErrorMessage: (params === null || params === void 0 ? void 0 : params.timeoutErrorMessage)
	                    ? params === null || params === void 0 ? void 0 : params.timeoutErrorMessage
	                    : "",
	            });
	            this.request.interceptors.request.use((config) => __awaiter(this, void 0, void 0, function* () {
	                if (params === null || params === void 0 ? void 0 : params.header) {
	                    let header;
	                    if (typeof params.header === "function")
	                        header = yield params.header(config);
	                    else
	                        header = params.header;
	                    for (const i in header) {
	                        if (!config.headers) {
	                            // @ts-ignore
	                            config.headers = {};
	                        }
	                        if (typeof header[i] === "function") {
	                            config.headers[i] = header[i]();
	                        }
	                        else {
	                            config.headers[i] = header[i];
	                        }
	                    }
	                }
	                return config;
	            }), function (error) {
	                // 
	                return Promise.reject(error);
	            });
	            // 
	            this.request.interceptors.response.use(function (response) {
	                return __awaiter(this, void 0, void 0, function* () {
	                    // 
	                    if (params === null || params === void 0 ? void 0 : params.responseHandel) {
	                        return yield params.responseHandel(response);
	                    }
	                    else {
	                        return response.data;
	                    }
	                });
	            }, function (error) {
	                if (params === null || params === void 0 ? void 0 : params.errorHandel) {
	                    return params.errorHandel(error);
	                }
	                else {
	                    return Promise.reject(error);
	                }
	            });
	        }
	    }

	    return HttpRequest;

	})));
	
} (requestSdk_min));

var requestSdk_minExports = requestSdk_min.exports;
var HttpRequest = /*@__PURE__*/getDefaultExportFromCjs(requestSdk_minExports);

class Request {
    request;
    constructor(baseUrl, params) {
        this.request = new HttpRequest(baseUrl, {
            // @ts-ignore
            timeoutErrorMessage: `Request Timeout`,
            ...params,
        }).request;
    }
}

new Request(`${Env.BASEAPI}/metaid-base`, {
    header: () => {
        const userInfo = JSON.parse(window.localStorage.getItem("userInfo"));
        if (userInfo.isAuthorized) {
            return {
                accessKey: userInfo.user.token,
                userName: userInfo.userName,
                timestamp: new Date().getTime(),
                metaId: userInfo.user.metaId,
            };
        }
        else {
            return {};
        }
    },
    responseHandel: (response) => {
        return new Promise((resolve, reject) => {
            if (response?.data && typeof response.data?.code === "number") {
                if (response.data.code === 0) {
                    resolve(response.data);
                }
                else {
                    reject({
                        code: response.data.code,
                        message: response.data.msg,
                    });
                }
            }
            else {
                resolve(response.data);
            }
        });
    },
}).request;

// @ts-ignore
({
    [Network$1.testnet]: "https://api-mvc-testnet.metasv.com",
    [Network$1.mainnet]: "https://api-mvc.metasv.com",
});
({
    [Network$1.testnet]: "https://apiv2.metasv.com",
    [Network$1.mainnet]: "https://apiv2.metasv.com",
});

const isBrowserEnv = typeof window === "undefined" ? false : true;
console.log("isBrowserEnv", isBrowserEnv);

async function init() {
    // console.log("mvc", mvc);
    return;
}
init();

export { init };
